void sub_180DB4728(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB4780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void sub_180DB4794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::CastOp &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.multiply";
    v21[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  if (!*(_DWORD *)(*(void *)a4 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *(void *)a4 - 16);
  v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    v16 = "Casting.h";
    v17 = "dyn_cast";
    goto LABEL_10;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    v16 = "Builders.h";
    v17 = "create";
LABEL_10:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DB4954(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB496C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter5::~GeneratedRewriter5(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter5::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter5 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    v7 = (long long *)__p;
    v8 = (char *)operator new(8uLL);
    *(void *)v8 = v6 - 16;
    uint64_t v18 = v7;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB4C78(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ReluOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.relu";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ReluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReluOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DB4E2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB4E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ReluOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ReluOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x756C65722E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.relu";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter6::~GeneratedRewriter6(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter6::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter6 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v24 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
    uint64_t v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.relu6", (const unsigned __int8 *)9, Context);
    if (!v9)
    {
      __int16 v28 = 1283;
      v27[2] = (uint64_t)"mps.relu6";
      v27[3] = 9;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v26 = 259;
      llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
      llvm::report_fatal_error((llvm::Twine *)v29, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    mlir::mps::ACosOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue);
    uint64_t v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v10)
    {
      uint64_t v11 = llvm::DefaultDoCastIfPossible<mlir::mps::Relu6Op,mlir::Operation *,llvm::CastInfo<mlir::mps::Relu6Op,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v10);
      if (v11)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v11 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v12 = (long long *)__p;
        int v13 = (char *)operator new(8uLL);
        *(void *)int v13 = v11 - 16;
        v29[0] = v12;
        uint64_t v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v12, (uint64_t)&std::piecewise_construct, v29);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v14 + 5, v13, v13 + 8, 1uLL);
        operator delete(v13);
        int v15 = (void **)__p;
        if (__p)
        {
          uint64_t v16 = (void **)v31;
          v17 = __p;
          if ((void *)v31 != __p)
          {
            do
            {
              if (*((char *)v16 - 1) < 0) {
                operator delete(*(v16 - 3));
              }
              v16 -= 3;
            }
            while (v16 != v15);
            v17 = __p;
          }
          *(void *)&long long v31 = v15;
          operator delete(v17);
        }
        return 1;
      }
      __int16 v20 = "result && \"builder didn't return the right type\"";
      int v21 = 497;
      __int16 v22 = "Builders.h";
      v23 = "create";
    }
    else
    {
      __int16 v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v21 = 662;
      __int16 v22 = "Casting.h";
      v23 = "dyn_cast";
    }
    __assert_rtn(v23, v22, v21, v20);
  }
  __p = operator new(0x40uLL);
  long long v31 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v18 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v31) < 0) {
    operator delete(__p);
  }
  return v18;
}

void sub_180DB5328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB533C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB5394(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::Relu6Op,mlir::Operation *,llvm::CastInfo<mlir::mps::Relu6Op,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x756C65722E73706DLL && *(unsigned char *)(AttrData + 8) == 54)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.relu6";
      v8[3] = 9;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::Relu6Op,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter7::~GeneratedRewriter7(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter7::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter7 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v31 = ArgValue;
  uint64_t v30 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  uint64_t v32 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    v29 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v32, (uint64_t *)&__p);
    uint64_t v28 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value &,mlir::mps::CastOp &>(a3 + 18, LocationForOp, &v31, (uint64_t)&v29);
    uint64_t v8 = mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::mps::MultiplyOp &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, (uint64_t)&v28);
    uint64_t v9 = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(v9);
    uint64_t v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v30, (uint64_t *)&__p);
    uint64_t v33 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v33);
    uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.multiply", (const unsigned __int8 *)0xC, Context);
    if (!v13)
    {
      __int16 v37 = 1283;
      v36[2] = (uint64_t)"mps.multiply";
      v36[3] = 12;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v35 = 259;
      llvm::operator+(v36, (uint64_t *)&v34, (uint64_t)v38);
      llvm::report_fatal_error((llvm::Twine *)v38, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*(_DWORD *)(v8 + 36) || !*((_DWORD *)v10 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ATan2Op::build(a3 + 18, (uint64_t)&__p, v8 - 16, (uint64_t)v10 - 16);
    uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v14)
    {
      uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::mps::MultiplyOp,mlir::Operation *,llvm::CastInfo<mlir::mps::MultiplyOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v14);
      if (v15)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v15 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v16 = (long long *)__p;
        v17 = (char *)operator new(8uLL);
        *(void *)v17 = v15 - 16;
        v38[0] = v16;
        uint64_t v18 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v16, (uint64_t)&std::piecewise_construct, v38);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v18 + 5, v17, v17 + 8, 1uLL);
        operator delete(v17);
        v19 = (void **)__p;
        if (__p)
        {
          __int16 v20 = (void **)v40;
          int v21 = __p;
          if ((void *)v40 != __p)
          {
            do
            {
              if (*((char *)v20 - 1) < 0) {
                operator delete(*(v20 - 3));
              }
              v20 -= 3;
            }
            while (v20 != v19);
            int v21 = __p;
          }
          *(void *)&long long v40 = v19;
          operator delete(v21);
        }
        return 1;
      }
      uint64_t v24 = "result && \"builder didn't return the right type\"";
      int v25 = 497;
      __int16 v26 = "Builders.h";
      v27 = "create";
    }
    else
    {
      uint64_t v24 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v25 = 662;
      __int16 v26 = "Casting.h";
      v27 = "dyn_cast";
    }
    __assert_rtn(v27, v26, v25, v24);
  }
  __p = operator new(0x40uLL);
  long long v40 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v22 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v40) < 0) {
    operator delete(__p);
  }
  return v22;
}

void sub_180DB5974(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB59CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void sub_180DB59E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void anonymous namespace'::GeneratedRewriter8::~GeneratedRewriter8(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter8::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter8 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::SigmoidOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = v6 - 16;
    uint64_t v18 = v7;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB5CEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SigmoidOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sigmoid", (const unsigned __int8 *)0xB, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.sigmoid";
    v19[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    uint64_t v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SigmoidOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SigmoidOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    uint64_t v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DB5EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB5EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter9::~GeneratedRewriter9(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter9::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter9 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v33 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  uint64_t v34 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    char v8 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v33, (uint64_t *)&__p);
    uint64_t v9 = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(v9);
    uint64_t v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v34, (uint64_t *)&__p);
    uint64_t v35 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v35);
    uint64_t v12 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sigmoid_hard", (const unsigned __int8 *)0x10, Context);
    if (!v13)
    {
      __int16 v41 = 1283;
      v39 = "mps.sigmoid_hard";
      uint64_t v40 = 16;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      __int16 v37 = 259;
      llvm::operator+(v38, v36, (uint64_t)v42);
      llvm::report_fatal_error((llvm::Twine *)v42, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v12);
    if (!*((_DWORD *)v8 + 9) || !*((_DWORD *)v10 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ClampOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue, (uint64_t)v8 - 16, (uint64_t)v10 - 16);
    uint64_t v14 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    uint64_t v15 = v14;
    if (v14)
    {
      uint64_t v16 = *((void *)v14 + 6);
      v17 = *(void **)(v16 + 16);
      if (v17 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v42[0] = *(long long **)(v16 + 8);
        uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
        if (v31 == 16 && *AttrData == 0x6D6769732E73706DLL && AttrData[1] == 0x647261685F64696FLL)
        {
          __int16 v41 = 1283;
          v38[0] = (uint64_t)"classof on '";
          v39 = "mps.sigmoid_hard";
          uint64_t v40 = 16;
          v36[0] = (uint64_t)"' failed due to the operation not being registered";
          __int16 v37 = 259;
          llvm::operator+(v38, v36, (uint64_t)v42);
          llvm::report_fatal_error((llvm::Twine *)v42, 1);
        }
      }
      else if (v17 == &mlir::detail::TypeIDResolver<mlir::mps::SigmoidHardOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v15 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        __int16 v18 = (long long *)__p;
        v19 = (char *)operator new(8uLL);
        *(void *)v19 = (char *)v15 - 16;
        v42[0] = v18;
        __int16 v20 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v18, (uint64_t)&std::piecewise_construct, v42);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v20 + 5, v19, v19 + 8, 1uLL);
        operator delete(v19);
        int v21 = (void **)__p;
        if (__p)
        {
          uint64_t v22 = (void **)v44;
          v23 = __p;
          if ((void *)v44 != __p)
          {
            do
            {
              if (*((char *)v22 - 1) < 0) {
                operator delete(*(v22 - 3));
              }
              v22 -= 3;
            }
            while (v22 != v21);
            v23 = __p;
          }
          *(void *)&long long v44 = v21;
          operator delete(v23);
        }
        return 1;
      }
      __int16 v26 = "result && \"builder didn't return the right type\"";
      int v27 = 497;
      uint64_t v28 = "Builders.h";
      v29 = "create";
    }
    else
    {
      __int16 v26 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v27 = 662;
      uint64_t v28 = "Casting.h";
      v29 = "dyn_cast";
    }
    __assert_rtn(v29, v28, v27, v26);
  }
  __p = operator new(0x40uLL);
  long long v44 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v24 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v44) < 0) {
    operator delete(__p);
  }
  return v24;
}

void sub_180DB6444(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  operator delete(v28);
  std::vector<std::string>::~vector[abi:ne180100](&a28);
  _Unwind_Resume(a1);
}

void sub_180DB6460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB649C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_180DB64B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void anonymous namespace'::GeneratedRewriter10::~GeneratedRewriter10(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter10::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter10 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v24 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v24);
    uint64_t v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.swish", (const unsigned __int8 *)9, Context);
    if (!v9)
    {
      __int16 v28 = 1283;
      v27[2] = (uint64_t)"mps.swish";
      v27[3] = 9;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v26 = 259;
      llvm::operator+(v27, (uint64_t *)&v25, (uint64_t)v29);
      llvm::report_fatal_error((llvm::Twine *)v29, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    mlir::mps::ACosOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue);
    uint64_t v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v10)
    {
      uint64_t v11 = llvm::DefaultDoCastIfPossible<mlir::mps::SwishOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SwishOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v10);
      if (v11)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v11 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v12 = (long long *)__p;
        char v13 = (char *)operator new(8uLL);
        *(void *)char v13 = v11 - 16;
        v29[0] = v12;
        uint64_t v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v12, (uint64_t)&std::piecewise_construct, v29);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v14 + 5, v13, v13 + 8, 1uLL);
        operator delete(v13);
        uint64_t v15 = (void **)__p;
        if (__p)
        {
          uint64_t v16 = (void **)v31;
          v17 = __p;
          if ((void *)v31 != __p)
          {
            do
            {
              if (*((char *)v16 - 1) < 0) {
                operator delete(*(v16 - 3));
              }
              v16 -= 3;
            }
            while (v16 != v15);
            v17 = __p;
          }
          *(void *)&long long v31 = v15;
          operator delete(v17);
        }
        return 1;
      }
      __int16 v20 = "result && \"builder didn't return the right type\"";
      int v21 = 497;
      uint64_t v22 = "Builders.h";
      v23 = "create";
    }
    else
    {
      __int16 v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v21 = 662;
      uint64_t v22 = "Casting.h";
      v23 = "dyn_cast";
    }
    __assert_rtn(v23, v22, v21, v20);
  }
  __p = operator new(0x40uLL);
  long long v31 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v18 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v31) < 0) {
    operator delete(__p);
  }
  return v18;
}

void sub_180DB68B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB68CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB6924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SwishOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SwishOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x736977732E73706DLL && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.swish";
      v8[3] = 9;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SwishOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter11::~GeneratedRewriter11(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter11::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter11 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v25 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v25);
    uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softmax", (const unsigned __int8 *)0xB, Context);
    if (!v10)
    {
      __int16 v29 = 1283;
      v28[2] = (uint64_t)"mps.softmax";
      v28[3] = 11;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v27 = 259;
      llvm::operator+(v28, (uint64_t *)&v26, (uint64_t)v30);
      llvm::report_fatal_error((llvm::Twine *)v30, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v9);
    mlir::mps::SoftmaxOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue, v7);
    uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v11)
    {
      uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::SoftmaxOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SoftmaxOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
      if (v12)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v12 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        char v13 = (long long *)__p;
        uint64_t v14 = (char *)operator new(8uLL);
        *(void *)uint64_t v14 = v12 - 16;
        v30[0] = v13;
        uint64_t v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v13, (uint64_t)&std::piecewise_construct, v30);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v15 + 5, v14, v14 + 8, 1uLL);
        operator delete(v14);
        uint64_t v16 = (void **)__p;
        if (__p)
        {
          v17 = (void **)v32;
          uint64_t v18 = __p;
          if ((void *)v32 != __p)
          {
            do
            {
              if (*((char *)v17 - 1) < 0) {
                operator delete(*(v17 - 3));
              }
              v17 -= 3;
            }
            while (v17 != v16);
            uint64_t v18 = __p;
          }
          *(void *)&long long v32 = v16;
          operator delete(v18);
        }
        return 1;
      }
      int v21 = "result && \"builder didn't return the right type\"";
      int v22 = 497;
      v23 = "Builders.h";
      uint64_t v24 = "create";
    }
    else
    {
      int v21 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v22 = 662;
      v23 = "Casting.h";
      uint64_t v24 = "dyn_cast";
    }
    __assert_rtn(v24, v23, v22, v21);
  }
  __p = operator new(0x40uLL);
  long long v32 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v19 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v32) < 0) {
    operator delete(__p);
  }
  return v19;
}

void sub_180DB6E38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB6E4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB6EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter12::~GeneratedRewriter12(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter12::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter12 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::SoftplusOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v18 = v7;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB71B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter13::~GeneratedRewriter13(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter13::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter13 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v39 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  uint64_t v40 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    uint64_t v8 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v39, (uint64_t *)&__p);
    uint64_t v9 = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(v9);
    char v10 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v40, (uint64_t *)&__p);
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v11);
    uint64_t v13 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v14 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v13, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v14, 1);
    uint64_t v15 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&__p);
    uint64_t v41 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
    uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softplus_parametric", (const unsigned __int8 *)0x17, Context);
    if (!v18)
    {
      __int16 v47 = 1283;
      uint64_t v45 = "mps.softplus_parametric";
      uint64_t v46 = 23;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      __int16 v43 = 259;
      llvm::operator+(v44, v42, (uint64_t)v48);
      llvm::report_fatal_error((llvm::Twine *)v48, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v17);
    if (!*((_DWORD *)v8 + 9) || !*((_DWORD *)v10 + 9) || !*((_DWORD *)v15 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::LPNormOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue, (uint64_t)v8 - 16, (uint64_t)v10 - 16, (uint64_t)v15 - 16);
    uint64_t v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    __int16 v20 = v19;
    if (v19)
    {
      uint64_t v21 = *((void *)v19 + 6);
      int v22 = *(void **)(v21 + 16);
      if (v22 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v48[0] = *(long long **)(v21 + 8);
        uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
        if (v36 == 23)
        {
          BOOL v37 = *AttrData == 0x74666F732E73706DLL && AttrData[1] == 0x7261705F73756C70;
          if (v37 && *(void *)((char *)AttrData + 15) == 0x63697274656D6172)
          {
            __int16 v47 = 1283;
            v44[0] = (uint64_t)"classof on '";
            uint64_t v45 = "mps.softplus_parametric";
            uint64_t v46 = 23;
            v42[0] = (uint64_t)"' failed due to the operation not being registered";
            __int16 v43 = 259;
            llvm::operator+(v44, v42, (uint64_t)v48);
            llvm::report_fatal_error((llvm::Twine *)v48, 1);
          }
        }
      }
      else if (v22 == &mlir::detail::TypeIDResolver<mlir::mps::SoftplusParametricOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v20 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        v23 = (long long *)__p;
        uint64_t v24 = (char *)operator new(8uLL);
        *(void *)uint64_t v24 = (char *)v20 - 16;
        v48[0] = v23;
        uint64_t v25 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v23, (uint64_t)&std::piecewise_construct, v48);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v25 + 5, v24, v24 + 8, 1uLL);
        operator delete(v24);
        __int16 v26 = (void **)__p;
        if (__p)
        {
          __int16 v27 = (void **)v50;
          __int16 v28 = __p;
          if ((void *)v50 != __p)
          {
            do
            {
              if (*((char *)v27 - 1) < 0) {
                operator delete(*(v27 - 3));
              }
              v27 -= 3;
            }
            while (v27 != v26);
            __int16 v28 = __p;
          }
          *(void *)&long long v50 = v26;
          operator delete(v28);
        }
        return 1;
      }
      long long v31 = "result && \"builder didn't return the right type\"";
      int v32 = 497;
      uint64_t v33 = "Builders.h";
      uint64_t v34 = "create";
    }
    else
    {
      long long v31 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v32 = 662;
      uint64_t v33 = "Casting.h";
      uint64_t v34 = "dyn_cast";
    }
    __assert_rtn(v34, v33, v32, v31);
  }
  __p = operator new(0x40uLL);
  long long v50 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v29 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v50) < 0) {
    operator delete(__p);
  }
  return v29;
}

void sub_180DB77DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28)
{
  operator delete(v28);
  std::vector<std::string>::~vector[abi:ne180100](&a28);
  _Unwind_Resume(a1);
}

void sub_180DB77F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB7834(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void sub_180DB7848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void anonymous namespace'::GeneratedRewriter14::~GeneratedRewriter14(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter14::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter14 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v29 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v29);
    uint64_t v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.softsign", (const unsigned __int8 *)0xC, Context);
    if (!v9)
    {
      __int16 v35 = 1283;
      uint64_t v33 = "mps.softsign";
      uint64_t v34 = 12;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      __int16 v31 = 259;
      llvm::operator+(v32, v30, (uint64_t)v36);
      llvm::report_fatal_error((llvm::Twine *)v36, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    mlir::mps::ACosOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue);
    char v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    uint64_t v11 = v10;
    if (v10)
    {
      uint64_t v12 = *((void *)v10 + 6);
      uint64_t v13 = *(void **)(v12 + 16);
      if (v13 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v36[0] = *(long long **)(v12 + 8);
        uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v36);
        if (v27 == 12 && *(void *)AttrData == 0x74666F732E73706DLL && *(_DWORD *)(AttrData + 8) == 1852270963)
        {
          __int16 v35 = 1283;
          v32[0] = (uint64_t)"classof on '";
          uint64_t v33 = "mps.softsign";
          uint64_t v34 = 12;
          v30[0] = (uint64_t)"' failed due to the operation not being registered";
          __int16 v31 = 259;
          llvm::operator+(v32, v30, (uint64_t)v36);
          llvm::report_fatal_error((llvm::Twine *)v36, 1);
        }
      }
      else if (v13 == &mlir::detail::TypeIDResolver<mlir::mps::SoftsignOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v11 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v14 = (long long *)__p;
        uint64_t v15 = (char *)operator new(8uLL);
        *(void *)uint64_t v15 = (char *)v11 - 16;
        v36[0] = v14;
        long long v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v36);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        uint64_t v17 = (void **)__p;
        if (__p)
        {
          char v18 = (void **)v38;
          uint64_t v19 = __p;
          if ((void *)v38 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0) {
                operator delete(*(v18 - 3));
              }
              v18 -= 3;
            }
            while (v18 != v17);
            uint64_t v19 = __p;
          }
          *(void *)&long long v38 = v17;
          operator delete(v19);
        }
        return 1;
      }
      int v22 = "result && \"builder didn't return the right type\"";
      int v23 = 497;
      uint64_t v24 = "Builders.h";
      uint64_t v25 = "create";
    }
    else
    {
      int v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v23 = 662;
      uint64_t v24 = "Casting.h";
      uint64_t v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  long long v38 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v38) < 0) {
    operator delete(__p);
  }
  return v20;
}

void sub_180DB7D04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  operator delete(v26);
  std::vector<std::string>::~vector[abi:ne180100](&a26);
  _Unwind_Resume(a1);
}

void sub_180DB7D20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DB7D34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DB7D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter15::~GeneratedRewriter15(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter15::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter15 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v40 = ArgValue;
  uint64_t v39 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(ArgValue);
    __p = (void *)mlir::TypeAttr::get(ElementTypeOrSelf);
    uint64_t v8 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>(a3 + 18, LocationForOp, &v39, (uint64_t *)&__p);
    uint64_t v41 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
    uint64_t v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.greater_equal", (const unsigned __int8 *)0x11, Context);
    if (!v11)
    {
      __int16 v47 = 1283;
      uint64_t v45 = "mps.greater_equal";
      uint64_t v46 = 17;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      __int16 v43 = 259;
      llvm::operator+(v44, v42, (uint64_t)v48);
      llvm::report_fatal_error((llvm::Twine *)v48, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*((_DWORD *)v8 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::EqualToOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue, (uint64_t)v8 - 16);
    uint64_t v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v12)
    {
      uint64_t v13 = llvm::DefaultDoCastIfPossible<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GreaterThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        uint64_t v14 = mlir::getElementTypeOrSelf(ArgValue);
        uint64_t v15 = mlir::TypeAttr::get(v14);
        uint64_t v41 = LocationForOp;
        long long v16 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
        uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, v16);
        if (!v18)
        {
          __int16 v47 = 1283;
          uint64_t v45 = "mps.cast";
          uint64_t v46 = 8;
                            "sn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#register"
                            "ed-loaded-dependent-whats-up-with-dialects-management";
          __int16 v43 = 259;
          llvm::operator+(v44, v42, (uint64_t)v48);
          llvm::report_fatal_error((llvm::Twine *)v48, 1);
        }
        mlir::OperationState::OperationState(&__p, LocationForOp, v17);
        if (!*(_DWORD *)(v13 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        mlir::mps::CastOp::build(a3 + 18, (uint64_t)&__p, v13 - 16, v15);
        uint64_t v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
        if (v19)
        {
          uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
          if (v20)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
            uint64_t v38 = v20;
            uint64_t v21 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::mps::CastOp &,mlir::Value &>(a3 + 18, LocationForOp, (uint64_t)&v38, &v40);
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
            if (!*(_DWORD *)(v21 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            int v22 = (long long *)__p;
            int v23 = (char *)operator new(8uLL);
            *(void *)int v23 = v21 - 16;
            v48[0] = v22;
            uint64_t v24 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v22, (uint64_t)&std::piecewise_construct, v48);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v24 + 5, v23, v23 + 8, 1uLL);
            operator delete(v23);
            uint64_t v25 = (void **)__p;
            if (__p)
            {
              __int16 v26 = (void **)v50;
              uint64_t v27 = __p;
              if ((void *)v50 != __p)
              {
                do
                {
                  if (*((char *)v26 - 1) < 0) {
                    operator delete(*(v26 - 3));
                  }
                  v26 -= 3;
                }
                while (v26 != v25);
                uint64_t v27 = __p;
              }
              *(void *)&long long v50 = v25;
              operator delete(v27);
            }
            return 1;
          }
          uint64_t v34 = "result && \"builder didn't return the right type\"";
          int v35 = 497;
          uint64_t v36 = "Builders.h";
          BOOL v37 = "create";
        }
        else
        {
          uint64_t v34 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          int v35 = 662;
          uint64_t v36 = "Casting.h";
          BOOL v37 = "dyn_cast";
        }
        __assert_rtn(v37, v36, v35, v34);
      }
      uint64_t v30 = "result && \"builder didn't return the right type\"";
      int v31 = 497;
      int v32 = "Builders.h";
      uint64_t v33 = "create";
    }
    else
    {
      uint64_t v30 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v31 = 662;
      int v32 = "Casting.h";
      uint64_t v33 = "dyn_cast";
    }
    __assert_rtn(v33, v32, v31, v30);
  }
  __p = operator new(0x40uLL);
  long long v50 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v28 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v50) < 0) {
    operator delete(__p);
  }
  return v28;
}

void sub_180DB8354(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter16::~GeneratedRewriter16(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter16::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter16 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::AddOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB8710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter17::~GeneratedRewriter17(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter17::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter17 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::SubtractOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB8A64(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter18::~GeneratedRewriter18(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter18::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter18 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::EqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB8DB8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter19::~GeneratedRewriter19(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter19::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter19 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::MultiplyOp,mlir::Value,mlir::Value&>(a3 + 18, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB910C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter20::~GeneratedRewriter20(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter20::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter20 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::PowerOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB9460(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter21::~GeneratedRewriter21(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter21::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter21 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::MinimumOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB97B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter22::~GeneratedRewriter22(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter22::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter22 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::MaximumOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB9B08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter23::~GeneratedRewriter23(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter23::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter23 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ModuloOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = v6 - 16;
    uint64_t v19 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DB9E5C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ModuloOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.modulo", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.modulo";
    v21[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *a4);
  char v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    long long v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::ModuloOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ModuloOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    long long v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DBA018(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBA030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ModuloOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ModuloOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(void *)AttrData == 0x75646F6D2E73706DLL && *(_WORD *)(AttrData + 8) == 28524)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.modulo";
      v8[3] = 10;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ModuloOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter24::~GeneratedRewriter24(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter24::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter24 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::DivideOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBA440(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter25::~GeneratedRewriter25(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter25::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter25 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::GreaterThanOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBA794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter26::~GeneratedRewriter26(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter26::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter26 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::GreaterThanOrEqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBAAE8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter27::~GeneratedRewriter27(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter27::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter27 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBAE3C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter28::~GeneratedRewriter28(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter28::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter28 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::LessThanOrEqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = v6 - 16;
    uint64_t v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBB190(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::LessThanOrEqualToOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.less_equal", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.less_equal";
    v21[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::EqualToOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  char v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    long long v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::LessThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LessThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    long long v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DBB34C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBB364(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::LessThanOrEqualToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::LessThanOrEqualToOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x7373656C2E73706DLL && *(void *)((char *)AttrData + 6) == 0x6C617571655F7373)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.less_equal";
      v8[3] = 14;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::LessThanOrEqualToOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter29::~GeneratedRewriter29(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter29::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter29 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v27 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::AndOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v27);
    uint64_t v7 = mlir::IntegerType::get((uint64_t)a3[18], 1u, 0);
    uint64_t v8 = mlir::TypeAttr::get(v7);
    uint64_t v28 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
    uint64_t v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
    if (!v11)
    {
      __int16 v32 = 1283;
      v31[2] = (uint64_t)"mps.cast";
      v31[3] = 8;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v30 = 259;
      llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
      llvm::report_fatal_error((llvm::Twine *)v33, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::CastOp::build(a3 + 18, (uint64_t)&__p, v6 - 16, v8);
    uint64_t v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v12)
    {
      uint64_t v13 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v13 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v14 = (long long *)__p;
        int v15 = (char *)operator new(8uLL);
        *(void *)int v15 = v13 - 16;
        v33[0] = v14;
        long long v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v33);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        uint64_t v17 = (void **)__p;
        if (__p)
        {
          uint64_t v18 = (void **)v35;
          uint64_t v19 = __p;
          if ((void *)v35 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0) {
                operator delete(*(v18 - 3));
              }
              v18 -= 3;
            }
            while (v18 != v17);
            uint64_t v19 = __p;
          }
          *(void *)&long long v35 = v17;
          operator delete(v19);
        }
        return 1;
      }
      __int16 v22 = "result && \"builder didn't return the right type\"";
      int v23 = 497;
      uint64_t v24 = "Builders.h";
      uint64_t v25 = "create";
    }
    else
    {
      __int16 v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v23 = 662;
      uint64_t v24 = "Casting.h";
      uint64_t v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  long long v35 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v35) < 0) {
    operator delete(__p);
  }
  return v20;
}

void sub_180DBB8E0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DBB94C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::AndOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.and", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.and";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *a4);
  char v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    long long v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::AndOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AndOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    long long v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DBBADC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBBAF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::AndOp,mlir::Operation *,llvm::CastInfo<mlir::mps::AndOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684955438)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.and";
      v8[3] = 7;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::AndOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter30::~GeneratedRewriter30(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter30::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter30 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::NotEqualToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBBF00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter31::~GeneratedRewriter31(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter31::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter31 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v27 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::OrOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v27);
    uint64_t v7 = mlir::IntegerType::get((uint64_t)a3[18], 1u, 0);
    uint64_t v8 = mlir::TypeAttr::get(v7);
    uint64_t v28 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
    uint64_t v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
    if (!v11)
    {
      __int16 v32 = 1283;
      v31[2] = (uint64_t)"mps.cast";
      v31[3] = 8;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v30 = 259;
      llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
      llvm::report_fatal_error((llvm::Twine *)v33, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::CastOp::build(a3 + 18, (uint64_t)&__p, v6 - 16, v8);
    uint64_t v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v12)
    {
      uint64_t v13 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v13 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v14 = (long long *)__p;
        int v15 = (char *)operator new(8uLL);
        *(void *)int v15 = v13 - 16;
        v33[0] = v14;
        long long v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v33);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        uint64_t v17 = (void **)__p;
        if (__p)
        {
          uint64_t v18 = (void **)v35;
          uint64_t v19 = __p;
          if ((void *)v35 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0) {
                operator delete(*(v18 - 3));
              }
              v18 -= 3;
            }
            while (v18 != v17);
            uint64_t v19 = __p;
          }
          *(void *)&long long v35 = v17;
          operator delete(v19);
        }
        return 1;
      }
      __int16 v22 = "result && \"builder didn't return the right type\"";
      int v23 = 497;
      uint64_t v24 = "Builders.h";
      uint64_t v25 = "create";
    }
    else
    {
      __int16 v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v23 = 662;
      uint64_t v24 = "Casting.h";
      uint64_t v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  long long v35 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v35) < 0) {
    operator delete(__p);
  }
  return v20;
}

void sub_180DBC3B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DBC420(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::OrOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.or", (const unsigned __int8 *)6, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.or";
    v21[3] = 6;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *a4);
  char v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    long long v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::OrOp,mlir::Operation *,llvm::CastInfo<mlir::mps::OrOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    long long v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DBC5B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBC5C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::OrOp,mlir::Operation *,llvm::CastInfo<mlir::mps::OrOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 6 && *(_DWORD *)AttrData == 779317357 && *(_WORD *)(AttrData + 4) == 29295)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.or";
      v8[3] = 6;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::OrOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter32::~GeneratedRewriter32(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter32::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter32 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v27 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::XorOp,mlir::Value &,mlir::Value &>(a3 + 18, LocationForOp, &ArgValue, &v27);
    uint64_t v7 = mlir::IntegerType::get((uint64_t)a3[18], 1u, 0);
    uint64_t v8 = mlir::TypeAttr::get(v7);
    uint64_t v28 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
    uint64_t v10 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cast", (const unsigned __int8 *)8, Context);
    if (!v11)
    {
      __int16 v32 = 1283;
      v31[2] = (uint64_t)"mps.cast";
      v31[3] = 8;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v30 = 259;
      llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
      llvm::report_fatal_error((llvm::Twine *)v33, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v10);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::CastOp::build(a3 + 18, (uint64_t)&__p, v6 - 16, v8);
    uint64_t v12 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v12)
    {
      uint64_t v13 = llvm::DefaultDoCastIfPossible<mlir::mps::CastOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CastOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v12);
      if (v13)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v13 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v14 = (long long *)__p;
        int v15 = (char *)operator new(8uLL);
        *(void *)int v15 = v13 - 16;
        v33[0] = v14;
        long long v16 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v14, (uint64_t)&std::piecewise_construct, v33);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v16 + 5, v15, v15 + 8, 1uLL);
        operator delete(v15);
        uint64_t v17 = (void **)__p;
        if (__p)
        {
          uint64_t v18 = (void **)v35;
          uint64_t v19 = __p;
          if ((void *)v35 != __p)
          {
            do
            {
              if (*((char *)v18 - 1) < 0) {
                operator delete(*(v18 - 3));
              }
              v18 -= 3;
            }
            while (v18 != v17);
            uint64_t v19 = __p;
          }
          *(void *)&long long v35 = v17;
          operator delete(v19);
        }
        return 1;
      }
      __int16 v22 = "result && \"builder didn't return the right type\"";
      int v23 = 497;
      uint64_t v24 = "Builders.h";
      uint64_t v25 = "create";
    }
    else
    {
      __int16 v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v23 = 662;
      uint64_t v24 = "Casting.h";
      uint64_t v25 = "dyn_cast";
    }
    __assert_rtn(v25, v24, v23, v22);
  }
  __p = operator new(0x40uLL);
  long long v35 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v20 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v35) < 0) {
    operator delete(__p);
  }
  return v20;
}

void sub_180DBCB30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DBCB9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

uint64_t mlir::OpBuilder::create<mlir::mps::XorOp,mlir::Value &,mlir::Value &>(mlir::Float32Type **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.xor", (const unsigned __int8 *)7, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.xor";
    v21[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::ATan2Op::build(a1, (uint64_t)v24, *a3, *a4);
  char v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    long long v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::XorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::XorOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    long long v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DBCD2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBCD44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::XorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::XorOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1919907886)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.xor";
      v8[3] = 7;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::XorOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter33::~GeneratedRewriter33(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter33::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter33 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "y");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v30 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v30);
    uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor_divide", (const unsigned __int8 *)0x10, Context);
    if (!v10)
    {
      __int16 v36 = 1283;
      uint64_t v34 = "mps.floor_divide";
      uint64_t v35 = 16;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      __int16 v32 = 259;
      llvm::operator+(v33, v31, (uint64_t)v37);
      llvm::report_fatal_error((llvm::Twine *)v37, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v9);
    mlir::mps::ATan2Op::build(a3 + 18, (uint64_t)&__p, ArgValue, v7);
    char v11 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    uint64_t v12 = v11;
    if (v11)
    {
      uint64_t v13 = *((void *)v11 + 6);
      uint64_t v14 = *(void **)(v13 + 16);
      if (v14 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        v37[0] = *(long long **)(v13 + 8);
        uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v37);
        if (v28 == 16 && *AttrData == 0x6F6F6C662E73706DLL && AttrData[1] == 0x6564697669645F72)
        {
          __int16 v36 = 1283;
          v33[0] = (uint64_t)"classof on '";
          uint64_t v34 = "mps.floor_divide";
          uint64_t v35 = 16;
          v31[0] = (uint64_t)"' failed due to the operation not being registered";
          __int16 v32 = 259;
          llvm::operator+(v33, v31, (uint64_t)v37);
          llvm::report_fatal_error((llvm::Twine *)v37, 1);
        }
      }
      else if (v14 == &mlir::detail::TypeIDResolver<mlir::mps::FloorDivideOp,void>::id)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*((_DWORD *)v12 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        int v15 = (long long *)__p;
        long long v16 = (char *)operator new(8uLL);
        *(void *)long long v16 = (char *)v12 - 16;
        v37[0] = v15;
        uint64_t v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v15, (uint64_t)&std::piecewise_construct, v37);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
        operator delete(v16);
        uint64_t v18 = (void **)__p;
        if (__p)
        {
          uint64_t v19 = (void **)v39;
          __int16 v20 = __p;
          if ((void *)v39 != __p)
          {
            do
            {
              if (*((char *)v19 - 1) < 0) {
                operator delete(*(v19 - 3));
              }
              v19 -= 3;
            }
            while (v19 != v18);
            __int16 v20 = __p;
          }
          *(void *)&long long v39 = v18;
          operator delete(v20);
        }
        return 1;
      }
      int v23 = "result && \"builder didn't return the right type\"";
      int v24 = 497;
      uint64_t v25 = "Builders.h";
      __int16 v26 = "create";
    }
    else
    {
      int v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v24 = 662;
      uint64_t v25 = "Casting.h";
      __int16 v26 = "dyn_cast";
    }
    __assert_rtn(v26, v25, v24, v23);
  }
  __p = operator new(0x40uLL);
  long long v39 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v21 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v39) < 0) {
    operator delete(__p);
  }
  return v21;
}

void sub_180DBD30C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  operator delete(v26);
  std::vector<std::string>::~vector[abi:ne180100](&a26);
  _Unwind_Resume(a1);
}

void sub_180DBD328(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBD33C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DBD378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter34::~GeneratedRewriter34(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter34::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter34 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::AbsoluteOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = v6 - 16;
    uint64_t v18 = v7;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBD684(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter35::~GeneratedRewriter35(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter35::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter35 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ACosOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = v6 - 16;
    uint64_t v18 = v7;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBD9BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ACosOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.acos", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.acos";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ACosOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ACosOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DBDB70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBDB88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ACosOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ACosOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x736F63612E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.acos";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ACosOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter36::~GeneratedRewriter36(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter36::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter36 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ACoshOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = v6 - 16;
    __int16 v18 = v7;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBDF70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ACoshOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.acosh", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.acosh";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ACoshOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ACoshOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DBE124(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBE13C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ACoshOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ACoshOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x736F63612E73706DLL && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.acosh";
      v8[3] = 9;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ACoshOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter37::~GeneratedRewriter37(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter37::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter37 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ASinOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBE530(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ASinOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.asin", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.asin";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ASinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ASinOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DBE6E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBE6FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ASinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ASinOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6E6973612E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.asin";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ASinOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter38::~GeneratedRewriter38(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter38::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter38 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ASinhOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBEAE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ASinhOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.asinh", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.asinh";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ASinhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ASinhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DBEC98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBECB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ASinhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ASinhOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x6E6973612E73706DLL && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.asinh";
      v8[3] = 9;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ASinhOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter39::~GeneratedRewriter39(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter39::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter39 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ATanOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBF0A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ATanOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atan", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.atan";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ATanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ATanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DBF258(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBF270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ATanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ATanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6E6174612E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.atan";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ATanOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter40::~GeneratedRewriter40(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter40::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter40 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ATanhOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBF658(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ATanhOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.atanh", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.atanh";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ATanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ATanhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DBF80C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DBF824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ATanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ATanhOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x6E6174612E73706DLL && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.atanh";
      v8[3] = 9;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ATanhOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter41::~GeneratedRewriter41(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter41::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter41 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::CeilOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBFC18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter42::~GeneratedRewriter42(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter42::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter42 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::CosOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DBFF50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CosOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cos", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.cos";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::CosOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CosOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC0104(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC011C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CosOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CosOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1936679726)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.cos";
      v8[3] = 7;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CosOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter43::~GeneratedRewriter43(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter43::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter43 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::CoshOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC050C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::CoshOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.cosh", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.cosh";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::CoshOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CoshOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC06C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC06D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::CoshOp,mlir::Operation *,llvm::CastInfo<mlir::mps::CoshOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x68736F632E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.cosh";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::CoshOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter44::~GeneratedRewriter44(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter44::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter44 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v17 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  uint64_t v19 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "beta");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    __int16 v6 = mlir::OpBuilder::create<mlir::mps::ClampOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v17, &v19);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = (char *)v6 - 16;
    __int16 v20 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v20);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC0AF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter45::~GeneratedRewriter45(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter45::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter45 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    __int16 v6 = mlir::OpBuilder::create<mlir::mps::ExponentOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = (char *)v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC0E30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter46::~GeneratedRewriter46(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter46::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter46 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ExponentBase2Op,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC1168(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::ExponentBase2Op,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.exponent_base_2", (const unsigned __int8 *)0x13, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.exponent_base_2";
    v19[3] = 19;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::ExponentBase2Op,mlir::Operation *,llvm::CastInfo<mlir::mps::ExponentBase2Op,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC131C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC1334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ExponentBase2Op,mlir::Operation *,llvm::CastInfo<mlir::mps::ExponentBase2Op,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 19
      && *AttrData == 0x6F7078652E73706DLL
      && AttrData[1] == 0x7361625F746E656ELL
      && *(void *)((char *)AttrData + 11) == 0x325F657361625F74)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.exponent_base_2";
      v9[3] = 19;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ExponentBase2Op,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter47::~GeneratedRewriter47(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter47::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter47 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    __int16 v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC1748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::FloorOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.floor", (const unsigned __int8 *)9, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.floor";
    v19[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::FloorOp,mlir::Operation *,llvm::CastInfo<mlir::mps::FloorOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC18FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC1914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter48::~GeneratedRewriter48(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter48::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter48 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::NotOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC1C20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::NotOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.not", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.not";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::NotOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NotOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC1DD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC1DEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::NotOp,mlir::Operation *,llvm::CastInfo<mlir::mps::NotOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1953459758)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.not";
      v8[3] = 7;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::NotOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter49::~GeneratedRewriter49(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter49::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter49 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::RoundOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC21DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter50::~GeneratedRewriter50(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter50::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter50 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::SignOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC2514(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SignOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sign", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.sign";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SignOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SignOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC26C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC26E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SignOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SignOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x6E6769732E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.sign";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SignOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter51::~GeneratedRewriter51(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter51::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter51 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::SinOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC2AC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SinOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sin", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.sin";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SinOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC2C7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC2C94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SinOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SinOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1852404526)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.sin";
      v8[3] = 7;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SinOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter52::~GeneratedRewriter52(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter52::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter52 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::SinhOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC3084(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SinhOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.sinh", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.sinh";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SinhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SinhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC3238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC3250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SinhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SinhOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x686E69732E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.sinh";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SinhOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter53::~GeneratedRewriter53(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter53::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter53 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC3638(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::SquareRootOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.square_root", (const unsigned __int8 *)0xF, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.square_root";
    v19[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::SquareRootOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SquareRootOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC37EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC3804(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter54::~GeneratedRewriter54(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter54::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter54 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::SquareOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC3B10(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter55::~GeneratedRewriter55(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter55::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter55 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::TanOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC3E48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TanOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tan", (const unsigned __int8 *)7, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.tan";
    v19[3] = 7;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::TanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC3FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC4014(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TanOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1851880494)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.tan";
      v8[3] = 7;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TanOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter56::~GeneratedRewriter56(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter56::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter56 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    char v8 = (char *)operator new(8uLL);
    *(void *)char v8 = v6 - 16;
    __int16 v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC4404(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TanhOp,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tanh", (const unsigned __int8 *)8, Context);
  if (!v8)
  {
    __int16 v20 = 1283;
    v19[2] = (uint64_t)"mps.tanh";
    v19[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v7);
  mlir::mps::ACosOp::build((uint64_t)a1, (uint64_t)v22, *a3);
  __int16 v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (!v9)
  {
    uint64_t v12 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v13 = 662;
    uint64_t v14 = "Casting.h";
    int v15 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v10 = llvm::DefaultDoCastIfPossible<mlir::mps::TanhOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TanhOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v9);
  if (!v10)
  {
    uint64_t v12 = "result && \"builder didn't return the right type\"";
    int v13 = 497;
    uint64_t v14 = "Builders.h";
    int v15 = "create";
LABEL_8:
    __assert_rtn(v15, v14, v13, v12);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v10;
}

void sub_180DC45B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC45D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter57::~GeneratedRewriter57(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter57::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter57 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v24 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "alpha");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::LessThanOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v24);
    uint64_t v26 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
    uint64_t v8 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
    if (!v9)
    {
      __int16 v30 = 1283;
      v29[2] = (uint64_t)"mps.select";
      v29[3] = 10;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v28 = 259;
      llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
      llvm::report_fatal_error((llvm::Twine *)v31, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v8);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::SelectOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, (uint64_t)v6 - 16, v24, ArgValue);
    uint64_t v10 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v10)
    {
      uint64_t v11 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v10);
      if (v11)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v11 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v12 = (long long *)__p;
        int v13 = (char *)operator new(8uLL);
        *(void *)int v13 = v11 - 16;
        v31[0] = v12;
        uint64_t v14 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v12, (uint64_t)&std::piecewise_construct, v31);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v14 + 5, v13, v13 + 8, 1uLL);
        operator delete(v13);
        int v15 = (void **)__p;
        if (__p)
        {
          uint64_t v16 = (void **)v33;
          uint64_t v17 = __p;
          if ((void *)v33 != __p)
          {
            do
            {
              if (*((char *)v16 - 1) < 0) {
                operator delete(*(v16 - 3));
              }
              v16 -= 3;
            }
            while (v16 != v15);
            uint64_t v17 = __p;
          }
          *(void *)&long long v33 = v15;
          operator delete(v17);
        }
        return 1;
      }
      __int16 v20 = "result && \"builder didn't return the right type\"";
      int v21 = 497;
      __int16 v22 = "Builders.h";
      int v23 = "create";
    }
    else
    {
      __int16 v20 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v21 = 662;
      __int16 v22 = "Casting.h";
      int v23 = "dyn_cast";
    }
    __assert_rtn(v23, v22, v21, v20);
  }
  __p = operator new(0x40uLL);
  long long v33 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v18 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  return v18;
}

void sub_180DC4A40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a33 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DC4AAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
}

void anonymous namespace'::GeneratedRewriter58::~GeneratedRewriter58(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter58::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter58 *this, const MIL::IROperation *a2, MILToMLIRRewriter *a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp((mlir::StringAttr **)a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "cond");
  uint64_t v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "a");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "b");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v8 = mlir::IntegerType::get(*((void *)a3 + 18), 1u, 0);
    __p = (void *)mlir::TypeAttr::get(v8);
    char v9 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::TypeAttr &>((mlir::UnknownLoc **)a3 + 18, LocationForOp, &ArgValue, (uint64_t *)&__p);
    uint64_t v28 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v28);
    uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, Context);
    if (!v12)
    {
      __int16 v32 = 1283;
      v31[2] = (uint64_t)"mps.select";
      v31[3] = 10;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v30 = 259;
      llvm::operator+(v31, (uint64_t *)&v29, (uint64_t)v33);
      llvm::report_fatal_error((llvm::Twine *)v33, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v11);
    if (!*((_DWORD *)v9 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::SelectOp::build((uint64_t)a3 + 144, (uint64_t)&__p, (uint64_t)v9 - 16, v6, v7);
    int v13 = mlir::OpBuilder::create((MILToMLIRRewriter *)((char *)a3 + 144), (const mlir::OperationState *)&__p);
    if (v13)
    {
      uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
      if (v14)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v14 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        int v15 = (long long *)__p;
        uint64_t v16 = (char *)operator new(8uLL);
        *(void *)uint64_t v16 = v14 - 16;
        v33[0] = v15;
        uint64_t v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a3 + 64, (uint64_t)v15, (uint64_t)&std::piecewise_construct, v33);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
        operator delete(v16);
        uint64_t v18 = (void **)__p;
        if (__p)
        {
          uint64_t v19 = (void **)v35;
          __int16 v20 = __p;
          if ((void *)v35 != __p)
          {
            do
            {
              if (*((char *)v19 - 1) < 0) {
                operator delete(*(v19 - 3));
              }
              v19 -= 3;
            }
            while (v19 != v18);
            __int16 v20 = __p;
          }
          *(void *)&long long v35 = v18;
          operator delete(v20);
        }
        return 1;
      }
      int v23 = "result && \"builder didn't return the right type\"";
      int v24 = 497;
      uint64_t v25 = "Builders.h";
      uint64_t v26 = "create";
    }
    else
    {
      int v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v24 = 662;
      uint64_t v25 = "Casting.h";
      uint64_t v26 = "dyn_cast";
    }
    __assert_rtn(v26, v25, v24, v23);
  }
  __p = operator new(0x40uLL);
  long long v35 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v21 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v35) < 0) {
    operator delete(__p);
  }
  return v21;
}

void sub_180DC4F58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DC4FC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter59::~GeneratedRewriter59(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter59::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter59 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::IdentityOp,mlir::Value>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v18 = v7;
    char v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = (void **)v16;
      char v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        char v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC52D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter60::~GeneratedRewriter60(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter60::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter60 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  uint64_t v54 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "one_hot_vector_size");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  uint64_t v8 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "on_value");
  uint64_t v9 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "off_value");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v11 = (uint64_t *)(a3 + 18);
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v10);
    int v13 = operator new(8uLL);
    *int v13 = 1;
    uint64_t v14 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    int v15 = (uint64_t *)mlir::RankedTensorType::get((uint64_t)v13, 1, v14, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v15, -1);
    long long v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&__p);
    uint64_t v55 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v55);
    uint64_t v18 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.expand_dims", (const unsigned __int8 *)0xF, Context);
    if (!v19)
    {
      __int16 v61 = 1283;
      v59 = "mps.expand_dims";
      uint64_t v60 = 15;
                        " been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loade"
                        "d-dependent-whats-up-with-dialects-management";
      __int16 v57 = 259;
      llvm::operator+(v58, v56, (uint64_t)v62);
      llvm::report_fatal_error((llvm::Twine *)v62, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v18);
    if (!*((_DWORD *)v16 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ExpandDimsOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue, (uint64_t)v16 - 16);
    __int16 v20 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v20)
    {
      uint64_t v21 = llvm::DefaultDoCastIfPossible<mlir::mps::ExpandDimsOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ExpandDimsOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v20);
      if (v21)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        operator delete(v13);
        __p = (void *)mlir::IntegerType::get(*v11, 0x20u, 2u);
        __int16 v22 = mlir::OpBuilder::create<mlir::mps::CastOp,mlir::Value &,mlir::Type>(a3 + 18, LocationForOp, &v54, (uint64_t *)&__p);
        uint64_t v23 = mlir::IntegerType::get(*v11, 1u, 0);
        uint64_t v55 = LocationForOp;
        int v24 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v55);
        uint64_t v25 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.one_hot", (const unsigned __int8 *)0xB, v24);
        if (!v26)
        {
          __int16 v61 = 1283;
          v59 = "mps.one_hot";
          uint64_t v60 = 11;
                            "sn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#register"
                            "ed-loaded-dependent-whats-up-with-dialects-management";
          __int16 v57 = 259;
          llvm::operator+(v58, v56, (uint64_t)v62);
          llvm::report_fatal_error((llvm::Twine *)v62, 1);
        }
        mlir::OperationState::OperationState(&__p, LocationForOp, v25);
        if (!*(_DWORD *)(v21 + 36) || !*((_DWORD *)v22 + 9)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        mlir::mps::OneHotOp::build(a3 + 18, (uint64_t)&__p, v21 - 16, (uint64_t)v22 - 16, v7, v23);
        uint64_t v27 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
        if (v27)
        {
          uint64_t v28 = llvm::DefaultDoCastIfPossible<mlir::mps::OneHotOp,mlir::Operation *,llvm::CastInfo<mlir::mps::OneHotOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v27);
          if (v28)
          {
            mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
            uint64_t v55 = LocationForOp;
            uint64_t v29 = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v55);
            uint64_t v30 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.select", (const unsigned __int8 *)0xA, v29);
            if (!v31)
            {
              __int16 v61 = 1283;
              v59 = "mps.select";
              uint64_t v60 = 10;
                                "n hasn't been added by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#"
                                "registered-loaded-dependent-whats-up-with-dialects-management";
              __int16 v57 = 259;
              llvm::operator+(v58, v56, (uint64_t)v62);
              llvm::report_fatal_error((llvm::Twine *)v62, 1);
            }
            mlir::OperationState::OperationState(&__p, LocationForOp, v30);
            if (!*(_DWORD *)(v28 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            mlir::mps::SelectOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, v28 - 16, v8, v9);
            __int16 v32 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
            if (v32)
            {
              uint64_t v33 = llvm::DefaultDoCastIfPossible<mlir::mps::SelectOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SelectOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v32);
              if (v33)
              {
                mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
                (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
                if (!*(_DWORD *)(v33 + 36)) {
                  __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                }
                uint64_t v34 = (long long *)__p;
                long long v35 = (char *)operator new(8uLL);
                *(void *)long long v35 = v33 - 16;
                v62[0] = v34;
                uint64_t v36 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v34, (uint64_t)&std::piecewise_construct, v62);
                std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v36 + 5, v35, v35 + 8, 1uLL);
                operator delete(v35);
                BOOL v37 = (void **)__p;
                if (__p)
                {
                  uint64_t v38 = (void **)v64;
                  long long v39 = __p;
                  if ((void *)v64 != __p)
                  {
                    do
                    {
                      if (*((char *)v38 - 1) < 0) {
                        operator delete(*(v38 - 3));
                      }
                      v38 -= 3;
                    }
                    while (v38 != v37);
                    long long v39 = __p;
                  }
                  *(void *)&long long v64 = v37;
                  operator delete(v39);
                }
                return 1;
              }
              long long v50 = "result && \"builder didn't return the right type\"";
              int v51 = 497;
              v52 = "Builders.h";
              v53 = "create";
            }
            else
            {
              long long v50 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
              int v51 = 662;
              v52 = "Casting.h";
              v53 = "dyn_cast";
            }
            __assert_rtn(v53, v52, v51, v50);
          }
          uint64_t v46 = "result && \"builder didn't return the right type\"";
          int v47 = 497;
          v48 = "Builders.h";
          v49 = "create";
        }
        else
        {
          uint64_t v46 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
          int v47 = 662;
          v48 = "Casting.h";
          v49 = "dyn_cast";
        }
        __assert_rtn(v49, v48, v47, v46);
      }
      v42 = "result && \"builder didn't return the right type\"";
      int v43 = 497;
      long long v44 = "Builders.h";
      uint64_t v45 = "create";
    }
    else
    {
      v42 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v43 = 662;
      long long v44 = "Casting.h";
      uint64_t v45 = "dyn_cast";
    }
    __assert_rtn(v45, v44, v43, v42);
  }
  __p = operator new(0x40uLL);
  long long v64 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v40 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v64) < 0) {
    operator delete(__p);
  }
  return v40;
}

void sub_180DC5AD0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,int a29,__int16 a30,char a31,char a32)
{
  if (a32 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::OneHotOp,mlir::Operation *,llvm::CastInfo<mlir::mps::OneHotOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x5F656E6F2E73706DLL && *(void *)((char *)AttrData + 3) == 0x746F685F656E6F2ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.one_hot";
      v8[3] = 11;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::OneHotOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter61::~GeneratedRewriter61(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter61::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter61 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = (char *)v6 - 16;
    uint64_t v18 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v18);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = (void **)v16;
      char v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        char v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC5F98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter62::~GeneratedRewriter62(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter62::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter62 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "reps");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::TileOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    __int16 v7 = (long long *)__p;
    uint64_t v8 = (char *)operator new(8uLL);
    *(void *)uint64_t v8 = v6 - 16;
    char v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = (void **)v16;
      char v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        char v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC62EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::TileOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.tile", (const unsigned __int8 *)8, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.tile";
    v21[3] = 8;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::TileOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    long long v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::TileOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TileOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    long long v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DC64A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC64C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::TileOp,mlir::Operation *,llvm::CastInfo<mlir::mps::TileOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v9[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v9);
    if (v4 == 8 && *AttrData == 0x656C69742E73706DLL)
    {
      __int16 v8 = 1283;
      v7[0] = (uint64_t)"classof on '";
      v7[2] = (uint64_t)"mps.tile";
      v7[3] = 8;
      v5 = "' failed due to the operation not being registered";
      __int16 v6 = 259;
      llvm::operator+(v7, (uint64_t *)&v5, (uint64_t)v9);
      llvm::report_fatal_error((llvm::Twine *)v9, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::TileOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter63::~GeneratedRewriter63(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter63::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter63 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  uint64_t v8 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "updates");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "mode");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    char v40 = 3;
    LODWORD(v39[0]) = 6579297;
    char v43 = 3;
    int v41 = 0;
    LODWORD(v42[0]) = 6452595;
    char v46 = 3;
    int v44 = 1;
    LODWORD(v45[0]) = 7107949;
    char v49 = 3;
    int v47 = 2;
    LODWORD(v48[0]) = 7760228;
    char v52 = 3;
    int v50 = 3;
    LODWORD(v51[0]) = 7235949;
    int v53 = 4;
    char v55 = 3;
    LODWORD(v54[0]) = 7889261;
    char v58 = 6;
    int v56 = 5;
    strcpy((char *)v57, "update");
    int v59 = 6;
    v32[0] = 0;
    v32[1] = 0;
    char v31 = v32;
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v39, (uint64_t)v39);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v42, (uint64_t)v42);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v45, (uint64_t)v45);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v48, (uint64_t)v48);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v51, (uint64_t)v51);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v54, (uint64_t)v54);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v31, (uint64_t)v32, (const void **)v57, (uint64_t)v57);
    char v28 = 4;
    strcpy((char *)v27, "mode");
    MIL::IROperation::TryGetParameterValue();
    MIL::IRValue::GetScalar<std::string>();
    unsigned int v9 = *((_DWORD *)std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v31, (const void **)v29, (uint64_t)v29)+ 14);
    uint64_t v33 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v33);
    uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter_nd", (const unsigned __int8 *)0xE, Context);
    if (!v12)
    {
      __int16 v37 = 1283;
      v36[2] = (uint64_t)"mps.scatter_nd";
      v36[3] = 14;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v35 = 259;
      llvm::operator+(v36, (uint64_t *)&v34, (uint64_t)v38);
      llvm::report_fatal_error((llvm::Twine *)v38, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v11);
    mlir::mps::ScatterNDOp::build((mlir::Builder *)(a3 + 18), (uint64_t)&__p, ArgValue, v8, v7, 0, v9);
    int v13 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v13)
    {
      uint64_t v14 = llvm::DefaultDoCastIfPossible<mlir::mps::ScatterNDOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterNDOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v13);
      if (v14)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v30 < 0)
        {
          operator delete(v29[0]);
          if ((v28 & 0x80000000) == 0)
          {
LABEL_7:
            std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v32[0]);
            if ((v58 & 0x80000000) == 0) {
              goto LABEL_8;
            }
            goto LABEL_29;
          }
        }
        else if ((v28 & 0x80000000) == 0)
        {
          goto LABEL_7;
        }
        operator delete(v27[0]);
        std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v32[0]);
        if ((v58 & 0x80000000) == 0)
        {
LABEL_8:
          if ((v55 & 0x80000000) == 0) {
            goto LABEL_9;
          }
          goto LABEL_30;
        }
LABEL_29:
        operator delete(v57[0]);
        if ((v55 & 0x80000000) == 0)
        {
LABEL_9:
          if ((v52 & 0x80000000) == 0) {
            goto LABEL_10;
          }
          goto LABEL_31;
        }
LABEL_30:
        operator delete(v54[0]);
        if ((v52 & 0x80000000) == 0)
        {
LABEL_10:
          if ((v49 & 0x80000000) == 0) {
            goto LABEL_11;
          }
          goto LABEL_32;
        }
LABEL_31:
        operator delete(v51[0]);
        if ((v49 & 0x80000000) == 0)
        {
LABEL_11:
          if ((v46 & 0x80000000) == 0) {
            goto LABEL_12;
          }
          goto LABEL_33;
        }
LABEL_32:
        operator delete(v48[0]);
        if ((v46 & 0x80000000) == 0)
        {
LABEL_12:
          if ((v43 & 0x80000000) == 0) {
            goto LABEL_13;
          }
          goto LABEL_34;
        }
LABEL_33:
        operator delete(v45[0]);
        if ((v43 & 0x80000000) == 0)
        {
LABEL_13:
          if ((v40 & 0x80000000) == 0)
          {
LABEL_14:
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
            if (!*(_DWORD *)(v14 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            int v15 = __p;
            long long v16 = (char *)operator new(8uLL);
            *(void *)long long v16 = v14 - 16;
            v39[0] = v15;
            uint64_t v17 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v15, (uint64_t)&std::piecewise_construct, (long long **)v39);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v17 + 5, v16, v16 + 8, 1uLL);
            operator delete(v16);
            uint64_t v18 = (void **)__p;
            if (__p)
            {
              char v19 = (void **)v61;
              __int16 v20 = __p;
              if ((void *)v61 != __p)
              {
                do
                {
                  if (*((char *)v19 - 1) < 0) {
                    operator delete(*(v19 - 3));
                  }
                  v19 -= 3;
                }
                while (v19 != v18);
                __int16 v20 = __p;
              }
              *(void *)&long long v61 = v18;
              operator delete(v20);
            }
            return 1;
          }
LABEL_35:
          operator delete(v39[0]);
          goto LABEL_14;
        }
LABEL_34:
        operator delete(v42[0]);
        if ((v40 & 0x80000000) == 0) {
          goto LABEL_14;
        }
        goto LABEL_35;
      }
      uint64_t v23 = "result && \"builder didn't return the right type\"";
      int v24 = 497;
      uint64_t v25 = "Builders.h";
      char v26 = "create";
    }
    else
    {
      uint64_t v23 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v24 = 662;
      uint64_t v25 = "Casting.h";
      char v26 = "dyn_cast";
    }
    __assert_rtn(v26, v25, v24, v23);
  }
  __p = operator new(0x40uLL);
  long long v61 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v21 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v61) < 0) {
    operator delete(__p);
  }
  return v21;
}

void sub_180DC6C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,char *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,int a42,__int16 a43,char a44,char a45,uint64_t a46,void *a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,void *a54,uint64_t a55,int a56,__int16 a57,char a58,char a59,uint64_t a60,void *a61,uint64_t a62,int a63)
{
  mlir::OperationState::~OperationState((mlir::OperationState *)&a77);
  if (a20 < 0)
  {
    operator delete(a15);
    if ((a14 & 0x80000000) == 0)
    {
LABEL_3:
      std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(a22);
      if ((a76 & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_13;
    }
  }
  else if ((a14 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a9);
  std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(a22);
  if ((a76 & 0x80000000) == 0)
  {
LABEL_4:
    if ((a74 & 0x80000000) == 0) {
      goto LABEL_5;
    }
    goto LABEL_14;
  }
LABEL_13:
  operator delete(a75);
  if ((a74 & 0x80000000) == 0)
  {
LABEL_5:
    if ((a72 & 0x80000000) == 0) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }
LABEL_14:
  operator delete(a73);
  if ((a72 & 0x80000000) == 0)
  {
LABEL_6:
    if ((a66 & 0x80000000) == 0) {
      goto LABEL_7;
    }
    goto LABEL_16;
  }
LABEL_15:
  operator delete(a68);
  if ((a66 & 0x80000000) == 0)
  {
LABEL_7:
    if ((a59 & 0x80000000) == 0) {
      goto LABEL_8;
    }
    goto LABEL_17;
  }
LABEL_16:
  operator delete(a61);
  if ((a59 & 0x80000000) == 0)
  {
LABEL_8:
    if ((a52 & 0x80000000) == 0) {
      goto LABEL_9;
    }
    goto LABEL_18;
  }
LABEL_17:
  operator delete(a54);
  if ((a52 & 0x80000000) == 0)
  {
LABEL_9:
    if (a45 < 0) {
      goto LABEL_10;
    }
    goto LABEL_19;
  }
LABEL_18:
  operator delete(a47);
  if (a45 < 0)
  {
LABEL_10:
    operator delete(__p);
    _Unwind_Resume(a1);
  }
LABEL_19:
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ScatterNDOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterNDOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 14 && *AttrData == 0x746163732E73706DLL && *(void *)((char *)AttrData + 6) == 0x646E5F7265747461)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.scatter_nd";
      v8[3] = 14;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id)
  {
    return 0;
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>(uint64_t *result, uint64_t a2, const void **a3, uint64_t a4)
{
  __int16 v6 = (void *)a2;
  __int16 v7 = result;
  uint64_t v8 = result + 1;
  if (result + 1 != (uint64_t *)a2)
  {
    int v9 = *(char *)(a2 + 55);
    int v10 = *((char *)a3 + 23);
    if (v10 >= 0) {
      size_t v11 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      size_t v11 = (size_t)a3[1];
    }
    if (v10 >= 0) {
      char v12 = a3;
    }
    else {
      char v12 = *a3;
    }
    if (v9 >= 0) {
      size_t v13 = *(unsigned __int8 *)(a2 + 55);
    }
    else {
      size_t v13 = *(void *)(a2 + 40);
    }
    if (v9 >= 0) {
      uint64_t v14 = (const void *)(a2 + 32);
    }
    else {
      uint64_t v14 = *(const void **)(a2 + 32);
    }
    if (v13 >= v11) {
      size_t v15 = v11;
    }
    else {
      size_t v15 = v13;
    }
    uint64_t result = (uint64_t *)memcmp(v12, v14, v15);
    BOOL v16 = v11 < v13;
    if (result) {
      BOOL v16 = (int)result < 0;
    }
    if (!v16)
    {
      uint64_t result = (uint64_t *)memcmp(v14, v12, v15);
      BOOL v20 = v13 < v11;
      if (result) {
        BOOL v20 = (int)result < 0;
      }
      if (v20)
      {
        __int16 v22 = v6 + 1;
        uint64_t v21 = (void *)v6[1];
        if (v21)
        {
          do
          {
            __int16 v22 = v21;
            uint64_t v21 = (void *)*v21;
            __int16 v6 = v22;
            uint64_t v23 = v22;
          }
          while (v21);
        }
        else
        {
          uint64_t v23 = v6;
          do
          {
            char v46 = v23;
            uint64_t v23 = (void *)v23[2];
          }
          while ((void *)*v23 != v46);
        }
        if (v23 == v8) {
          goto LABEL_96;
        }
        char v49 = (const void *)v23[4];
        int v47 = v23 + 4;
        v48 = v49;
        int v50 = *((char *)v47 + 23);
        if (v50 >= 0) {
          size_t v51 = *((unsigned __int8 *)v47 + 23);
        }
        else {
          size_t v51 = v47[1];
        }
        if (v50 >= 0) {
          char v52 = v47;
        }
        else {
          char v52 = v48;
        }
        if (v51 >= v11) {
          size_t v53 = v11;
        }
        else {
          size_t v53 = v51;
        }
        int v54 = memcmp(v12, v52, v53);
        BOOL v55 = v11 < v51;
        if (v54) {
          BOOL v55 = v54 < 0;
        }
        if (v55) {
          goto LABEL_96;
        }
        int v56 = (void *)*v8;
        __int16 v22 = v8;
        __int16 v6 = v8;
        if (!*v8) {
          goto LABEL_96;
        }
        while (1)
        {
          while (1)
          {
            __int16 v6 = v56;
            long long v61 = (const void *)v56[4];
            int v59 = v56 + 4;
            uint64_t v60 = v61;
            int v62 = *((char *)v59 + 23);
            if (v62 >= 0) {
              size_t v63 = *((unsigned __int8 *)v59 + 23);
            }
            else {
              size_t v63 = v59[1];
            }
            if (v62 >= 0) {
              long long v64 = v59;
            }
            else {
              long long v64 = v60;
            }
            if (v63 >= v11) {
              size_t v65 = v11;
            }
            else {
              size_t v65 = v63;
            }
            int v66 = memcmp(v12, v64, v65);
            BOOL v67 = v11 < v63;
            if (v66) {
              BOOL v67 = v66 < 0;
            }
            if (!v67) {
              break;
            }
            int v56 = (void *)*v6;
            __int16 v22 = v6;
            if (!*v6) {
              goto LABEL_96;
            }
          }
          uint64_t result = (uint64_t *)memcmp(v64, v12, v65);
          BOOL v68 = v63 < v11;
          if (result) {
            BOOL v68 = (int)result < 0;
          }
          if (!v68) {
            break;
          }
          int v56 = (void *)v6[1];
          if (!v56)
          {
LABEL_79:
            __int16 v22 = v6 + 1;
            goto LABEL_96;
          }
        }
      }
      return result;
    }
  }
  uint64_t v17 = *v6;
  if ((void *)*v7 == v6)
  {
    char v19 = v6;
  }
  else
  {
    if (v17)
    {
      uint64_t v18 = (void *)*v6;
      do
      {
        char v19 = v18;
        uint64_t v18 = (void *)v18[1];
      }
      while (v18);
    }
    else
    {
      int v24 = v6;
      do
      {
        char v19 = (void *)v24[2];
        BOOL v25 = *v19 == (void)v24;
        int v24 = v19;
      }
      while (v25);
    }
    int v26 = *((char *)a3 + 23);
    int v27 = *((char *)v19 + 55);
    if (v27 >= 0) {
      size_t v28 = *((unsigned __int8 *)v19 + 55);
    }
    else {
      size_t v28 = v19[5];
    }
    if (v27 >= 0) {
      uint64_t v29 = v19 + 4;
    }
    else {
      uint64_t v29 = (const void *)v19[4];
    }
    if (v26 >= 0) {
      size_t v30 = *((unsigned __int8 *)a3 + 23);
    }
    else {
      size_t v30 = (size_t)a3[1];
    }
    if (v26 >= 0) {
      char v31 = a3;
    }
    else {
      char v31 = *a3;
    }
    if (v30 >= v28) {
      size_t v32 = v28;
    }
    else {
      size_t v32 = v30;
    }
    uint64_t result = (uint64_t *)memcmp(v29, v31, v32);
    BOOL v33 = v28 < v30;
    if (result) {
      BOOL v33 = (int)result < 0;
    }
    if (!v33)
    {
      __int16 v35 = (void *)*v8;
      __int16 v22 = v8;
      __int16 v6 = v8;
      if (!*v8) {
        goto LABEL_96;
      }
      while (1)
      {
        while (1)
        {
          __int16 v6 = v35;
          uint64_t v38 = (const void *)v35[4];
          uint64_t v36 = v35 + 4;
          __int16 v37 = v38;
          int v39 = *((char *)v36 + 23);
          if (v39 >= 0) {
            size_t v40 = *((unsigned __int8 *)v36 + 23);
          }
          else {
            size_t v40 = v36[1];
          }
          if (v39 >= 0) {
            int v41 = v36;
          }
          else {
            int v41 = v37;
          }
          if (v40 >= v30) {
            size_t v42 = v30;
          }
          else {
            size_t v42 = v40;
          }
          int v43 = memcmp(v31, v41, v42);
          BOOL v44 = v30 < v40;
          if (v43) {
            BOOL v44 = v43 < 0;
          }
          if (!v44) {
            break;
          }
          __int16 v35 = (void *)*v6;
          __int16 v22 = v6;
          if (!*v6) {
            goto LABEL_96;
          }
        }
        uint64_t result = (uint64_t *)memcmp(v41, v31, v42);
        BOOL v45 = v40 < v30;
        if (result) {
          BOOL v45 = (int)result < 0;
        }
        if (!v45) {
          return result;
        }
        __int16 v35 = (void *)v6[1];
        if (!v35) {
          goto LABEL_79;
        }
      }
    }
  }
  if (v17) {
    uint64_t v34 = v19;
  }
  else {
    uint64_t v34 = v6;
  }
  if (v17) {
    __int16 v22 = v19 + 1;
  }
  else {
    __int16 v22 = v6;
  }
  if (!*v22)
  {
    __int16 v6 = v34;
LABEL_96:
    __int16 v57 = (char *)operator new(0x40uLL);
    char v58 = (std::string *)(v57 + 32);
    if (*(char *)(a4 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(v58, *(const std::string::value_type **)a4, *(void *)(a4 + 8));
    }
    else
    {
      *(_OWORD *)&v58->__r_.__value_.__l.__data_ = *(_OWORD *)a4;
      *((void *)v57 + 6) = *(void *)(a4 + 16);
    }
    *((_DWORD *)v57 + 14) = *(_DWORD *)(a4 + 24);
    *(void *)__int16 v57 = 0;
    *((void *)v57 + 1) = 0;
    *((void *)v57 + 2) = v6;
    *__int16 v22 = v57;
    uint64_t v69 = *(void *)*v7;
    if (v69)
    {
      uint64_t *v7 = v69;
      __int16 v57 = (char *)*v22;
    }
    uint64_t result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)v7[1], (uint64_t *)v57);
    ++v7[2];
  }
  return result;
}

void sub_180DC730C(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(char *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(*(void *)a1);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(*((void *)a1 + 1));
    if (a1[55] < 0)
    {
      operator delete(*((void **)a1 + 4));
      v2 = a1;
    }
    else
    {
      v2 = a1;
    }
    operator delete(v2);
  }
}

uint64_t **std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3)
{
  __int16 v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    int v7 = *((char *)a2 + 23);
    if (v7 >= 0) {
      size_t v8 = *((unsigned __int8 *)a2 + 23);
    }
    else {
      size_t v8 = (size_t)a2[1];
    }
    if (v7 >= 0) {
      int v9 = a2;
    }
    else {
      int v9 = *a2;
    }
    while (1)
    {
      while (1)
      {
        int v10 = (uint64_t **)v5;
        size_t v13 = (const void *)v5[4];
        size_t v11 = v5 + 4;
        char v12 = v13;
        int v14 = *((char *)v11 + 23);
        if (v14 >= 0) {
          size_t v15 = *((unsigned __int8 *)v11 + 23);
        }
        else {
          size_t v15 = v11[1];
        }
        if (v14 >= 0) {
          BOOL v16 = v11;
        }
        else {
          BOOL v16 = v12;
        }
        if (v15 >= v8) {
          size_t v17 = v8;
        }
        else {
          size_t v17 = v15;
        }
        int v18 = memcmp(v9, v16, v17);
        BOOL v19 = v8 < v15;
        if (v18) {
          BOOL v19 = v18 < 0;
        }
        if (!v19) {
          break;
        }
        v5 = *v10;
        __int16 v6 = v10;
        if (!*v10) {
          goto LABEL_27;
        }
      }
      int v20 = memcmp(v16, v9, v17);
      BOOL v21 = v15 < v8;
      if (v20) {
        BOOL v21 = v20 < 0;
      }
      if (!v21) {
        break;
      }
      v5 = v10[1];
      if (!v5)
      {
        __int16 v6 = v10 + 1;
        goto LABEL_27;
      }
    }
  }
  else
  {
    int v10 = a1 + 1;
LABEL_27:
    __int16 v22 = (uint64_t *)v10;
    int v10 = (uint64_t **)operator new(0x40uLL);
    *((_OWORD *)v10 + 2) = *(_OWORD *)a3;
    v10[6] = *(uint64_t **)(a3 + 16);
    *(void *)a3 = 0;
    *(void *)(a3 + 8) = 0;
    *(void *)(a3 + 16) = 0;
    *((_DWORD *)v10 + 14) = 0;
    *int v10 = 0;
    v10[1] = 0;
    v10[2] = v22;
    *__int16 v6 = (uint64_t *)v10;
    uint64_t v23 = (uint64_t *)**a1;
    int v24 = (uint64_t *)v10;
    if (v23)
    {
      *a1 = v23;
      int v24 = *v6;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v24);
    a1[2] = (uint64_t *)((char *)a1[2] + 1);
  }
  return v10;
}

void anonymous namespace'::GeneratedRewriter64::~GeneratedRewriter64(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter64::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter64 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  uint64_t v8 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "updates");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "mode");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v9);
    uint64_t v11 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    char v40 = 4;
    strcpy((char *)v39, "axis");
    MIL::IROperation::TryGetParameterValue();
    int v12 = MIL::IRValue::GetScalar<int>();
    size_t v13 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v11, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v13, v12);
    int v14 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&__p);
    char v48 = 3;
    LODWORD(v47[0]) = 6579297;
    char v51 = 3;
    int v49 = 0;
    LODWORD(v50[0]) = 6452595;
    char v54 = 3;
    int v52 = 1;
    LODWORD(v53[0]) = 7107949;
    char v57 = 3;
    int v55 = 2;
    LODWORD(v56[0]) = 7760228;
    char v60 = 3;
    int v58 = 3;
    LODWORD(v59[0]) = 7235949;
    int v61 = 4;
    char v63 = 3;
    LODWORD(v62[0]) = 7889261;
    char v66 = 6;
    int v64 = 5;
    strcpy((char *)v65, "update");
    int v67 = 6;
    v38[0] = 0;
    v38[1] = 0;
    __int16 v37 = v38;
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v47, (uint64_t)v47);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v50, (uint64_t)v50);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v53, (uint64_t)v53);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v56, (uint64_t)v56);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v59, (uint64_t)v59);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v62, (uint64_t)v62);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v65, (uint64_t)v65);
    char v34 = 4;
    strcpy((char *)v33, "mode");
    MIL::IROperation::TryGetParameterValue();
    MIL::IRValue::GetScalar<std::string>();
    unsigned int v15 = *((_DWORD *)std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v37, (const void **)v35, (uint64_t)v35)+ 14);
    uint64_t v41 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
    uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter", (const unsigned __int8 *)0xB, Context);
    if (!v18)
    {
      __int16 v45 = 1283;
      uint64_t v44[2] = (uint64_t)"mps.scatter";
      v44[3] = 11;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v43 = 259;
      llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)v46);
      llvm::report_fatal_error((llvm::Twine *)v46, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v17);
    if (!*((_DWORD *)v14 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ScatterOp::build(a3 + 18, (uint64_t)&__p, ArgValue, v8, v7, (uint64_t)v14 - 16, v15);
    BOOL v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v19)
    {
      uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::ScatterOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
      if (v20)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v36 < 0)
        {
          operator delete(v35[0]);
          if ((v34 & 0x80000000) == 0)
          {
LABEL_8:
            std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v38[0]);
            if ((v66 & 0x80000000) == 0) {
              goto LABEL_9;
            }
            goto LABEL_31;
          }
        }
        else if ((v34 & 0x80000000) == 0)
        {
          goto LABEL_8;
        }
        operator delete(v33[0]);
        std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v38[0]);
        if ((v66 & 0x80000000) == 0)
        {
LABEL_9:
          if ((v63 & 0x80000000) == 0) {
            goto LABEL_10;
          }
          goto LABEL_32;
        }
LABEL_31:
        operator delete(v65[0]);
        if ((v63 & 0x80000000) == 0)
        {
LABEL_10:
          if ((v60 & 0x80000000) == 0) {
            goto LABEL_11;
          }
          goto LABEL_33;
        }
LABEL_32:
        operator delete(v62[0]);
        if ((v60 & 0x80000000) == 0)
        {
LABEL_11:
          if ((v57 & 0x80000000) == 0) {
            goto LABEL_12;
          }
          goto LABEL_34;
        }
LABEL_33:
        operator delete(v59[0]);
        if ((v57 & 0x80000000) == 0)
        {
LABEL_12:
          if ((v54 & 0x80000000) == 0) {
            goto LABEL_13;
          }
          goto LABEL_35;
        }
LABEL_34:
        operator delete(v56[0]);
        if ((v54 & 0x80000000) == 0)
        {
LABEL_13:
          if ((v51 & 0x80000000) == 0) {
            goto LABEL_14;
          }
          goto LABEL_36;
        }
LABEL_35:
        operator delete(v53[0]);
        if ((v51 & 0x80000000) == 0)
        {
LABEL_14:
          if ((v48 & 0x80000000) == 0) {
            goto LABEL_15;
          }
          goto LABEL_37;
        }
LABEL_36:
        operator delete(v50[0]);
        if ((v48 & 0x80000000) == 0)
        {
LABEL_15:
          if ((v40 & 0x80000000) == 0)
          {
LABEL_16:
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
            if (!*(_DWORD *)(v20 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            BOOL v21 = __p;
            __int16 v22 = (char *)operator new(8uLL);
            *(void *)__int16 v22 = v20 - 16;
            v47[0] = v21;
            uint64_t v23 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v21, (uint64_t)&std::piecewise_construct, (long long **)v47);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v23 + 5, v22, v22 + 8, 1uLL);
            operator delete(v22);
            int v24 = (void **)__p;
            if (__p)
            {
              BOOL v25 = (void **)v69;
              int v26 = __p;
              if ((void *)v69 != __p)
              {
                do
                {
                  if (*((char *)v25 - 1) < 0) {
                    operator delete(*(v25 - 3));
                  }
                  v25 -= 3;
                }
                while (v25 != v24);
                int v26 = __p;
              }
              *(void *)&long long v69 = v24;
              operator delete(v26);
            }
            return 1;
          }
LABEL_38:
          operator delete(v39[0]);
          goto LABEL_16;
        }
LABEL_37:
        operator delete(v47[0]);
        if ((v40 & 0x80000000) == 0) {
          goto LABEL_16;
        }
        goto LABEL_38;
      }
      uint64_t v29 = "result && \"builder didn't return the right type\"";
      int v30 = 497;
      char v31 = "Builders.h";
      size_t v32 = "create";
    }
    else
    {
      uint64_t v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v30 = 662;
      char v31 = "Casting.h";
      size_t v32 = "dyn_cast";
    }
    __assert_rtn(v32, v31, v30, v29);
  }
  __p = operator new(0x40uLL);
  long long v69 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v27 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v69) < 0) {
    operator delete(__p);
  }
  return v27;
}

void sub_180DC7CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  if (a70 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ScatterOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 11 && *AttrData == 0x746163732E73706DLL && *(void *)((char *)AttrData + 3) == 0x726574746163732ELL)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.scatter";
      v8[3] = 11;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter65::~GeneratedRewriter65(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter65::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter65 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "data");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  uint64_t v8 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "updates");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "mode");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v9);
    uint64_t v11 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    char v40 = 4;
    strcpy((char *)v39, "axis");
    MIL::IROperation::TryGetParameterValue();
    int v12 = MIL::IRValue::GetScalar<int>();
    size_t v13 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v11, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v13, v12);
    int v14 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&__p);
    char v48 = 3;
    LODWORD(v47[0]) = 6579297;
    char v51 = 3;
    int v49 = 0;
    LODWORD(v50[0]) = 6452595;
    char v54 = 3;
    int v52 = 1;
    LODWORD(v53[0]) = 7107949;
    char v57 = 3;
    int v55 = 2;
    LODWORD(v56[0]) = 7760228;
    char v60 = 3;
    int v58 = 3;
    LODWORD(v59[0]) = 7235949;
    int v61 = 4;
    char v63 = 3;
    LODWORD(v62[0]) = 7889261;
    char v66 = 6;
    int v64 = 5;
    strcpy((char *)v65, "update");
    int v67 = 6;
    v38[0] = 0;
    v38[1] = 0;
    __int16 v37 = v38;
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v47, (uint64_t)v47);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v50, (uint64_t)v50);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v53, (uint64_t)v53);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v56, (uint64_t)v56);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v59, (uint64_t)v59);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v62, (uint64_t)v62);
    std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,mlir::mps::ScatterMode> const&>((uint64_t *)&v37, (uint64_t)v38, (const void **)v65, (uint64_t)v65);
    char v34 = 4;
    strcpy((char *)v33, "mode");
    MIL::IROperation::TryGetParameterValue();
    MIL::IRValue::GetScalar<std::string>();
    unsigned int v15 = *((_DWORD *)std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string&&>,std::tuple<>>((uint64_t **)&v37, (const void **)v35, (uint64_t)v35)+ 14);
    uint64_t v41 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v41);
    uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.scatter_along_axis", (const unsigned __int8 *)0x16, Context);
    if (!v18)
    {
      __int16 v45 = 1283;
      uint64_t v44[2] = (uint64_t)"mps.scatter_along_axis";
      v44[3] = 22;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v43 = 259;
      llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)v46);
      llvm::report_fatal_error((llvm::Twine *)v46, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v17);
    if (!*((_DWORD *)v14 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::ScatterAlongAxisOp::build(a3 + 18, (uint64_t)&__p, ArgValue, v8, v7, (uint64_t)v14 - 16, v15);
    BOOL v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v19)
    {
      uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::ScatterAlongAxisOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterAlongAxisOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
      if (v20)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v36 < 0)
        {
          operator delete(v35[0]);
          if ((v34 & 0x80000000) == 0)
          {
LABEL_8:
            std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v38[0]);
            if ((v66 & 0x80000000) == 0) {
              goto LABEL_9;
            }
            goto LABEL_31;
          }
        }
        else if ((v34 & 0x80000000) == 0)
        {
          goto LABEL_8;
        }
        operator delete(v33[0]);
        std::__tree<std::__value_type<std::string,mlir::mps::ScatterMode>,std::__map_value_compare<std::string,std::__value_type<std::string,mlir::mps::ScatterMode>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,mlir::mps::ScatterMode>>>::destroy(v38[0]);
        if ((v66 & 0x80000000) == 0)
        {
LABEL_9:
          if ((v63 & 0x80000000) == 0) {
            goto LABEL_10;
          }
          goto LABEL_32;
        }
LABEL_31:
        operator delete(v65[0]);
        if ((v63 & 0x80000000) == 0)
        {
LABEL_10:
          if ((v60 & 0x80000000) == 0) {
            goto LABEL_11;
          }
          goto LABEL_33;
        }
LABEL_32:
        operator delete(v62[0]);
        if ((v60 & 0x80000000) == 0)
        {
LABEL_11:
          if ((v57 & 0x80000000) == 0) {
            goto LABEL_12;
          }
          goto LABEL_34;
        }
LABEL_33:
        operator delete(v59[0]);
        if ((v57 & 0x80000000) == 0)
        {
LABEL_12:
          if ((v54 & 0x80000000) == 0) {
            goto LABEL_13;
          }
          goto LABEL_35;
        }
LABEL_34:
        operator delete(v56[0]);
        if ((v54 & 0x80000000) == 0)
        {
LABEL_13:
          if ((v51 & 0x80000000) == 0) {
            goto LABEL_14;
          }
          goto LABEL_36;
        }
LABEL_35:
        operator delete(v53[0]);
        if ((v51 & 0x80000000) == 0)
        {
LABEL_14:
          if ((v48 & 0x80000000) == 0) {
            goto LABEL_15;
          }
          goto LABEL_37;
        }
LABEL_36:
        operator delete(v50[0]);
        if ((v48 & 0x80000000) == 0)
        {
LABEL_15:
          if ((v40 & 0x80000000) == 0)
          {
LABEL_16:
            (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
            if (!*(_DWORD *)(v20 + 36)) {
              __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
            }
            BOOL v21 = __p;
            __int16 v22 = (char *)operator new(8uLL);
            *(void *)__int16 v22 = v20 - 16;
            v47[0] = v21;
            uint64_t v23 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v21, (uint64_t)&std::piecewise_construct, (long long **)v47);
            std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v23 + 5, v22, v22 + 8, 1uLL);
            operator delete(v22);
            int v24 = (void **)__p;
            if (__p)
            {
              BOOL v25 = (void **)v69;
              int v26 = __p;
              if ((void *)v69 != __p)
              {
                do
                {
                  if (*((char *)v25 - 1) < 0) {
                    operator delete(*(v25 - 3));
                  }
                  v25 -= 3;
                }
                while (v25 != v24);
                int v26 = __p;
              }
              *(void *)&long long v69 = v24;
              operator delete(v26);
            }
            return 1;
          }
LABEL_38:
          operator delete(v39[0]);
          goto LABEL_16;
        }
LABEL_37:
        operator delete(v47[0]);
        if ((v40 & 0x80000000) == 0) {
          goto LABEL_16;
        }
        goto LABEL_38;
      }
      uint64_t v29 = "result && \"builder didn't return the right type\"";
      int v30 = 497;
      char v31 = "Builders.h";
      size_t v32 = "create";
    }
    else
    {
      uint64_t v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v30 = 662;
      char v31 = "Casting.h";
      size_t v32 = "dyn_cast";
    }
    __assert_rtn(v32, v31, v30, v29);
  }
  __p = operator new(0x40uLL);
  long long v69 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v27 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v69) < 0) {
    operator delete(__p);
  }
  return v27;
}

void sub_180DC8718(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38,uint64_t a39,uint64_t a40,void *a41,uint64_t a42,uint64_t a43,uint64_t a44,void *a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61,uint64_t a62,uint64_t a63)
{
  if (a70 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(a1);
  }
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::ScatterAlongAxisOp,mlir::Operation *,llvm::CastInfo<mlir::mps::ScatterAlongAxisOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 22
      && *AttrData == 0x746163732E73706DLL
      && AttrData[1] == 0x6E6F6C615F726574
      && *(void *)((char *)AttrData + 14) == 0x736978615F676E6FLL)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.scatter_along_axis";
      v9[3] = 22;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter66::~GeneratedRewriter66(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter66::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter66 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 0);
    uint64_t v9 = mlir::IntegerAttr::get(IntegerType, 0);
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a3 + 18, v10);
    uint64_t v29 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v29);
    uint64_t v13 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather_nd", (const unsigned __int8 *)0xD, Context);
    if (!v14)
    {
      __int16 v33 = 1283;
      uint64_t v32[2] = (uint64_t)"mps.gather_nd";
      v32[3] = 13;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v31 = 259;
      llvm::operator+(v32, (uint64_t *)&v30, (uint64_t)v34);
      llvm::report_fatal_error((llvm::Twine *)v34, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v13);
    mlir::mps::GatherNDOp::build(a3 + 18, (uint64_t)&__p, ArgValue, v7, v9, UnitAttr);
    unsigned int v15 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v15)
    {
      uint64_t v16 = llvm::DefaultDoCastIfPossible<mlir::mps::GatherNDOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherNDOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v15);
      if (v16)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v16 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v17 = (long long *)__p;
        char v18 = (char *)operator new(8uLL);
        *(void *)char v18 = v16 - 16;
        v34[0] = v17;
        BOOL v19 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v17, (uint64_t)&std::piecewise_construct, v34);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v19 + 5, v18, v18 + 8, 1uLL);
        operator delete(v18);
        uint64_t v20 = (void **)__p;
        if (__p)
        {
          BOOL v21 = (void **)v36;
          __int16 v22 = __p;
          if ((void *)v36 != __p)
          {
            do
            {
              if (*((char *)v21 - 1) < 0) {
                operator delete(*(v21 - 3));
              }
              v21 -= 3;
            }
            while (v21 != v20);
            __int16 v22 = __p;
          }
          *(void *)&long long v36 = v20;
          operator delete(v22);
        }
        return 1;
      }
      BOOL v25 = "result && \"builder didn't return the right type\"";
      int v26 = 497;
      uint64_t v27 = "Builders.h";
      size_t v28 = "create";
    }
    else
    {
      BOOL v25 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v26 = 662;
      uint64_t v27 = "Casting.h";
      size_t v28 = "dyn_cast";
    }
    __assert_rtn(v28, v27, v26, v25);
  }
  __p = operator new(0x40uLL);
  long long v36 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v23 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v36) < 0) {
    operator delete(__p);
  }
  return v23;
}

void sub_180DC8E14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DC8E28(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DC8E80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GatherNDOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherNDOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 13 && *AttrData == 0x687461672E73706DLL && *(void *)((char *)AttrData + 5) == 0x646E5F7265687461)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.gather_nd";
      v8[3] = 13;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GatherNDOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter67::~GeneratedRewriter67(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter67::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter67 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v8);
    uint64_t v10 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    char v36 = 4;
    strcpy((char *)__p, "axis");
    MIL::IROperation::TryGetParameterValue();
    int v11 = MIL::IRValue::GetScalar<int>();
    int v12 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v10, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v12, v11);
    uint64_t v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&Constant);
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 0);
    uint64_t v15 = mlir::IntegerAttr::get(IntegerType, 0);
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a3 + 18, v16);
    uint64_t v37 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v37);
    uint64_t v19 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather", (const unsigned __int8 *)0xA, Context);
    if (!v20)
    {
      __int16 v41 = 1283;
      v40[2] = (uint64_t)"mps.gather";
      v40[3] = 10;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)v42);
      llvm::report_fatal_error((llvm::Twine *)v42, 1);
    }
    mlir::OperationState::OperationState(&Constant, LocationForOp, v19);
    if (!*((_DWORD *)v13 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::GatherOp::build(a3 + 18, (uint64_t)&Constant, ArgValue, v7, (uint64_t)v13 - 16, v15, UnitAttr);
    BOOL v21 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&Constant);
    if (v21)
    {
      uint64_t v22 = llvm::DefaultDoCastIfPossible<mlir::mps::GatherOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v21);
      if (v22)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&Constant);
        if (v36 < 0) {
          operator delete(__p[0]);
        }
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&Constant, a2);
        if (!*(_DWORD *)(v22 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v23 = (long long *)Constant;
        int v24 = (char *)operator new(8uLL);
        *(void *)int v24 = v22 - 16;
        v42[0] = v23;
        BOOL v25 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v23, (uint64_t)&std::piecewise_construct, v42);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v25 + 5, v24, v24 + 8, 1uLL);
        operator delete(v24);
        int v26 = (void **)Constant;
        if (Constant)
        {
          uint64_t v27 = (void **)v44;
          size_t v28 = Constant;
          if ((void *)v44 != Constant)
          {
            do
            {
              if (*((char *)v27 - 1) < 0) {
                operator delete(*(v27 - 3));
              }
              v27 -= 3;
            }
            while (v27 != v26);
            size_t v28 = Constant;
          }
          *(void *)&long long v44 = v26;
          operator delete(v28);
        }
        return 1;
      }
      __int16 v31 = "result && \"builder didn't return the right type\"";
      int v32 = 497;
      __int16 v33 = "Builders.h";
      char v34 = "create";
    }
    else
    {
      __int16 v31 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v32 = 662;
      __int16 v33 = "Casting.h";
      char v34 = "dyn_cast";
    }
    __assert_rtn(v34, v33, v32, v31);
  }
  Constant = operator new(0x40uLL);
  long long v44 = xmmword_181129DA0;
  strcpy((char *)Constant, "The number of outputs does not match the number of results.");
  uint64_t v29 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&Constant);
  if (SHIBYTE(v44) < 0) {
    operator delete(Constant);
  }
  return v29;
}

void sub_180DC94B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GatherOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 10 && *(void *)AttrData == 0x687461672E73706DLL && *(_WORD *)(AttrData + 8) == 29285)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.gather";
      v8[3] = 10;
      __int16 v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GatherOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter68::~GeneratedRewriter68(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter68::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter68 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "indices");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axis");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v8);
    uint64_t v10 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    char v34 = 4;
    strcpy((char *)__p, "axis");
    MIL::IROperation::TryGetParameterValue();
    int v11 = MIL::IRValue::GetScalar<int>();
    int v12 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v10, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v12, v11);
    uint64_t v13 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&Constant);
    uint64_t UnitAttr = mlir::Builder::getUnitAttr(a3 + 18, v14);
    uint64_t v35 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v35);
    uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.gather_along_axis", (const unsigned __int8 *)0x15, Context);
    if (!v18)
    {
      __int16 v39 = 1283;
      uint64_t v38[2] = (uint64_t)"mps.gather_along_axis";
      v38[3] = 21;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v37 = 259;
      llvm::operator+(v38, (uint64_t *)&v36, (uint64_t)v40);
      llvm::report_fatal_error((llvm::Twine *)v40, 1);
    }
    mlir::OperationState::OperationState(&Constant, LocationForOp, v17);
    if (!*((_DWORD *)v13 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::GatherAlongAxisOp::build((uint64_t)(a3 + 18), (uint64_t)&Constant, ArgValue, v7, (uint64_t)v13 - 16, UnitAttr);
    uint64_t v19 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&Constant);
    if (v19)
    {
      uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::GatherAlongAxisOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherAlongAxisOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
      if (v20)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&Constant);
        if (v34 < 0) {
          operator delete(__p[0]);
        }
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&Constant, a2);
        if (!*(_DWORD *)(v20 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        BOOL v21 = (long long *)Constant;
        uint64_t v22 = (char *)operator new(8uLL);
        *(void *)uint64_t v22 = v20 - 16;
        v40[0] = v21;
        uint64_t v23 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v21, (uint64_t)&std::piecewise_construct, v40);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v23 + 5, v22, v22 + 8, 1uLL);
        operator delete(v22);
        int v24 = (void **)Constant;
        if (Constant)
        {
          BOOL v25 = (void **)v42;
          int v26 = Constant;
          if ((void *)v42 != Constant)
          {
            do
            {
              if (*((char *)v25 - 1) < 0) {
                operator delete(*(v25 - 3));
              }
              v25 -= 3;
            }
            while (v25 != v24);
            int v26 = Constant;
          }
          *(void *)&long long v42 = v24;
          operator delete(v26);
        }
        return 1;
      }
      uint64_t v29 = "result && \"builder didn't return the right type\"";
      int v30 = 497;
      __int16 v31 = "Builders.h";
      int v32 = "create";
    }
    else
    {
      uint64_t v29 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v30 = 662;
      __int16 v31 = "Casting.h";
      int v32 = "dyn_cast";
    }
    __assert_rtn(v32, v31, v30, v29);
  }
  Constant = operator new(0x40uLL);
  long long v42 = xmmword_181129DA0;
  strcpy((char *)Constant, "The number of outputs does not match the number of results.");
  uint64_t v27 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&Constant);
  if (SHIBYTE(v42) < 0) {
    operator delete(Constant);
  }
  return v27;
}

void sub_180DC9B2C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36)
{
  if (a36 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::GatherAlongAxisOp,mlir::Operation *,llvm::CastInfo<mlir::mps::GatherAlongAxisOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x687461672E73706DLL
      && AttrData[1] == 0x676E6F6C615F7265
      && *(void *)((char *)AttrData + 13) == 0x736978615F676E6FLL)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.gather_along_axis";
      v9[3] = 21;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::GatherAlongAxisOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter69::~GeneratedRewriter69(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter69::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter69 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "axes");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    __int16 v6 = mlir::OpBuilder::create<mlir::mps::ExpandDimsOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    __int16 v10 = (void **)__p;
    if (__p)
    {
      int v11 = (void **)v16;
      int v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        int v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DC9FC8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter70::~GeneratedRewriter70(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter70::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter70 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "shape");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "value");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    __int16 v6 = mlir::OpBuilder::create<mlir::mps::BroadcastToOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &v18, &ArgValue);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*((_DWORD *)v6 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = (char *)v6 - 16;
    uint64_t v19 = v7;
    __int16 v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    __int16 v10 = (void **)__p;
    if (__p)
    {
      int v11 = (void **)v16;
      int v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        int v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DCA31C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter71::~GeneratedRewriter71(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter71::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter71 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "ref_tensor");
  uint64_t v6 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "value");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v7 = mlir::OpBuilder::create<mlir::mps::ShapeOp,mlir::Value>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue);
    uint64_t v26 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
    uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.broadcast_to", (const unsigned __int8 *)0x10, Context);
    if (!v10)
    {
      __int16 v30 = 1283;
      v29[2] = (uint64_t)"mps.broadcast_to";
      v29[3] = 16;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v28 = 259;
      llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
      llvm::report_fatal_error((llvm::Twine *)v31, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v9);
    if (!*((_DWORD *)v7 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::BroadcastToOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, v6, (uint64_t)v7 - 16);
    int v11 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v11)
    {
      uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::BroadcastToOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BroadcastToOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
      if (v12)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
        if (!*(_DWORD *)(v12 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        uint64_t v13 = (long long *)__p;
        uint64_t v14 = (char *)operator new(8uLL);
        *(void *)uint64_t v14 = v12 - 16;
        v31[0] = v13;
        uint64_t v15 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v13, (uint64_t)&std::piecewise_construct, v31);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v15 + 5, v14, v14 + 8, 1uLL);
        operator delete(v14);
        long long v16 = (void **)__p;
        if (__p)
        {
          uint64_t v17 = (void **)v33;
          uint64_t v18 = __p;
          if ((void *)v33 != __p)
          {
            do
            {
              if (*((char *)v17 - 1) < 0) {
                operator delete(*(v17 - 3));
              }
              v17 -= 3;
            }
            while (v17 != v16);
            uint64_t v18 = __p;
          }
          *(void *)&long long v33 = v16;
          operator delete(v18);
        }
        return 1;
      }
      BOOL v21 = "result && \"builder didn't return the right type\"";
      int v22 = 497;
      uint64_t v23 = "Builders.h";
      int v24 = "create";
    }
    else
    {
      BOOL v21 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v22 = 662;
      uint64_t v23 = "Casting.h";
      int v24 = "dyn_cast";
    }
    __assert_rtn(v24, v23, v22, v21);
  }
  __p = operator new(0x40uLL);
  long long v33 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v19 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v33) < 0) {
    operator delete(__p);
  }
  return v19;
}

void sub_180DCA7B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,int a28,__int16 a29,char a30,char a31)
{
  if (a31 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DCA820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter72::~GeneratedRewriter72(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter72::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter72 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  uint64_t v18 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "perm");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v6 = mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 18), LocationForOp, &ArgValue, &v18);
    (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
    if (!*(_DWORD *)(v6 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v7 = (long long *)__p;
    __int16 v8 = (char *)operator new(8uLL);
    *(void *)__int16 v8 = v6 - 16;
    uint64_t v19 = v7;
    uint64_t v9 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v7, (uint64_t)&std::piecewise_construct, &v19);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v9 + 5, v8, v8 + 8, 1uLL);
    operator delete(v8);
    char v10 = (void **)__p;
    if (__p)
    {
      int v11 = (void **)v16;
      uint64_t v12 = __p;
      if ((void *)v16 != __p)
      {
        do
        {
          if (*((char *)v11 - 1) < 0) {
            operator delete(*(v11 - 3));
          }
          v11 -= 3;
        }
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      *(void *)&long long v16 = v10;
      operator delete(v12);
    }
    return 1;
  }
  else
  {
    __p = operator new(0x40uLL);
    long long v16 = xmmword_181129DA0;
    strcpy((char *)__p, "The number of outputs does not match the number of results.");
    uint64_t result = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
    uint64_t v14 = result;
    if (SHIBYTE(v16) < 0)
    {
      operator delete(__p);
      return v14;
    }
  }
  return result;
}

void sub_180DCAB48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t mlir::OpBuilder::create<mlir::mps::PermuteOp,mlir::Value &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v24[38] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.permute", (const unsigned __int8 *)0xB, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"mps.permute";
    v21[3] = 11;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  mlir::mps::PermuteOp::build((uint64_t)a1, (uint64_t)v24, *a3, *a4);
  int v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (!v11)
  {
    uint64_t v14 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v15 = 662;
    long long v16 = "Casting.h";
    uint64_t v17 = "dyn_cast";
    goto LABEL_8;
  }
  uint64_t v12 = llvm::DefaultDoCastIfPossible<mlir::mps::PermuteOp,mlir::Operation *,llvm::CastInfo<mlir::mps::PermuteOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v11);
  if (!v12)
  {
    uint64_t v14 = "result && \"builder didn't return the right type\"";
    int v15 = 497;
    long long v16 = "Builders.h";
    uint64_t v17 = "create";
LABEL_8:
    __assert_rtn(v17, v16, v15, v14);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v12;
}

void sub_180DCAD04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DCAD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void anonymous namespace'::GeneratedRewriter73::~GeneratedRewriter73(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter73::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter73 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "block_size");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v6);
    uint64_t v8 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v9 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v8, 0);
    *(void *)__p = mlir::mps::getConstantAttr<int>(v9, -1);
    long long v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)__p);
    uint64_t v11 = mlir::Builder::getUnknownLoc(a3 + 18, v10);
    uint64_t v12 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v13 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v12, 0);
    *(void *)__p = mlir::mps::getConstantAttr<int>(v13, -2);
    __int16 v30 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v11, (uint64_t **)__p);
    uint64_t v15 = mlir::Builder::getUnknownLoc(a3 + 18, v14);
    uint64_t v16 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v17 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v16, 0);
    *(void *)__p = mlir::mps::getConstantAttr<int>(v17, -3);
    uint64_t v29 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v15, (uint64_t **)__p);
    __p[23] = 10;
    strcpy(__p, "block_size");
    MIL::IROperation::TryGetParameterValue();
    unsigned int v28 = MIL::IRValue::GetScalar<int>();
    unsigned __int8 v27 = 0;
    uint64_t v18 = mlir::OpBuilder::create<mlir::mps::DepthToSpace2DOp,mlir::Value &,mlir::mps::ConstantOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp,int,BOOL>((mlir::Builder *)(a3 + 18), LocationForOp, &ArgValue, (uint64_t)&v33, (uint64_t)&v30, (uint64_t)&v29, &v28, &v27);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    (*(void (**)(unsigned char *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
    if (!*(_DWORD *)(v18 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v19 = *(long long **)__p;
    __int16 v20 = (char *)operator new(8uLL);
    *(void *)__int16 v20 = v18 - 16;
    long long v33 = (mlir::GenericProgramPoint *)v19;
    BOOL v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v19, (uint64_t)&std::piecewise_construct, (long long **)&v33);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v21 + 5, v20, v20 + 8, 1uLL);
    operator delete(v20);
    uint64_t v22 = *(void *)__p;
    if (*(void *)__p)
    {
      uint64_t v23 = *(void *)&__p[8];
      int v24 = *(void **)__p;
      if (*(void *)&__p[8] != *(void *)__p)
      {
        do
        {
          if (*(char *)(v23 - 1) < 0) {
            operator delete(*(void **)(v23 - 24));
          }
          v23 -= 24;
        }
        while (v23 != v22);
        int v24 = *(void **)__p;
      }
      *(void *)&__p[8] = v22;
      operator delete(v24);
    }
    return 1;
  }
  else
  {
    *(void *)__p = operator new(0x40uLL);
    *(_OWORD *)&__p[8] = xmmword_181129DA0;
    strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
    uint64_t v25 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  return v25;
}

void sub_180DCB16C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DCB1C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

uint64_t mlir::OpBuilder::create<mlir::mps::DepthToSpace2DOp,mlir::Value &,mlir::mps::ConstantOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp,int,BOOL>(mlir::Builder *a1, uint64_t a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int *a7, unsigned __int8 *a8)
{
  v32[38] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v26);
  uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.depth_to_space_2d", (const unsigned __int8 *)0x15, Context);
  if (!v18)
  {
    __int16 v30 = 1283;
    v29[2] = (uint64_t)"mps.depth_to_space_2d";
    v29[3] = 21;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v28 = 259;
    llvm::operator+(v29, (uint64_t *)&v27, (uint64_t)v31);
    llvm::report_fatal_error((llvm::Twine *)v31, 1);
  }
  mlir::OperationState::OperationState(v32, a2, v17);
  if (!*(_DWORD *)(*(void *)a4 + 36) || !*(_DWORD *)(*(void *)a5 + 36) || !*(_DWORD *)(*(void *)a6 + 36)) {
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  }
  mlir::mps::DepthToSpace2DOp::build(a1, (uint64_t)v32, *a3, *(void *)a4 - 16, *(void *)a5 - 16, *(void *)a6 - 16, *a7, *a8);
  uint64_t v19 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  if (!v19)
  {
    uint64_t v22 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
    int v23 = 662;
    int v24 = "Casting.h";
    uint64_t v25 = "dyn_cast";
    goto LABEL_12;
  }
  uint64_t v20 = llvm::DefaultDoCastIfPossible<mlir::mps::DepthToSpace2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthToSpace2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v19);
  if (!v20)
  {
    uint64_t v22 = "result && \"builder didn't return the right type\"";
    int v23 = 497;
    int v24 = "Builders.h";
    uint64_t v25 = "create";
LABEL_12:
    __assert_rtn(v25, v24, v23, v22);
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  return v20;
}

void sub_180DCB3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_180DCB3E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::DepthToSpace2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::DepthToSpace2DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x747065642E73706DLL
      && AttrData[1] == 0x6170735F6F745F68
      && *(void *)((char *)AttrData + 13) == 0x64325F6563617073)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.depth_to_space_2d";
      v9[3] = 21;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::DepthToSpace2DOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter74::~GeneratedRewriter74(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter74::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter74 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "block_size");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v7);
    uint64_t v9 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    __int16 v10 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v9, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v10, -1);
    uint64_t v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&Constant);
    uint64_t v13 = mlir::Builder::getUnknownLoc(a3 + 18, v12);
    uint64_t v14 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v15 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v14, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v15, -2);
    uint64_t v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v13, (uint64_t **)&Constant);
    uint64_t v18 = mlir::Builder::getUnknownLoc(a3 + 18, v17);
    uint64_t v19 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v20 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v19, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v20, -3);
    BOOL v21 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v18, (uint64_t **)&Constant);
    char v41 = 10;
    strcpy((char *)__p, "block_size");
    MIL::IROperation::TryGetParameterValue();
    unsigned int v22 = MIL::IRValue::GetScalar<int>();
    uint64_t v42 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v42);
    uint64_t v24 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_depth_2d", (const unsigned __int8 *)0x15, Context);
    if (!v25)
    {
      __int16 v46 = 1283;
      v45[2] = (uint64_t)"mps.space_to_depth_2d";
      v45[3] = 21;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)v47);
      llvm::report_fatal_error((llvm::Twine *)v47, 1);
    }
    mlir::OperationState::OperationState(&Constant, LocationForOp, v24);
    if (!*((_DWORD *)v11 + 9) || !*((_DWORD *)v16 + 9) || !*((_DWORD *)v21 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::SpaceToDepth2DOp::build((mlir::Builder *)(a3 + 18), (uint64_t)&Constant, ArgValue, (uint64_t)v11 - 16, (uint64_t)v16 - 16, (uint64_t)v21 - 16, v22, 0);
    uint64_t v26 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&Constant);
    if (v26)
    {
      uint64_t v27 = llvm::DefaultDoCastIfPossible<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v26);
      if (v27)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&Constant);
        if (v41 < 0) {
          operator delete(__p[0]);
        }
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&Constant, a2);
        if (!*(_DWORD *)(v27 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        __int16 v28 = (long long *)Constant;
        uint64_t v29 = (char *)operator new(8uLL);
        *(void *)uint64_t v29 = v27 - 16;
        v47[0] = v28;
        __int16 v30 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v28, (uint64_t)&std::piecewise_construct, v47);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v30 + 5, v29, v29 + 8, 1uLL);
        operator delete(v29);
        __int16 v31 = (void **)Constant;
        if (Constant)
        {
          int v32 = (void **)v49;
          long long v33 = Constant;
          if ((void *)v49 != Constant)
          {
            do
            {
              if (*((char *)v32 - 1) < 0) {
                operator delete(*(v32 - 3));
              }
              v32 -= 3;
            }
            while (v32 != v31);
            long long v33 = Constant;
          }
          *(void *)&long long v49 = v31;
          operator delete(v33);
        }
        return 1;
      }
      char v36 = "result && \"builder didn't return the right type\"";
      int v37 = 497;
      uint64_t v38 = "Builders.h";
      __int16 v39 = "create";
    }
    else
    {
      char v36 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v37 = 662;
      uint64_t v38 = "Casting.h";
      __int16 v39 = "dyn_cast";
    }
    __assert_rtn(v39, v38, v37, v36);
  }
  Constant = operator new(0x40uLL);
  long long v49 = xmmword_181129DA0;
  strcpy((char *)Constant, "The number of outputs does not match the number of results.");
  uint64_t v34 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&Constant);
  if (SHIBYTE(v49) < 0) {
    operator delete(Constant);
  }
  return v34;
}

void sub_180DCBAA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v11[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v11);
    if (v4 == 21
      && *AttrData == 0x636170732E73706DLL
      && AttrData[1] == 0x7065645F6F745F65
      && *(void *)((char *)AttrData + 13) == 0x64325F6874706564)
    {
      __int16 v10 = 1283;
      v9[0] = (uint64_t)"classof on '";
      v9[2] = (uint64_t)"mps.space_to_depth_2d";
      v9[3] = 21;
      uint64_t v7 = "' failed due to the operation not being registered";
      __int16 v8 = 259;
      llvm::operator+(v9, (uint64_t *)&v7, (uint64_t)v11);
      llvm::report_fatal_error((llvm::Twine *)v11, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::SpaceToDepth2DOp,void>::id)
  {
    return 0;
  }
  return result;
}

void anonymous namespace'::GeneratedRewriter75::~GeneratedRewriter75(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter75::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter75 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "upscale_factor");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v6);
    uint64_t v8 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v9 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v8, 0);
    *(void *)__p = mlir::mps::getConstantAttr<int>(v9, -1);
    long long v33 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)__p);
    uint64_t v11 = mlir::Builder::getUnknownLoc(a3 + 18, v10);
    uint64_t v12 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v13 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v12, 0);
    *(void *)__p = mlir::mps::getConstantAttr<int>(v13, -2);
    __int16 v30 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v11, (uint64_t **)__p);
    uint64_t v15 = mlir::Builder::getUnknownLoc(a3 + 18, v14);
    uint64_t v16 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v17 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v16, 0);
    *(void *)__p = mlir::mps::getConstantAttr<int>(v17, -3);
    uint64_t v29 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v15, (uint64_t **)__p);
    __p[23] = 14;
    strcpy(__p, "upscale_factor");
    MIL::IROperation::TryGetParameterValue();
    unsigned int v28 = MIL::IRValue::GetScalar<int>();
    unsigned __int8 v27 = 1;
    uint64_t v18 = mlir::OpBuilder::create<mlir::mps::DepthToSpace2DOp,mlir::Value &,mlir::mps::ConstantOp,mlir::mps::ConstantOp,mlir::mps::ConstantOp,int,BOOL>((mlir::Builder *)(a3 + 18), LocationForOp, &ArgValue, (uint64_t)&v33, (uint64_t)&v30, (uint64_t)&v29, &v28, &v27);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
    (*(void (**)(unsigned char *__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
    if (!*(_DWORD *)(v18 + 36)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    uint64_t v19 = *(long long **)__p;
    uint64_t v20 = (char *)operator new(8uLL);
    *(void *)uint64_t v20 = v18 - 16;
    long long v33 = (mlir::GenericProgramPoint *)v19;
    BOOL v21 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v19, (uint64_t)&std::piecewise_construct, (long long **)&v33);
    std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v21 + 5, v20, v20 + 8, 1uLL);
    operator delete(v20);
    uint64_t v22 = *(void *)__p;
    if (*(void *)__p)
    {
      uint64_t v23 = *(void *)&__p[8];
      uint64_t v24 = *(void **)__p;
      if (*(void *)&__p[8] != *(void *)__p)
      {
        do
        {
          if (*(char *)(v23 - 1) < 0) {
            operator delete(*(void **)(v23 - 24));
          }
          v23 -= 24;
        }
        while (v23 != v22);
        uint64_t v24 = *(void **)__p;
      }
      *(void *)&__p[8] = v22;
      operator delete(v24);
    }
    return 1;
  }
  else
  {
    *(void *)__p = operator new(0x40uLL);
    *(_OWORD *)&__p[8] = xmmword_181129DA0;
    strcpy(*(char **)__p, "The number of outputs does not match the number of results.");
    uint64_t v25 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, __p);
    if ((__p[23] & 0x80000000) != 0) {
      operator delete(*(void **)__p);
    }
  }
  return v25;
}

void sub_180DCC070(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void sub_180DCC0CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_start(va, a4);
  std::vector<std::string>::~vector[abi:ne180100]((void **)va);
  _Unwind_Resume(a1);
}

void anonymous namespace'::GeneratedRewriter76::~GeneratedRewriter76(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter76::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter76 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "downscale_factor");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v7);
    uint64_t v9 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    __int16 v10 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v9, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v10, -1);
    uint64_t v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&Constant);
    uint64_t v13 = mlir::Builder::getUnknownLoc(a3 + 18, v12);
    uint64_t v14 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v15 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v14, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v15, -2);
    uint64_t v16 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v13, (uint64_t **)&Constant);
    uint64_t v18 = mlir::Builder::getUnknownLoc(a3 + 18, v17);
    uint64_t v19 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    uint64_t v20 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v19, 0);
    Constant = (void *)mlir::mps::getConstantAttr<int>(v20, -3);
    BOOL v21 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v18, (uint64_t **)&Constant);
    char v41 = 16;
    strcpy(__p, "downscale_factor");
    MIL::IROperation::TryGetParameterValue();
    unsigned int v22 = MIL::IRValue::GetScalar<unsigned int>();
    uint64_t v42 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v42);
    uint64_t v24 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.space_to_depth_2d", (const unsigned __int8 *)0x15, Context);
    if (!v25)
    {
      __int16 v46 = 1283;
      v45[2] = (uint64_t)"mps.space_to_depth_2d";
      v45[3] = 21;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)v47);
      llvm::report_fatal_error((llvm::Twine *)v47, 1);
    }
    mlir::OperationState::OperationState(&Constant, LocationForOp, v24);
    if (!*((_DWORD *)v11 + 9) || !*((_DWORD *)v16 + 9) || !*((_DWORD *)v21 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::SpaceToDepth2DOp::build((mlir::Builder *)(a3 + 18), (uint64_t)&Constant, ArgValue, (uint64_t)v11 - 16, (uint64_t)v16 - 16, (uint64_t)v21 - 16, v22, 1);
    uint64_t v26 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&Constant);
    if (v26)
    {
      uint64_t v27 = llvm::DefaultDoCastIfPossible<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,llvm::CastInfo<mlir::mps::SpaceToDepth2DOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v26);
      if (v27)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&Constant);
        if (v41 < 0) {
          operator delete(*(void **)__p);
        }
        (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&Constant, a2);
        if (!*(_DWORD *)(v27 + 36)) {
          __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
        }
        unsigned int v28 = (long long *)Constant;
        uint64_t v29 = (char *)operator new(8uLL);
        *(void *)uint64_t v29 = v27 - 16;
        v47[0] = v28;
        __int16 v30 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v28, (uint64_t)&std::piecewise_construct, v47);
        std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v30 + 5, v29, v29 + 8, 1uLL);
        operator delete(v29);
        __int16 v31 = (void **)Constant;
        if (Constant)
        {
          int v32 = (void **)v49;
          long long v33 = Constant;
          if ((void *)v49 != Constant)
          {
            do
            {
              if (*((char *)v32 - 1) < 0) {
                operator delete(*(v32 - 3));
              }
              v32 -= 3;
            }
            while (v32 != v31);
            long long v33 = Constant;
          }
          *(void *)&long long v49 = v31;
          operator delete(v33);
        }
        return 1;
      }
      char v36 = "result && \"builder didn't return the right type\"";
      int v37 = 497;
      uint64_t v38 = "Builders.h";
      __int16 v39 = "create";
    }
    else
    {
      char v36 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v37 = 662;
      uint64_t v38 = "Casting.h";
      __int16 v39 = "dyn_cast";
    }
    __assert_rtn(v39, v38, v37, v36);
  }
  Constant = operator new(0x40uLL);
  long long v49 = xmmword_181129DA0;
  strcpy((char *)Constant, "The number of outputs does not match the number of results.");
  uint64_t v34 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&Constant);
  if (SHIBYTE(v49) < 0) {
    operator delete(Constant);
  }
  return v34;
}

void sub_180DCC678(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  if (a37 < 0)
  {
    operator delete(__p);
    _Unwind_Resume(exception_object);
  }
  _Unwind_Resume(exception_object);
}

void anonymous namespace'::GeneratedRewriter77::~GeneratedRewriter77(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

uint64_t anonymous namespace'::GeneratedRewriter77::matchAndRewrite(_anonymous_namespace_::GeneratedRewriter77 *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "lower");
  MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "upper");
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t UnknownLoc = mlir::Builder::getUnknownLoc(a3 + 18, v7);
    uint64_t v9 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    char v39 = 5;
    strcpy((char *)v38, "lower");
    MIL::IROperation::TryGetParameterValue();
    int v10 = MIL::IRValue::GetScalar<int>();
    uint64_t v11 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v9, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v11, v10);
    uint64_t v12 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), UnknownLoc, (uint64_t **)&__p);
    uint64_t v14 = mlir::Builder::getUnknownLoc(a3 + 18, v13);
    uint64_t v15 = mlir::IntegerType::get((uint64_t)a3[18], 0x20u, 1u);
    char v37 = 5;
    strcpy((char *)v36, "upper");
    MIL::IROperation::TryGetParameterValue();
    int v16 = MIL::IRValue::GetScalar<int>();
    uint64_t v17 = (uint64_t *)mlir::RankedTensorType::get(0, 0, v15, 0);
    __p = (void *)mlir::mps::getConstantAttr<int>(v17, v16);
    uint64_t v18 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), v14, (uint64_t **)&__p);
    uint64_t v40 = LocationForOp;
    Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v40);
    uint64_t v20 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.band_part", (const unsigned __int8 *)0xD, Context);
    if (!v21)
    {
      __int16 v44 = 1283;
      v43[2] = (uint64_t)"mps.band_part";
      v43[3] = 13;
            "by the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-wit"
            "h-dialects-management";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)v45);
      llvm::report_fatal_error((llvm::Twine *)v45, 1);
    }
    mlir::OperationState::OperationState(&__p, LocationForOp, v20);
    if (!*((_DWORD *)v12 + 9) || !*((_DWORD *)v18 + 9)) {
      __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
    }
    mlir::mps::BandPartOp::build((uint64_t)(a3 + 18), (uint64_t)&__p, ArgValue, (uint64_t)v12 - 16, (uint64_t)v18 - 16);
    unsigned int v22 = mlir::OpBuilder::create((mlir::OpBuilder *)(a3 + 18), (const mlir::OperationState *)&__p);
    if (v22)
    {
      uint64_t v23 = llvm::DefaultDoCastIfPossible<mlir::mps::BandPartOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BandPartOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v22);
      if (v23)
      {
        mlir::OperationState::~OperationState((mlir::OperationState *)&__p);
        if (v37 < 0)
        {
          operator delete(v36[0]);
          if ((v39 & 0x80000000) == 0) {
            goto LABEL_9;
          }
        }
        else if ((v39 & 0x80000000) == 0)
        {
LABEL_9:
          (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(&__p, a2);
          if (!*(_DWORD *)(v23 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          uint64_t v24 = (long long *)__p;
          char v25 = (char *)operator new(8uLL);
          *(void *)char v25 = v23 - 16;
          v45[0] = v24;
          uint64_t v26 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v24, (uint64_t)&std::piecewise_construct, v45);
          std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v26 + 5, v25, v25 + 8, 1uLL);
          operator delete(v25);
          uint64_t v27 = (void **)__p;
          if (__p)
          {
            unsigned int v28 = (void **)v47;
            uint64_t v29 = __p;
            if ((void *)v47 != __p)
            {
              do
              {
                if (*((char *)v28 - 1) < 0) {
                  operator delete(*(v28 - 3));
                }
                v28 -= 3;
              }
              while (v28 != v27);
              uint64_t v29 = __p;
            }
            *(void *)&long long v47 = v27;
            operator delete(v29);
          }
          return 1;
        }
        operator delete(v38[0]);
        goto LABEL_9;
      }
      int v32 = "result && \"builder didn't return the right type\"";
      int v33 = 497;
      uint64_t v34 = "Builders.h";
      uint64_t v35 = "create";
    }
    else
    {
      int v32 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      int v33 = 662;
      uint64_t v34 = "Casting.h";
      uint64_t v35 = "dyn_cast";
    }
    __assert_rtn(v35, v34, v33, v32);
  }
  __p = operator new(0x40uLL);
  long long v47 = xmmword_181129DA0;
  strcpy((char *)__p, "The number of outputs does not match the number of results.");
  uint64_t v30 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)&__p);
  if (SHIBYTE(v47) < 0) {
    operator delete(__p);
  }
  return v30;
}

void sub_180DCCCA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a21 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::mps::BandPartOp,mlir::Operation *,llvm::CastInfo<mlir::mps::BandPartOp,mlir::Operation *,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 13 && *AttrData == 0x646E61622E73706DLL && *(void *)((char *)AttrData + 5) == 0x747261705F646E61)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"mps.band_part";
      v8[3] = 13;
      uint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::mps::BandPartOp,void>::id)
  {
    return 0;
  }
  return result;
}

void MILToMLIRRewriter::~MILToMLIRRewriter(MILToMLIRRewriter *this)
{
  v2 = (void **)*((void *)this + 15);
  if (v2)
  {
    do
    {
      uint64_t v8 = (void **)*v2;
      if (*((char *)v2 + 63) < 0)
      {
        operator delete(v2[5]);
        if (*((char *)v2 + 39) < 0) {
LABEL_16:
        }
          operator delete(v2[2]);
      }
      else if (*((char *)v2 + 39) < 0)
      {
        goto LABEL_16;
      }
      operator delete(v2);
      v2 = v8;
    }
    while (v8);
  }
  v3 = (void *)*((void *)this + 13);
  *((void *)this + 13) = 0;
  if (v3) {
    operator delete(v3);
  }
  uint64_t v4 = (char *)*((void *)this + 10);
  if (v4)
  {
    do
    {
      __int16 v9 = *(char **)v4;
      int v10 = (void *)*((void *)v4 + 5);
      if (v10)
      {
        *((void *)v4 + 6) = v10;
        operator delete(v10);
      }
      if (v4[39] < 0) {
        operator delete(*((void **)v4 + 2));
      }
      operator delete(v4);
      uint64_t v4 = v9;
    }
    while (v9);
  }
  v5 = (void *)*((void *)this + 8);
  *((void *)this + 8) = 0;
  if (v5) {
    operator delete(v5);
  }
  uint64_t v6 = (void **)*((void *)this + 5);
  if (v6)
  {
    do
    {
      uint64_t v11 = (void **)*v6;
      if (*((char *)v6 + 39) < 0) {
        operator delete(v6[2]);
      }
      operator delete(v6);
      uint64_t v6 = v11;
    }
    while (v11);
  }
  __int16 v7 = (void *)*((void *)this + 3);
  *((void *)this + 3) = 0;
  if (v7) {
    operator delete(v7);
  }
}

void EmitViewerSPI::initializeOps(EmitViewerSPI *this)
{
  uint64_t v1 = (int8x8_t *)MEMORY[0x1F4188790](this);
  uint64_t v975 = *MEMORY[0x1E4F143B8];
  char v169 = 14;
  strcpy((char *)v168, "anec.A11Legacy");
  int v170 = 1;
  v171[23] = 8;
  strcpy(v171, "anec.A12");
  int v172 = 2;
  v173[23] = 8;
  strcpy(v173, "anec.A13");
  int v174 = 3;
  v175[23] = 8;
  strcpy(v175, "anec.A14");
  int v176 = 4;
  v177[23] = 8;
  strcpy(v177, "anec.A15");
  int v178 = 5;
  v179[23] = 8;
  strcpy(v179, "anec.A16");
  int v180 = 6;
  v181[23] = 8;
  strcpy(v181, "anec.A17");
  int v182 = 7;
  v183[23] = 16;
  strcpy(v183, "anec.arg_min_max");
  int v184 = 8;
  v185[23] = 17;
  strcpy(v185, "anec.average_pool");
  int v186 = 9;
  v187[23] = 19;
  strcpy(v187, "anec.batch_to_space");
  int v188 = 10;
  v189[23] = 14;
  strcpy(v189, "anec.broadcast");
  int v190 = 11;
  v191[23] = 9;
  strcpy(v191, "anec.cast");
  int v192 = 12;
  v193[23] = 9;
  strcpy(v193, "anec.ceil");
  int v194 = 13;
  v195[23] = 21;
  strcpy(v195, "anec.channel_to_space");
  int v196 = 14;
  v197[23] = 17;
  strcpy(v197, "anec.clamped_relu");
  int v198 = 15;
  v199[23] = 11;
  strcpy(v199, "anec.concat");
  int v200 = 16;
  v201[23] = 16;
  strcpy(v201, "anec.convolution");
  int v202 = 17;
  v203[23] = 8;
  strcpy(v203, "anec.cos");
  int v204 = 18;
  v205[23] = 16;
  strcpy(v205, "anec.crop_resize");
  int v206 = 19;
  v207[23] = 12;
  strcpy(v207, "anec.dequant");
  int v208 = 20;
  v209[23] = 18;
  strcpy(v209, "anec.deconvolution");
  int v210 = 21;
  v211[23] = 12;
  strcpy(v211, "anec.degamma");
  int v212 = 22;
  v213[23] = 10;
  strcpy(v213, "anec.dirac");
  int v214 = 23;
  v215[23] = 8;
  strcpy(v215, "anec.abs");
  int v216 = 24;
  v217[23] = 8;
  strcpy(v217, "anec.add");
  int v218 = 25;
  v219[23] = 8;
  strcpy(v219, "anec.div");
  int v220 = 26;
  v221[23] = 10;
  strcpy(v221, "anec.equal");
  int v222 = 27;
  v223[23] = 15;
  strcpy(v223, "anec.equal_zero");
  int v224 = 28;
  v225[23] = 17;
  strcpy(v225, "anec.greater_than");
  int v226 = 29;
  v227 = (char *)operator new(0x19uLL);
  unint64_t v229 = 0x8000000000000019;
  uint64_t v228 = 23;
  strcpy(v227, "anec.greater_than_equal");
  int v230 = 30;
  v231 = (char *)operator new(0x20uLL);
  unint64_t v233 = 0x8000000000000020;
  uint64_t v232 = 28;
  strcpy(v231, "anec.greater_than_equal_zero");
  int v234 = 31;
  strcpy(v235, "anec.greater_than_zero");
  v235[23] = 22;
  int v236 = 32;
  v237[23] = 14;
  strcpy(v237, "anec.less_than");
  int v238 = 33;
  v239[23] = 20;
  strcpy(v239, "anec.less_than_equal");
  int v240 = 34;
  v241 = (char *)operator new(0x20uLL);
  unint64_t v243 = 0x8000000000000020;
  uint64_t v242 = 25;
  strcpy(v241, "anec.less_than_equal_zero");
  int v244 = 35;
  v245[23] = 19;
  strcpy(v245, "anec.less_than_zero");
  int v246 = 36;
  v247[23] = 8;
  strcpy(v247, "anec.max");
  int v248 = 37;
  v249[23] = 8;
  strcpy(v249, "anec.min");
  int v250 = 38;
  strcpy(v252, "\t'");
  strcpy(v251, "anec.mult");
  *(_WORD *)&v252[3] = 0;
  v253[23] = 14;
  strcpy(v253, "anec.not_equal");
  int v254 = 40;
  v255[23] = 19;
  strcpy(v255, "anec.not_equal_zero");
  int v256 = 41;
  strcpy(v258, "\n*");
  strcpy(v257, "anec.power");
  *(_WORD *)&v258[3] = 0;
  v259[23] = 11;
  strcpy(v259, "anec.square");
  int v260 = 43;
  v261[23] = 8;
  strcpy(v261, "anec.sub");
  int v262 = 44;
  v263[23] = 8;
  strcpy(v263, "anec.elu");
  int v264 = 45;
  v265[23] = 8;
  strcpy(v265, "anec.erf");
  int v266 = 46;
  strcpy(v268, "\t/");
  strcpy(v267, "anec.exp2");
  *(_WORD *)&v268[3] = 0;
  v269[23] = 12;
  strcpy(v269, "anec.flatten");
  int v270 = 48;
  strcpy(v272, "\n1");
  strcpy(v271, "anec.floor");
  *(_WORD *)&v272[3] = 0;
  v273 = (char *)operator new(0x20uLL);
  unint64_t v275 = 0x8000000000000020;
  uint64_t v274 = 24;
  strcpy(v273, "anec.gain_offset_control");
  int v276 = 50;
  v277[23] = 14;
  strcpy(v277, "anec.gather_nd");
  int v278 = 51;
  strcpy(v280, "\t4");
  strcpy(v279, "anec.gelu");
  *(_WORD *)&v280[3] = 0;
  v281 = (char *)operator new(0x19uLL);
  unint64_t v283 = 0x8000000000000019;
  uint64_t v282 = 23;
  strcpy(v281, "anec.global_arg_min_max");
  int v284 = 53;
  v285 = (char *)operator new(0x20uLL);
  unint64_t v287 = 0x8000000000000020;
  uint64_t v286 = 27;
  strcpy(v285, "anec.high_precision_sigmoid");
  int v288 = 54;
  v289[23] = 15;
  strcpy(v289, "anec.input_view");
  int v290 = 55;
  v291[23] = 18;
  strcpy(v291, "anec.instance_norm");
  int v292 = 56;
  v293[23] = 11;
  strcpy(v293, "anec.invert");
  int v294 = 57;
  v295[23] = 16;
  strcpy(v295, "anec.l2norm_pool");
  int v296 = 58;
  v297[23] = 15;
  strcpy(v297, "anec.leaky_relu");
  int v298 = 59;
  v299[23] = 11;
  strcpy(v299, "anec.linear");
  int v300 = 60;
  strcpy(v302, "\t=");
  strcpy(v301, "anec.log2");
  *(_WORD *)&v302[3] = 0;
  v303[23] = 11;
  strcpy(v303, "anec.matmul");
  int v304 = 62;
  v305[23] = 13;
  strcpy(v305, "anec.max_pool");
  int v306 = 63;
  v307[23] = 11;
  strcpy(v307, "anec.n_relu");
  int v308 = 64;
  v309[23] = 12;
  strcpy(v309, "anec.padding");
  int v310 = 65;
  v311[23] = 18;
  strcpy(v311, "anec.pixel_shuffle");
  int v312 = 66;
  v313[23] = 20;
  strcpy(v313, "anec.pixel_unshuffle");
  int v314 = 67;
  strcpy(v316, "\nD");
  strcpy(v315, "anec.quant");
  *(_WORD *)&v316[3] = 0;
  v317[23] = 15;
  strcpy(v317, "anec.reduce_avg");
  int v318 = 69;
  v319[23] = 15;
  strcpy(v319, "anec.reduce_max");
  int v320 = 70;
  v321[23] = 15;
  strcpy(v321, "anec.reduce_min");
  int v322 = 71;
  v323[23] = 15;
  strcpy(v323, "anec.reduce_sum");
  int v324 = 72;
  v325[23] = 18;
  strcpy(v325, "anec.region_return");
  int v326 = 73;
  strcpy(v328, "\tJ");
  strcpy(v327, "anec.relu");
  *(_WORD *)&v328[3] = 0;
  v329[23] = 12;
  strcpy(v329, "anec.reshape");
  int v330 = 75;
  v331[23] = 11;
  strcpy(v331, "anec.resize");
  int v332 = 76;
  v333[23] = 18;
  strcpy(v333, "anec.round_nearest");
  int v334 = 77;
  v335[23] = 11;
  strcpy(v335, "anec.r_sqrt");
  int v336 = 78;
  v337[23] = 12;
  strcpy(v337, "anec.sigmoid");
  int v338 = 79;
  strcpy(v340, "\tP");
  strcpy(v339, "anec.sign");
  *(_WORD *)&v340[3] = 0;
  v341[23] = 8;
  strcpy(v341, "anec.sin");
  int v342 = 81;
  v343[23] = 12;
  strcpy(v343, "anec.softmax");
  int v344 = 82;
  v345[23] = 19;
  strcpy(v345, "anec.space_to_batch");
  int v346 = 83;
  v347[23] = 21;
  strcpy(v347, "anec.space_to_channel");
  int v348 = 84;
  v349[23] = 8;
  strcpy(v349, "anec.sqr");
  int v350 = 85;
  strcpy(v352, "\tV");
  strcpy(v351, "anec.sqrt");
  *(_WORD *)&v352[3] = 0;
  strcpy(v354, "\nW");
  strcpy(v353, "anec.swish");
  *(_WORD *)&v354[3] = 0;
  strcpy(v356, "\nX");
  strcpy(v355, "anec.A12r0");
  *(_WORD *)&v356[3] = 0;
  strcpy(v358, "\tY");
  strcpy(v357, "anec.tanh");
  *(_WORD *)&v358[3] = 0;
  strcpy(v360, "\tZ");
  strcpy(v359, "anec.tile");
  *(_WORD *)&v360[3] = 0;
  v361[23] = 14;
  strcpy(v361, "anec.transpose");
  int v362 = 91;
  strcpy(v364, "\n\\"");
  strcpy(v363, "anec.trunc");
  *(_WORD *)&v364[3] = 0;
  v365[23] = 14;
  strcpy(v365, "anec.unflatten");
  int v366 = 93;
  v367 = (char *)operator new(0x20uLL);
  unint64_t v369 = 0x8000000000000020;
  uint64_t v368 = 31;
  strcpy(v367, "anec.unrealized_conversion_cast");
  int v370 = 94;
  v371[23] = 8;
  strcpy(v371, "mps.acos");
  int v372 = 95;
  strcpy(v373, "mps.acosh");
  *(_WORD *)&v374[3] = 0;
  v375[23] = 8;
  strcpy(v375, "mps.asin");
  int v376 = 97;
  strcpy(v378, "\tb");
  strcpy(v377, "mps.asinh");
  *(_WORD *)&v378[3] = 0;
  strcpy(v380, "\tc");
  strcpy(v379, "mps.atan2");
  *(_WORD *)&v380[3] = 0;
  v381[23] = 8;
  strcpy(v381, "mps.atan");
  int v382 = 100;
  strcpy(v384, "\te");
  strcpy(v383, "mps.atanh");
  *(_WORD *)&v384[3] = 0;
  v385[23] = 12;
  strcpy(v385, "mps.absolute");
  int v386 = 102;
  v387[23] = 19;
  strcpy(v387, "mps.absolute_square");
  int v388 = 103;
  v389[23] = 7;
  strcpy(v389, "mps.add");
  int v390 = 104;
  v391[23] = 7;
  strcpy(v391, "mps.and");
  int v392 = 105;
  v393[23] = 19;
  strcpy(v393, "mps.assign_variable");
  int v394 = 106;
  v395[23] = 13;
  strcpy(v395, "mps.band_part");
  int v396 = 107;
  v397[23] = 18;
  strcpy(v397, "mps.batch_to_space");
  int v398 = 108;
  v399[23] = 17;
  strcpy(v399, "mps.bias_add_grad");
  int v400 = 109;
  v401[23] = 12;
  strcpy(v401, "mps.bias_add");
  int v402 = 110;
  v403[23] = 15;
  strcpy(v403, "mps.bitwise_and");
  int v404 = 111;
  v405[23] = 22;
  strcpy(v405, "mps.bitwise_left_shift");
  int v406 = 112;
  v407[23] = 15;
  strcpy(v407, "mps.bitwise_not");
  int v408 = 113;
  v409[23] = 14;
  strcpy(v409, "mps.bitwise_or");
  int v410 = 114;
  v411[23] = 20;
  strcpy(v411, "mps.bitwise_popcount");
  int v412 = 115;
  v413 = (char *)operator new(0x19uLL);
  unint64_t v415 = 0x8000000000000019;
  uint64_t v414 = 23;
  strcpy(v413, "mps.bitwise_right_shift");
  int v416 = 116;
  v417[23] = 15;
  strcpy(v417, "mps.bitwise_xor");
  int v418 = 117;
  v419 = (char *)operator new(0x20uLL);
  unint64_t v421 = 0x8000000000000020;
  uint64_t v420 = 27;
  strcpy(v419, "mps.broadcast_gradient_args");
  int v422 = 118;
  v423[23] = 16;
  strcpy(v423, "mps.broadcast_to");
  int v424 = 119;
  v425[23] = 8;
  strcpy(v425, "mps.call");
  int v426 = 120;
  v427[23] = 8;
  strcpy(v427, "mps.cast");
  int v428 = 121;
  v429[23] = 8;
  strcpy(v429, "mps.ceil");
  int v430 = 122;
  strcpy(v432, "\t{");
  strcpy(v431, "mps.clamp");
  *(_WORD *)&v432[3] = 0;
  v433[23] = 13;
  strcpy(v433, "mps.col_to_im");
  int v434 = 124;
  strcpy(v436, "\n}");
  strcpy(v435, "mps.concat");
  *(_WORD *)&v436[3] = 0;
  v437[23] = 13;
  strcpy(v437, "mps.conjugate");
  int v438 = 126;
  v439[23] = 12;
  strcpy(v439, "mps.constant");
  int v440 = 127;
  v441 = (char *)operator new(0x20uLL);
  unint64_t v443 = 0x8000000000000020;
  uint64_t v442 = 25;
  strcpy(v441, "mps.conv_2d_data_gradient");
  int v444 = 128;
  v445[23] = 11;
  strcpy(v445, "mps.conv_2d");
  int v446 = 129;
  v447 = (char *)operator new(0x20uLL);
  unint64_t v449 = 0x8000000000000020;
  uint64_t v448 = 28;
  strcpy(v447, "mps.conv_2d_weights_gradient");
  int v450 = 130;
  v451 = (char *)operator new(0x20uLL);
  unint64_t v453 = 0x8000000000000020;
  uint64_t v452 = 25;
  strcpy(v451, "mps.conv_3d_data_gradient");
  int v454 = 131;
  v455[23] = 11;
  strcpy(v455, "mps.conv_3d");
  int v456 = 132;
  v457 = (char *)operator new(0x20uLL);
  unint64_t v459 = 0x8000000000000020;
  uint64_t v458 = 28;
  strcpy(v457, "mps.conv_3d_weights_gradient");
  int v460 = 133;
  v461[23] = 7;
  strcpy(v461, "mps.cos");
  int v462 = 134;
  v463[23] = 8;
  strcpy(v463, "mps.cosh");
  int v464 = 135;
  v465[23] = 15;
  strcpy(v465, "mps.cost_volume");
  int v466 = 136;
  v467[23] = 18;
  strcpy(v467, "mps.create_complex");
  int v468 = 137;
  v469 = (char *)operator new(0x20uLL);
  unint64_t v471 = 0x8000000000000020;
  uint64_t v470 = 25;
  strcpy(v469, "mps.create_texture_tensor");
  int v472 = 138;
  v473[23] = 8;
  strcpy(v473, "mps.crop");
  int v474 = 139;
  v475[23] = 15;
  strcpy(v475, "mps.crop_resize");
  int v476 = 140;
  strcpy(v477, "mps.cumulative_maximum");
  v477[23] = 22;
  int v478 = 141;
  strcpy(v479, "mps.cumulative_minimum");
  v479[23] = 22;
  int v480 = 142;
  v481[23] = 22;
  strcpy(v481, "mps.cumulative_product");
  int v482 = 143;
  v483[23] = 18;
  strcpy(v483, "mps.cumulative_sum");
  int v484 = 144;
  v485[23] = 11;
  strcpy(v485, "mps.degamma");
  int v486 = 145;
  v487[23] = 21;
  strcpy(v487, "mps.depth_to_space_2d");
  int v488 = 146;
  v489 = (char *)operator new(0x28uLL);
  unint64_t v491 = 0x8000000000000028;
  uint64_t v490 = 35;
  strcpy(v489, "mps.depthwise_conv_2d_data_gradient");
  int v492 = 147;
  v493[23] = 21;
  strcpy(v493, "mps.depthwise_conv_2d");
  int v494 = 148;
  v495 = (char *)operator new(0x28uLL);
  unint64_t v497 = 0x8000000000000028;
  uint64_t v496 = 38;
  strcpy(v495, "mps.depthwise_conv_2d_weights_gradient");
  int v498 = 149;
  v499 = (char *)operator new(0x28uLL);
  unint64_t v501 = 0x8000000000000028;
  uint64_t v500 = 35;
  strcpy(v499, "mps.depthwise_conv_3d_data_gradient");
  int v502 = 150;
  v503[23] = 21;
  strcpy(v503, "mps.depthwise_conv_3d");
  int v504 = 151;
  v505 = (char *)operator new(0x28uLL);
  unint64_t v507 = 0x8000000000000028;
  uint64_t v506 = 38;
  strcpy(v505, "mps.depthwise_conv_3d_weights_gradient");
  int v508 = 152;
  v509[23] = 18;
  strcpy(v509, "mps.dequantize_lut");
  int v510 = 153;
  v511[23] = 14;
  strcpy(v511, "mps.dequantize");
  int v512 = 154;
  v513[23] = 18;
  strcpy(v513, "mps.dimension_size");
  int v514 = 155;
  v515[23] = 9;
  strcpy(v515, "mps.dirac");
  int v516 = 156;
  v517[23] = 10;
  strcpy(v517, "mps.divide");
  int v518 = 157;
  strcpy(v519, "mps.dynamic_shape_cast");
  v519[23] = 22;
  int v520 = 158;
  v521[23] = 7;
  strcpy(v521, "mps.elu");
  int v522 = 159;
  v523[23] = 9;
  strcpy(v523, "mps.equal");
  int v524 = 160;
  v525[23] = 7;
  strcpy(v525, "mps.erf");
  int v526 = 161;
  v527[23] = 15;
  strcpy(v527, "mps.expand_dims");
  int v528 = 162;
  v529[23] = 19;
  strcpy(v529, "mps.exponent_base_2");
  int v530 = 163;
  v531[23] = 20;
  strcpy(v531, "mps.exponent_base_10");
  int v532 = 164;
  v533[23] = 12;
  strcpy(v533, "mps.exponent");
  int v534 = 165;
  v535 = (char *)operator new(0x20uLL);
  uint64_t v536 = 26;
  unint64_t v537 = 0x8000000000000020;
  strcpy(v535, "mps.fast_fourier_transform");
  int v538 = 166;
  v539[23] = 14;
  strcpy(v539, "mps.flatten_2d");
  int v540 = 167;
  v541[23] = 16;
  strcpy(v541, "mps.floor_divide");
  int v542 = 168;
  v543[23] = 9;
  strcpy(v543, "mps.floor");
  int v544 = 169;
  v545[23] = 16;
  strcpy(v545, "mps.gru_gradient");
  int v546 = 170;
  v547[23] = 7;
  strcpy(v547, "mps.gru");
  int v548 = 171;
  v549[23] = 21;
  strcpy(v549, "mps.gather_along_axis");
  int v550 = 172;
  v551[23] = 13;
  strcpy(v551, "mps.gather_nd");
  int v552 = 173;
  v553[23] = 10;
  strcpy(v553, "mps.gather");
  int v554 = 174;
  v555[23] = 8;
  strcpy(v555, "mps.gelu");
  int v556 = 175;
  v557[23] = 19;
  strcpy(v557, "mps.get_coordinates");
  int v558 = 176;
  v559[23] = 11;
  strcpy(v559, "mps.greater");
  int v560 = 177;
  v561[23] = 17;
  strcpy(v561, "mps.greater_equal");
  int v562 = 178;
  v563[23] = 20;
  strcpy(v563, "mps.hamming_distance");
  int v564 = 179;
  v565 = (char *)operator new(0x20uLL);
  unint64_t v567 = 0x8000000000000020;
  uint64_t v566 = 25;
  strcpy(v565, "mps.hermitean_to_real_fft");
  int v568 = 180;
  v569[23] = 12;
  strcpy(v569, "mps.identity");
  int v570 = 181;
  v571[23] = 13;
  strcpy(v571, "mps.im_to_col");
  int v572 = 182;
  v573[23] = 18;
  strcpy(v573, "mps.imaginary_part");
  int v574 = 183;
  v575 = (char *)operator new(0x20uLL);
  unint64_t v577 = 0x8000000000000020;
  uint64_t v576 = 28;
  strcpy(v575, "mps.init_random_philox_state");
  int v578 = 184;
  v579[23] = 17;
  strcpy(v579, "mps.instance_norm");
  int v580 = 185;
  v581[23] = 13;
  strcpy(v581, "mps.is_finite");
  int v582 = 186;
  v583[23] = 15;
  strcpy(v583, "mps.is_infinite");
  int v584 = 187;
  v585[23] = 10;
  strcpy(v585, "mps.is_nan");
  int v586 = 188;
  v587[23] = 11;
  strcpy(v587, "mps.lp_norm");
  int v588 = 189;
  v589[23] = 17;
  strcpy(v589, "mps.lstm_gradient");
  int v590 = 190;
  v591[23] = 8;
  strcpy(v591, "mps.lstm");
  int v592 = 191;
  v593[23] = 14;
  strcpy(v593, "mps.leaky_relu");
  int v594 = 192;
  v595[23] = 8;
  strcpy(v595, "mps.less");
  int v596 = 193;
  v597[23] = 14;
  strcpy(v597, "mps.less_equal");
  int v598 = 194;
  v599 = (char *)operator new(0x28uLL);
  unint64_t v601 = 0x8000000000000028;
  uint64_t v600 = 35;
  strcpy(v599, "mps.local_convolution_data_gradient");
  int v602 = 195;
  v603[23] = 21;
  strcpy(v603, "mps.local_convolution");
  int v604 = 196;
  v605 = (char *)operator new(0x28uLL);
  unint64_t v607 = 0x8000000000000028;
  uint64_t v606 = 37;
  strcpy(v605, "mps.local_convolution_weight_gradient");
  int v608 = 197;
  v609[23] = 20;
  strcpy(v609, "mps.logarithm_base_2");
  int v610 = 198;
  v611[23] = 21;
  strcpy(v611, "mps.logarithm_base_10");
  int v612 = 199;
  v613[23] = 13;
  strcpy(v613, "mps.logarithm");
  int v614 = 200;
  v615[23] = 10;
  strcpy(v615, "mps.matmul");
  int v616 = 201;
  v617 = (char *)operator new(0x20uLL);
  unint64_t v619 = 0x8000000000000020;
  uint64_t v618 = 29;
  strcpy(v617, "mps.materialize_sparse_tensor");
  int v620 = 202;
  v621 = (char *)operator new(0x20uLL);
  unint64_t v623 = 0x8000000000000020;
  uint64_t v622 = 27;
  strcpy(v621, "mps.matrix_decomposition_lu");
  int v624 = 203;
  v625[23] = 18;
  strcpy(v625, "mps.matrix_inverse");
  int v626 = 204;
  v627[23] = 20;
  strcpy(v627, "mps.matrix_solver_lu");
  int v628 = 205;
  v629[23] = 11;
  strcpy(v629, "mps.maximum");
  int v630 = 206;
  v631[23] = 11;
  strcpy(v631, "mps.minimum");
  int v632 = 207;
  v633[23] = 10;
  strcpy(v633, "mps.modulo");
  int v634 = 208;
  v635[23] = 12;
  strcpy(v635, "mps.multiply");
  int v636 = 209;
  v637[23] = 10;
  strcpy(v637, "mps.n_relu");
  int v638 = 210;
  v639[23] = 8;
  strcpy(v639, "mps.nand");
  int v640 = 211;
  v641[23] = 12;
  strcpy(v641, "mps.negative");
  int v642 = 212;
  v643 = (char *)operator new(0x20uLL);
  unint64_t v645 = 0x8000000000000020;
  uint64_t v644 = 27;
  strcpy(v643, "mps.non_maximum_suppression");
  int v646 = 213;
  v647[23] = 12;
  strcpy(v647, "mps.non_zero");
  int v648 = 214;
  v649[23] = 7;
  strcpy(v649, "mps.nor");
  int v650 = 215;
  v651[23] = 17;
  strcpy(v651, "mps.normalization");
  int v652 = 216;
  v653[23] = 13;
  strcpy(v653, "mps.not_equal");
  int v654 = 217;
  v655[23] = 7;
  strcpy(v655, "mps.not");
  int v656 = 218;
  v657[23] = 11;
  strcpy(v657, "mps.one_hot");
  int v658 = 219;
  v659[23] = 6;
  strcpy(v659, "mps.or");
  int v660 = 220;
  v661[23] = 9;
  strcpy(v661, "mps.prelu");
  int v662 = 221;
  v663[23] = 16;
  strcpy(v663, "mps.pad_gradient");
  int v664 = 222;
  v665[23] = 7;
  strcpy(v665, "mps.pad");
  int v666 = 223;
  v667[23] = 11;
  strcpy(v667, "mps.permute");
  int v668 = 224;
  v669[23] = 15;
  strcpy(v669, "mps.placeholder");
  int v670 = 225;
  v671 = (char *)operator new(0x20uLL);
  unint64_t v673 = 0x8000000000000020;
  uint64_t v672 = 28;
  strcpy(v671, "mps.pooling_average_gradient");
  int v674 = 226;
  v675[23] = 19;
  strcpy(v675, "mps.pooling_average");
  int v676 = 227;
  v677 = (char *)operator new(0x20uLL);
  unint64_t v679 = 0x8000000000000020;
  uint64_t v678 = 28;
  strcpy(v677, "mps.pooling_l2_norm_gradient");
  int v680 = 228;
  v681[23] = 19;
  strcpy(v681, "mps.pooling_l2_norm");
  int v682 = 229;
  v683 = (char *)operator new(0x20uLL);
  unint64_t v685 = 0x8000000000000020;
  uint64_t v684 = 24;
  strcpy(v683, "mps.pooling_max_gradient");
  int v686 = 230;
  v687[23] = 15;
  strcpy(v687, "mps.pooling_max");
  int v688 = 231;
  v689[23] = 9;
  strcpy(v689, "mps.power");
  int v690 = 232;
  v691[23] = 18;
  strcpy(v691, "mps.prune_gradient");
  int v692 = 233;
  v693[23] = 9;
  strcpy(v693, "mps.prune");
  int v694 = 234;
  v695[23] = 12;
  strcpy(v695, "mps.quantize");
  int v696 = 235;
  v697[23] = 17;
  strcpy(v697, "mps.random_normal");
  int v698 = 236;
  v699 = (char *)operator new(0x20uLL);
  unint64_t v701 = 0x8000000000000020;
  uint64_t v700 = 27;
  strcpy(v699, "mps.random_truncated_normal");
  int v702 = 237;
  v703[23] = 18;
  strcpy(v703, "mps.random_uniform");
  int v704 = 238;
  v705[23] = 8;
  strcpy(v705, "mps.rank");
  int v706 = 239;
  v707 = (char *)operator new(0x19uLL);
  unint64_t v709 = 0x8000000000000019;
  uint64_t v708 = 23;
  strcpy(v707, "mps.read_data_from_file");
  int v710 = 240;
  v711[23] = 17;
  strcpy(v711, "mps.read_variable");
  int v712 = 241;
  v713[23] = 13;
  strcpy(v713, "mps.real_part");
  int v714 = 242;
  v715 = (char *)operator new(0x20uLL);
  unint64_t v717 = 0x8000000000000020;
  uint64_t v716 = 25;
  strcpy(v715, "mps.real_to_hermitean_fft");
  int v718 = 243;
  v719[23] = 14;
  strcpy(v719, "mps.reciprocal");
  int v720 = 244;
  v721 = (char *)operator new(0x20uLL);
  unint64_t v723 = 0x8000000000000020;
  uint64_t v722 = 26;
  strcpy(v721, "mps.reciprocal_square_root");
  int v724 = 245;
  v725[23] = 17;
  strcpy(v725, "mps.reduction_and");
  int v726 = 246;
  v727[23] = 20;
  strcpy(v727, "mps.reduction_argmax");
  int v728 = 247;
  v729[23] = 20;
  strcpy(v729, "mps.reduction_argmin");
  int v730 = 248;
  v731 = (char *)operator new(0x19uLL);
  unint64_t v733 = 0x8000000000000019;
  uint64_t v732 = 23;
  strcpy(v731, "mps.reduction_logsumexp");
  int v734 = 249;
  v735[23] = 17;
  strcpy(v735, "mps.reduction_max");
  int v736 = 250;
  v737[23] = 18;
  strcpy(v737, "mps.reduction_mean");
  int v738 = 251;
  v739[23] = 17;
  strcpy(v739, "mps.reduction_min");
  int v740 = 252;
  v741[23] = 16;
  strcpy(v741, "mps.reduction_or");
  int v742 = 253;
  v743[23] = 18;
  strcpy(v743, "mps.reduction_prod");
  int v744 = 254;
  v745[23] = 17;
  strcpy(v745, "mps.reduction_sum");
  int v746 = 255;
  strcpy(v747, "mps.reduction_variance");
  v747[23] = 22;
  int v748 = 256;
  v749[23] = 20;
  strcpy(v749, "mps.reinterpret_cast");
  int v750 = 257;
  v751[23] = 9;
  strcpy(v751, "mps.relu6");
  int v752 = 258;
  v753[23] = 13;
  strcpy(v753, "mps.relu_grad");
  int v754 = 259;
  v755[23] = 8;
  strcpy(v755, "mps.relu");
  int v756 = 260;
  v757[23] = 11;
  strcpy(v757, "mps.reshape");
  int v758 = 261;
  v759[23] = 19;
  strcpy(v759, "mps.resize_gradient");
  int v760 = 262;
  v761[23] = 10;
  strcpy(v761, "mps.resize");
  int v762 = 263;
  v763[23] = 11;
  strcpy(v763, "mps.reverse");
  int v764 = 264;
  v765[23] = 8;
  strcpy(v765, "mps.rint");
  int v766 = 265;
  v767[23] = 9;
  strcpy(v767, "mps.round");
  int v768 = 266;
  v769 = (char *)operator new(0x20uLL);
  unint64_t v771 = 0x8000000000000020;
  uint64_t v770 = 29;
  strcpy(v769, "mps.sample_grid_data_gradient");
  int v772 = 267;
  v773[23] = 15;
  strcpy(v773, "mps.sample_grid");
  int v774 = 268;
  v775[23] = 22;
  strcpy(v775, "mps.scatter_along_axis");
  int v776 = 269;
  v777[23] = 14;
  strcpy(v777, "mps.scatter_nd");
  int v778 = 270;
  v779[23] = 11;
  strcpy(v779, "mps.scatter");
  int v780 = 271;
  v781[23] = 10;
  strcpy(v781, "mps.select");
  int v782 = 272;
  v783[23] = 9;
  strcpy(v783, "mps.shape");
  int v784 = 273;
  v785[23] = 20;
  strcpy(v785, "mps.sigmoid_gradient");
  int v786 = 274;
  v787 = (char *)operator new(0x28uLL);
  int8x8_t v2 = (int8x8_t)&v791[16];
  unint64_t v789 = 0x8000000000000028;
  uint64_t v788 = 33;
  strcpy(v787, "mps.sigmoid_gradient_with_sigmoid");
  int v790 = 275;
  v791[23] = 16;
  strcpy(v791, "mps.sigmoid_hard");
  int v792 = 276;
  v793[23] = 11;
  strcpy(v793, "mps.sigmoid");
  int v794 = 277;
  v795[23] = 8;
  strcpy(v795, "mps.sign");
  int v796 = 278;
  v797[23] = 11;
  strcpy(v797, "mps.signbit");
  int v798 = 279;
  v799[23] = 7;
  strcpy(v799, "mps.sin");
  int v800 = 280;
  v801 = (char *)operator new(0x20uLL);
  unint64_t v803 = 0x8000000000000020;
  uint64_t v802 = 27;
  strcpy(v801, "mps.singlegate_rnn_gradient");
  int v804 = 281;
  v805[23] = 18;
  strcpy(v805, "mps.singlegate_rnn");
  int v806 = 282;
  v807[23] = 8;
  strcpy(v807, "mps.sinh");
  int v808 = 283;
  v809[23] = 8;
  strcpy(v809, "mps.size");
  int v810 = 284;
  v811[23] = 9;
  strcpy(v811, "mps.slice");
  int v812 = 285;
  v813[23] = 11;
  strcpy(v813, "mps.softmax");
  int v814 = 286;
  v815[23] = 12;
  strcpy(v815, "mps.softplus");
  int v816 = 287;
  v817 = (char *)operator new(0x19uLL);
  unint64_t v819 = 0x8000000000000019;
  uint64_t v818 = 23;
  strcpy(v817, "mps.softplus_parametric");
  int v820 = 288;
  v821[23] = 12;
  strcpy(v821, "mps.softsign");
  int v822 = 289;
  v823[23] = 8;
  strcpy(v823, "mps.sort");
  int v824 = 290;
  v825[23] = 18;
  strcpy(v825, "mps.space_to_batch");
  int v826 = 291;
  v827[23] = 21;
  strcpy(v827, "mps.space_to_depth_2d");
  int v828 = 292;
  v829[23] = 9;
  strcpy(v829, "mps.split");
  int v830 = 293;
  v831[23] = 10;
  strcpy(v831, "mps.square");
  int v832 = 294;
  v833[23] = 15;
  strcpy(v833, "mps.square_root");
  int v834 = 295;
  v835[23] = 11;
  strcpy(v835, "mps.squeeze");
  int v836 = 296;
  v837[23] = 11;
  strcpy(v837, "mps.stencil");
  int v838 = 297;
  v839 = (char *)operator new(0x20uLL);
  unint64_t v841 = 0x8000000000000020;
  uint64_t v840 = 26;
  strcpy(v839, "mps.strided_slice_gradient");
  int v842 = 298;
  v843[23] = 17;
  strcpy(v843, "mps.strided_slice");
  int v844 = 299;
  v845 = (char *)operator new(0x20uLL);
  unint64_t v847 = 0x8000000000000020;
  uint64_t v846 = 24;
  strcpy(v845, "mps.strided_slice_update");
  int v848 = 300;
  v849[23] = 12;
  strcpy(v849, "mps.subtract");
  int v850 = 301;
  v851[23] = 9;
  strcpy(v851, "mps.swish");
  int v852 = 302;
  v853[23] = 7;
  strcpy(v853, "mps.tan");
  int v854 = 303;
  v855[23] = 8;
  strcpy(v855, "mps.tanh");
  int v856 = 304;
  v857[23] = 17;
  strcpy(v857, "mps.tile_gradient");
  int v858 = 305;
  v859[23] = 8;
  strcpy(v859, "mps.tile");
  int v860 = 306;
  v861[23] = 14;
  strcpy(v861, "mps.top_k_grad");
  int v862 = 307;
  v863[23] = 9;
  strcpy(v863, "mps.top_k");
  int v864 = 308;
  v865[23] = 13;
  strcpy(v865, "mps.transpose");
  int v866 = 309;
  v867[23] = 12;
  strcpy(v867, "mps.truncate");
  int v868 = 310;
  v869[23] = 19;
  strcpy(v869, "mps.type_constraint");
  int v870 = 311;
  v871[23] = 19;
  strcpy(v871, "mps.unrealized_fold");
  int v872 = 312;
  v873 = (char *)operator new(0x19uLL);
  unint64_t v875 = 0x8000000000000019;
  uint64_t v874 = 23;
  strcpy(v873, "mps.update_random_state");
  int v876 = 313;
  v877 = (char *)operator new(0x20uLL);
  unint64_t v879 = 0x8000000000000020;
  uint64_t v878 = 24;
  strcpy(v877, "mps.variable_from_tensor");
  int v880 = 314;
  v881[23] = 8;
  strcpy(v881, "mps.xnor");
  int v882 = 315;
  v883[23] = 7;
  strcpy(v883, "mps.xor");
  int v884 = 316;
  v885[23] = 13;
  strcpy(v885, "mps.condition");
  int v886 = 317;
  v887[23] = 7;
  strcpy(v887, "mps.for");
  int v888 = 318;
  char v890 = 6;
  strcpy((char *)v889, "mps.if");
  int v891 = 319;
  v892[23] = 11;
  strcpy(v892, "mps.extract");
  int v893 = 320;
  v894[23] = 17;
  strcpy(v894, "mps.from_elements");
  int v895 = 321;
  v896[23] = 8;
  strcpy(v896, "mps.func");
  int v897 = 322;
  v898[23] = 10;
  strcpy(v898, "mps.module");
  int v899 = 323;
  v900[23] = 10;
  strcpy(v900, "mps.return");
  int v901 = 324;
  v902[23] = 9;
  strcpy(v902, "mps.while");
  int v903 = 325;
  v904[23] = 9;
  strcpy(v904, "mps.yield");
  int v905 = 326;
  v906[23] = 8;
  strcpy(v906, "mpsx.ane");
  int v907 = 327;
  v908[23] = 8;
  strcpy(v908, "mpsx.cpu");
  int v909 = 328;
  v910[23] = 17;
  strcpy(v910, "mpsx.deinterleave");
  int v911 = 329;
  v912[23] = 22;
  strcpy(v912, "mpsx.fp_to_int_clamped");
  int v913 = 330;
  v914[23] = 11;
  strcpy(v914, "mpsx.fusion");
  int v915 = 331;
  v916[23] = 18;
  strcpy(v916, "mpsx.fusion_return");
  int v917 = 332;
  v918[23] = 8;
  strcpy(v918, "mpsx.gpu");
  int v919 = 333;
  v920[23] = 15;
  strcpy(v920, "mpsx.interleave");
  int v921 = 334;
  v922[23] = 18;
  strcpy(v922, "mpsx.list_pop_back");
  int v923 = 335;
  v924[23] = 19;
  strcpy(v924, "mpsx.list_push_back");
  int v925 = 336;
  v926[23] = 14;
  strcpy(v926, "mpsx.make_list");
  int v927 = 337;
  v928[23] = 21;
  strcpy(v928, "mpsx.quantized_gather");
  int v929 = 338;
  v930[23] = 21;
  strcpy(v930, "mpsx.quantized_matmul");
  int v931 = 339;
  v932[23] = 13;
  strcpy(v932, "mpsx.rms_norm");
  int v933 = 340;
  v934[23] = 18;
  strcpy(v934, "mpsx.region_return");
  int v935 = 341;
  v936[23] = 20;
  strcpy(v936, "mpsx.stitched_return");
  int v937 = 342;
  v938[23] = 9;
  strcpy(v938, "mpsx.sdpa");
  int v939 = 343;
  v940 = (char *)operator new(0x20uLL);
  unint64_t v942 = 0x8000000000000020;
  uint64_t v941 = 24;
  strcpy(v940, "mpsx.sparse_dense_matmul");
  int v943 = 344;
  v944[23] = 13;
  strcpy(v944, "mpsx.stitched");
  int v945 = 345;
  v946[23] = 15;
  strcpy(v946, "mpsx.var_handle");
  int v947 = 346;
  v948[23] = 21;
  strcpy(v948, "placement.ane_io_cast");
  int v949 = 347;
  v950 = (char *)operator new(0x20uLL);
  unint64_t v952 = 0x8000000000000020;
  uint64_t v951 = 24;
  strcpy(v950, "placement.host_type_cast");
  int v953 = 348;
  v954 = (char *)operator new(0x20uLL);
  unint64_t v956 = 0x8000000000000020;
  uint64_t v955 = 26;
  strcpy(v954, "placement.memref_to_tensor");
  int v957 = 349;
  v958[23] = 21;
  strcpy(v958, "placement.region_call");
  int v959 = 350;
  v960[23] = 22;
  strcpy(v960, "placement.replaced_ops");
  int v961 = 351;
  v962[23] = 19;
  strcpy(v962, "placement.live_outs");
  int v963 = 352;
  v964[23] = 21;
  strcpy(v964, "placement.start_timer");
  int v965 = 353;
  v966[23] = 20;
  strcpy(v966, "placement.stop_timer");
  int v967 = 354;
  v968 = (char *)operator new(0x20uLL);
  unint64_t v970 = 0x8000000000000020;
  uint64_t v969 = 26;
  strcpy(v968, "placement.tensor_to_memref");
  int v971 = 355;
  char v973 = 11;
  strcpy(v972, "func.return");
  int v974 = 356;
  v3 = v1 + 23;
  int8x8_t v4 = v1[24];
  v152 = v1 + 23;
  if (!*(void *)&v4)
  {
    uint64_t v7 = 0;
LABEL_115:
    v150 = v1 + 25;
    while (1)
    {
      int v55 = &v168[4 * v7];
      int v56 = *((char *)v55 + 23);
      if (v56 >= 0) {
        char v57 = (std::string::value_type *)&v168[4 * v7];
      }
      else {
        char v57 = *v55;
      }
      if (v56 >= 0) {
        unint64_t v58 = *((unsigned __int8 *)v55 + 23);
      }
      else {
        unint64_t v58 = (unint64_t)v55[1];
      }
      unint64_t v59 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&__dst, (uint64_t *)v57, v58);
      unint64_t v60 = v59;
      unint64_t v61 = (unint64_t)v1[24];
      if (v61)
      {
        uint8x8_t v62 = (uint8x8_t)vcnt_s8((int8x8_t)v61);
        v62.i16[0] = vaddlv_u8(v62);
        if (v62.u32[0] > 1uLL)
        {
          int8x8_t v2 = (int8x8_t)v59;
          if (v59 >= v61) {
            int8x8_t v2 = (int8x8_t)(v59 % v61);
          }
        }
        else
        {
          int8x8_t v2 = (int8x8_t)((v61 - 1) & v59);
        }
        char v63 = *(uint64_t ***)(*(void *)v3 + 8 * *(void *)&v2);
        if (v63)
        {
          int v64 = *v63;
          if (*v63)
          {
            char v65 = *((unsigned char *)v55 + 23);
            if (v65 >= 0) {
              char v66 = (std::string::value_type *)*((unsigned __int8 *)v55 + 23);
            }
            else {
              char v66 = v55[1];
            }
            if (v65 >= 0) {
              int v67 = (std::string::value_type *)&v168[4 * v7];
            }
            else {
              int v67 = *v55;
            }
            if (v62.u32[0] < 2uLL)
            {
              while (1)
              {
                uint64_t v73 = v64[1];
                if (v73 == v60)
                {
                  uint64_t v74 = *((unsigned __int8 *)v64 + 39);
                  if ((v74 & 0x80u) == 0) {
                    v75 = (std::string::value_type *)*((unsigned __int8 *)v64 + 39);
                  }
                  else {
                    v75 = (std::string::value_type *)v64[3];
                  }
                  if (v75 == v66)
                  {
                    v76 = (const void **)(v64 + 2);
                    if ((v74 & 0x80) != 0)
                    {
                      if (!memcmp(*v76, v67, v64[3])) {
                        goto LABEL_118;
                      }
                    }
                    else
                    {
                      if (!*((unsigned char *)v64 + 39)) {
                        goto LABEL_118;
                      }
                      v77 = v67;
                      while (*(unsigned __int8 *)v76 == *v77)
                      {
                        v76 = (const void **)((char *)v76 + 1);
                        ++v77;
                        if (!--v74) {
                          goto LABEL_118;
                        }
                      }
                    }
                  }
                }
                else if ((v73 & (v61 - 1)) != *(void *)&v2)
                {
                  goto LABEL_172;
                }
                int v64 = (uint64_t *)*v64;
                if (!v64) {
                  goto LABEL_172;
                }
              }
            }
            while (1)
            {
              unint64_t v68 = v64[1];
              if (v68 == v60)
              {
                uint64_t v69 = *((unsigned __int8 *)v64 + 39);
                if ((v69 & 0x80u) == 0) {
                  uint64_t v70 = (std::string::value_type *)*((unsigned __int8 *)v64 + 39);
                }
                else {
                  uint64_t v70 = (std::string::value_type *)v64[3];
                }
                if (v70 == v66)
                {
                  v71 = (const void **)(v64 + 2);
                  if ((v69 & 0x80) != 0)
                  {
                    if (!memcmp(*v71, v67, v64[3])) {
                      goto LABEL_118;
                    }
                  }
                  else
                  {
                    if (!*((unsigned char *)v64 + 39)) {
                      goto LABEL_118;
                    }
                    v72 = v67;
                    while (*(unsigned __int8 *)v71 == *v72)
                    {
                      v71 = (const void **)((char *)v71 + 1);
                      ++v72;
                      if (!--v69) {
                        goto LABEL_118;
                      }
                    }
                  }
                }
              }
              else
              {
                if (v68 >= v61) {
                  v68 %= v61;
                }
                if (v68 != *(void *)&v2)
                {
LABEL_172:
                  v3 = v1 + 23;
                  break;
                }
              }
              int v64 = (uint64_t *)*v64;
              if (!v64) {
                goto LABEL_172;
              }
            }
          }
        }
      }
      v78 = (char *)operator new(0x30uLL);
      *(void *)&long long __dst = v78;
      *((void *)&__dst + 1) = v1 + 25;
      LOBYTE(v160) = 0;
      *(void *)v78 = 0;
      *((void *)v78 + 1) = v60;
      v79 = (std::string *)(v78 + 16);
      if (*((char *)v55 + 23) < 0)
      {
        std::string::__init_copy_ctor_external(v79, *v55, (std::string::size_type)v55[1]);
      }
      else
      {
        *(_OWORD *)&v79->__r_.__value_.__l.__data_ = *(_OWORD *)v55;
        *((void *)v78 + 4) = v55[2];
      }
      *((_DWORD *)v78 + 10) = *(_DWORD *)&v171[32 * v7];
      LOBYTE(v160) = 1;
      float v80 = (float)(unint64_t)(*(void *)&v1[26] + 1);
      float v81 = *(float *)v1[27].i32;
      if (v61 && (float)(v81 * (float)v61) >= v80) {
        goto LABEL_204;
      }
      BOOL v82 = (v61 & (v61 - 1)) != 0;
      if (v61 < 3) {
        BOOL v82 = 1;
      }
      unint64_t v83 = v82 | (2 * v61);
      unint64_t v84 = vcvtps_u32_f32(v80 / v81);
      if (v83 <= v84) {
        size_t prime = v84;
      }
      else {
        size_t prime = v83;
      }
      if (prime == 1)
      {
        size_t prime = 2;
      }
      else if ((prime & (prime - 1)) != 0)
      {
        size_t prime = std::__next_prime(prime);
      }
      int8x8_t v86 = v1[24];
      if (prime > *(void *)&v86) {
        goto LABEL_188;
      }
      if (prime < *(void *)&v86)
      {
        unint64_t v87 = vcvtps_u32_f32((float)(unint64_t)v1[26] / *(float *)v1[27].i32);
        if (*(void *)&v86 < 3uLL || (uint8x8_t v88 = (uint8x8_t)vcnt_s8(v86), v88.i16[0] = vaddlv_u8(v88), v88.u32[0] > 1uLL))
        {
          unint64_t v87 = std::__next_prime(v87);
        }
        else
        {
          uint64_t v89 = 1 << -(char)__clz(v87 - 1);
          if (v87 >= 2) {
            unint64_t v87 = v89;
          }
        }
        if (prime <= v87) {
          size_t prime = v87;
        }
        if (prime < *(void *)&v86) {
LABEL_188:
        }
          std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>((uint64_t)v3, prime);
      }
      unint64_t v61 = (unint64_t)v1[24];
      unint64_t v90 = v61 - 1;
      if ((v61 & (v61 - 1)) == 0)
      {
        int8x8_t v2 = (int8x8_t)(v90 & v60);
        v91 = *(int8x8_t **)(*(void *)v3 + 8 * (v90 & v60));
        v92 = (int8x8_t *)__dst;
        if (v91) {
          goto LABEL_116;
        }
        goto LABEL_205;
      }
      if (v60 < v61) {
        break;
      }
      int8x8_t v2 = (int8x8_t)(v60 % v61);
      v91 = *(int8x8_t **)(*(void *)v3 + 8 * (v60 % v61));
      v92 = (int8x8_t *)__dst;
      if (v91)
      {
LABEL_116:
        int8x8_t *v92 = *v91;
        int8x8_t *v91 = (int8x8_t)__dst;
        goto LABEL_117;
      }
LABEL_205:
      int8x8_t *v92 = *v150;
      int8x8_t *v150 = (int8x8_t)__dst;
      *(void *)(*(void *)v3 + 8 * *(void *)&v2) = v150;
      if (*(void *)__dst)
      {
        unint64_t v93 = *(void *)(*(void *)__dst + 8);
        if ((v61 & (v61 - 1)) != 0)
        {
          if (v93 >= v61) {
            v93 %= v61;
          }
        }
        else
        {
          v93 &= v61 - 1;
        }
        *(void *)(*(void *)v3 + 8 * v93) = __dst;
      }
LABEL_117:
      ++*(void *)&v1[26];
LABEL_118:
      ++v7;
      v3 = v1 + 23;
      if (v7 == 356) {
        goto LABEL_100;
      }
    }
    int8x8_t v2 = (int8x8_t)v60;
LABEL_204:
    v91 = *(int8x8_t **)(*(void *)v3 + 8 * *(void *)&v2);
    v92 = (int8x8_t *)__dst;
    if (v91) {
      goto LABEL_116;
    }
    goto LABEL_205;
  }
  uint64_t v5 = 0;
  do
    *(void *)(*(void *)v3 + 8 * v5++) = 0;
  while (*(void *)&v4 != v5);
  uint64_t v6 = (void **)v1[25];
  v1[25] = 0;
  v1[26] = 0;
  v149 = v1 + 25;
  uint64_t v7 = 0;
  if (!v6) {
    goto LABEL_115;
  }
  do
  {
    uint64_t v8 = (unsigned __int8 *)(v6 + 2);
    std::string::operator=((std::string *)(v6 + 2), (const std::string *)&v168[4 * v7]);
    *((_DWORD *)v6 + 10) = *(_DWORD *)&v171[32 * v7];
    __int16 v9 = (void **)*v6;
    int v10 = *((char *)v6 + 39);
    if (v10 >= 0) {
      uint64_t v11 = (uint64_t *)(v6 + 2);
    }
    else {
      uint64_t v11 = (uint64_t *)v6[2];
    }
    if (v10 >= 0) {
      unint64_t v12 = *((unsigned __int8 *)v6 + 39);
    }
    else {
      unint64_t v12 = (unint64_t)v6[3];
    }
    unint64_t v13 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)&__dst, v11, v12);
    unint64_t v14 = v13;
    v6[1] = (void *)v13;
    int8x8_t v2 = v1[24];
    if (v2)
    {
      uint8x8_t v15 = (uint8x8_t)vcnt_s8(v2);
      v15.i16[0] = vaddlv_u8(v15);
      if (v15.u32[0] > 1uLL)
      {
        unint64_t v16 = v13;
        if (*(void *)&v2 <= v13) {
          unint64_t v16 = v13 % *(void *)&v2;
        }
      }
      else
      {
        unint64_t v16 = (*(void *)&v2 - 1) & v13;
      }
      uint64_t v17 = *(uint64_t ***)(*(void *)v152 + 8 * v16);
      if (v17)
      {
        uint64_t v18 = *v17;
        if (*v17)
        {
          char v19 = *((unsigned char *)v6 + 39);
          if (v19 >= 0) {
            uint64_t v20 = (void *)*((unsigned __int8 *)v6 + 39);
          }
          else {
            uint64_t v20 = v6[3];
          }
          if (v19 < 0) {
            uint64_t v8 = (unsigned __int8 *)v6[2];
          }
          if (v15.u32[0] < 2uLL)
          {
            while (1)
            {
              uint64_t v27 = v18[1];
              if (v27 == v14)
              {
                uint64_t v28 = *((unsigned __int8 *)v18 + 39);
                if ((v28 & 0x80u) == 0) {
                  uint64_t v29 = (void *)*((unsigned __int8 *)v18 + 39);
                }
                else {
                  uint64_t v29 = (void *)v18[3];
                }
                if (v29 == v20)
                {
                  if ((v28 & 0x80) != 0)
                  {
                    v148 = v20;
                    int v31 = memcmp((const void *)v18[2], v8, v18[3]);
                    uint64_t v20 = v148;
                    if (!v31) {
                      goto LABEL_96;
                    }
                  }
                  else
                  {
                    if (!*((unsigned char *)v18 + 39)) {
                      goto LABEL_96;
                    }
                    uint64_t v30 = 0;
                    while (*((unsigned __int8 *)v18 + v30 + 16) == v8[v30])
                    {
                      if (v28 == ++v30) {
                        goto LABEL_76;
                      }
                    }
                  }
                }
              }
              else if ((v27 & (*(void *)&v2 - 1)) != v16)
              {
                goto LABEL_57;
              }
              uint64_t v18 = (uint64_t *)*v18;
              if (!v18) {
                goto LABEL_57;
              }
            }
          }
          do
          {
            unint64_t v21 = v18[1];
            if (v21 == v14)
            {
              uint64_t v22 = *((unsigned __int8 *)v18 + 39);
              if ((v22 & 0x80u) == 0) {
                uint64_t v23 = (void *)*((unsigned __int8 *)v18 + 39);
              }
              else {
                uint64_t v23 = (void *)v18[3];
              }
              if (v23 == v20)
              {
                if ((v22 & 0x80) != 0)
                {
                  char v25 = v20;
                  int v26 = memcmp((const void *)v18[2], v8, v18[3]);
                  uint64_t v20 = v25;
                  if (!v26) {
                    goto LABEL_96;
                  }
                }
                else
                {
                  if (!*((unsigned char *)v18 + 39)) {
                    goto LABEL_96;
                  }
                  uint64_t v24 = 0;
                  while (*((unsigned __int8 *)v18 + v24 + 16) == v8[v24])
                  {
                    if (v22 == ++v24)
                    {
LABEL_76:
                      if (v18) {
                        goto LABEL_96;
                      }
                      goto LABEL_82;
                    }
                  }
                }
              }
            }
            else
            {
              if (v21 >= *(void *)&v2) {
                v21 %= *(void *)&v2;
              }
              if (v21 != v16) {
                break;
              }
            }
            uint64_t v18 = (uint64_t *)*v18;
          }
          while (v18);
        }
      }
    }
LABEL_57:
    float v32 = (float)(unint64_t)(*(void *)&v1[26] + 1);
    float v33 = *(float *)v1[27].i32;
    if (!*(void *)&v2 || (float)(v33 * (float)(unint64_t)v2) < v32)
    {
      BOOL v34 = (*(void *)&v2 & (*(void *)&v2 - 1)) != 0;
      if (*(void *)&v2 < 3uLL) {
        BOOL v34 = 1;
      }
      unint64_t v35 = v34 | (2 * *(void *)&v2);
      unint64_t v36 = vcvtps_u32_f32(v32 / v33);
      if (v35 <= v36) {
        size_t v37 = v36;
      }
      else {
        size_t v37 = v35;
      }
      if (v37 == 1)
      {
        size_t v37 = 2;
      }
      else if ((v37 & (v37 - 1)) != 0)
      {
        size_t v37 = std::__next_prime(v37);
        int8x8_t v2 = v1[24];
      }
      if (v37 > *(void *)&v2) {
        goto LABEL_69;
      }
      if (v37 < *(void *)&v2)
      {
        unint64_t v38 = vcvtps_u32_f32((float)(unint64_t)v1[26] / *(float *)v1[27].i32);
        if (*(void *)&v2 < 3uLL || (uint8x8_t v39 = (uint8x8_t)vcnt_s8(v2), v39.i16[0] = vaddlv_u8(v39), v39.u32[0] > 1uLL))
        {
          unint64_t v38 = std::__next_prime(v38);
        }
        else
        {
          uint64_t v40 = 1 << -(char)__clz(v38 - 1);
          if (v38 >= 2) {
            unint64_t v38 = v40;
          }
        }
        if (v37 <= v38) {
          size_t v37 = v38;
        }
        if (v37 < *(void *)&v2) {
LABEL_69:
        }
          std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::__do_rehash<true>((uint64_t)v152, v37);
      }
    }
LABEL_82:
    int8x8_t v41 = v1[24];
    unint64_t v42 = (unint64_t)v6[1];
    uint8x8_t v43 = (uint8x8_t)vcnt_s8(v41);
    v43.i16[0] = vaddlv_u8(v43);
    if (v43.u32[0] > 1uLL)
    {
      __int16 v44 = v1 + 23;
      if (v42 >= *(void *)&v41) {
        v42 %= *(void *)&v41;
      }
    }
    else
    {
      v42 &= *(void *)&v41 - 1;
      __int16 v44 = v1 + 23;
    }
    uint64_t v45 = *(void ***)(*(void *)v44 + 8 * v42);
    if (v45)
    {
      *uint64_t v6 = *v45;
LABEL_94:
      *uint64_t v45 = v6;
      goto LABEL_95;
    }
    *uint64_t v6 = (void *)*v149;
    int8x8_t *v149 = (int8x8_t)v6;
    *(void *)(*(void *)v44 + 8 * v42) = v149;
    if (*v6)
    {
      unint64_t v46 = *((void *)*v6 + 1);
      if (v43.u32[0] > 1uLL)
      {
        if (v46 >= *(void *)&v41) {
          v46 %= *(void *)&v41;
        }
      }
      else
      {
        v46 &= *(void *)&v41 - 1;
      }
      uint64_t v45 = (void **)(*(void *)v44 + 8 * v46);
      goto LABEL_94;
    }
LABEL_95:
    ++*(void *)&v1[26];
LABEL_96:
    ++v7;
    if (!v9) {
      break;
    }
    uint64_t v6 = v9;
  }
  while (v7 != 356);
  v3 = v1 + 23;
  if (v9)
  {
    do
    {
      uint64_t v48 = (void **)*v9;
      if (*((char *)v9 + 39) < 0) {
        operator delete(v9[2]);
      }
      operator delete(v9);
      __int16 v9 = v48;
    }
    while (v48);
  }
  if (v7 != 356) {
    goto LABEL_115;
  }
LABEL_100:
  for (uint64_t i = 0; i != -11392; i -= 32)
  {
    if (*(&v973 + i) < 0) {
      operator delete(*(void **)&v972[i]);
    }
  }
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(*(void *)&v1[7] + 24));
  mlir::PassManager::PassManager(v168, Context, "any", 3uLL, 1);
  id WeakRetained = objc_loadWeakRetained((id *)&v1[8]);
  BOOL v51 = ([WeakRetained options] & 2) == 0;

  if (v51) {
    goto LABEL_216;
  }
  mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)&__dst);
  int v52 = (llvm *)mlir::OpPrintingFlags::elideLargeElementsAttrs((uint64_t)&__dst, 256);
  v166[0] = &unk_1EC988F08;
  v167 = v166;
  v164[0] = &unk_1EC988F60;
  v165 = v164;
  uint64_t v53 = llvm::dbgs(v52);
  v157[0] = __dst;
  v157[1] = v160;
  uint64_t v158 = v161;
  mlir::PassManager::enableIRPrinting((uint64_t)v168, v166, v164, 0, 0, 0, v53, (uint64_t)v157);
  if (v165 == v164)
  {
    (*(void (**)(void *))(v164[0] + 32))(v164);
    char v54 = v167;
    if (v167 != v166) {
      goto LABEL_112;
    }
    goto LABEL_214;
  }
  if (v165) {
    (*(void (**)(void))(*v165 + 40))();
  }
  char v54 = v167;
  if (v167 == v166)
  {
LABEL_214:
    (*(void (**)(void *))(v166[0] + 32))(v166);
    goto LABEL_215;
  }
LABEL_112:
  if (v54) {
    (*(void (**)(void *))(*v54 + 40))(v54);
  }
LABEL_215:
  mlir::PassManager::enableTiming((mlir::PassManager *)v168);
LABEL_216:
  v94 = (id *)objc_loadWeakRetained((id *)&v1[8]);
  BOOL v95 = ([v94[12] compilerOptions] & 0x200) == 0;

  if (!v95)
  {
    mlir::mps::createConvertF32ToF16Pass(&v156);
    mlir::OpPassManager::addPass(v168, &v156);
    uint64_t v96 = v156;
    uint64_t v156 = 0;
    if (v96) {
      (*(void (**)(uint64_t))(*(void *)v96 + 8))(v96);
    }
  }
  v97 = (unsigned char **)mlir::OpPassManager::nest((uint64_t *)v168, "func.func", 9uLL);
  mlir::createCanonicalizerPass(&v155);
  mlir::OpPassManager::addPass(v97, &v155);
  uint64_t v98 = v155;
  uint64_t v155 = 0;
  if (v98) {
    (*(void (**)(uint64_t))(*(void *)v98 + 8))(v98);
  }
  if (!mlir::PassManager::run((mlir::PassManager *)v168, *(mlir::Operation **)&v1[7])
    && MTLReportFailureTypeEnabled())
  {
    MTLReportFailure();
  }
  int8x8_t v99 = v1[7];
  unint64_t v100 = *(unsigned int *)(*(void *)&v99 + 44);
  if ((v100 & 0x7FFFFF) == 0)
  {
    v144 = "index < numRegions && \"invalid region index\"";
    int v145 = 666;
    v146 = "Operation.h";
    v147 = "getRegion";
    goto LABEL_275;
  }
  unint64_t v101 = *(void *)&v99 + 16 * ((v100 >> 23) & 1) + ((v100 >> 21) & 0x7F8) + 64;
  if (v101 > 0xFFFFFFFFFFFFFFF8)
  {
    v144 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
    int v145 = 191;
    v146 = "Alignment.h";
    v147 = "alignAddr";
    goto LABEL_275;
  }
  v102 = (void *)(((v101 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(*(void *)&v99 + 40));
  if ((void *)*v102 == v102)
  {
    v144 = "!region.empty() && \"unexpected empty region\"";
    int v145 = 895;
    v146 = "OpDefinition.h";
    v147 = "getBody";
LABEL_275:
    __assert_rtn(v147, v146, v145, v144);
  }
  uint64_t v103 = v102[1];
  if (v103) {
    uint64_t v104 = v103 - 8;
  }
  else {
    uint64_t v104 = 0;
  }
  v105 = *(mlir::GenericProgramPoint **)(v104 + 40);
  v151 = (mlir::GenericProgramPoint *)(v104 + 32);
  if (v105 != (mlir::GenericProgramPoint *)(v104 + 32))
  {
    uint64_t v106 = MEMORY[0x1E4F1CBF0];
    while (1)
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(v105);
      uint64_t v108 = v107;
      uint64_t v109 = llvm::DefaultDoCastIfPossible<mlir::func::FuncOp,mlir::Operation &,llvm::CastInfo<mlir::func::FuncOp,mlir::Operation,void>>::doCastIfPossible(v107);
      v153 = v105;
      uint64_t v154 = v109;
      if (!v109) {
        break;
      }
      unint64_t v110 = *(unsigned int *)(v109 + 44);
      if ((v110 & 0x7FFFFF) == 0)
      {
        int v140 = 666;
        v141 = "index < numRegions && \"invalid region index\"";
        v142 = "Operation.h";
        v143 = "getRegion";
        goto LABEL_269;
      }
      unint64_t v111 = v109 + 16 * ((v110 >> 23) & 1) + ((v110 >> 21) & 0x7F8) + 64;
      if (v111 >= 0xFFFFFFFFFFFFFFF9)
      {
        int v140 = 191;
        v143 = "alignAddr";
        v142 = "Alignment.h";
        v141 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
LABEL_269:
        __assert_rtn(v143, v142, v140, v141);
      }
      v112 = (void *)(((v111 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(v109 + 40));
      if ((void *)*v112 != v112)
      {
        uint64_t v113 = v112[1];
        uint64_t v114 = v113 ? v113 - 8 : 0;
        v115 = *(uint64_t **)(v114 + 48);
        uint64_t v116 = *(void *)(v114 + 56) - (void)v115;
        if (v116)
        {
          uint64_t v117 = 8 * (v116 >> 3);
          do
          {
            uint64_t v118 = *v115;
            v119 = (void *)v1[22];
            v120 = [MPSGraphViewerNodeSPI alloc];
            if (v118)
            {
              uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v118 + 8) & 0xFFFFFFFFFFFFFFF8));
              v122 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v118 + 8) & 0xFFFFFFFFFFFFFFF8));
              v123 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"Value" dataType:MPSDataType shape:v122 valueRef:(*(uint64_t (**)(int8x8_t *, uint64_t))(*(void *)v1 + 32))(v1, v118)];
            }
            else
            {
              v123 = 0;
            }
            v163 = v123;
            v124 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v163 count:1];
            v125 = [(MPSGraphViewerNodeSPI *)v120 initWithType:@"mps.placeholder" inputs:v106 outputs:v124 properties:v106 regions:v106];
            [v119 addObject:v125];

            ++v115;
            v117 -= 8;
          }
          while (v117);
        }
      }
      unint64_t Body = mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v154);
      for (uint64_t j = *(void *)(Body + 8); j != Body; uint64_t j = *(void *)(j + 8))
      {
        uint64_t v128 = j - 8;
        if (!j) {
          uint64_t v128 = 0;
        }
        v129 = (mlir::GenericProgramPoint *)(v128 + 32);
        v130 = *(mlir::GenericProgramPoint **)(v128 + 40);
        if (v130 != (mlir::GenericProgramPoint *)(v128 + 32))
        {
          do
          {
            mlir::GenericProgramPoint::~GenericProgramPoint(v130);
            v132 = EmitViewerSPI::emitNode(v1, v131);
            if (v132) {
              [*(id *)&v1[22] addObject:v132];
            }

            v130 = (mlir::GenericProgramPoint *)*((void *)v130 + 1);
          }
          while (v130 != v129);
        }
      }
LABEL_230:
      v105 = (mlir::GenericProgramPoint *)*((void *)v153 + 1);
      if (v105 == v151) {
        goto LABEL_266;
      }
    }
    uint64_t v162 = *(void *)(*(void *)(v108 + 48) + 8);
    uint64_t AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v162);
    size_t v134 = strlen(AttrData);
    if (v134 > 0x7FFFFFFFFFFFFFF7) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    size_t v135 = v134;
    if (v134 >= 0x17)
    {
      uint64_t v137 = (v134 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v134 | 7) != 0x17) {
        uint64_t v137 = v134 | 7;
      }
      uint64_t v138 = v137 + 1;
      p_dst = (long long *)operator new(v137 + 1);
      *(void *)&long long __dst = p_dst;
      *(void *)&long long v160 = v138 | 0x8000000000000000;
    }
    else
    {
      BYTE7(v160) = v134;
      p_dst = &__dst;
      if (!v134) {
        goto LABEL_262;
      }
    }
    memmove(p_dst, AttrData, v135);
LABEL_262:
    *((unsigned char *)p_dst + v135) = 0;
    v139 = EmitViewerSPI::emitNode(v1, (MPSGraphViewerNodePortSPI *)v108);
    if (v139) {
      [*(id *)&v1[22] addObject:v139];
    }

    if (SBYTE7(v160) < 0) {
      operator delete((void *)__dst);
    }
    goto LABEL_230;
  }
LABEL_266:
  mlir::PassManager::~PassManager((mlir::PassManager *)v168);
}

void sub_180DD2628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  if (a16)
  {
    (*(void (**)(uint64_t))(*(void *)a16 + 8))(a16);
    mlir::PassManager::~PassManager((mlir::PassManager *)&a38);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x180DD28E8);
}

void sub_180DD2684()
{
  JUMPOUT(0x180DD28E8);
}

void sub_180DD2690(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

void sub_180DD26B4()
{
  JUMPOUT(0x180DD28E8);
}

void sub_180DD26C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  while (1)
  {
    if (*(v38 - 9) < 0) {
      operator delete(*((void **)v38 - 4));
    }
    v38 -= 32;
    if (v38 == &a38) {
      _Unwind_Resume(exception_object);
    }
  }
}

void sub_180DD27AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  if (a28 < 0)
  {
    operator delete(__p);
    mlir::PassManager::~PassManager((mlir::PassManager *)&a41);
    _Unwind_Resume(a1);
  }
  JUMPOUT(0x180DD28E8);
}

void sub_180DD27E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::string,MPSMLIROps>,void *>>>>::~unique_ptr[abi:ne180100]((uint64_t *)va);
  unint64_t v16 = (char *)(a3 + 2567);
  uint64_t v17 = -11392;
  uint64_t v18 = (char *)(a3 + 2567);
  while (1)
  {
    int v19 = *v18;
    v18 -= 32;
    if (v19 < 0) {
      operator delete(*(void **)(v16 - 23));
    }
    unint64_t v16 = v18;
    v17 += 32;
    if (!v17) {
      _Unwind_Resume(a1);
    }
  }
}

void sub_180DD2820(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  __cxa_end_catch();
  int v10 = (char *)(a10 + 2567);
  uint64_t v11 = -11392;
  unint64_t v12 = (char *)(a10 + 2567);
  while (1)
  {
    int v13 = *v12;
    v12 -= 32;
    if (v13 < 0) {
      operator delete(*(void **)(v10 - 23));
    }
    int v10 = v12;
    v11 += 32;
    if (!v11) {
      JUMPOUT(0x180DD28DCLL);
    }
  }
}

void sub_180DD2874(_Unwind_Exception *a1, int a2)
{
  if (a2) {
    __clang_call_terminate(a1);
  }
  _Unwind_Resume(a1);
}

void sub_180DD288C()
{
  JUMPOUT(0x180DD28E8);
}

void sub_180DD28B4()
{
  JUMPOUT(0x180DD28E8);
}

void sub_180DD28C4()
{
  JUMPOUT(0x180DD28E8);
}

void sub_180DD28E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
}

void *std::function<BOOL ()(mlir::Pass *,mlir::Operation *)>::~function(void *a1)
{
  int8x8_t v2 = (void *)a1[3];
  if (v2 == a1)
  {
    (*(void (**)(void *))(*a1 + 32))(a1);
    return a1;
  }
  else
  {
    if (v2) {
      (*(void (**)(void *))(*v2 + 40))(v2);
    }
    return a1;
  }
}

MPSGraphViewerNodePortSPI *EmitViewerSPI::emitNodeOutputPort(uint64_t a1, void *a2, MPSGraphViewerNodePortSPI *a3)
{
  id v5 = a2;
  if (a3)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&a3->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v7 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&a3->_dataType & 0xFFFFFFFFFFFFFFF8));
    a3 = [[MPSGraphViewerNodePortSPI alloc] initWithName:v5 dataType:MPSDataType shape:v7 valueRef:(*(uint64_t (**)(uint64_t, MPSGraphViewerNodePortSPI *))(*(void *)a1 + 32))(a1, a3)];
  }

  return a3;
}

void sub_180DD2A60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180DD2A70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180DD2A80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

MPSGraphViewerNodeSPI *EmitViewerSPI::emitNode(int8x8_t *this, MPSGraphViewerNodePortSPI *a2)
{
  __p[0] = *(void **)(*(void *)&a2[1]._dataType + 8);
  uint64_t AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__p);
  size_t v5 = strlen(AttrData);
  if (v5 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v6 = v5;
  if (v5 >= 0x17)
  {
    uint64_t v8 = (v5 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v5 | 7) != 0x17) {
      uint64_t v8 = v5 | 7;
    }
    uint64_t v9 = v8 + 1;
    p_dst = (void **)operator new(v8 + 1);
    size_t v75 = v6;
    int64_t v76 = v9 | 0x8000000000000000;
    long long __dst = (uint64_t *)p_dst;
    goto LABEL_8;
  }
  HIBYTE(v76) = v5;
  p_dst = (void **)&__dst;
  if (v5) {
LABEL_8:
  }
    memmove(p_dst, AttrData, v6);
  *((unsigned char *)p_dst + v6) = 0;
  if (v76 >= 0) {
    int v10 = (uint64_t *)&__dst;
  }
  else {
    int v10 = __dst;
  }
  if (v76 >= 0) {
    unint64_t v11 = HIBYTE(v76);
  }
  else {
    unint64_t v11 = v75;
  }
  unint64_t v12 = std::__murmur2_or_cityhash<unsigned long,64ul>::operator()[abi:ne180100]((uint64_t)__p, v10, v11);
  int8x8_t v13 = this[24];
  if (!*(void *)&v13) {
    goto LABEL_426;
  }
  unint64_t v14 = v12;
  uint8x8_t v15 = (uint8x8_t)vcnt_s8(v13);
  v15.i16[0] = vaddlv_u8(v15);
  if (v15.u32[0] > 1uLL)
  {
    unint64_t v16 = v12;
    if (v12 >= *(void *)&v13) {
      unint64_t v16 = v12 % *(void *)&v13;
    }
  }
  else
  {
    unint64_t v16 = (*(void *)&v13 - 1) & v12;
  }
  uint64_t v17 = *(uint64_t ***)(*(void *)&this[23] + 8 * v16);
  if (!v17) {
    goto LABEL_426;
  }
  uint64_t v18 = *v17;
  if (!*v17) {
    goto LABEL_426;
  }
  if (v76 >= 0) {
    size_t v19 = HIBYTE(v76);
  }
  else {
    size_t v19 = v75;
  }
  if (v76 >= 0) {
    uint64_t v20 = (void **)&__dst;
  }
  else {
    uint64_t v20 = (void **)__dst;
  }
  if (v15.u32[0] < 2uLL)
  {
    uint64_t v21 = *(void *)&v13 - 1;
    while (1)
    {
      uint64_t v26 = v18[1];
      if (v26 == v14)
      {
        uint64_t v27 = *((unsigned __int8 *)v18 + 39);
        if ((v27 & 0x80u) == 0) {
          uint64_t v28 = *((unsigned __int8 *)v18 + 39);
        }
        else {
          uint64_t v28 = v18[3];
        }
        if (v28 == v19)
        {
          if ((v27 & 0x80) != 0)
          {
            if (!memcmp((const void *)v18[2], v20, v18[3])) {
              goto LABEL_63;
            }
          }
          else
          {
            if (!*((unsigned char *)v18 + 39)) {
              goto LABEL_63;
            }
            uint64_t v29 = 0;
            while (*((unsigned __int8 *)v18 + v29 + 16) == *((unsigned __int8 *)v20 + v29))
            {
              if (v27 == ++v29) {
                goto LABEL_62;
              }
            }
          }
        }
      }
      else if ((v26 & v21) != v16)
      {
        goto LABEL_426;
      }
      uint64_t v18 = (uint64_t *)*v18;
      if (!v18) {
        goto LABEL_426;
      }
    }
  }
  while (1)
  {
    unint64_t v22 = v18[1];
    if (v22 == v14) {
      break;
    }
    if (v22 >= *(void *)&v13) {
      v22 %= *(void *)&v13;
    }
    if (v22 != v16) {
      goto LABEL_426;
    }
LABEL_31:
    uint64_t v18 = (uint64_t *)*v18;
    if (!v18) {
      goto LABEL_426;
    }
  }
  uint64_t v23 = *((unsigned __int8 *)v18 + 39);
  if ((v23 & 0x80u) == 0) {
    uint64_t v24 = *((unsigned __int8 *)v18 + 39);
  }
  else {
    uint64_t v24 = v18[3];
  }
  if (v24 != v19) {
    goto LABEL_31;
  }
  if ((v23 & 0x80) != 0)
  {
    if (!memcmp((const void *)v18[2], v20, v18[3])) {
      goto LABEL_63;
    }
    goto LABEL_31;
  }
  if (*((unsigned char *)v18 + 39))
  {
    uint64_t v25 = 0;
    do
    {
      if (*((unsigned __int8 *)v18 + v25 + 16) != *((unsigned __int8 *)v20 + v25)) {
        goto LABEL_31;
      }
      ++v25;
    }
    while (v23 != v25);
LABEL_62:
    if (!v18) {
LABEL_426:
    }
      std::__throw_out_of_range[abi:ne180100]("unordered_map::at: key not found");
  }
LABEL_63:
  switch(*((_DWORD *)v18 + 10))
  {
    case 1:
      EmitterViewerSPI::ANECA11LegacyOpHandler::ANECA11LegacyOpHandler((EmitterViewerSPI::ANECA11LegacyOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 2:
      EmitterViewerSPI::ANECA12OpHandler::ANECA12OpHandler((EmitterViewerSPI::ANECA12OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 3:
      EmitterViewerSPI::ANECA13OpHandler::ANECA13OpHandler((EmitterViewerSPI::ANECA13OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 4:
      EmitterViewerSPI::ANECA14OpHandler::ANECA14OpHandler((EmitterViewerSPI::ANECA14OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 5:
      EmitterViewerSPI::ANECA15OpHandler::ANECA15OpHandler((EmitterViewerSPI::ANECA15OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 6:
      EmitterViewerSPI::ANECA16OpHandler::ANECA16OpHandler((EmitterViewerSPI::ANECA16OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 7:
      EmitterViewerSPI::ANECA17OpHandler::ANECA17OpHandler((EmitterViewerSPI::ANECA17OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 8:
      EmitterViewerSPI::ANECArgMinMaxOpHandler::ANECArgMinMaxOpHandler((EmitterViewerSPI::ANECArgMinMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 9:
      EmitterViewerSPI::ANECAveragePoolOpHandler::ANECAveragePoolOpHandler((EmitterViewerSPI::ANECAveragePoolOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA:
      EmitterViewerSPI::ANECBatchToSpaceOpHandler::ANECBatchToSpaceOpHandler((EmitterViewerSPI::ANECBatchToSpaceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB:
      EmitterViewerSPI::ANECBroadcastOpHandler::ANECBroadcastOpHandler((EmitterViewerSPI::ANECBroadcastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC:
      EmitterViewerSPI::ANECCastOpHandler::ANECCastOpHandler((EmitterViewerSPI::ANECCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD:
      EmitterViewerSPI::ANECCeilOpHandler::ANECCeilOpHandler((EmitterViewerSPI::ANECCeilOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE:
      EmitterViewerSPI::ANECChannelToSpaceOpHandler::ANECChannelToSpaceOpHandler((EmitterViewerSPI::ANECChannelToSpaceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF:
      EmitterViewerSPI::ANECClampedReluOpHandler::ANECClampedReluOpHandler((EmitterViewerSPI::ANECClampedReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x10:
      EmitterViewerSPI::ANECConcatOpHandler::ANECConcatOpHandler((EmitterViewerSPI::ANECConcatOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x11:
      EmitterViewerSPI::ANECConvolutionOpHandler::ANECConvolutionOpHandler((EmitterViewerSPI::ANECConvolutionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x12:
      EmitterViewerSPI::ANECCosOpHandler::ANECCosOpHandler((EmitterViewerSPI::ANECCosOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x13:
      EmitterViewerSPI::ANECCropResizeOpHandler::ANECCropResizeOpHandler((EmitterViewerSPI::ANECCropResizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x14:
      EmitterViewerSPI::ANECDeQuantOpHandler::ANECDeQuantOpHandler((EmitterViewerSPI::ANECDeQuantOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x15:
      EmitterViewerSPI::ANECDeconvolutionOpHandler::ANECDeconvolutionOpHandler((EmitterViewerSPI::ANECDeconvolutionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x16:
      EmitterViewerSPI::ANECDegammaOpHandler::ANECDegammaOpHandler((EmitterViewerSPI::ANECDegammaOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x17:
      EmitterViewerSPI::ANECDiracOpHandler::ANECDiracOpHandler((EmitterViewerSPI::ANECDiracOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x18:
      EmitterViewerSPI::ANECElementwiseAbsOpHandler::ANECElementwiseAbsOpHandler((EmitterViewerSPI::ANECElementwiseAbsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x19:
      EmitterViewerSPI::ANECElementwiseAddOpHandler::ANECElementwiseAddOpHandler((EmitterViewerSPI::ANECElementwiseAddOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x1A:
      EmitterViewerSPI::ANECElementwiseDivOpHandler::ANECElementwiseDivOpHandler((EmitterViewerSPI::ANECElementwiseDivOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x1B:
      EmitterViewerSPI::ANECElementwiseEqualOpHandler::ANECElementwiseEqualOpHandler((EmitterViewerSPI::ANECElementwiseEqualOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x1C:
      EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler::ANECElementwiseEqualZeroOpHandler((EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x1D:
      EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler::ANECElementwiseGreaterThanOpHandler((EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x1E:
      EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler::ANECElementwiseGreaterThanEqualOpHandler((EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x1F:
      EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler::ANECElementwiseGreaterThanEqualZeroOpHandler((EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x20:
      EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler::ANECElementwiseGreaterThanZeroOpHandler((EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x21:
      EmitterViewerSPI::ANECElementwiseLessThanOpHandler::ANECElementwiseLessThanOpHandler((EmitterViewerSPI::ANECElementwiseLessThanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x22:
      EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler::ANECElementwiseLessThanEqualOpHandler((EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x23:
      EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler::ANECElementwiseLessThanEqualZeroOpHandler((EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x24:
      EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler::ANECElementwiseLessThanZeroOpHandler((EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x25:
      EmitterViewerSPI::ANECElementwiseMaxOpHandler::ANECElementwiseMaxOpHandler((EmitterViewerSPI::ANECElementwiseMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x26:
      EmitterViewerSPI::ANECElementwiseMinOpHandler::ANECElementwiseMinOpHandler((EmitterViewerSPI::ANECElementwiseMinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x27:
      EmitterViewerSPI::ANECElementwiseMultOpHandler::ANECElementwiseMultOpHandler((EmitterViewerSPI::ANECElementwiseMultOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x28:
      EmitterViewerSPI::ANECElementwiseNotEqualOpHandler::ANECElementwiseNotEqualOpHandler((EmitterViewerSPI::ANECElementwiseNotEqualOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x29:
      EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler::ANECElementwiseNotEqualZeroOpHandler((EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x2A:
      EmitterViewerSPI::ANECElementwisePowerOpHandler::ANECElementwisePowerOpHandler((EmitterViewerSPI::ANECElementwisePowerOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x2B:
      EmitterViewerSPI::ANECElementwiseSquareOpHandler::ANECElementwiseSquareOpHandler((EmitterViewerSPI::ANECElementwiseSquareOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x2C:
      EmitterViewerSPI::ANECElementwiseSubOpHandler::ANECElementwiseSubOpHandler((EmitterViewerSPI::ANECElementwiseSubOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x2D:
      EmitterViewerSPI::ANECEluOpHandler::ANECEluOpHandler((EmitterViewerSPI::ANECEluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x2E:
      EmitterViewerSPI::ANECErfOpHandler::ANECErfOpHandler((EmitterViewerSPI::ANECErfOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x2F:
      EmitterViewerSPI::ANECExp2OpHandler::ANECExp2OpHandler((EmitterViewerSPI::ANECExp2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x30:
      EmitterViewerSPI::ANECFlattenOpHandler::ANECFlattenOpHandler((EmitterViewerSPI::ANECFlattenOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x31:
      EmitterViewerSPI::ANECFloorOpHandler::ANECFloorOpHandler((EmitterViewerSPI::ANECFloorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x32:
      EmitterViewerSPI::ANECGOCOpHandler::ANECGOCOpHandler((EmitterViewerSPI::ANECGOCOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x33:
      EmitterViewerSPI::ANECGatherNDOpHandler::ANECGatherNDOpHandler((EmitterViewerSPI::ANECGatherNDOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x34:
      EmitterViewerSPI::ANECGeluOpHandler::ANECGeluOpHandler((EmitterViewerSPI::ANECGeluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x35:
      EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler::ANECGlobalArgMinMaxOpHandler((EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x36:
      EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler::ANECHighPrecisionSigmoidOpHandler((EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x37:
      EmitterViewerSPI::ANECInputViewOpHandler::ANECInputViewOpHandler((EmitterViewerSPI::ANECInputViewOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x38:
      EmitterViewerSPI::ANECInstanceNormOpHandler::ANECInstanceNormOpHandler((EmitterViewerSPI::ANECInstanceNormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x39:
      EmitterViewerSPI::ANECInvertOpHandler::ANECInvertOpHandler((EmitterViewerSPI::ANECInvertOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x3A:
      EmitterViewerSPI::ANECL2NormPoolOpHandler::ANECL2NormPoolOpHandler((EmitterViewerSPI::ANECL2NormPoolOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x3B:
      EmitterViewerSPI::ANECLeakyReluOpHandler::ANECLeakyReluOpHandler((EmitterViewerSPI::ANECLeakyReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x3C:
      EmitterViewerSPI::ANECLinearOpHandler::ANECLinearOpHandler((EmitterViewerSPI::ANECLinearOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x3D:
      EmitterViewerSPI::ANECLog2OpHandler::ANECLog2OpHandler((EmitterViewerSPI::ANECLog2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x3E:
      EmitterViewerSPI::ANECMatMulOpHandler::ANECMatMulOpHandler((EmitterViewerSPI::ANECMatMulOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x3F:
      EmitterViewerSPI::ANECMaxPoolOpHandler::ANECMaxPoolOpHandler((EmitterViewerSPI::ANECMaxPoolOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x40:
      EmitterViewerSPI::ANECNReluOpHandler::ANECNReluOpHandler((EmitterViewerSPI::ANECNReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x41:
      EmitterViewerSPI::ANECPaddingOpHandler::ANECPaddingOpHandler((EmitterViewerSPI::ANECPaddingOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x42:
      EmitterViewerSPI::ANECPixelShuffleOpHandler::ANECPixelShuffleOpHandler((EmitterViewerSPI::ANECPixelShuffleOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x43:
      EmitterViewerSPI::ANECPixelUnshuffleOpHandler::ANECPixelUnshuffleOpHandler((EmitterViewerSPI::ANECPixelUnshuffleOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x44:
      EmitterViewerSPI::ANECQuantOpHandler::ANECQuantOpHandler((EmitterViewerSPI::ANECQuantOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x45:
      EmitterViewerSPI::ANECReduceAvgOpHandler::ANECReduceAvgOpHandler((EmitterViewerSPI::ANECReduceAvgOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x46:
      EmitterViewerSPI::ANECReduceMaxOpHandler::ANECReduceMaxOpHandler((EmitterViewerSPI::ANECReduceMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x47:
      EmitterViewerSPI::ANECReduceMinOpHandler::ANECReduceMinOpHandler((EmitterViewerSPI::ANECReduceMinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x48:
      EmitterViewerSPI::ANECReduceSumOpHandler::ANECReduceSumOpHandler((EmitterViewerSPI::ANECReduceSumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x49:
      EmitterViewerSPI::ANECRegionReturnOpHandler::ANECRegionReturnOpHandler((EmitterViewerSPI::ANECRegionReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x4A:
      EmitterViewerSPI::ANECReluOpHandler::ANECReluOpHandler((EmitterViewerSPI::ANECReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x4B:
      EmitterViewerSPI::ANECReshapeOpHandler::ANECReshapeOpHandler((EmitterViewerSPI::ANECReshapeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x4C:
      EmitterViewerSPI::ANECResizeOpHandler::ANECResizeOpHandler((EmitterViewerSPI::ANECResizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x4D:
      EmitterViewerSPI::ANECRoundNearestOpHandler::ANECRoundNearestOpHandler((EmitterViewerSPI::ANECRoundNearestOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x4E:
      EmitterViewerSPI::ANECRsqrtOpHandler::ANECRsqrtOpHandler((EmitterViewerSPI::ANECRsqrtOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x4F:
      EmitterViewerSPI::ANECSigmoidOpHandler::ANECSigmoidOpHandler((EmitterViewerSPI::ANECSigmoidOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x50:
      EmitterViewerSPI::ANECSignOpHandler::ANECSignOpHandler((EmitterViewerSPI::ANECSignOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x51:
      EmitterViewerSPI::ANECSinOpHandler::ANECSinOpHandler((EmitterViewerSPI::ANECSinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x52:
      EmitterViewerSPI::ANECSoftmaxOpHandler::ANECSoftmaxOpHandler((EmitterViewerSPI::ANECSoftmaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x53:
      EmitterViewerSPI::ANECSpaceToBatchOpHandler::ANECSpaceToBatchOpHandler((EmitterViewerSPI::ANECSpaceToBatchOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x54:
      EmitterViewerSPI::ANECSpaceToChannelOpHandler::ANECSpaceToChannelOpHandler((EmitterViewerSPI::ANECSpaceToChannelOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x55:
      EmitterViewerSPI::ANECSqrOpHandler::ANECSqrOpHandler((EmitterViewerSPI::ANECSqrOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x56:
      EmitterViewerSPI::ANECSqrtOpHandler::ANECSqrtOpHandler((EmitterViewerSPI::ANECSqrtOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x57:
      EmitterViewerSPI::ANECSwishOpHandler::ANECSwishOpHandler((EmitterViewerSPI::ANECSwishOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x58:
      EmitterViewerSPI::ANECT0OpHandler::ANECT0OpHandler((EmitterViewerSPI::ANECT0OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x59:
      EmitterViewerSPI::ANECTanhOpHandler::ANECTanhOpHandler((EmitterViewerSPI::ANECTanhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x5A:
      EmitterViewerSPI::ANECTileOpHandler::ANECTileOpHandler((EmitterViewerSPI::ANECTileOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x5B:
      EmitterViewerSPI::ANECTransposeOpHandler::ANECTransposeOpHandler((EmitterViewerSPI::ANECTransposeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x5C:
      EmitterViewerSPI::ANECTruncOpHandler::ANECTruncOpHandler((EmitterViewerSPI::ANECTruncOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x5D:
      EmitterViewerSPI::ANECUnflattenOpHandler::ANECUnflattenOpHandler((EmitterViewerSPI::ANECUnflattenOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x5E:
      EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler::ANECUnrealizedConversionCastOpHandler((EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x5F:
      EmitterViewerSPI::MPSACosOpHandler::MPSACosOpHandler((EmitterViewerSPI::MPSACosOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x60:
      EmitterViewerSPI::MPSACoshOpHandler::MPSACoshOpHandler((EmitterViewerSPI::MPSACoshOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x61:
      EmitterViewerSPI::MPSASinOpHandler::MPSASinOpHandler((EmitterViewerSPI::MPSASinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x62:
      EmitterViewerSPI::MPSASinhOpHandler::MPSASinhOpHandler((EmitterViewerSPI::MPSASinhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x63:
      EmitterViewerSPI::MPSATan2OpHandler::MPSATan2OpHandler((EmitterViewerSPI::MPSATan2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x64:
      EmitterViewerSPI::MPSATanOpHandler::MPSATanOpHandler((EmitterViewerSPI::MPSATanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x65:
      EmitterViewerSPI::MPSATanhOpHandler::MPSATanhOpHandler((EmitterViewerSPI::MPSATanhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x66:
      EmitterViewerSPI::MPSAbsoluteOpHandler::MPSAbsoluteOpHandler((EmitterViewerSPI::MPSAbsoluteOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x67:
      EmitterViewerSPI::MPSAbsoluteSquareOpHandler::MPSAbsoluteSquareOpHandler((EmitterViewerSPI::MPSAbsoluteSquareOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x68:
      EmitterViewerSPI::MPSAddOpHandler::MPSAddOpHandler((EmitterViewerSPI::MPSAddOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x69:
      EmitterViewerSPI::MPSAndOpHandler::MPSAndOpHandler((EmitterViewerSPI::MPSAndOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x6A:
      EmitterViewerSPI::MPSAssignVariableOpHandler::MPSAssignVariableOpHandler((EmitterViewerSPI::MPSAssignVariableOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x6B:
      EmitterViewerSPI::MPSBandPartOpHandler::MPSBandPartOpHandler((EmitterViewerSPI::MPSBandPartOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x6C:
      EmitterViewerSPI::MPSBatchToSpaceOpHandler::MPSBatchToSpaceOpHandler((EmitterViewerSPI::MPSBatchToSpaceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x6D:
      EmitterViewerSPI::MPSBiasAddGradOpHandler::MPSBiasAddGradOpHandler((EmitterViewerSPI::MPSBiasAddGradOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x6E:
      EmitterViewerSPI::MPSBiasAddOpHandler::MPSBiasAddOpHandler((EmitterViewerSPI::MPSBiasAddOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x6F:
      EmitterViewerSPI::MPSBitwiseAndOpHandler::MPSBitwiseAndOpHandler((EmitterViewerSPI::MPSBitwiseAndOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x70:
      EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler::MPSBitwiseLeftShiftOpHandler((EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x71:
      EmitterViewerSPI::MPSBitwiseNotOpHandler::MPSBitwiseNotOpHandler((EmitterViewerSPI::MPSBitwiseNotOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x72:
      EmitterViewerSPI::MPSBitwiseOrOpHandler::MPSBitwiseOrOpHandler((EmitterViewerSPI::MPSBitwiseOrOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x73:
      EmitterViewerSPI::MPSBitwisePopcountOpHandler::MPSBitwisePopcountOpHandler((EmitterViewerSPI::MPSBitwisePopcountOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x74:
      EmitterViewerSPI::MPSBitwiseRightShiftOpHandler::MPSBitwiseRightShiftOpHandler((EmitterViewerSPI::MPSBitwiseRightShiftOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x75:
      EmitterViewerSPI::MPSBitwiseXorOpHandler::MPSBitwiseXorOpHandler((EmitterViewerSPI::MPSBitwiseXorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x76:
      EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler::MPSBroadcastGradientArgsOpHandler((EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x77:
      EmitterViewerSPI::MPSBroadcastToOpHandler::MPSBroadcastToOpHandler((EmitterViewerSPI::MPSBroadcastToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x78:
      EmitterViewerSPI::MPSCallOpHandler::MPSCallOpHandler((EmitterViewerSPI::MPSCallOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x79:
      EmitterViewerSPI::MPSCastOpHandler::MPSCastOpHandler((EmitterViewerSPI::MPSCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x7A:
      EmitterViewerSPI::MPSCeilOpHandler::MPSCeilOpHandler((EmitterViewerSPI::MPSCeilOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x7B:
      EmitterViewerSPI::MPSClampOpHandler::MPSClampOpHandler((EmitterViewerSPI::MPSClampOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x7C:
      EmitterViewerSPI::MPSColToImOpHandler::MPSColToImOpHandler((EmitterViewerSPI::MPSColToImOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x7D:
      EmitterViewerSPI::MPSConcatOpHandler::MPSConcatOpHandler((EmitterViewerSPI::MPSConcatOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x7E:
      EmitterViewerSPI::MPSConjugateOpHandler::MPSConjugateOpHandler((EmitterViewerSPI::MPSConjugateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x7F:
      EmitterViewerSPI::MPSConstantOpHandler::MPSConstantOpHandler((EmitterViewerSPI::MPSConstantOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x80:
      EmitterViewerSPI::MPSConv2DDataGradientOpHandler::MPSConv2DDataGradientOpHandler((EmitterViewerSPI::MPSConv2DDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x81:
      EmitterViewerSPI::MPSConv2DOpHandler::MPSConv2DOpHandler((EmitterViewerSPI::MPSConv2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x82:
      EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler::MPSConv2DWeightsGradientOpHandler((EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x83:
      EmitterViewerSPI::MPSConv3DDataGradientOpHandler::MPSConv3DDataGradientOpHandler((EmitterViewerSPI::MPSConv3DDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x84:
      EmitterViewerSPI::MPSConv3DOpHandler::MPSConv3DOpHandler((EmitterViewerSPI::MPSConv3DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x85:
      EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler::MPSConv3DWeightsGradientOpHandler((EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x86:
      EmitterViewerSPI::MPSCosOpHandler::MPSCosOpHandler((EmitterViewerSPI::MPSCosOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x87:
      EmitterViewerSPI::MPSCoshOpHandler::MPSCoshOpHandler((EmitterViewerSPI::MPSCoshOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x88:
      EmitterViewerSPI::MPSCostVolumeOpHandler::MPSCostVolumeOpHandler((EmitterViewerSPI::MPSCostVolumeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x89:
      EmitterViewerSPI::MPSCreateComplexOpHandler::MPSCreateComplexOpHandler((EmitterViewerSPI::MPSCreateComplexOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x8A:
      EmitterViewerSPI::MPSCreateTextureTensorOpHandler::MPSCreateTextureTensorOpHandler((EmitterViewerSPI::MPSCreateTextureTensorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x8B:
      EmitterViewerSPI::MPSCropOpHandler::MPSCropOpHandler((EmitterViewerSPI::MPSCropOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x8C:
      EmitterViewerSPI::MPSCropResizeOpHandler::MPSCropResizeOpHandler((EmitterViewerSPI::MPSCropResizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x8D:
      EmitterViewerSPI::MPSCumulativeMaximumOpHandler::MPSCumulativeMaximumOpHandler((EmitterViewerSPI::MPSCumulativeMaximumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x8E:
      EmitterViewerSPI::MPSCumulativeMinimumOpHandler::MPSCumulativeMinimumOpHandler((EmitterViewerSPI::MPSCumulativeMinimumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x8F:
      EmitterViewerSPI::MPSCumulativeProductOpHandler::MPSCumulativeProductOpHandler((EmitterViewerSPI::MPSCumulativeProductOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x90:
      EmitterViewerSPI::MPSCumulativeSumOpHandler::MPSCumulativeSumOpHandler((EmitterViewerSPI::MPSCumulativeSumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x91:
      EmitterViewerSPI::MPSDegammaOpHandler::MPSDegammaOpHandler((EmitterViewerSPI::MPSDegammaOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x92:
      EmitterViewerSPI::MPSDepthToSpace2DOpHandler::MPSDepthToSpace2DOpHandler((EmitterViewerSPI::MPSDepthToSpace2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x93:
      EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler::MPSDepthwiseConv2DDataGradientOpHandler((EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x94:
      EmitterViewerSPI::MPSDepthwiseConv2DOpHandler::MPSDepthwiseConv2DOpHandler((EmitterViewerSPI::MPSDepthwiseConv2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x95:
      EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler::MPSDepthwiseConv2DWeightsGradientOpHandler((EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x96:
      EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler::MPSDepthwiseConv3DDataGradientOpHandler((EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x97:
      EmitterViewerSPI::MPSDepthwiseConv3DOpHandler::MPSDepthwiseConv3DOpHandler((EmitterViewerSPI::MPSDepthwiseConv3DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x98:
      EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler::MPSDepthwiseConv3DWeightsGradientOpHandler((EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x99:
      EmitterViewerSPI::MPSDequantizeLUTOpHandler::MPSDequantizeLUTOpHandler((EmitterViewerSPI::MPSDequantizeLUTOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x9A:
      EmitterViewerSPI::MPSDequantizeOpHandler::MPSDequantizeOpHandler((EmitterViewerSPI::MPSDequantizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x9B:
      EmitterViewerSPI::MPSDimensionSizeOpHandler::MPSDimensionSizeOpHandler((EmitterViewerSPI::MPSDimensionSizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x9C:
      EmitterViewerSPI::MPSDiracOpHandler::MPSDiracOpHandler((EmitterViewerSPI::MPSDiracOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x9D:
      EmitterViewerSPI::MPSDivideOpHandler::MPSDivideOpHandler((EmitterViewerSPI::MPSDivideOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x9E:
      EmitterViewerSPI::MPSDynamicShapeCastOpHandler::MPSDynamicShapeCastOpHandler((EmitterViewerSPI::MPSDynamicShapeCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x9F:
      EmitterViewerSPI::MPSEluOpHandler::MPSEluOpHandler((EmitterViewerSPI::MPSEluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA0:
      EmitterViewerSPI::MPSEqualToOpHandler::MPSEqualToOpHandler((EmitterViewerSPI::MPSEqualToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA1:
      EmitterViewerSPI::MPSErfOpHandler::MPSErfOpHandler((EmitterViewerSPI::MPSErfOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA2:
      EmitterViewerSPI::MPSExpandDimsOpHandler::MPSExpandDimsOpHandler((EmitterViewerSPI::MPSExpandDimsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA3:
      EmitterViewerSPI::MPSExponentBase2OpHandler::MPSExponentBase2OpHandler((EmitterViewerSPI::MPSExponentBase2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA4:
      EmitterViewerSPI::MPSExponentBase10OpHandler::MPSExponentBase10OpHandler((EmitterViewerSPI::MPSExponentBase10OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA5:
      EmitterViewerSPI::MPSExponentOpHandler::MPSExponentOpHandler((EmitterViewerSPI::MPSExponentOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA6:
      EmitterViewerSPI::MPSFastFourierTransformOpHandler::MPSFastFourierTransformOpHandler((EmitterViewerSPI::MPSFastFourierTransformOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA7:
      EmitterViewerSPI::MPSFlatten2DOpHandler::MPSFlatten2DOpHandler((EmitterViewerSPI::MPSFlatten2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA8:
      EmitterViewerSPI::MPSFloorDivideOpHandler::MPSFloorDivideOpHandler((EmitterViewerSPI::MPSFloorDivideOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xA9:
      EmitterViewerSPI::MPSFloorOpHandler::MPSFloorOpHandler((EmitterViewerSPI::MPSFloorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xAA:
      EmitterViewerSPI::MPSGRUGradientOpHandler::MPSGRUGradientOpHandler((EmitterViewerSPI::MPSGRUGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xAB:
      EmitterViewerSPI::MPSGRUOpHandler::MPSGRUOpHandler((EmitterViewerSPI::MPSGRUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xAC:
      EmitterViewerSPI::MPSGatherAlongAxisOpHandler::MPSGatherAlongAxisOpHandler((EmitterViewerSPI::MPSGatherAlongAxisOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xAD:
      EmitterViewerSPI::MPSGatherNDOpHandler::MPSGatherNDOpHandler((EmitterViewerSPI::MPSGatherNDOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xAE:
      EmitterViewerSPI::MPSGatherOpHandler::MPSGatherOpHandler((EmitterViewerSPI::MPSGatherOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xAF:
      EmitterViewerSPI::MPSGeluOpHandler::MPSGeluOpHandler((EmitterViewerSPI::MPSGeluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB0:
      EmitterViewerSPI::MPSGetCoordOpHandler::MPSGetCoordOpHandler((EmitterViewerSPI::MPSGetCoordOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB1:
      EmitterViewerSPI::MPSGreaterThanOpHandler::MPSGreaterThanOpHandler((EmitterViewerSPI::MPSGreaterThanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB2:
      EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler::MPSGreaterThanOrEqualToOpHandler((EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB3:
      EmitterViewerSPI::MPSHammingDistanceOpHandler::MPSHammingDistanceOpHandler((EmitterViewerSPI::MPSHammingDistanceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB4:
      EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler::MPSHermiteanToRealFFTOpHandler((EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB5:
      EmitterViewerSPI::MPSIdentityOpHandler::MPSIdentityOpHandler((EmitterViewerSPI::MPSIdentityOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB6:
      EmitterViewerSPI::MPSImToColOpHandler::MPSImToColOpHandler((EmitterViewerSPI::MPSImToColOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB7:
      EmitterViewerSPI::MPSImaginaryPartOpHandler::MPSImaginaryPartOpHandler((EmitterViewerSPI::MPSImaginaryPartOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB8:
      EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler::MPSInitRandomPhiloxStateOpHandler((EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xB9:
      EmitterViewerSPI::MPSInstanceNormOpHandler::MPSInstanceNormOpHandler((EmitterViewerSPI::MPSInstanceNormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xBA:
      EmitterViewerSPI::MPSIsFiniteOpHandler::MPSIsFiniteOpHandler((EmitterViewerSPI::MPSIsFiniteOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xBB:
      EmitterViewerSPI::MPSIsInfiniteOpHandler::MPSIsInfiniteOpHandler((EmitterViewerSPI::MPSIsInfiniteOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xBC:
      EmitterViewerSPI::MPSIsNaNOpHandler::MPSIsNaNOpHandler((EmitterViewerSPI::MPSIsNaNOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xBD:
      EmitterViewerSPI::MPSLPNormOpHandler::MPSLPNormOpHandler((EmitterViewerSPI::MPSLPNormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xBE:
      EmitterViewerSPI::MPSLSTMGradientOpHandler::MPSLSTMGradientOpHandler((EmitterViewerSPI::MPSLSTMGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xBF:
      EmitterViewerSPI::MPSLSTMOpHandler::MPSLSTMOpHandler((EmitterViewerSPI::MPSLSTMOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC0:
      EmitterViewerSPI::MPSLeakyReluOpHandler::MPSLeakyReluOpHandler((EmitterViewerSPI::MPSLeakyReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC1:
      EmitterViewerSPI::MPSLessThanOpHandler::MPSLessThanOpHandler((EmitterViewerSPI::MPSLessThanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC2:
      EmitterViewerSPI::MPSLessThanOrEqualToOpHandler::MPSLessThanOrEqualToOpHandler((EmitterViewerSPI::MPSLessThanOrEqualToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC3:
      EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler::MPSLocalConvolutionDataGradientOpHandler((EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC4:
      EmitterViewerSPI::MPSLocalConvolutionOpHandler::MPSLocalConvolutionOpHandler((EmitterViewerSPI::MPSLocalConvolutionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC5:
      EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler::MPSLocalConvolutionWeightGradientOpHandler((EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC6:
      EmitterViewerSPI::MPSLogarithmBase2OpHandler::MPSLogarithmBase2OpHandler((EmitterViewerSPI::MPSLogarithmBase2OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC7:
      EmitterViewerSPI::MPSLogarithmBase10OpHandler::MPSLogarithmBase10OpHandler((EmitterViewerSPI::MPSLogarithmBase10OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC8:
      EmitterViewerSPI::MPSLogarithmOpHandler::MPSLogarithmOpHandler((EmitterViewerSPI::MPSLogarithmOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xC9:
      EmitterViewerSPI::MPSMatMulOpHandler::MPSMatMulOpHandler((EmitterViewerSPI::MPSMatMulOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xCA:
      EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler::MPSMaterializeSparseTensorOpHandler((EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xCB:
      EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler::MPSMatrixDecompositionLUOpHandler((EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xCC:
      EmitterViewerSPI::MPSMatrixInverseOpHandler::MPSMatrixInverseOpHandler((EmitterViewerSPI::MPSMatrixInverseOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xCD:
      EmitterViewerSPI::MPSMatrixSolverLUOpHandler::MPSMatrixSolverLUOpHandler((EmitterViewerSPI::MPSMatrixSolverLUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xCE:
      EmitterViewerSPI::MPSMaximumOpHandler::MPSMaximumOpHandler((EmitterViewerSPI::MPSMaximumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xCF:
      EmitterViewerSPI::MPSMinimumOpHandler::MPSMinimumOpHandler((EmitterViewerSPI::MPSMinimumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD0:
      EmitterViewerSPI::MPSModuloOpHandler::MPSModuloOpHandler((EmitterViewerSPI::MPSModuloOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD1:
      EmitterViewerSPI::MPSMultiplyOpHandler::MPSMultiplyOpHandler((EmitterViewerSPI::MPSMultiplyOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD2:
      EmitterViewerSPI::MPSNReluOpHandler::MPSNReluOpHandler((EmitterViewerSPI::MPSNReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD3:
      EmitterViewerSPI::MPSNandOpHandler::MPSNandOpHandler((EmitterViewerSPI::MPSNandOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD4:
      EmitterViewerSPI::MPSNegativeOpHandler::MPSNegativeOpHandler((EmitterViewerSPI::MPSNegativeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD5:
      EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler::MPSNonMaximumSuppressionOpHandler((EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD6:
      EmitterViewerSPI::MPSNonZeroOpHandler::MPSNonZeroOpHandler((EmitterViewerSPI::MPSNonZeroOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD7:
      EmitterViewerSPI::MPSNorOpHandler::MPSNorOpHandler((EmitterViewerSPI::MPSNorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD8:
      EmitterViewerSPI::MPSNormalizationOpHandler::MPSNormalizationOpHandler((EmitterViewerSPI::MPSNormalizationOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xD9:
      EmitterViewerSPI::MPSNotEqualToOpHandler::MPSNotEqualToOpHandler((EmitterViewerSPI::MPSNotEqualToOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xDA:
      EmitterViewerSPI::MPSNotOpHandler::MPSNotOpHandler((EmitterViewerSPI::MPSNotOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xDB:
      EmitterViewerSPI::MPSOneHotOpHandler::MPSOneHotOpHandler((EmitterViewerSPI::MPSOneHotOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xDC:
      EmitterViewerSPI::MPSOrOpHandler::MPSOrOpHandler((EmitterViewerSPI::MPSOrOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xDD:
      EmitterViewerSPI::MPSPReluOpHandler::MPSPReluOpHandler((EmitterViewerSPI::MPSPReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xDE:
      EmitterViewerSPI::MPSPadGradientOpHandler::MPSPadGradientOpHandler((EmitterViewerSPI::MPSPadGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xDF:
      EmitterViewerSPI::MPSPadOpHandler::MPSPadOpHandler((EmitterViewerSPI::MPSPadOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE0:
      EmitterViewerSPI::MPSPermuteOpHandler::MPSPermuteOpHandler((EmitterViewerSPI::MPSPermuteOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE1:
      EmitterViewerSPI::MPSPlaceholderOpHandler::MPSPlaceholderOpHandler((EmitterViewerSPI::MPSPlaceholderOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE2:
      EmitterViewerSPI::MPSPoolAvgGradientOpHandler::MPSPoolAvgGradientOpHandler((EmitterViewerSPI::MPSPoolAvgGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE3:
      EmitterViewerSPI::MPSPoolAvgOpHandler::MPSPoolAvgOpHandler((EmitterViewerSPI::MPSPoolAvgOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE4:
      EmitterViewerSPI::MPSPoolL2NormGradientOpHandler::MPSPoolL2NormGradientOpHandler((EmitterViewerSPI::MPSPoolL2NormGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE5:
      EmitterViewerSPI::MPSPoolL2NormOpHandler::MPSPoolL2NormOpHandler((EmitterViewerSPI::MPSPoolL2NormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE6:
      EmitterViewerSPI::MPSPoolMaxGradientOpHandler::MPSPoolMaxGradientOpHandler((EmitterViewerSPI::MPSPoolMaxGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE7:
      EmitterViewerSPI::MPSPoolMaxOpHandler::MPSPoolMaxOpHandler((EmitterViewerSPI::MPSPoolMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE8:
      EmitterViewerSPI::MPSPowerOpHandler::MPSPowerOpHandler((EmitterViewerSPI::MPSPowerOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xE9:
      EmitterViewerSPI::MPSPruningGradientOpHandler::MPSPruningGradientOpHandler((EmitterViewerSPI::MPSPruningGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xEA:
      EmitterViewerSPI::MPSPruningOpHandler::MPSPruningOpHandler((EmitterViewerSPI::MPSPruningOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xEB:
      EmitterViewerSPI::MPSQuantizeOpHandler::MPSQuantizeOpHandler((EmitterViewerSPI::MPSQuantizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xEC:
      EmitterViewerSPI::MPSRandomNormalOpHandler::MPSRandomNormalOpHandler((EmitterViewerSPI::MPSRandomNormalOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xED:
      EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler::MPSRandomTruncatedNormalOpHandler((EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xEE:
      EmitterViewerSPI::MPSRandomUniformOpHandler::MPSRandomUniformOpHandler((EmitterViewerSPI::MPSRandomUniformOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xEF:
      EmitterViewerSPI::MPSRankOpHandler::MPSRankOpHandler((EmitterViewerSPI::MPSRankOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF0:
      EmitterViewerSPI::MPSReadDataFromFileOpHandler::MPSReadDataFromFileOpHandler((EmitterViewerSPI::MPSReadDataFromFileOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF1:
      EmitterViewerSPI::MPSReadVariableOpHandler::MPSReadVariableOpHandler((EmitterViewerSPI::MPSReadVariableOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF2:
      EmitterViewerSPI::MPSRealPartOpHandler::MPSRealPartOpHandler((EmitterViewerSPI::MPSRealPartOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF3:
      EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler::MPSRealToHermiteanFFTOpHandler((EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF4:
      EmitterViewerSPI::MPSReciprocalOpHandler::MPSReciprocalOpHandler((EmitterViewerSPI::MPSReciprocalOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF5:
      EmitterViewerSPI::MPSReciprocalSquareRootOpHandler::MPSReciprocalSquareRootOpHandler((EmitterViewerSPI::MPSReciprocalSquareRootOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF6:
      EmitterViewerSPI::MPSReductionAndOpHandler::MPSReductionAndOpHandler((EmitterViewerSPI::MPSReductionAndOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF7:
      EmitterViewerSPI::MPSReductionArgMaxOpHandler::MPSReductionArgMaxOpHandler((EmitterViewerSPI::MPSReductionArgMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF8:
      EmitterViewerSPI::MPSReductionArgMinOpHandler::MPSReductionArgMinOpHandler((EmitterViewerSPI::MPSReductionArgMinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xF9:
      EmitterViewerSPI::MPSReductionLogSumExpOpHandler::MPSReductionLogSumExpOpHandler((EmitterViewerSPI::MPSReductionLogSumExpOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xFA:
      EmitterViewerSPI::MPSReductionMaxOpHandler::MPSReductionMaxOpHandler((EmitterViewerSPI::MPSReductionMaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xFB:
      EmitterViewerSPI::MPSReductionMeanOpHandler::MPSReductionMeanOpHandler((EmitterViewerSPI::MPSReductionMeanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xFC:
      EmitterViewerSPI::MPSReductionMinOpHandler::MPSReductionMinOpHandler((EmitterViewerSPI::MPSReductionMinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xFD:
      EmitterViewerSPI::MPSReductionOrOpHandler::MPSReductionOrOpHandler((EmitterViewerSPI::MPSReductionOrOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xFE:
      EmitterViewerSPI::MPSReductionProdOpHandler::MPSReductionProdOpHandler((EmitterViewerSPI::MPSReductionProdOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0xFF:
      EmitterViewerSPI::MPSReductionSumOpHandler::MPSReductionSumOpHandler((EmitterViewerSPI::MPSReductionSumOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x100:
      EmitterViewerSPI::MPSReductionVarianceOpHandler::MPSReductionVarianceOpHandler((EmitterViewerSPI::MPSReductionVarianceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x101:
      EmitterViewerSPI::MPSReinterpretCastOpHandler::MPSReinterpretCastOpHandler((EmitterViewerSPI::MPSReinterpretCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x102:
      EmitterViewerSPI::MPSRelu6OpHandler::MPSRelu6OpHandler((EmitterViewerSPI::MPSRelu6OpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x103:
      EmitterViewerSPI::MPSReluGradOpHandler::MPSReluGradOpHandler((EmitterViewerSPI::MPSReluGradOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x104:
      EmitterViewerSPI::MPSReluOpHandler::MPSReluOpHandler((EmitterViewerSPI::MPSReluOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x105:
      EmitterViewerSPI::MPSReshapeOpHandler::MPSReshapeOpHandler((EmitterViewerSPI::MPSReshapeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x106:
      EmitterViewerSPI::MPSResizeGradientOpHandler::MPSResizeGradientOpHandler((EmitterViewerSPI::MPSResizeGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x107:
      EmitterViewerSPI::MPSResizeOpHandler::MPSResizeOpHandler((EmitterViewerSPI::MPSResizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x108:
      EmitterViewerSPI::MPSReverseOpHandler::MPSReverseOpHandler((EmitterViewerSPI::MPSReverseOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x109:
      EmitterViewerSPI::MPSRintOpHandler::MPSRintOpHandler((EmitterViewerSPI::MPSRintOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x10A:
      EmitterViewerSPI::MPSRoundOpHandler::MPSRoundOpHandler((EmitterViewerSPI::MPSRoundOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x10B:
      EmitterViewerSPI::MPSSampleGridDataGradientOpHandler::MPSSampleGridDataGradientOpHandler((EmitterViewerSPI::MPSSampleGridDataGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x10C:
      EmitterViewerSPI::MPSSampleGridOpHandler::MPSSampleGridOpHandler((EmitterViewerSPI::MPSSampleGridOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x10D:
      EmitterViewerSPI::MPSScatterAlongAxisOpHandler::MPSScatterAlongAxisOpHandler((EmitterViewerSPI::MPSScatterAlongAxisOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x10E:
      EmitterViewerSPI::MPSScatterNDOpHandler::MPSScatterNDOpHandler((EmitterViewerSPI::MPSScatterNDOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x10F:
      EmitterViewerSPI::MPSScatterOpHandler::MPSScatterOpHandler((EmitterViewerSPI::MPSScatterOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x110:
      EmitterViewerSPI::MPSSelectOpHandler::MPSSelectOpHandler((EmitterViewerSPI::MPSSelectOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x111:
      EmitterViewerSPI::MPSShapeOpHandler::MPSShapeOpHandler((EmitterViewerSPI::MPSShapeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x112:
      EmitterViewerSPI::MPSSigmoidGradientOpHandler::MPSSigmoidGradientOpHandler((EmitterViewerSPI::MPSSigmoidGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x113:
      EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler::MPSSigmoidGradientWithSigmoidOpHandler((EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x114:
      EmitterViewerSPI::MPSSigmoidHardOpHandler::MPSSigmoidHardOpHandler((EmitterViewerSPI::MPSSigmoidHardOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x115:
      EmitterViewerSPI::MPSSigmoidOpHandler::MPSSigmoidOpHandler((EmitterViewerSPI::MPSSigmoidOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x116:
      EmitterViewerSPI::MPSSignOpHandler::MPSSignOpHandler((EmitterViewerSPI::MPSSignOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x117:
      EmitterViewerSPI::MPSSignbitOpHandler::MPSSignbitOpHandler((EmitterViewerSPI::MPSSignbitOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x118:
      EmitterViewerSPI::MPSSinOpHandler::MPSSinOpHandler((EmitterViewerSPI::MPSSinOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x119:
      EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler::MPSSingleGateRNNGradientOpHandler((EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x11A:
      EmitterViewerSPI::MPSSingleGateRNNOpHandler::MPSSingleGateRNNOpHandler((EmitterViewerSPI::MPSSingleGateRNNOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x11B:
      EmitterViewerSPI::MPSSinhOpHandler::MPSSinhOpHandler((EmitterViewerSPI::MPSSinhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x11C:
      EmitterViewerSPI::MPSSizeOpHandler::MPSSizeOpHandler((EmitterViewerSPI::MPSSizeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x11D:
      EmitterViewerSPI::MPSSliceOpHandler::MPSSliceOpHandler((EmitterViewerSPI::MPSSliceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x11E:
      EmitterViewerSPI::MPSSoftmaxOpHandler::MPSSoftmaxOpHandler((EmitterViewerSPI::MPSSoftmaxOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x11F:
      EmitterViewerSPI::MPSSoftplusOpHandler::MPSSoftplusOpHandler((EmitterViewerSPI::MPSSoftplusOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x120:
      EmitterViewerSPI::MPSSoftplusParametricOpHandler::MPSSoftplusParametricOpHandler((EmitterViewerSPI::MPSSoftplusParametricOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x121:
      EmitterViewerSPI::MPSSoftsignOpHandler::MPSSoftsignOpHandler((EmitterViewerSPI::MPSSoftsignOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x122:
      EmitterViewerSPI::MPSSortOpHandler::MPSSortOpHandler((EmitterViewerSPI::MPSSortOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x123:
      EmitterViewerSPI::MPSSpaceToBatchOpHandler::MPSSpaceToBatchOpHandler((EmitterViewerSPI::MPSSpaceToBatchOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x124:
      EmitterViewerSPI::MPSSpaceToDepth2DOpHandler::MPSSpaceToDepth2DOpHandler((EmitterViewerSPI::MPSSpaceToDepth2DOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x125:
      EmitterViewerSPI::MPSSplitOpHandler::MPSSplitOpHandler((EmitterViewerSPI::MPSSplitOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x126:
      EmitterViewerSPI::MPSSquareOpHandler::MPSSquareOpHandler((EmitterViewerSPI::MPSSquareOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x127:
      EmitterViewerSPI::MPSSquareRootOpHandler::MPSSquareRootOpHandler((EmitterViewerSPI::MPSSquareRootOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x128:
      EmitterViewerSPI::MPSSqueezeOpHandler::MPSSqueezeOpHandler((EmitterViewerSPI::MPSSqueezeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x129:
      EmitterViewerSPI::MPSStencilOpHandler::MPSStencilOpHandler((EmitterViewerSPI::MPSStencilOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x12A:
      EmitterViewerSPI::MPSStridedSliceGradientOpHandler::MPSStridedSliceGradientOpHandler((EmitterViewerSPI::MPSStridedSliceGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x12B:
      EmitterViewerSPI::MPSStridedSliceOpHandler::MPSStridedSliceOpHandler((EmitterViewerSPI::MPSStridedSliceOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x12C:
      EmitterViewerSPI::MPSStridedSliceUpdateOpHandler::MPSStridedSliceUpdateOpHandler((EmitterViewerSPI::MPSStridedSliceUpdateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x12D:
      EmitterViewerSPI::MPSSubtractOpHandler::MPSSubtractOpHandler((EmitterViewerSPI::MPSSubtractOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x12E:
      EmitterViewerSPI::MPSSwishOpHandler::MPSSwishOpHandler((EmitterViewerSPI::MPSSwishOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x12F:
      EmitterViewerSPI::MPSTanOpHandler::MPSTanOpHandler((EmitterViewerSPI::MPSTanOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x130:
      EmitterViewerSPI::MPSTanhOpHandler::MPSTanhOpHandler((EmitterViewerSPI::MPSTanhOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x131:
      EmitterViewerSPI::MPSTileGradientOpHandler::MPSTileGradientOpHandler((EmitterViewerSPI::MPSTileGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x132:
      EmitterViewerSPI::MPSTileOpHandler::MPSTileOpHandler((EmitterViewerSPI::MPSTileOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x133:
      EmitterViewerSPI::MPSTopKGradientOpHandler::MPSTopKGradientOpHandler((EmitterViewerSPI::MPSTopKGradientOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x134:
      EmitterViewerSPI::MPSTopKOpHandler::MPSTopKOpHandler((EmitterViewerSPI::MPSTopKOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x135:
      EmitterViewerSPI::MPSTransposeOpHandler::MPSTransposeOpHandler((EmitterViewerSPI::MPSTransposeOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x136:
      EmitterViewerSPI::MPSTruncateOpHandler::MPSTruncateOpHandler((EmitterViewerSPI::MPSTruncateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x137:
      EmitterViewerSPI::MPSTypeConstraintOpHandler::MPSTypeConstraintOpHandler((EmitterViewerSPI::MPSTypeConstraintOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x138:
      EmitterViewerSPI::MPSUnrealizedFoldOpHandler::MPSUnrealizedFoldOpHandler((EmitterViewerSPI::MPSUnrealizedFoldOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x139:
      EmitterViewerSPI::MPSUpdateRandomStateOpHandler::MPSUpdateRandomStateOpHandler((EmitterViewerSPI::MPSUpdateRandomStateOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x13A:
      EmitterViewerSPI::MPSVariableFromTensorOpHandler::MPSVariableFromTensorOpHandler((EmitterViewerSPI::MPSVariableFromTensorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x13B:
      EmitterViewerSPI::MPSXnorOpHandler::MPSXnorOpHandler((EmitterViewerSPI::MPSXnorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x13C:
      EmitterViewerSPI::MPSXorOpHandler::MPSXorOpHandler((EmitterViewerSPI::MPSXorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x13D:
      EmitterViewerSPI::ConditionOpHandler::ConditionOpHandler((EmitterViewerSPI::ConditionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x13E:
      EmitterViewerSPI::ForOpHandler::ForOpHandler((EmitterViewerSPI::ForOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x13F:
      EmitterViewerSPI::IfOpHandler::IfOpHandler((EmitterViewerSPI::IfOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x140:
      EmitterViewerSPI::MPSExtractOpHandler::MPSExtractOpHandler((EmitterViewerSPI::MPSExtractOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x141:
      EmitterViewerSPI::MPSFromElementsOpHandler::MPSFromElementsOpHandler((EmitterViewerSPI::MPSFromElementsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x142:
      EmitterViewerSPI::MPSFuncOpHandler::MPSFuncOpHandler((EmitterViewerSPI::MPSFuncOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x143:
      EmitterViewerSPI::MPSModuleOpHandler::MPSModuleOpHandler((EmitterViewerSPI::MPSModuleOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x144:
      EmitterViewerSPI::MPSReturnOpHandler::MPSReturnOpHandler((EmitterViewerSPI::MPSReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x145:
      EmitterViewerSPI::WhileOpHandler::WhileOpHandler((EmitterViewerSPI::WhileOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x146:
      EmitterViewerSPI::YieldOpHandler::YieldOpHandler((EmitterViewerSPI::YieldOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x147:
      EmitterViewerSPI::MPSXANEOpHandler::MPSXANEOpHandler((EmitterViewerSPI::MPSXANEOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x148:
      EmitterViewerSPI::MPSXCPUOpHandler::MPSXCPUOpHandler((EmitterViewerSPI::MPSXCPUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x149:
      EmitterViewerSPI::MPSXDeinterleaveOpHandler::MPSXDeinterleaveOpHandler((EmitterViewerSPI::MPSXDeinterleaveOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x14A:
      EmitterViewerSPI::MPSXFPToIntClampedOpHandler::MPSXFPToIntClampedOpHandler((EmitterViewerSPI::MPSXFPToIntClampedOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x14B:
      EmitterViewerSPI::MPSXFusionOpHandler::MPSXFusionOpHandler((EmitterViewerSPI::MPSXFusionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x14C:
      EmitterViewerSPI::MPSXFusionReturnOpHandler::MPSXFusionReturnOpHandler((EmitterViewerSPI::MPSXFusionReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x14D:
      EmitterViewerSPI::MPSXGPUOpHandler::MPSXGPUOpHandler((EmitterViewerSPI::MPSXGPUOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x14E:
      EmitterViewerSPI::MPSXInterleaveOpHandler::MPSXInterleaveOpHandler((EmitterViewerSPI::MPSXInterleaveOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x14F:
      EmitterViewerSPI::MPSXListPopBackOpHandler::MPSXListPopBackOpHandler((EmitterViewerSPI::MPSXListPopBackOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x150:
      EmitterViewerSPI::MPSXListPushBackOpHandler::MPSXListPushBackOpHandler((EmitterViewerSPI::MPSXListPushBackOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x151:
      EmitterViewerSPI::MPSXMakeListOpHandler::MPSXMakeListOpHandler((EmitterViewerSPI::MPSXMakeListOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x152:
      EmitterViewerSPI::MPSXQuantizedGatherOpHandler::MPSXQuantizedGatherOpHandler((EmitterViewerSPI::MPSXQuantizedGatherOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x153:
      EmitterViewerSPI::MPSXQuantizedMatMulOpHandler::MPSXQuantizedMatMulOpHandler((EmitterViewerSPI::MPSXQuantizedMatMulOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x154:
      EmitterViewerSPI::MPSXRMSNormOpHandler::MPSXRMSNormOpHandler((EmitterViewerSPI::MPSXRMSNormOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x155:
      EmitterViewerSPI::MPSXRegionReturnOpHandler::MPSXRegionReturnOpHandler((EmitterViewerSPI::MPSXRegionReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x156:
      EmitterViewerSPI::MPSXReturnStitchedOpHandler::MPSXReturnStitchedOpHandler((EmitterViewerSPI::MPSXReturnStitchedOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x157:
      EmitterViewerSPI::MPSXScaledDotProductAttentionOpHandler::MPSXScaledDotProductAttentionOpHandler((EmitterViewerSPI::MPSXScaledDotProductAttentionOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x158:
      EmitterViewerSPI::MPSXSparseDenseMatMulOpHandler::MPSXSparseDenseMatMulOpHandler((EmitterViewerSPI::MPSXSparseDenseMatMulOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x159:
      EmitterViewerSPI::MPSXStitchedOpHandler::MPSXStitchedOpHandler((EmitterViewerSPI::MPSXStitchedOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x15A:
      EmitterViewerSPI::MPSXVarHandleOpHandler::MPSXVarHandleOpHandler((EmitterViewerSPI::MPSXVarHandleOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x15B:
      EmitterViewerSPI::PlacementANEIOCastOpHandler::PlacementANEIOCastOpHandler((EmitterViewerSPI::PlacementANEIOCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x15C:
      EmitterViewerSPI::PlacementHostTypeCastOpHandler::PlacementHostTypeCastOpHandler((EmitterViewerSPI::PlacementHostTypeCastOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x15D:
      EmitterViewerSPI::PlacementMemrefToTensorOpHandler::PlacementMemrefToTensorOpHandler((EmitterViewerSPI::PlacementMemrefToTensorOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x15E:
      EmitterViewerSPI::PlacementRegionCallOpHandler::PlacementRegionCallOpHandler((EmitterViewerSPI::PlacementRegionCallOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x15F:
      EmitterViewerSPI::PlacementReplacedOpsOpHandler::PlacementReplacedOpsOpHandler((EmitterViewerSPI::PlacementReplacedOpsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x160:
      EmitterViewerSPI::PlacementReplacedOpsLiveOutsOpHandler::PlacementReplacedOpsLiveOutsOpHandler((EmitterViewerSPI::PlacementReplacedOpsLiveOutsOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x161:
      EmitterViewerSPI::PlacementStartTimerOpHandler::PlacementStartTimerOpHandler((EmitterViewerSPI::PlacementStartTimerOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x162:
      EmitterViewerSPI::PlacementStopTimerOpHandler::PlacementStopTimerOpHandler((EmitterViewerSPI::PlacementStopTimerOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x163:
      EmitterViewerSPI::PlacementTensorToMemrefOpHandler::PlacementTensorToMemrefOpHandler((EmitterViewerSPI::PlacementTensorToMemrefOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
      goto LABEL_420;
    case 0x164:
      EmitterViewerSPI::ReturnOpHandler::ReturnOpHandler((EmitterViewerSPI::ReturnOpHandler *)__p, (EmitViewerSPI *)this, (mlir::Operation *)a2);
LABEL_420:
      uint64_t v30 = (MPSGraphViewerNodeSPI *)v73;

      goto LABEL_421;
    default:
      if (MTLReportFailureTypeEnabled())
      {
        float v32 = (void **)&__dst;
        if (v76 < 0) {
          float v32 = (void **)__dst;
        }
        char v65 = v32;
        MTLReportFailure();
      }
      uint64_t v77 = *(void *)(*(void *)&a2[1]._dataType + 8);
      float v33 = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v77);
      std::string::basic_string[abi:ne180100]<0>(__p, v33);
      if (v72 >= 0) {
        BOOL v34 = __p;
      }
      else {
        BOOL v34 = (void **)__p[0];
      }
      uint64_t v70 = objc_msgSend(NSString, "stringWithCString:encoding:", v34, 4, v65);
      uint64_t v69 = [MEMORY[0x1E4F1CA48] array];
      unint64_t v35 = [MEMORY[0x1E4F1CA48] array];
      if ((BYTE6(a2[1].super.super.isa) & 0x80) == 0) {
        goto LABEL_443;
      }
      uint64_t shape_high = HIDWORD(a2[1]._shape);
      if (!shape_high) {
        goto LABEL_443;
      }
      unint64_t v37 = 0;
      uint64_t v38 = 24;
      int v67 = "Operation.h";
      unint64_t v68 = "hasOperandStorage && \"expected operation to have operand storage\"";
      char v66 = "getOperandStorage";
      break;
  }
  while (2)
  {
    if ((BYTE6(a2[1].super.super.isa) & 0x80) == 0)
    {
      int v60 = 960;
      goto LABEL_471;
    }
    if (v37 >= HIDWORD(a2[1]._shape))
    {
      int v60 = 443;
      char v66 = "operator[]";
      int v67 = "ArrayRef.h";
      unint64_t v68 = "Index < this->size() && \"Invalid index!\"";
LABEL_471:
      __assert_rtn(v66, v67, v60, v68);
    }
    unint64_t v39 = *(void *)(a2[1]._valueRef + v38);
    uint64_t v40 = objc_msgSend(NSString, "stringWithFormat:", @"in%d", v37, v66, v67, v68);
    int8x8_t v41 = EmitViewerSPI::emitNodeInputPort((uint64_t)this, v40, v39);

    if (v41) {
      [v35 addObject:v41];
    }

    ++v37;
    v38 += 32;
    if (shape_high != v37) {
      continue;
    }
    break;
  }
LABEL_443:
  unint64_t v42 = [MEMORY[0x1E4F1CA48] array];
  uint64_t valueRef_high = HIDWORD(a2->_valueRef);
  if (!valueRef_high) {
    goto LABEL_467;
  }
  __int16 v44 = objc_msgSend(NSString, "stringWithFormat:", @"out%d", 0);
  uint64_t v45 = EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v44, (MPSGraphViewerNodePortSPI *)((char *)a2 - 16));

  if (v45) {
    [v42 addObject:v45];
  }

  if (valueRef_high == 1) {
    goto LABEL_467;
  }
  if (HIDWORD(a2->_valueRef) < 2) {
    goto LABEL_477;
  }
  unint64_t v46 = objc_msgSend(NSString, "stringWithFormat:", @"out%d", 1);
  long long v47 = EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v46, (MPSGraphViewerNodePortSPI *)((char *)a2 - 32));

  if (v47) {
    [v42 addObject:v47];
  }

  if (valueRef_high == 2) {
    goto LABEL_467;
  }
  if (HIDWORD(a2->_valueRef) < 3) {
    goto LABEL_477;
  }
  uint64_t v48 = objc_msgSend(NSString, "stringWithFormat:", @"out%d", 2);
  long long v49 = EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v48, (MPSGraphViewerNodePortSPI *)((char *)a2 - 48));

  if (v49) {
    [v42 addObject:v49];
  }

  if (valueRef_high == 3) {
    goto LABEL_467;
  }
  if (HIDWORD(a2->_valueRef) < 4) {
    goto LABEL_477;
  }
  uint64_t v50 = objc_msgSend(NSString, "stringWithFormat:", @"out%d", 3);
  BOOL v51 = EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v50, (MPSGraphViewerNodePortSPI *)((char *)a2 - 64));

  if (v51) {
    [v42 addObject:v51];
  }

  if (valueRef_high == 4) {
    goto LABEL_467;
  }
  if (HIDWORD(a2->_valueRef) < 5) {
    goto LABEL_477;
  }
  int v52 = objc_msgSend(NSString, "stringWithFormat:", @"out%d", 4);
  uint64_t v53 = EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v52, a2 - 2);

  if (v53) {
    [v42 addObject:v53];
  }

  if (valueRef_high == 5) {
    goto LABEL_467;
  }
  if (HIDWORD(a2->_valueRef) < 6) {
LABEL_477:
  }
    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
  char v54 = objc_msgSend(NSString, "stringWithFormat:", @"out%d", 5);
  int v55 = EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v54, (MPSGraphViewerNodePortSPI *)((char *)a2 - 96));

  if (v55) {
    [v42 addObject:v55];
  }

  if (valueRef_high != 6)
  {
    unint64_t v61 = a2 - 3;
    unint64_t v62 = 6;
    while (v62 < HIDWORD(a2->_valueRef))
    {
      char v63 = objc_msgSend(NSString, "stringWithFormat:", @"out%d", v62);
      int v64 = EmitViewerSPI::emitNodeOutputPort((uint64_t)this, v63, v61);

      if (v64) {
        [v42 addObject:v64];
      }

      ++v62;
      unint64_t v61 = (MPSGraphViewerNodePortSPI *)((char *)v61 - 24);
      if (valueRef_high == v62) {
        goto LABEL_467;
      }
    }
    goto LABEL_477;
  }
LABEL_467:
  int v56 = [MPSGraphViewerNodeSPI alloc];
  char v57 = [MEMORY[0x1E4F1C978] arrayWithArray:v35];
  unint64_t v58 = [MEMORY[0x1E4F1C978] arrayWithArray:v42];
  unint64_t v59 = [MEMORY[0x1E4F1C978] arrayWithArray:v69];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v56 initWithType:v70 inputs:v57 outputs:v58 properties:v59 regions:MEMORY[0x1E4F1CBF0]];

  if (v72 < 0) {
    operator delete(__p[0]);
  }
LABEL_421:
  if (SHIBYTE(v76) < 0) {
    operator delete(__dst);
  }

  return v30;
}

void sub_180DD626C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  JUMPOUT(0x180DD630CLL);
}

void sub_180DD6284()
{
  JUMPOUT(0x180DD630CLL);
}

void sub_180DD62AC()
{
}

void sub_180DD62B4()
{
}

void sub_180DD62BC()
{
}

void sub_180DD62DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0) {
    JUMPOUT(0x180DD6354);
  }
  JUMPOUT(0x180DD6344);
}

void sub_180DD62EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a20 < 0)
  {
    operator delete(a15);
    if ((a27 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((a27 & 0x80000000) == 0)
  {
LABEL_3:
    _Unwind_Resume(a1);
  }
  operator delete(a22);
  _Unwind_Resume(a1);
}

void sub_180DD62FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a20 < 0)
  {
    operator delete(a15);
    if ((a27 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((a27 & 0x80000000) == 0)
  {
LABEL_3:
    _Unwind_Resume(a1);
  }
  operator delete(a22);
  _Unwind_Resume(a1);
}

void sub_180DD6308(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a20 < 0)
  {
    operator delete(__p);
    if ((a27 & 0x80000000) == 0) {
      goto LABEL_3;
    }
  }
  else if ((a27 & 0x80000000) == 0)
  {
LABEL_3:
    _Unwind_Resume(a1);
  }
  operator delete(a22);
  _Unwind_Resume(a1);
}

MPSGraphViewerNodePortSPI *EmitViewerSPI::emitNodeInputPort(uint64_t a1, void *a2, unint64_t a3)
{
  id v5 = a2;
  if (a3)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v7 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(a3 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v8 = [MPSGraphViewerNodePortSPI alloc];
    uint64_t v9 = std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)(a1 + 232), a3);
    if (v9)
    {
      uint64_t v10 = v9[3];
    }
    else
    {
      if (MTLReportFailureTypeEnabled())
      {
        unint64_t v13 = a3;
        MTLReportFailure();
      }
      uint64_t v10 = -1;
    }
    unint64_t v11 = -[MPSGraphViewerNodePortSPI initWithName:dataType:shape:valueRef:](v8, "initWithName:dataType:shape:valueRef:", v5, MPSDataType, v7, v10, v13);
  }
  else
  {
    unint64_t v11 = 0;
  }

  return v11;
}

void sub_180DD69F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180DD6A00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180DD6A10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

MPSGraphViewerSPI *EmitViewerSPI::emitGraph(EmitViewerSPI *this)
{
  int8x8_t v2 = [MPSGraphViewerSPI alloc];
  v3 = [MEMORY[0x1E4F1C978] arrayWithArray:*((void *)this + 22)];
  int8x8_t v4 = [(MPSGraphViewerSPI *)v2 initWithName:&stru_1EC9D55D0 nodes:v3];

  return v4;
}

void sub_180DD6A9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void EmitViewerSPI::emitJSONDump(id *this, NSString *a2)
{
  v3 = a2;
  if (!v3)
  {
    id WeakRetained = (id *)objc_loadWeakRetained(this + 8);
    v3 = (NSString *)WeakRetained[67];
  }
  id v5 = (id *)objc_loadWeakRetained(this + 8);
  [v5[69] createDirectoryAtPath:v3 withIntermediateDirectories:1 attributes:0 error:0];

  size_t v6 = [NSString stringWithFormat:@"%@/model.mpsasteria", v3];
  uint64_t v7 = [MPSGraphViewerSPI alloc];
  uint64_t v8 = [MEMORY[0x1E4F1C978] arrayWithArray:this[22]];
  uint64_t v9 = [(MPSGraphViewerSPI *)v7 initWithName:&stru_1EC9D55D0 nodes:v8];

  uint64_t v10 = (void *)MEMORY[0x1E4F28D90];
  unint64_t v11 = [(MPSGraphViewerSPI *)v9 jsonDictionary];
  id v21 = 0;
  unint64_t v12 = [v10 dataWithJSONObject:v11 options:1 error:&v21];
  id v13 = v21;

  if (v12)
  {
    id v20 = v13;
    char v14 = [v12 writeToFile:v6 options:1 error:&v20];
    id v15 = v20;

    if ((v14 & 1) == 0)
    {
      id v16 = v6;
      if (!v15)
      {
        printf("EmitViewerSPI : unable to write model to %s", (const char *)[v16 UTF8String]);
        id v13 = 0;
        goto LABEL_12;
      }
      uint64_t v17 = (const char *)[v16 UTF8String];
      id v18 = [v15 description];
      printf("EmitViewerSPI : unable to write model to %s: %s\n", v17, (const char *)[v18 UTF8String]);
    }
    id v13 = v15;
  }
  else if (v13)
  {
    id v19 = [v13 description];
    printf("EmitViewerSPI : unable to serialize model: %s\n", (const char *)[v19 UTF8String]);
  }
  else
  {
    printf("EmitViewerSPI : unable to serialize model");
  }
LABEL_12:
}

void sub_180DD6CF8(_Unwind_Exception *a1)
{
  uint64_t v7 = v6;

  _Unwind_Resume(a1);
}

void sub_180DD6D8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

MPSGraphViewerNodePortSPI *EmitViewerSPI::emitNodeOutputPort(void *a1, uint64_t **a2)
{
  id v3 = a1;
  if (a2)
  {
    uint64_t MPSDataType = getMPSDataType(a2);
    id v5 = getMPSShapeFromMLIR(a2);
    size_t v6 = [[MPSGraphViewerNodePortSPI alloc] initWithName:v3 dataType:MPSDataType shape:v5 valueRef:-1];
  }
  else
  {
    size_t v6 = 0;
  }

  return v6;
}

void sub_180DD6E38(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180DD6E4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

MPSGraphViewerNodePropertyStringSPI *EmitViewerSPI::emitStringProperty(void *a1, const void *a2, size_t a3)
{
  id v5 = a1;
  size_t v6 = NSString;
  if (!a2)
  {
    long long __dst = 0;
    size_t v15 = 0;
    p_dst = (void **)&__dst;
    int64_t v16 = 0;
    goto LABEL_14;
  }
  if (a3 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  if (a3 >= 0x17)
  {
    uint64_t v9 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17) {
      uint64_t v9 = a3 | 7;
    }
    uint64_t v10 = v9 + 1;
    uint64_t v7 = (void **)operator new(v9 + 1);
    size_t v15 = a3;
    int64_t v16 = v10 | 0x8000000000000000;
    long long __dst = v7;
    goto LABEL_10;
  }
  HIBYTE(v16) = a3;
  uint64_t v7 = (void **)&__dst;
  if (a3) {
LABEL_10:
  }
    memmove(v7, a2, a3);
  *((unsigned char *)v7 + a3) = 0;
  if (v16 >= 0) {
    p_dst = (void **)&__dst;
  }
  else {
    p_dst = __dst;
  }
LABEL_14:
  unint64_t v11 = [v6 stringWithCString:p_dst encoding:4];
  if (SHIBYTE(v16) < 0) {
    operator delete(__dst);
  }
  unint64_t v12 = [[MPSGraphViewerNodePropertyStringSPI alloc] initWithName:v5 value:v11];

  return v12;
}

void sub_180DD6FA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180DD6FB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

MPSGraphViewerNodePropertyDataSPI *EmitViewerSPI::emitElementsAttrProperty(void *a1, uint64_t a2, uint64_t a3)
{
  v18[0] = a2;
  v18[1] = a3;
  id v5 = a1;
  mlir::mps::CPUNDArray::CPUNDArray(v17, a2, a3);
  uint64_t NumElements = mlir::mps::CPUNDArray::getNumElements((mlir::mps::CPUNDArray *)v17);
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v18);
  uint64_t MPSDataType = getMPSDataType(Type);
  uint64_t v9 = (uint64_t **)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v18);
  uint64_t v10 = getMPSShapeFromMLIR(v9);
  unint64_t v11 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:v5 dataType:MPSDataType shape:v10];
  if (!v11) {
    goto LABEL_13;
  }
  if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v18))
  {
    id v13 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v17[5] length:(NumElements * (unint64_t)(unsigned __int16)MPSDataType + 7) >> 3];
    [(MPSGraphViewerNodePropertyDataSPI *)v11 setValue:v13];
    goto LABEL_6;
  }
  if (mlir::mps::CPUNDArray::isComplexType((mlir::mps::CPUNDArray *)v17))
  {
    LODWORD(SplatIntegerValue) = mlir::mps::CPUNDArray::getSplatComplexValue(v17);
    HIDWORD(SplatIntegerValue) = v12;
    id v13 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&SplatIntegerValue length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v11 setSplatValue:v13];
LABEL_6:

    char v14 = v11;
    goto LABEL_14;
  }
  if (mlir::mps::CPUNDArray::isFloatType((mlir::mps::CPUNDArray *)v17))
  {
    LODWORD(SplatIntegerValue) = mlir::mps::CPUNDArray::getSplatFloatValue((mlir::mps::CPUNDArray *)v17);
    id v13 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&SplatIntegerValue length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v11 setSplatValue:v13];
    goto LABEL_6;
  }
  if (mlir::mps::CPUNDArray::isIntegerType((mlir::mps::CPUNDArray *)v17))
  {
    uint64_t SplatIntegerValue = mlir::mps::CPUNDArray::getSplatIntegerValue((mlir::mps::CPUNDArray *)v17);
    id v13 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&SplatIntegerValue length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v11 setSplatValue:v13];
    goto LABEL_6;
  }
  if (MTLReportFailureTypeEnabled())
  {
    MTLReportFailure();
    char v14 = 0;
  }
  else
  {
LABEL_13:
    char v14 = 0;
  }
LABEL_14:

  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v17);

  return v14;
}

void sub_180DD720C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)va);
  _Unwind_Resume(a1);
}

void sub_180DD727C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)va);
  _Unwind_Resume(a1);
}

void sub_180DD729C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)va);
  _Unwind_Resume(a1);
}

void sub_180DD72BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)va);

  _Unwind_Resume(a1);
}

void sub_180DD72D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180DD72E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)va);
  _Unwind_Resume(a1);
}

void sub_180DD7304(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);

  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)va);
  _Unwind_Resume(a1);
}

void sub_180DD7320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)va);

  _Unwind_Resume(a1);
}

void sub_180DD7338(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)va);

  _Unwind_Resume(a1);
}

void EmitViewerSPI::~EmitViewerSPI(EmitViewerSPI *this)
{
  EmitViewerSPI::~EmitViewerSPI(this);

  JUMPOUT(0x1852FDE70);
}

{
  void *v2;
  void *v3;
  void *v4;
  void **v5;
  void *v6;
  void **v7;
  uint64_t vars8;

  *(void *)this = &unk_1EC9864B0;
  int8x8_t v2 = (void *)*((void *)this + 31);
  if (v2)
  {
    do
    {
      id v3 = (void *)*v2;
      operator delete(v2);
      int8x8_t v2 = v3;
    }
    while (v3);
  }
  int8x8_t v4 = (void *)*((void *)this + 29);
  *((void *)this + 29) = 0;
  if (v4) {
    operator delete(v4);
  }
  id v5 = (void **)*((void *)this + 25);
  if (v5)
  {
    do
    {
      uint64_t v7 = (void **)*v5;
      if (*((char *)v5 + 39) < 0) {
        operator delete(v5[2]);
      }
      operator delete(v5);
      id v5 = v7;
    }
    while (v7);
  }
  size_t v6 = (void *)*((void *)this + 23);
  *((void *)this + 23) = 0;
  if (v6) {
    operator delete(v6);
  }

  EmitBase::~EmitBase(this);
}

uint64_t EmitViewerSPI::getNewTensorNameForValue(uint64_t a1, unint64_t a2)
{
  uint64_t v5 = *(void *)(a1 + 224);
  *(void *)(a1 + 224) = v5 + 1;
  unint64_t v6 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v7 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v6 >> 47) ^ v6);
  unint64_t v8 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
  unint64_t v9 = *(void *)(a1 + 240);
  if (v9)
  {
    uint8x8_t v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      unint64_t v2 = 0x9DDFEA08EB382D69 * (v7 ^ (v7 >> 47));
      if (v8 >= v9) {
        unint64_t v2 = v8 % v9;
      }
    }
    else
    {
      unint64_t v2 = (v9 - 1) & v8;
    }
    unint64_t v11 = *(void ***)(*(void *)(a1 + 232) + 8 * v2);
    if (v11)
    {
      int v12 = *v11;
      if (*v11)
      {
        if (v10.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v14 = v12[1];
            if (v14 == v8)
            {
              if (v12[2] == a2) {
                goto LABEL_93;
              }
            }
            else if ((v14 & (v9 - 1)) != v2)
            {
              goto LABEL_22;
            }
            int v12 = (void *)*v12;
            if (!v12) {
              goto LABEL_22;
            }
          }
        }
        do
        {
          unint64_t v13 = v12[1];
          if (v13 == v8)
          {
            if (v12[2] == a2) {
              goto LABEL_93;
            }
          }
          else
          {
            if (v13 >= v9) {
              v13 %= v9;
            }
            if (v13 != v2) {
              break;
            }
          }
          int v12 = (void *)*v12;
        }
        while (v12);
      }
    }
  }
LABEL_22:
  int v12 = operator new(0x20uLL);
  *int v12 = 0;
  v12[1] = v8;
  v12[2] = a2;
  v12[3] = 0;
  float v15 = (float)(unint64_t)(*(void *)(a1 + 256) + 1);
  float v16 = *(float *)(a1 + 264);
  if (!v9 || (float)(v16 * (float)v9) < v15)
  {
    BOOL v19 = 1;
    if (v9 >= 3) {
      BOOL v19 = (v9 & (v9 - 1)) != 0;
    }
    unint64_t v20 = v19 | (2 * v9);
    unint64_t v21 = vcvtps_u32_f32(v15 / v16);
    if (v20 <= v21) {
      size_t prime = v21;
    }
    else {
      size_t prime = v20;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v9 = *(void *)(a1 + 240);
    }
    if (prime > v9)
    {
LABEL_36:
      if (prime >> 61) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v23 = operator new(8 * prime);
      uint64_t v24 = *(void **)(a1 + 232);
      *(void *)(a1 + 232) = v23;
      if (v24) {
        operator delete(v24);
      }
      uint64_t v25 = 0;
      *(void *)(a1 + 240) = prime;
      do
        *(void *)(*(void *)(a1 + 232) + 8 * v25++) = 0;
      while (prime != v25);
      uint64_t v27 = a1 + 248;
      uint64_t v26 = *(void **)(a1 + 248);
      if (!v26) {
        goto LABEL_68;
      }
      size_t v28 = v26[1];
      size_t v29 = prime - 1;
      if ((prime & (prime - 1)) == 0)
      {
        size_t v30 = v28 & v29;
        *(void *)(*(void *)(a1 + 232) + 8 * v30) = v27;
        for (uint64_t i = (void *)*v26; *v26; uint64_t i = (void *)*v26)
        {
          size_t v32 = i[1] & v29;
          if (v32 == v30)
          {
            uint64_t v26 = i;
          }
          else
          {
            uint64_t v33 = *(void *)(a1 + 232);
            if (*(void *)(v33 + 8 * v32))
            {
              *uint64_t v26 = *i;
              uint64_t v34 = 8 * v32;
              *uint64_t i = **(void **)(*(void *)(a1 + 232) + v34);
              **(void **)(*(void *)(a1 + 232) + v34) = i;
            }
            else
            {
              *(void *)(v33 + 8 * v32) = v26;
              uint64_t v26 = i;
              size_t v30 = v32;
            }
          }
        }
        goto LABEL_68;
      }
      if (v28 >= prime) {
        v28 %= prime;
      }
      *(void *)(*(void *)(a1 + 232) + 8 * v28) = v27;
      uint64_t v38 = (void *)*v26;
      if (!*v26)
      {
LABEL_68:
        unint64_t v9 = prime;
        uint64_t v42 = prime - 1;
        if ((prime & (prime - 1)) != 0) {
          goto LABEL_69;
        }
        goto LABEL_84;
      }
      while (1)
      {
        size_t v40 = v38[1];
        if (v40 >= prime) {
          v40 %= prime;
        }
        if (v40 == v28) {
          goto LABEL_62;
        }
        uint64_t v41 = *(void *)(a1 + 232);
        if (*(void *)(v41 + 8 * v40))
        {
          *uint64_t v26 = *v38;
          uint64_t v39 = 8 * v40;
          *uint64_t v38 = **(void **)(*(void *)(a1 + 232) + v39);
          **(void **)(*(void *)(a1 + 232) + v39) = v38;
          uint64_t v38 = v26;
LABEL_62:
          uint64_t v26 = v38;
          uint64_t v38 = (void *)*v38;
          if (!v38) {
            goto LABEL_68;
          }
        }
        else
        {
          *(void *)(v41 + 8 * v40) = v26;
          uint64_t v26 = v38;
          uint64_t v38 = (void *)*v38;
          size_t v28 = v40;
          if (!v38) {
            goto LABEL_68;
          }
        }
      }
    }
    if (prime < v9)
    {
      unint64_t v35 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 256) / *(float *)(a1 + 264));
      if (v9 < 3 || (uint8x8_t v36 = (uint8x8_t)vcnt_s8((int8x8_t)v9), v36.i16[0] = vaddlv_u8(v36), v36.u32[0] > 1uLL))
      {
        unint64_t v35 = std::__next_prime(v35);
      }
      else
      {
        uint64_t v37 = 1 << -(char)__clz(v35 - 1);
        if (v35 >= 2) {
          unint64_t v35 = v37;
        }
      }
      if (prime <= v35) {
        size_t prime = v35;
      }
      if (prime < v9)
      {
        if (!prime)
        {
          uint8x8_t v43 = *(void **)(a1 + 232);
          *(void *)(a1 + 232) = 0;
          if (v43) {
            operator delete(v43);
          }
          unint64_t v9 = 0;
          *(void *)(a1 + 240) = 0;
          uint64_t v42 = -1;
          goto LABEL_84;
        }
        goto LABEL_36;
      }
      unint64_t v9 = *(void *)(a1 + 240);
    }
    uint64_t v42 = v9 - 1;
    if ((v9 & (v9 - 1)) != 0)
    {
LABEL_69:
      if (v8 >= v9)
      {
        unint64_t v2 = v8 % v9;
        uint64_t v17 = *(void *)(a1 + 232);
        id v18 = *(void **)(v17 + 8 * (v8 % v9));
        if (v18) {
          goto LABEL_25;
        }
      }
      else
      {
        unint64_t v2 = v8;
        uint64_t v17 = *(void *)(a1 + 232);
        id v18 = *(void **)(v17 + 8 * v8);
        if (v18) {
          goto LABEL_25;
        }
      }
      goto LABEL_85;
    }
LABEL_84:
    unint64_t v2 = v42 & v8;
    uint64_t v17 = *(void *)(a1 + 232);
    id v18 = *(void **)(v17 + 8 * (v42 & v8));
    if (v18) {
      goto LABEL_25;
    }
    goto LABEL_85;
  }
  uint64_t v17 = *(void *)(a1 + 232);
  id v18 = *(void **)(v17 + 8 * v2);
  if (v18)
  {
LABEL_25:
    *int v12 = *v18;
LABEL_91:
    *id v18 = v12;
    goto LABEL_92;
  }
LABEL_85:
  *int v12 = *(void *)(a1 + 248);
  *(void *)(a1 + 248) = v12;
  *(void *)(v17 + 8 * v2) = a1 + 248;
  if (*v12)
  {
    unint64_t v44 = *(void *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v44 >= v9) {
        v44 %= v9;
      }
    }
    else
    {
      v44 &= v9 - 1;
    }
    id v18 = (void *)(*(void *)(a1 + 232) + 8 * v44);
    goto LABEL_91;
  }
LABEL_92:
  ++*(void *)(a1 + 256);
LABEL_93:
  v12[3] = v5;
  return v5;
}

void sub_180DD7870(_Unwind_Exception *a1)
{
  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::func::FuncOp,mlir::Operation &,llvm::CastInfo<mlir::func::FuncOp,mlir::Operation,void>>::doCastIfPossible(uint64_t result)
{
  uint64_t v1 = *(void *)(result + 48);
  unint64_t v2 = *(void **)(v1 + 16);
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v10[0] = *(void *)(v1 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v10);
    if (v4 == 9 && *(void *)AttrData == 0x6E75662E636E7566 && *(unsigned char *)(AttrData + 8) == 99)
    {
      __int16 v9 = 1283;
      v8[0] = (uint64_t)"classof on '";
      v8[2] = (uint64_t)"func.func";
      v8[3] = 9;
      unint64_t v6 = "' failed due to the operation not being registered";
      __int16 v7 = 259;
      llvm::operator+(v8, (uint64_t *)&v6, (uint64_t)v10);
      llvm::report_fatal_error((llvm::Twine *)v10, 1);
    }
    return 0;
  }
  else if (v2 != &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    return 0;
  }
  return result;
}

EmitterViewerSPI::ANECA11LegacyOpHandler *EmitterViewerSPI::ANECA11LegacyOpHandler::ANECA11LegacyOpHandler(EmitterViewerSPI::ANECA11LegacyOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9875B0;
  uint64_t v4 = *((void *)a3 + 6);
  uint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 14 && *AttrData == 0x3131412E63656E61 && *(void *)((char *)AttrData + 6) == 0x79636167654C3131)
    {
      __int16 v62 = 1283;
      v61[0] = (uint64_t)"classof on '";
      v61[2] = (uint64_t)"anec.A11Legacy";
      v61[3] = 14;
      unint64_t v59 = "' failed due to the operation not being registered";
      __int16 v60 = 259;
      llvm::operator+(v61, (uint64_t *)&v59, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_58:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A11Legacy,void>::id) {
    goto LABEL_58;
  }
  unint64_t v58 = a3;
  v61[0] = *(void *)(v4 + 8);
  __int16 v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v61);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint8x8_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v64 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v64) = v8;
  uint8x8_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v64 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
  char v57 = [MEMORY[0x1E4F1CA48] array];
  float v15 = [MEMORY[0x1E4F1CA48] array];
  int v55 = [MEMORY[0x1E4F1CA48] array];
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v58);
  id v18 = EmitViewerSPI::emitStringProperty(@"sym_name", SymName, v17);
  if (v18) {
    [v55 addObject:v18];
  }
  unint64_t v19 = 0;
  v61[0] = mlir::anec::A11Legacy::getFunctionType(&v58);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v61))
  {
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)v61);
    if (v21 <= v19) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v22 = *(uint64_t ***)(Results + 8 * v19);
    uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"result%d", v19);
    uint64_t v24 = EmitViewerSPI::emitNodeOutputPort(v23, v22);

    if (v24) {
      [v15 addObject:v24];
    }

    ++v19;
  }

  int v56 = [MEMORY[0x1E4F1CA48] array];
  char v54 = (void *)v14;
  unint64_t Body = (void *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v58);
  uint64_t v26 = (void *)*Body;
  if ((void *)*Body != Body)
  {
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = Body[1];
      uint64_t v29 = v28 - 8;
      if (!v28) {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v29 + 48);
      uint64_t v31 = *(void *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3)) {
        break;
      }
      if (v27 >= v31 >> 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      size_t v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)a2 + 29, *(void *)(v30 + 8 * v27)))
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        uint64_t v34 = };

        if (v34) {
          [v57 addObject:v34];
        }

        uint64_t v26 = (void *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  id v35 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (uint64_t i = (void *)Body[1]; i != Body; uint64_t i = (void *)i[1])
  {
    unint64_t v46 = i - 1;
    if (!i) {
      unint64_t v46 = 0;
    }
    long long v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (uint64_t j = (mlir::GenericProgramPoint *)v46[5]; j != v47; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      uint64_t v50 = EmitViewerSPI::emitNode(a2, v49);
      if (v50) {
        [v35 addObject:v50];
      }
    }
  }
  uint64_t v37 = [[MPSGraphViewerNodeRegionSPI alloc] initWithName:@"body" returnType:@"anec.region_return" nodes:v35];
  [v56 addObject:v37];

  uint64_t v38 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v57];
  size_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v54 inputs:v39 outputs:v40 properties:v41 regions:v42];
  unint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v64) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DD7F8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }

  _Unwind_Resume(a1);
}

void *std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>(void *a1, unint64_t a2)
{
  int8x8_t v2 = (int8x8_t)a1[1];
  if (!*(void *)&v2) {
    return 0;
  }
  unint64_t v3 = 0x9DDFEA08EB382D69 * (((8 * a2) + 8) ^ HIDWORD(a2));
  unint64_t v4 = 0x9DDFEA08EB382D69 * (HIDWORD(a2) ^ (v3 >> 47) ^ v3);
  unint64_t v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  uint8x8_t v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    unint64_t v7 = v5;
    if (v5 >= *(void *)&v2) {
      unint64_t v7 = v5 % *(void *)&v2;
    }
  }
  else
  {
    unint64_t v7 = (*(void *)&v2 - 1) & v5;
  }
  size_t v8 = *(void **)(*a1 + 8 * v7);
  if (!v8) {
    return 0;
  }
  uint64_t result = (void *)*v8;
  if (*v8)
  {
    if (v6.u32[0] < 2uLL)
    {
      uint64_t v10 = *(void *)&v2 - 1;
      while (1)
      {
        uint64_t v12 = result[1];
        if (v12 == v5)
        {
          if (result[2] == a2) {
            return result;
          }
        }
        else if ((v12 & v10) != v7)
        {
          return 0;
        }
        uint64_t result = (void *)*result;
        if (!result) {
          return result;
        }
      }
    }
    do
    {
      unint64_t v11 = result[1];
      if (v11 == v5)
      {
        if (result[2] == a2) {
          return result;
        }
      }
      else
      {
        if (v11 >= *(void *)&v2) {
          v11 %= *(void *)&v2;
        }
        if (v11 != v7) {
          return 0;
        }
      }
      uint64_t result = (void *)*result;
    }
    while (result);
  }
  return result;
}

EmitterViewerSPI::ANECA12OpHandler *EmitterViewerSPI::ANECA12OpHandler::ANECA12OpHandler(EmitterViewerSPI::ANECA12OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9867D0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3231412E63656E61)
    {
      __int16 v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A12";
      v60[3] = 8;
      unint64_t v58 = "' failed due to the operation not being registered";
      __int16 v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A12,void>::id) {
    goto LABEL_54;
  }
  char v57 = a3;
  v60[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v63 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
  int v56 = [MEMORY[0x1E4F1CA48] array];
  float v15 = [MEMORY[0x1E4F1CA48] array];
  char v54 = [MEMORY[0x1E4F1CA48] array];
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  id v18 = EmitViewerSPI::emitStringProperty(@"sym_name", SymName, v17);
  if (v18) {
    [v54 addObject:v18];
  }
  unint64_t v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v22 = *(uint64_t ***)(Results + 8 * v19);
    uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"result%d", v19);
    uint64_t v24 = EmitViewerSPI::emitNodeOutputPort(v23, v22);

    if (v24) {
      [v15 addObject:v24];
    }

    ++v19;
  }

  int v55 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v53 = (void *)v14;
  unint64_t Body = (void *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  uint64_t v26 = (void *)*Body;
  if ((void *)*Body != Body)
  {
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = Body[1];
      uint64_t v29 = v28 - 8;
      if (!v28) {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v29 + 48);
      uint64_t v31 = *(void *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3)) {
        break;
      }
      if (v27 >= v31 >> 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      size_t v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)a2 + 29, *(void *)(v30 + 8 * v27)))
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        uint64_t v34 = };

        if (v34) {
          [v56 addObject:v34];
        }

        uint64_t v26 = (void *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  id v35 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (uint64_t i = (void *)Body[1]; i != Body; uint64_t i = (void *)i[1])
  {
    unint64_t v46 = i - 1;
    if (!i) {
      unint64_t v46 = 0;
    }
    long long v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (uint64_t j = (mlir::GenericProgramPoint *)v46[5]; j != v47; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      uint64_t v50 = EmitViewerSPI::emitNode(a2, v49);
      if (v50) {
        [v35 addObject:v50];
      }
    }
  }
  uint64_t v37 = [[MPSGraphViewerNodeRegionSPI alloc] initWithName:@"body" returnType:@"anec.region_return" nodes:v35];
  [v55 addObject:v37];

  uint64_t v38 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  size_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v54];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v53 inputs:v39 outputs:v40 properties:v41 regions:v42];
  unint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v63) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DD8820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA13OpHandler *EmitterViewerSPI::ANECA13OpHandler::ANECA13OpHandler(EmitterViewerSPI::ANECA13OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9867E8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3331412E63656E61)
    {
      __int16 v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A13";
      v60[3] = 8;
      unint64_t v58 = "' failed due to the operation not being registered";
      __int16 v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A13,void>::id) {
    goto LABEL_54;
  }
  char v57 = a3;
  v60[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v63 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
  int v56 = [MEMORY[0x1E4F1CA48] array];
  float v15 = [MEMORY[0x1E4F1CA48] array];
  char v54 = [MEMORY[0x1E4F1CA48] array];
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  id v18 = EmitViewerSPI::emitStringProperty(@"sym_name", SymName, v17);
  if (v18) {
    [v54 addObject:v18];
  }
  unint64_t v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v22 = *(uint64_t ***)(Results + 8 * v19);
    uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"result%d", v19);
    uint64_t v24 = EmitViewerSPI::emitNodeOutputPort(v23, v22);

    if (v24) {
      [v15 addObject:v24];
    }

    ++v19;
  }

  int v55 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v53 = (void *)v14;
  unint64_t Body = (void *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  uint64_t v26 = (void *)*Body;
  if ((void *)*Body != Body)
  {
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = Body[1];
      uint64_t v29 = v28 - 8;
      if (!v28) {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v29 + 48);
      uint64_t v31 = *(void *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3)) {
        break;
      }
      if (v27 >= v31 >> 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      size_t v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)a2 + 29, *(void *)(v30 + 8 * v27)))
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        uint64_t v34 = };

        if (v34) {
          [v56 addObject:v34];
        }

        uint64_t v26 = (void *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  id v35 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (uint64_t i = (void *)Body[1]; i != Body; uint64_t i = (void *)i[1])
  {
    unint64_t v46 = i - 1;
    if (!i) {
      unint64_t v46 = 0;
    }
    long long v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (uint64_t j = (mlir::GenericProgramPoint *)v46[5]; j != v47; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      uint64_t v50 = EmitViewerSPI::emitNode(a2, v49);
      if (v50) {
        [v35 addObject:v50];
      }
    }
  }
  uint64_t v37 = [[MPSGraphViewerNodeRegionSPI alloc] initWithName:@"body" returnType:@"anec.region_return" nodes:v35];
  [v55 addObject:v37];

  uint64_t v38 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  size_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v54];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v53 inputs:v39 outputs:v40 properties:v41 regions:v42];
  unint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v63) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DD8FA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA14OpHandler *EmitterViewerSPI::ANECA14OpHandler::ANECA14OpHandler(EmitterViewerSPI::ANECA14OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986800;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3431412E63656E61)
    {
      __int16 v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A14";
      v60[3] = 8;
      unint64_t v58 = "' failed due to the operation not being registered";
      __int16 v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A14,void>::id) {
    goto LABEL_54;
  }
  char v57 = a3;
  v60[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v63 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
  int v56 = [MEMORY[0x1E4F1CA48] array];
  float v15 = [MEMORY[0x1E4F1CA48] array];
  char v54 = [MEMORY[0x1E4F1CA48] array];
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  id v18 = EmitViewerSPI::emitStringProperty(@"sym_name", SymName, v17);
  if (v18) {
    [v54 addObject:v18];
  }
  unint64_t v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v22 = *(uint64_t ***)(Results + 8 * v19);
    uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"result%d", v19);
    uint64_t v24 = EmitViewerSPI::emitNodeOutputPort(v23, v22);

    if (v24) {
      [v15 addObject:v24];
    }

    ++v19;
  }

  int v55 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v53 = (void *)v14;
  unint64_t Body = (void *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  uint64_t v26 = (void *)*Body;
  if ((void *)*Body != Body)
  {
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = Body[1];
      uint64_t v29 = v28 - 8;
      if (!v28) {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v29 + 48);
      uint64_t v31 = *(void *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3)) {
        break;
      }
      if (v27 >= v31 >> 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      size_t v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)a2 + 29, *(void *)(v30 + 8 * v27)))
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        uint64_t v34 = };

        if (v34) {
          [v56 addObject:v34];
        }

        uint64_t v26 = (void *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  id v35 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (uint64_t i = (void *)Body[1]; i != Body; uint64_t i = (void *)i[1])
  {
    unint64_t v46 = i - 1;
    if (!i) {
      unint64_t v46 = 0;
    }
    long long v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (uint64_t j = (mlir::GenericProgramPoint *)v46[5]; j != v47; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      uint64_t v50 = EmitViewerSPI::emitNode(a2, v49);
      if (v50) {
        [v35 addObject:v50];
      }
    }
  }
  uint64_t v37 = [[MPSGraphViewerNodeRegionSPI alloc] initWithName:@"body" returnType:@"anec.region_return" nodes:v35];
  [v55 addObject:v37];

  uint64_t v38 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  size_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v54];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v53 inputs:v39 outputs:v40 properties:v41 regions:v42];
  unint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v63) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DD9720(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA15OpHandler *EmitterViewerSPI::ANECA15OpHandler::ANECA15OpHandler(EmitterViewerSPI::ANECA15OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986818;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3531412E63656E61)
    {
      __int16 v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A15";
      v60[3] = 8;
      unint64_t v58 = "' failed due to the operation not being registered";
      __int16 v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A15,void>::id) {
    goto LABEL_54;
  }
  char v57 = a3;
  v60[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v63 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
  int v56 = [MEMORY[0x1E4F1CA48] array];
  float v15 = [MEMORY[0x1E4F1CA48] array];
  char v54 = [MEMORY[0x1E4F1CA48] array];
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  id v18 = EmitViewerSPI::emitStringProperty(@"sym_name", SymName, v17);
  if (v18) {
    [v54 addObject:v18];
  }
  unint64_t v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v22 = *(uint64_t ***)(Results + 8 * v19);
    uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"result%d", v19);
    uint64_t v24 = EmitViewerSPI::emitNodeOutputPort(v23, v22);

    if (v24) {
      [v15 addObject:v24];
    }

    ++v19;
  }

  int v55 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v53 = (void *)v14;
  unint64_t Body = (void *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  uint64_t v26 = (void *)*Body;
  if ((void *)*Body != Body)
  {
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = Body[1];
      uint64_t v29 = v28 - 8;
      if (!v28) {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v29 + 48);
      uint64_t v31 = *(void *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3)) {
        break;
      }
      if (v27 >= v31 >> 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      size_t v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)a2 + 29, *(void *)(v30 + 8 * v27)))
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        uint64_t v34 = };

        if (v34) {
          [v56 addObject:v34];
        }

        uint64_t v26 = (void *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  id v35 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (uint64_t i = (void *)Body[1]; i != Body; uint64_t i = (void *)i[1])
  {
    unint64_t v46 = i - 1;
    if (!i) {
      unint64_t v46 = 0;
    }
    long long v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (uint64_t j = (mlir::GenericProgramPoint *)v46[5]; j != v47; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      uint64_t v50 = EmitViewerSPI::emitNode(a2, v49);
      if (v50) {
        [v35 addObject:v50];
      }
    }
  }
  uint64_t v37 = [[MPSGraphViewerNodeRegionSPI alloc] initWithName:@"body" returnType:@"anec.region_return" nodes:v35];
  [v55 addObject:v37];

  uint64_t v38 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  size_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v54];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v53 inputs:v39 outputs:v40 properties:v41 regions:v42];
  unint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v63) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DD9EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA16OpHandler *EmitterViewerSPI::ANECA16OpHandler::ANECA16OpHandler(EmitterViewerSPI::ANECA16OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986830;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3631412E63656E61)
    {
      __int16 v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A16";
      v60[3] = 8;
      unint64_t v58 = "' failed due to the operation not being registered";
      __int16 v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A16,void>::id) {
    goto LABEL_54;
  }
  char v57 = a3;
  v60[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v63 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
  int v56 = [MEMORY[0x1E4F1CA48] array];
  float v15 = [MEMORY[0x1E4F1CA48] array];
  char v54 = [MEMORY[0x1E4F1CA48] array];
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  id v18 = EmitViewerSPI::emitStringProperty(@"sym_name", SymName, v17);
  if (v18) {
    [v54 addObject:v18];
  }
  unint64_t v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v22 = *(uint64_t ***)(Results + 8 * v19);
    uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"result%d", v19);
    uint64_t v24 = EmitViewerSPI::emitNodeOutputPort(v23, v22);

    if (v24) {
      [v15 addObject:v24];
    }

    ++v19;
  }

  int v55 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v53 = (void *)v14;
  unint64_t Body = (void *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  uint64_t v26 = (void *)*Body;
  if ((void *)*Body != Body)
  {
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = Body[1];
      uint64_t v29 = v28 - 8;
      if (!v28) {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v29 + 48);
      uint64_t v31 = *(void *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3)) {
        break;
      }
      if (v27 >= v31 >> 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      size_t v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)a2 + 29, *(void *)(v30 + 8 * v27)))
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        uint64_t v34 = };

        if (v34) {
          [v56 addObject:v34];
        }

        uint64_t v26 = (void *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  id v35 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (uint64_t i = (void *)Body[1]; i != Body; uint64_t i = (void *)i[1])
  {
    unint64_t v46 = i - 1;
    if (!i) {
      unint64_t v46 = 0;
    }
    long long v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (uint64_t j = (mlir::GenericProgramPoint *)v46[5]; j != v47; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      uint64_t v50 = EmitViewerSPI::emitNode(a2, v49);
      if (v50) {
        [v35 addObject:v50];
      }
    }
  }
  uint64_t v37 = [[MPSGraphViewerNodeRegionSPI alloc] initWithName:@"body" returnType:@"anec.region_return" nodes:v35];
  [v55 addObject:v37];

  uint64_t v38 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  size_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v54];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v53 inputs:v39 outputs:v40 properties:v41 regions:v42];
  unint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v63) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDA620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECA17OpHandler *EmitterViewerSPI::ANECA17OpHandler::ANECA17OpHandler(EmitterViewerSPI::ANECA17OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC97E188;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 8 && *AttrData == 0x3731412E63656E61)
    {
      __int16 v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.A17";
      v60[3] = 8;
      unint64_t v58 = "' failed due to the operation not being registered";
      __int16 v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_54:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::A17,void>::id) {
    goto LABEL_54;
  }
  char v57 = a3;
  v60[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v63 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
  int v56 = [MEMORY[0x1E4F1CA48] array];
  float v15 = [MEMORY[0x1E4F1CA48] array];
  char v54 = [MEMORY[0x1E4F1CA48] array];
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v57);
  id v18 = EmitViewerSPI::emitStringProperty(@"sym_name", SymName, v17);
  if (v18) {
    [v54 addObject:v18];
  }
  unint64_t v19 = 0;
  v60[0] = mlir::anec::A11Legacy::getFunctionType(&v57);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v60))
  {
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)v60);
    if (v21 <= v19) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v22 = *(uint64_t ***)(Results + 8 * v19);
    uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"result%d", v19);
    uint64_t v24 = EmitViewerSPI::emitNodeOutputPort(v23, v22);

    if (v24) {
      [v15 addObject:v24];
    }

    ++v19;
  }

  int v55 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v53 = (void *)v14;
  unint64_t Body = (void *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v57);
  uint64_t v26 = (void *)*Body;
  if ((void *)*Body != Body)
  {
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = Body[1];
      uint64_t v29 = v28 - 8;
      if (!v28) {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v29 + 48);
      uint64_t v31 = *(void *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3)) {
        break;
      }
      if (v27 >= v31 >> 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      size_t v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)a2 + 29, *(void *)(v30 + 8 * v27)))
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        uint64_t v34 = };

        if (v34) {
          [v56 addObject:v34];
        }

        uint64_t v26 = (void *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  id v35 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (uint64_t i = (void *)Body[1]; i != Body; uint64_t i = (void *)i[1])
  {
    unint64_t v46 = i - 1;
    if (!i) {
      unint64_t v46 = 0;
    }
    long long v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (uint64_t j = (mlir::GenericProgramPoint *)v46[5]; j != v47; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      uint64_t v50 = EmitViewerSPI::emitNode(a2, v49);
      if (v50) {
        [v35 addObject:v50];
      }
    }
  }
  uint64_t v37 = [[MPSGraphViewerNodeRegionSPI alloc] initWithName:@"body" returnType:@"anec.region_return" nodes:v35];
  [v55 addObject:v37];

  uint64_t v38 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  size_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v54];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v53 inputs:v39 outputs:v40 properties:v41 regions:v42];
  unint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v63) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDADA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECArgMinMaxOpHandler *EmitterViewerSPI::ANECArgMinMaxOpHandler::ANECArgMinMaxOpHandler(EmitterViewerSPI::ANECArgMinMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9875C8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v71 == 16 && *AttrData == 0x6772612E63656E61 && AttrData[1] == 0x78616D5F6E696D5FLL)
    {
      __int16 v78 = 1283;
      v77[0] = (uint64_t)"classof on '";
      v77[2] = (uint64_t)"anec.arg_min_max";
      v77[3] = 16;
      size_t v75 = "' failed due to the operation not being registered";
      __int16 v76 = 259;
      llvm::operator+(v77, (uint64_t *)&v75, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_77:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ArgMinMax,void>::id) {
    goto LABEL_77;
  }
  uint64_t v74 = a3;
  v77[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v77);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v80 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v80) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v80 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  id v73 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v74);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v74);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::ArgMinMax::getAxes((mlir::anec::ArgMinMax *)&v74);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    unint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    unint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_59:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    unint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_59;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"axes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  uint64_t Mode = mlir::anec::ArgMinMax::getMode(&v74);
  uint64_t v33 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Min" value:0];
  [v33 addObject:v34];

  id v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Max" value:1];
  [v33 addObject:v35];

  uint8x8_t v36 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"mode" type:@"ANECArgMinMaxMode" cases:v33 value:Mode];
  if (v36) {
    [v23 addObject:v36];
  }

  KernelSize = (uint64_t **)mlir::anec::ArgMinMax::getKernelSize((mlir::anec::ArgMinMax *)&v74);
  uint64_t v38 = KernelSize;
  if (!KernelSize)
  {
    uint64_t v39 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelSize))
  {
    size_t v40 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v41 = 692;
    uint64_t v42 = "Casting.h";
    uint64_t v43 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v38))
  {
    size_t v40 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v41 = 566;
    uint64_t v42 = "Casting.h";
    uint64_t v43 = "cast";
LABEL_62:
    __assert_rtn(v43, v42, v41, v40);
  }
  uint64_t v39 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v38);
  if (!v39)
  {
    size_t v40 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v41 = 98;
    uint64_t v42 = "InterfaceSupport.h";
    uint64_t v43 = "Interface";
    goto LABEL_62;
  }
LABEL_36:
  unint64_t v44 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_size", (uint64_t)v38, v39);
  if (v44) {
    [v23 addObject:v44];
  }
  StrideValues = (uint64_t **)mlir::anec::ArgMinMax::getStrideValues((mlir::anec::ArgMinMax *)&v74);
  unint64_t v46 = StrideValues;
  if (!StrideValues)
  {
    uint64_t v47 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(StrideValues))
  {
    uint64_t v48 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v49 = 692;
    uint64_t v50 = "Casting.h";
    BOOL v51 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v46))
  {
    uint64_t v48 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v49 = 566;
    uint64_t v50 = "Casting.h";
    BOOL v51 = "cast";
LABEL_65:
    __assert_rtn(v51, v50, v49, v48);
  }
  uint64_t v47 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v46);
  if (!v47)
  {
    uint64_t v48 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v49 = 98;
    uint64_t v50 = "InterfaceSupport.h";
    BOOL v51 = "Interface";
    goto LABEL_65;
  }
LABEL_44:
  uint64_t v52 = EmitViewerSPI::emitElementsAttrProperty(@"stride_values", (uint64_t)v46, v47);
  if (v52) {
    [v23 addObject:v52];
  }
  PadValues = (uint64_t **)mlir::anec::ArgMinMax::getPadValues((mlir::anec::ArgMinMax *)&v74);
  char v54 = PadValues;
  if (!PadValues)
  {
    uint64_t v55 = 0;
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(PadValues))
  {
    int v56 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v57 = 692;
    unint64_t v58 = "Casting.h";
    __int16 v59 = "cast_if_present";
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v54))
  {
    int v56 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v57 = 566;
    unint64_t v58 = "Casting.h";
    __int16 v59 = "cast";
LABEL_68:
    __assert_rtn(v59, v58, v57, v56);
  }
  uint64_t v55 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v54);
  if (!v55)
  {
    int v56 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v57 = 98;
    unint64_t v58 = "InterfaceSupport.h";
    __int16 v59 = "Interface";
    goto LABEL_68;
  }
LABEL_52:
  __int16 v60 = EmitViewerSPI::emitElementsAttrProperty(@"pad_values", (uint64_t)v54, v55);
  if (v60) {
    [v23 addObject:v60];
  }

  __int16 v61 = [MEMORY[0x1E4F1CA48] array];
  __int16 v62 = [MPSGraphViewerNodeSPI alloc];
  int64_t v63 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int64_t v64 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  char v65 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  char v66 = [MEMORY[0x1E4F1C978] arrayWithArray:v61];
  uint64_t v67 = [(MPSGraphViewerNodeSPI *)v62 initWithType:v73 inputs:v63 outputs:v64 properties:v65 regions:v66];
  unint64_t v68 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v67;

  if (SHIBYTE(v80) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDB738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECAveragePoolOpHandler *EmitterViewerSPI::ANECAveragePoolOpHandler::ANECAveragePoolOpHandler(EmitterViewerSPI::ANECAveragePoolOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987928;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v59 == 17)
    {
      BOOL v60 = *(void *)AttrData == 0x6576612E63656E61 && *(void *)(AttrData + 8) == 0x6F6F705F65676172;
      if (v60 && *(unsigned char *)(AttrData + 16) == 108)
      {
        __int16 v68 = 1283;
        v67[0] = (uint64_t)"classof on '";
        v67[2] = (uint64_t)"anec.average_pool";
        v67[3] = 17;
        char v65 = "' failed due to the operation not being registered";
        __int16 v66 = 259;
        llvm::operator+(v67, (uint64_t *)&v65, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_69:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id) {
    goto LABEL_69;
  }
  int64_t v64 = a3;
  v67[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v67);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v70 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v70) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v70 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v62 = [NSString stringWithCString:v13 encoding:4];
  int64_t v63 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v64);
  float v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v63 addObject:v15];
  }

  uint64_t v16 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v17 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v64);
  uint64_t v18 = @"result";
  if (v17)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v20 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v17)];

    if (v21) {
      [v16 addObject:v21];
    }
  }
  else
  {

    unint64_t v21 = 0;
  }

  unint64_t v22 = [MEMORY[0x1E4F1CA48] array];
  Stride = (uint64_t **)mlir::anec::AveragePool::getStride((mlir::anec::AveragePool *)&v64);
  uint64_t v24 = Stride;
  if (!Stride)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    uint64_t v26 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v27 = 692;
    int v28 = "Casting.h";
    uint64_t v29 = "cast_if_present";
    goto LABEL_51;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24))
  {
    uint64_t v26 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v27 = 566;
    int v28 = "Casting.h";
    uint64_t v29 = "cast";
LABEL_51:
    __assert_rtn(v29, v28, v27, v26);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24);
  if (!InterfaceFor)
  {
    uint64_t v26 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v27 = 98;
    int v28 = "InterfaceSupport.h";
    uint64_t v29 = "Interface";
    goto LABEL_51;
  }
LABEL_26:
  uint64_t v30 = EmitViewerSPI::emitElementsAttrProperty(@"stride", (uint64_t)v24, InterfaceFor);
  if (v30) {
    [v22 addObject:v30];
  }
  Padding = (uint64_t **)mlir::anec::AveragePool::getPadding((mlir::anec::AveragePool *)&v64);
  size_t v32 = Padding;
  if (!Padding)
  {
    uint64_t v33 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    uint64_t v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v35 = 692;
    uint8x8_t v36 = "Casting.h";
    uint64_t v37 = "cast_if_present";
    goto LABEL_54;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    uint64_t v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v35 = 566;
    uint8x8_t v36 = "Casting.h";
    uint64_t v37 = "cast";
LABEL_54:
    __assert_rtn(v37, v36, v35, v34);
  }
  uint64_t v33 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!v33)
  {
    uint64_t v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v35 = 98;
    uint8x8_t v36 = "InterfaceSupport.h";
    uint64_t v37 = "Interface";
    goto LABEL_54;
  }
LABEL_34:
  uint64_t v38 = EmitViewerSPI::emitElementsAttrProperty(@"padding", (uint64_t)v32, v33);
  if (v38) {
    [v22 addObject:v38];
  }
  Dilation = (uint64_t **)mlir::anec::Convolution::getDilation((mlir::anec::Convolution *)&v64);
  size_t v40 = Dilation;
  if (!Dilation)
  {
    uint64_t v41 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Dilation))
  {
    uint64_t v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v43 = 692;
    unint64_t v44 = "Casting.h";
    uint64_t v45 = "cast_if_present";
    goto LABEL_57;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    uint64_t v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v43 = 566;
    unint64_t v44 = "Casting.h";
    uint64_t v45 = "cast";
LABEL_57:
    __assert_rtn(v45, v44, v43, v42);
  }
  uint64_t v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    uint64_t v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v43 = 98;
    unint64_t v44 = "InterfaceSupport.h";
    uint64_t v45 = "Interface";
    goto LABEL_57;
  }
LABEL_42:
  unint64_t v46 = EmitViewerSPI::emitElementsAttrProperty(@"ksize", (uint64_t)v40, v41);
  if (v46) {
    [v22 addObject:v46];
  }
  LOBYTE(v67[0]) = 0;
  LOBYTE(v67[0]) = mlir::anec::AveragePool::getIncPad(&v64);
  uint64_t v47 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"inc_pad" dataType:2147483656 shape:&unk_1EC9F0140];
  if (v47)
  {
    uint64_t v48 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v67 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v47 setValue:v48];

    [v22 addObject:v47];
  }

  int v49 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v50 = [MPSGraphViewerNodeSPI alloc];
  BOOL v51 = [MEMORY[0x1E4F1C978] arrayWithArray:v63];
  uint64_t v52 = [MEMORY[0x1E4F1C978] arrayWithArray:v16];
  uint64_t v53 = [MEMORY[0x1E4F1C978] arrayWithArray:v22];
  char v54 = [MEMORY[0x1E4F1C978] arrayWithArray:v49];
  uint64_t v55 = [(MPSGraphViewerNodeSPI *)v50 initWithType:v62 inputs:v51 outputs:v52 properties:v53 regions:v54];
  int v56 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v55;

  if (SHIBYTE(v70) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDBFC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECBatchToSpaceOpHandler *EmitterViewerSPI::ANECBatchToSpaceOpHandler::ANECBatchToSpaceOpHandler(EmitterViewerSPI::ANECBatchToSpaceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987AD8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 19)
    {
      BOOL v43 = *AttrData == 0x7461622E63656E61 && AttrData[1] == 0x70735F6F745F6863;
      if (v43 && *(void *)((char *)AttrData + 11) == 0x65636170735F6F74)
      {
        __int16 v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.batch_to_space";
        v49[3] = 19;
        uint64_t v47 = "' failed due to the operation not being registered";
        __int16 v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
    goto LABEL_45;
  }
  unint64_t v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v45 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"factors", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint8x8_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v45 inputs:v34 outputs:v35 properties:v36 regions:v37];
  uint64_t v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDC620(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECBroadcastOpHandler *EmitterViewerSPI::ANECBroadcastOpHandler::ANECBroadcastOpHandler(EmitterViewerSPI::ANECBroadcastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9875E0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 14 && *AttrData == 0x6F72622E63656E61 && *(void *)((char *)AttrData + 6) == 0x7473616364616F72)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.broadcast";
      v40[3] = 14;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Broadcast,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint8x8_t v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDCB78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECCastOpHandler *EmitterViewerSPI::ANECCastOpHandler::ANECCastOpHandler(EmitterViewerSPI::ANECCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986B30;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(void *)AttrData == 0x7361632E63656E61 && *(unsigned char *)(AttrData + 8) == 116)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.cast";
      v40[3] = 9;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Cast,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint8x8_t v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDD0B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECCeilOpHandler *EmitterViewerSPI::ANECCeilOpHandler::ANECCeilOpHandler(EmitterViewerSPI::ANECCeilOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986B48;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(void *)AttrData == 0x6965632E63656E61 && *(unsigned char *)(AttrData + 8) == 108)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.ceil";
      v40[3] = 9;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Ceil,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint8x8_t v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDD5F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECChannelToSpaceOpHandler *EmitterViewerSPI::ANECChannelToSpaceOpHandler::ANECChannelToSpaceOpHandler(EmitterViewerSPI::ANECChannelToSpaceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987DD8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 21)
    {
      BOOL v43 = *AttrData == 0x6168632E63656E61 && AttrData[1] == 0x5F6F745F6C656E6ELL;
      if (v43 && *(void *)((char *)AttrData + 13) == 0x65636170735F6F74)
      {
        __int16 v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.channel_to_space";
        v49[3] = 21;
        uint64_t v47 = "' failed due to the operation not being registered";
        __int16 v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id) {
    goto LABEL_45;
  }
  unint64_t v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v45 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"factors", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint8x8_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v45 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDDC18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECClampedReluOpHandler *EmitterViewerSPI::ANECClampedReluOpHandler::ANECClampedReluOpHandler(EmitterViewerSPI::ANECClampedReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v55[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987940;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v53 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v53);
    if (v41 == 17)
    {
      BOOL v42 = *(void *)AttrData == 0x616C632E63656E61 && *(void *)(AttrData + 8) == 0x6C65725F6465706DLL;
      if (v42 && *(unsigned char *)(AttrData + 16) == 117)
      {
        __int16 v52 = 1283;
        int v49 = "classof on '";
        v51[0] = "anec.clamped_relu";
        v51[1] = 17;
        __dst[0] = "' failed due to the operation not being registered";
        __int16 v48 = 259;
        llvm::operator+((uint64_t *)&v49, (uint64_t *)__dst, (uint64_t)&v53);
        llvm::report_fatal_error((llvm::Twine *)&v53, 1);
      }
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ClampedRelu,void>::id) {
    goto LABEL_44;
  }
  uint64_t v45 = a3;
  uint64_t v53 = *(void *)(v4 + 8);
  unint64_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v53);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  unint64_t v44 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::InstanceNorm::getEpsilon(&v45, (uint64_t)&v53);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"min_value" dataType:268435488 shape:&unk_1EC9F0158];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v53 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }
  mlir::anec::DeQuant::getScale(&v45, (uint64_t)&v49);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"max_value" dataType:268435488 shape:&unk_1EC9F0170];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v49 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v23 addObject:v26];
  }

  int v28 = v50;
  uint64_t v30 = llvm::APFloatBase::PPCDoubleDouble(v29);
  if (v30 == v28) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v51);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v50);
  }

  if (v30 == v54) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v55);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v54);
  }
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  size_t v32 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint8x8_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  uint64_t v37 = [(MPSGraphViewerNodeSPI *)v32 initWithType:v44 inputs:v33 outputs:v34 properties:v35 regions:v36];
  uint64_t v38 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v37;

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDE2E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECConcatOpHandler *EmitterViewerSPI::ANECConcatOpHandler::ANECConcatOpHandler(EmitterViewerSPI::ANECConcatOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986FC8;
  uint64_t v3 = *((void *)a3 + 6);
  uint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v44 == 11 && *AttrData == 0x6E6F632E63656E61 && *(void *)((char *)AttrData + 3) == 0x7461636E6F632E63)
    {
      __int16 v52 = 1283;
      v51[0] = (uint64_t)"classof on '";
      void v51[2] = (uint64_t)"anec.concat";
      v51[3] = 11;
      v49[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v50 = 259;
      llvm::operator+(v51, v49, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::anec::Concat,void>::id) {
    goto LABEL_38;
  }
  __int16 v48 = a3;
  v51[0] = *(void *)(v3 + 8);
  uint8x8_t v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v51);
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    __int16 v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    int64_t v54 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v54) = v7;
  __int16 v9 = __dst;
  if (v7) {
LABEL_10:
  }
    memmove(v9, v6, (size_t)v8);
  *((unsigned char *)v8 + (void)v9) = 0;
  if (v54 >= 0) {
    uint64_t v12 = __dst;
  }
  else {
    uint64_t v12 = (void **)__dst[0];
  }
  unint64_t v46 = [NSString stringWithCString:v12 encoding:4];
  unint64_t v13 = [MEMORY[0x1E4F1CA48] array];
  uint64_t Inputs = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v48);
  unint64_t v16 = v15;
  if (v15)
  {
    uint64_t v17 = Inputs;
    unint64_t v18 = 0;
    unsigned int v19 = 1;
    do
    {
      unint64_t v20 = *(void *)(v17 + 32 * v18 + 24);
      unint64_t v21 = objc_msgSend(NSString, "stringWithFormat:", @"inputs%d", v19 - 1);
      unint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v21, v20);

      if (v22) {
        [v13 addObject:v22];
      }

      unint64_t v18 = v19++;
    }
    while (v16 > v18);
  }
  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v48);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    int v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  v51[0] = 0;
  v51[0] = (uint64_t)mlir::anec::Concat::getAxis(&v48);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"axis" dataType:64 shape:&unk_1EC9F0188];
  if (v30)
  {
    uint64_t v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v51 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v29 addObject:v30];
  }
  LOBYTE(v49[0]) = 0;
  LOBYTE(v49[0]) = mlir::anec::Softmax::getSubtractMax(&v48);
  size_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"interleave" dataType:2147483656 shape:&unk_1EC9F01A0];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v49 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v29 addObject:v32];
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  int v35 = [MPSGraphViewerNodeSPI alloc];
  uint8x8_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v13];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v46 inputs:v36 outputs:v37 properties:v38 regions:v39];
  uint64_t v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;

  if (SHIBYTE(v54) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDE9CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECConvolutionOpHandler *EmitterViewerSPI::ANECConvolutionOpHandler::ANECConvolutionOpHandler(EmitterViewerSPI::ANECConvolutionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987958;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v92 == 16 && *AttrData == 0x6E6F632E63656E61 && AttrData[1] == 0x6E6F6974756C6F76)
    {
      __int16 v101 = 1283;
      v100[0] = (uint64_t)"classof on '";
      v100[2] = (uint64_t)"anec.convolution";
      v100[3] = 16;
      v98[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v99 = 259;
      llvm::operator+(v100, v98, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_98:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id) {
    goto LABEL_98;
  }
  v97 = a3;
  v100[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v100);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v103 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v103) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v103 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  v94 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v96 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v97);
  unint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v96 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v97);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"filter", Filter);
  if (v17) {
    [v96 addObject:v17];
  }

  BOOL v95 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v97);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v95 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Stride = (uint64_t **)mlir::anec::Convolution::getStride((mlir::anec::Convolution *)&v97);
  uint64_t v25 = Stride;
  if (!Stride)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_77;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_77:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_77;
  }
LABEL_28:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"stride", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  Dilation = (uint64_t **)mlir::anec::Convolution::getDilation((mlir::anec::Convolution *)&v97);
  uint64_t v33 = Dilation;
  if (!Dilation)
  {
    uint64_t v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Dilation))
  {
    int v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    uint64_t v37 = "Casting.h";
    uint64_t v38 = "cast_if_present";
    goto LABEL_80;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    int v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    uint64_t v37 = "Casting.h";
    uint64_t v38 = "cast";
LABEL_80:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    int v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    uint64_t v37 = "InterfaceSupport.h";
    uint64_t v38 = "Interface";
    goto LABEL_80;
  }
LABEL_36:
  __int16 v39 = EmitViewerSPI::emitElementsAttrProperty(@"dilation", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  Padding = (uint64_t **)mlir::anec::Convolution::getPadding((mlir::anec::Convolution *)&v97);
  uint64_t v41 = Padding;
  if (!Padding)
  {
    uint64_t v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    BOOL v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    uint64_t v45 = "Casting.h";
    unint64_t v46 = "cast_if_present";
    goto LABEL_83;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    BOOL v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    uint64_t v45 = "Casting.h";
    unint64_t v46 = "cast";
LABEL_83:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    BOOL v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    uint64_t v45 = "InterfaceSupport.h";
    unint64_t v46 = "Interface";
    goto LABEL_83;
  }
LABEL_44:
  int64_t v47 = EmitViewerSPI::emitElementsAttrProperty(@"padding", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }
  Paddinguint64_t Mode = mlir::anec::Convolution::getPaddingMode(&v97);
  int v49 = [MEMORY[0x1E4F1CA48] array];
  __int16 v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Zero" value:0];
  [v49 addObject:v50];

  BOOL v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Negative" value:1];
  [v49 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Replication" value:2];
  [v49 addObject:v52];

  uint64_t v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Positive" value:3];
  [v49 addObject:v53];

  int64_t v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Symmetric" value:4];
  [v49 addObject:v54];

  uint64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Reflective" value:5];
  [v49 addObject:v55];

  int v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Background" value:6];
  [v49 addObject:v56];

  int v57 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DontCare" value:7];
  [v49 addObject:v57];

  unint64_t v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"None" value:8];
  [v49 addObject:v58];

  uint64_t v59 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_mode" type:@"ANECPaddingMode" cases:v49 value:PaddingMode];
  if (v59) {
    [v23 addObject:v59];
  }

  v100[0] = 0;
  v100[0] = (uint64_t)mlir::anec::Convolution::getGroups(&v97);
  BOOL v60 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"groups" dataType:64 shape:&unk_1EC9F01B8];
  if (v60)
  {
    __int16 v61 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v100 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v60 setValue:v61];

    [v23 addObject:v60];
  }
  LOBYTE(v98[0]) = 0;
  LOBYTE(v98[0]) = mlir::anec::AveragePool::getIncPad(&v97);
  __int16 v62 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"channel_wise" dataType:2147483656 shape:&unk_1EC9F01D0];
  if (v62)
  {
    int64_t v63 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v98 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v62 setValue:v63];

    [v23 addObject:v62];
  }
  KernelScale = (uint64_t **)mlir::anec::Convolution::getKernelScale(&v97);
  if (v65)
  {
    __int16 v66 = KernelScale;
    if (KernelScale)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelScale))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v66))
        {
          uint64_t v67 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v66);
          if (!v67)
          {
            __int16 v68 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v69 = 98;
            int64_t v70 = "InterfaceSupport.h";
            uint64_t v71 = "Interface";
            goto LABEL_86;
          }
          goto LABEL_59;
        }
        __int16 v68 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v69 = 566;
        int64_t v70 = "Casting.h";
        uint64_t v71 = "cast";
      }
      else
      {
        __int16 v68 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v69 = 692;
        int64_t v70 = "Casting.h";
        uint64_t v71 = "cast_if_present";
      }
LABEL_86:
      __assert_rtn(v71, v70, v69, v68);
    }
    uint64_t v67 = 0;
LABEL_59:
    char v72 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_scale", (uint64_t)v66, v67);
    if (v72) {
      [v23 addObject:v72];
    }
  }
  KernelZeroPoint = (uint64_t **)mlir::anec::Convolution::getKernelZeroPoint(&v97);
  if (!v74) {
    goto LABEL_72;
  }
  size_t v75 = KernelZeroPoint;
  if (KernelZeroPoint)
  {
    if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelZeroPoint))
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v75))
      {
        uint64_t v76 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v75);
        if (!v76)
        {
          uint64_t v77 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          int v78 = 98;
          v79 = "InterfaceSupport.h";
          int64_t v80 = "Interface";
          goto LABEL_89;
        }
        goto LABEL_69;
      }
      uint64_t v77 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v78 = 566;
      v79 = "Casting.h";
      int64_t v80 = "cast";
    }
    else
    {
      uint64_t v77 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
      int v78 = 692;
      v79 = "Casting.h";
      int64_t v80 = "cast_if_present";
    }
LABEL_89:
    __assert_rtn(v80, v79, v78, v77);
  }
  uint64_t v76 = 0;
LABEL_69:
  float v81 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_zero_point", (uint64_t)v75, v76);
  if (v81) {
    [v23 addObject:v81];
  }

LABEL_72:
  BOOL v82 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v83 = [MPSGraphViewerNodeSPI alloc];
  unint64_t v84 = [MEMORY[0x1E4F1C978] arrayWithArray:v96];
  v85 = [MEMORY[0x1E4F1C978] arrayWithArray:v95];
  int8x8_t v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  unint64_t v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v82];
  uint64_t v88 = [(MPSGraphViewerNodeSPI *)v83 initWithType:v94 inputs:v84 outputs:v85 properties:v86 regions:v87];
  uint64_t v89 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v88;

  if (SHIBYTE(v103) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDF688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  exception = __cxa_allocate_exception(8uLL);
  void *exception = MEMORY[0x1E4FBA4F8] + 16;
  __cxa_throw(exception, MEMORY[0x1E4FBA348], MEMORY[0x1E4FBA1F0]);
}

EmitterViewerSPI::ANECCosOpHandler *EmitterViewerSPI::ANECCosOpHandler::ANECCosOpHandler(EmitterViewerSPI::ANECCosOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986848;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x736F632E63656E61)
    {
      __int16 v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.cos";
      v39[3] = 8;
      uint64_t v37 = "' failed due to the operation not being registered";
      __int16 v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Cos,void>::id) {
    goto LABEL_27;
  }
  int v36 = a3;
  v39[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v42 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v35 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v35 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DDFCEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECCropResizeOpHandler *EmitterViewerSPI::ANECCropResizeOpHandler::ANECCropResizeOpHandler(EmitterViewerSPI::ANECCropResizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v108[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987808;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v106 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v106);
    if (v93 == 16 && *AttrData == 0x6F72632E63656E61 && AttrData[1] == 0x657A697365725F70)
    {
      __int16 v105 = 1283;
      __dst[0] = "classof on '";
      int64_t v103 = "anec.crop_resize";
      uint64_t v104 = 16;
      unint64_t v100 = "' failed due to the operation not being registered";
      __int16 v101 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v100, (uint64_t)&v106);
      llvm::report_fatal_error((llvm::Twine *)&v106, 1);
    }
LABEL_115:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::CropResize,void>::id) {
    goto LABEL_115;
  }
  __int16 v99 = a3;
  uint64_t v106 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v106);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v103 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v103) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v103) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v96 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v98 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v99);
  unint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v98 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v99);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"index", Filter);
  if (v17) {
    [v98 addObject:v17];
  }

  v97 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v99);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v97 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  OutputDims = (uint64_t **)mlir::anec::CropResize::getOutputDims((mlir::anec::CropResize *)&v99);
  uint64_t v25 = OutputDims;
  if (!OutputDims)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(OutputDims))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_88;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_88:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_88;
  }
LABEL_28:
  BOOL v95 = EmitViewerSPI::emitElementsAttrProperty(@"output_dims", (uint64_t)v25, InterfaceFor);
  if (v95) {
    [v23 addObject:v95];
  }
  CropDims = (uint64_t **)mlir::anec::CropResize::getCropDims((mlir::anec::CropResize *)&v99);
  size_t v32 = CropDims;
  if (!CropDims)
  {
    uint64_t v33 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(CropDims))
  {
    uint64_t v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v35 = 692;
    int v36 = "Casting.h";
    uint64_t v37 = "cast_if_present";
    goto LABEL_91;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    uint64_t v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v35 = 566;
    int v36 = "Casting.h";
    uint64_t v37 = "cast";
LABEL_91:
    __assert_rtn(v37, v36, v35, v34);
  }
  uint64_t v33 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!v33)
  {
    uint64_t v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v35 = 98;
    int v36 = "InterfaceSupport.h";
    uint64_t v37 = "Interface";
    goto LABEL_91;
  }
LABEL_36:
  __int16 v38 = EmitViewerSPI::emitElementsAttrProperty(@"crop_dims", (uint64_t)v32, v33);
  if (v38) {
    [v23 addObject:v38];
  }
  mlir::anec::CropResize::getBoxCoordinateMode(&v99);
  Coordinateuint64_t Mode = (uint64_t **)mlir::anec::CropResize::getCoordinateMode((mlir::anec::CropResize *)&v99);
  __int16 v40 = CoordinateMode;
  if (!CoordinateMode)
  {
    uint64_t v41 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(CoordinateMode))
  {
    int64_t v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v43 = 692;
    int v44 = "Casting.h";
    uint64_t v45 = "cast_if_present";
    goto LABEL_94;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    int64_t v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v43 = 566;
    int v44 = "Casting.h";
    uint64_t v45 = "cast";
LABEL_94:
    __assert_rtn(v45, v44, v43, v42);
  }
  uint64_t v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    int64_t v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v43 = 98;
    int v44 = "InterfaceSupport.h";
    uint64_t v45 = "Interface";
    goto LABEL_94;
  }
LABEL_44:
  unint64_t v46 = EmitViewerSPI::emitElementsAttrProperty(@"coordinate_mode", (uint64_t)v40, v41);
  if (v46) {
    [v23 addObject:v46];
  }
  NormalizedRange = (uint64_t **)mlir::anec::CropResize::getNormalizedRange((mlir::anec::CropResize *)&v99);
  __int16 v48 = NormalizedRange;
  if (!NormalizedRange)
  {
    uint64_t v49 = 0;
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(NormalizedRange))
  {
    __int16 v50 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v51 = 692;
    __int16 v52 = "Casting.h";
    uint64_t v53 = "cast_if_present";
    goto LABEL_97;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v48))
  {
    __int16 v50 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v51 = 566;
    __int16 v52 = "Casting.h";
    uint64_t v53 = "cast";
LABEL_97:
    __assert_rtn(v53, v52, v51, v50);
  }
  uint64_t v49 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v48);
  if (!v49)
  {
    __int16 v50 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v51 = 98;
    __int16 v52 = "InterfaceSupport.h";
    uint64_t v53 = "Interface";
    goto LABEL_97;
  }
LABEL_52:
  int64_t v54 = EmitViewerSPI::emitElementsAttrProperty(@"normalized_range", (uint64_t)v48, v49);
  if (v54) {
    [v23 addObject:v54];
  }
  Samplinguint64_t Mode = (uint64_t **)mlir::anec::CropResize::getSamplingMode((mlir::anec::CropResize *)&v99);
  int v56 = SamplingMode;
  if (!SamplingMode)
  {
    uint64_t v57 = 0;
    goto LABEL_60;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(SamplingMode))
  {
    unint64_t v58 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v59 = 692;
    BOOL v60 = "Casting.h";
    __int16 v61 = "cast_if_present";
    goto LABEL_100;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56))
  {
    unint64_t v58 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v59 = 566;
    BOOL v60 = "Casting.h";
    __int16 v61 = "cast";
LABEL_100:
    __assert_rtn(v61, v60, v59, v58);
  }
  uint64_t v57 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56);
  if (!v57)
  {
    unint64_t v58 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v59 = 98;
    BOOL v60 = "InterfaceSupport.h";
    __int16 v61 = "Interface";
    goto LABEL_100;
  }
LABEL_60:
  __int16 v62 = EmitViewerSPI::emitElementsAttrProperty(@"sampling_mode", (uint64_t)v56, v57);
  if (v62) {
    [v23 addObject:v62];
  }
  SamplingMethod = (uint64_t **)mlir::anec::CropResize::getSamplingMethod((mlir::anec::CropResize *)&v99);
  int64_t v64 = SamplingMethod;
  if (!SamplingMethod)
  {
    uint64_t v65 = 0;
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(SamplingMethod))
  {
    __int16 v66 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v67 = 692;
    __int16 v68 = "Casting.h";
    int v69 = "cast_if_present";
    goto LABEL_103;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v64))
  {
    __int16 v66 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v67 = 566;
    __int16 v68 = "Casting.h";
    int v69 = "cast";
LABEL_103:
    __assert_rtn(v69, v68, v67, v66);
  }
  uint64_t v65 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v64);
  if (!v65)
  {
    __int16 v66 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v67 = 98;
    __int16 v68 = "InterfaceSupport.h";
    int v69 = "Interface";
    goto LABEL_103;
  }
LABEL_68:
  int64_t v70 = EmitViewerSPI::emitElementsAttrProperty(@"sampling_method", (uint64_t)v64, v65);
  if (v70) {
    [v23 addObject:v70];
  }
  PaddingModes = (uint64_t **)mlir::anec::CropResize::getPaddingModes((mlir::anec::CropResize *)&v99);
  char v72 = PaddingModes;
  if (!PaddingModes)
  {
    uint64_t v73 = 0;
    goto LABEL_76;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(PaddingModes))
  {
    char v74 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v75 = 692;
    uint64_t v76 = "Casting.h";
    uint64_t v77 = "cast_if_present";
    goto LABEL_106;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v72))
  {
    char v74 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v75 = 566;
    uint64_t v76 = "Casting.h";
    uint64_t v77 = "cast";
LABEL_106:
    __assert_rtn(v77, v76, v75, v74);
  }
  uint64_t v73 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v72);
  if (!v73)
  {
    char v74 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v75 = 98;
    uint64_t v76 = "InterfaceSupport.h";
    uint64_t v77 = "Interface";
    goto LABEL_106;
  }
LABEL_76:
  int v78 = EmitViewerSPI::emitElementsAttrProperty(@"padding_modes", (uint64_t)v72, v73);
  if (v78) {
    [v23 addObject:v78];
  }
  mlir::anec::CropResize::getBackgroundValue(&v99, (uint64_t)&v106);
  v79 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"background_value" dataType:268435488 shape:&unk_1EC9F01E8];
  if (v79)
  {
    int64_t v80 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v106 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v79 setValue:v80];

    [v23 addObject:v79];
  }

  float v81 = v107;
  if (llvm::APFloatBase::PPCDoubleDouble(v82) == v81) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v108);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v107);
  }

  unint64_t v83 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v84 = [MPSGraphViewerNodeSPI alloc];
  v85 = [MEMORY[0x1E4F1C978] arrayWithArray:v98];
  int8x8_t v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v97];
  unint64_t v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v83];
  uint64_t v89 = [(MPSGraphViewerNodeSPI *)v84 initWithType:v96 inputs:v85 outputs:v86 properties:v87 regions:v88];
  unint64_t v90 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v89;

  if (SHIBYTE(v103) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE08EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, uint64_t a11, void *a12, void *a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a26 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECDeQuantOpHandler *EmitterViewerSPI::ANECDeQuantOpHandler::ANECDeQuantOpHandler(EmitterViewerSPI::ANECDeQuantOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v52[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987238;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v50 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
    if (v40 == 12 && *(void *)AttrData == 0x7165642E63656E61 && *(_DWORD *)(AttrData + 8) == 1953390965)
    {
      __int16 v49 = 1283;
      __dst[0] = "classof on '";
      int64_t v47 = "anec.dequant";
      uint64_t v48 = 12;
      v44[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v45 = 259;
      llvm::operator+((uint64_t *)__dst, v44, (uint64_t)&v50);
      llvm::report_fatal_error((llvm::Twine *)&v50, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::DeQuant,void>::id) {
    goto LABEL_38;
  }
  int v43 = a3;
  uint64_t v50 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v47) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v42 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::DeQuant::getScale(&v43, (uint64_t)&v50);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"scale" dataType:268435488 shape:&unk_1EC9F0200];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v50 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }
  LODWORD(v44[0]) = 0;
  LODWORD(v44[0]) = mlir::anec::DeQuant::getZeroPoint(&v43);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"zero_point" dataType:536870944 shape:&unk_1EC9F0218];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v44 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v23 addObject:v26];
  }

  int v28 = v51;
  if (llvm::APFloatBase::PPCDoubleDouble(v29) == v28) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v52);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v51);
  }
  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v42 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE1040(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECDeconvolutionOpHandler *EmitterViewerSPI::ANECDeconvolutionOpHandler::ANECDeconvolutionOpHandler(EmitterViewerSPI::ANECDeconvolutionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987CD0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v92 == 18)
    {
      BOOL v93 = *(void *)AttrData == 0x6365642E63656E61 && *(void *)(AttrData + 8) == 0x6974756C6F766E6FLL;
      if (v93 && *(_WORD *)(AttrData + 16) == 28271)
      {
        __int16 v102 = 1283;
        v101[0] = (uint64_t)"classof on '";
        v101[2] = (uint64_t)"anec.deconvolution";
        v101[3] = 18;
        v99[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v100 = 259;
        llvm::operator+(v101, v99, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_101:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Deconvolution,void>::id) {
    goto LABEL_101;
  }
  uint64_t v98 = a3;
  v101[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v101);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v104 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v104) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v104 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v95 = [NSString stringWithCString:v13 encoding:4];
  v97 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v98);
  unint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v97 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v98);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"filter", Filter);
  if (v17) {
    [v97 addObject:v17];
  }

  uint64_t v96 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v98);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v96 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Stride = (uint64_t **)mlir::anec::Convolution::getStride((mlir::anec::Convolution *)&v98);
  uint64_t v25 = Stride;
  if (!Stride)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_77;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_77:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_77;
  }
LABEL_28:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"stride", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  Dilation = (uint64_t **)mlir::anec::Convolution::getDilation((mlir::anec::Convolution *)&v98);
  uint64_t v33 = Dilation;
  if (!Dilation)
  {
    uint64_t v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Dilation))
  {
    int v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    uint64_t v37 = "Casting.h";
    __int16 v38 = "cast_if_present";
    goto LABEL_80;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    int v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    uint64_t v37 = "Casting.h";
    __int16 v38 = "cast";
LABEL_80:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    int v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    uint64_t v37 = "InterfaceSupport.h";
    __int16 v38 = "Interface";
    goto LABEL_80;
  }
LABEL_36:
  __int16 v39 = EmitViewerSPI::emitElementsAttrProperty(@"dilation", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  Padding = (uint64_t **)mlir::anec::Convolution::getPadding((mlir::anec::Convolution *)&v98);
  uint64_t v41 = Padding;
  if (!Padding)
  {
    uint64_t v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    int v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    __int16 v45 = "Casting.h";
    unint64_t v46 = "cast_if_present";
    goto LABEL_83;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    int v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    __int16 v45 = "Casting.h";
    unint64_t v46 = "cast";
LABEL_83:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    int v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    __int16 v45 = "InterfaceSupport.h";
    unint64_t v46 = "Interface";
    goto LABEL_83;
  }
LABEL_44:
  int64_t v47 = EmitViewerSPI::emitElementsAttrProperty(@"padding", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }
  Paddinguint64_t Mode = mlir::anec::Convolution::getPaddingMode(&v98);
  __int16 v49 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Zero" value:0];
  [v49 addObject:v50];

  int v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Negative" value:1];
  [v49 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Replication" value:2];
  [v49 addObject:v52];

  uint64_t v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Positive" value:3];
  [v49 addObject:v53];

  int64_t v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Symmetric" value:4];
  [v49 addObject:v54];

  uint64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Reflective" value:5];
  [v49 addObject:v55];

  int v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Background" value:6];
  [v49 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DontCare" value:7];
  [v49 addObject:v57];

  unint64_t v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"None" value:8];
  [v49 addObject:v58];

  int v59 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_mode" type:@"ANECPaddingMode" cases:v49 value:PaddingMode];
  if (v59) {
    [v23 addObject:v59];
  }

  v101[0] = 0;
  v101[0] = (uint64_t)mlir::anec::Convolution::getGroups(&v98);
  BOOL v60 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"groups" dataType:64 shape:&unk_1EC9F0230];
  if (v60)
  {
    __int16 v61 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v101 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v60 setValue:v61];

    [v23 addObject:v60];
  }
  LOBYTE(v99[0]) = 0;
  LOBYTE(v99[0]) = mlir::anec::AveragePool::getIncPad(&v98);
  __int16 v62 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"channel_wise" dataType:2147483656 shape:&unk_1EC9F0248];
  if (v62)
  {
    int64_t v63 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v99 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v62 setValue:v63];

    [v23 addObject:v62];
  }
  KernelScale = (uint64_t **)mlir::anec::Convolution::getKernelScale(&v98);
  if (v65)
  {
    __int16 v66 = KernelScale;
    if (KernelScale)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelScale))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v66))
        {
          uint64_t v67 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v66);
          if (!v67)
          {
            __int16 v68 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v69 = 98;
            int64_t v70 = "InterfaceSupport.h";
            uint64_t v71 = "Interface";
            goto LABEL_86;
          }
          goto LABEL_59;
        }
        __int16 v68 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v69 = 566;
        int64_t v70 = "Casting.h";
        uint64_t v71 = "cast";
      }
      else
      {
        __int16 v68 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v69 = 692;
        int64_t v70 = "Casting.h";
        uint64_t v71 = "cast_if_present";
      }
LABEL_86:
      __assert_rtn(v71, v70, v69, v68);
    }
    uint64_t v67 = 0;
LABEL_59:
    char v72 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_scale", (uint64_t)v66, v67);
    if (v72) {
      [v23 addObject:v72];
    }
  }
  KernelZeroPoint = (uint64_t **)mlir::anec::Convolution::getKernelZeroPoint(&v98);
  if (!v74) {
    goto LABEL_72;
  }
  int v75 = KernelZeroPoint;
  if (KernelZeroPoint)
  {
    if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelZeroPoint))
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v75))
      {
        uint64_t v76 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v75);
        if (!v76)
        {
          uint64_t v77 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          int v78 = 98;
          v79 = "InterfaceSupport.h";
          int64_t v80 = "Interface";
          goto LABEL_89;
        }
        goto LABEL_69;
      }
      uint64_t v77 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v78 = 566;
      v79 = "Casting.h";
      int64_t v80 = "cast";
    }
    else
    {
      uint64_t v77 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
      int v78 = 692;
      v79 = "Casting.h";
      int64_t v80 = "cast_if_present";
    }
LABEL_89:
    __assert_rtn(v80, v79, v78, v77);
  }
  uint64_t v76 = 0;
LABEL_69:
  float v81 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_zero_point", (uint64_t)v75, v76);
  if (v81) {
    [v23 addObject:v81];
  }

LABEL_72:
  BOOL v82 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v83 = [MPSGraphViewerNodeSPI alloc];
  unint64_t v84 = [MEMORY[0x1E4F1C978] arrayWithArray:v97];
  v85 = [MEMORY[0x1E4F1C978] arrayWithArray:v96];
  int8x8_t v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  unint64_t v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v82];
  uint64_t v88 = [(MPSGraphViewerNodeSPI *)v83 initWithType:v95 inputs:v84 outputs:v85 properties:v86 regions:v87];
  uint64_t v89 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v88;

  if (SHIBYTE(v104) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE1CF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECDegammaOpHandler *EmitterViewerSPI::ANECDegammaOpHandler::ANECDegammaOpHandler(EmitterViewerSPI::ANECDegammaOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987250;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 12 && *(void *)AttrData == 0x6765642E63656E61 && *(_DWORD *)(AttrData + 8) == 1634561377)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.degamma";
      v40[3] = 12;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Degamma,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE2320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECDiracOpHandler *EmitterViewerSPI::ANECDiracOpHandler::ANECDiracOpHandler(EmitterViewerSPI::ANECDiracOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986DB8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 10 && *(void *)AttrData == 0x7269642E63656E61 && *(_WORD *)(AttrData + 8) == 25441)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.dirac";
      v40[3] = 10;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Dirac,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE285C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseAbsOpHandler *EmitterViewerSPI::ANECElementwiseAbsOpHandler::ANECElementwiseAbsOpHandler(EmitterViewerSPI::ANECElementwiseAbsOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987DF0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x7362612E63656E61)
    {
      __int16 v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.abs";
      v39[3] = 8;
      uint64_t v37 = "' failed due to the operation not being registered";
      __int16 v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAbs,void>::id) {
    goto LABEL_27;
  }
  int v36 = a3;
  v39[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v42 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v35 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v35 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE2D8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseAddOpHandler *EmitterViewerSPI::ANECElementwiseAddOpHandler::ANECElementwiseAddOpHandler(EmitterViewerSPI::ANECElementwiseAddOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987E08;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6464612E63656E61)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.add";
      v40[3] = 8;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id) {
    goto LABEL_29;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v36 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE32F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE3408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseDivOpHandler *EmitterViewerSPI::ANECElementwiseDivOpHandler::ANECElementwiseDivOpHandler(EmitterViewerSPI::ANECElementwiseDivOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987E20;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x7669642E63656E61)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.div";
      v40[3] = 8;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseDiv,void>::id) {
    goto LABEL_29;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v36 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE3870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE3988(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseEqualOpHandler *EmitterViewerSPI::ANECElementwiseEqualOpHandler::ANECElementwiseEqualOpHandler(EmitterViewerSPI::ANECElementwiseEqualOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988108;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 10 && *(void *)AttrData == 0x7571652E63656E61 && *(_WORD *)(AttrData + 8) == 27745)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.equal";
      v41[3] = 10;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqual,void>::id) {
    goto LABEL_33;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v37 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE3DFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE3F14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler *EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler::ANECElementwiseEqualZeroOpHandler(EmitterViewerSPI::ANECElementwiseEqualZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9883D8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 15 && *AttrData == 0x7571652E63656E61 && *(void *)((char *)AttrData + 7) == 0x6F72657A5F6C6175)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.equal_zero";
      v40[3] = 15;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE4360(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler *EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler::ANECElementwiseGreaterThanOpHandler(EmitterViewerSPI::ANECElementwiseGreaterThanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9884E0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 17)
    {
      BOOL v36 = *(void *)AttrData == 0x6572672E63656E61 && *(void *)(AttrData + 8) == 0x6168745F72657461;
      if (v36 && *(unsigned char *)(AttrData + 16) == 110)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.greater_than";
        v42[3] = 17;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThan,void>::id) {
    goto LABEL_36;
  }
  __int16 v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v38 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE48E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE49FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler *EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler::ANECElementwiseGreaterThanEqualOpHandler(EmitterViewerSPI::ANECElementwiseGreaterThanEqualOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988600;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 23)
    {
      BOOL v36 = *AttrData == 0x6572672E63656E61 && AttrData[1] == 0x6168745F72657461;
      if (v36 && *(void *)((char *)AttrData + 15) == 0x6C617571655F6E61)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.greater_than_equal";
        v42[3] = 23;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqual,void>::id) {
    goto LABEL_36;
  }
  __int16 v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v38 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE4E90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE4FA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler *EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler::ANECElementwiseGreaterThanEqualZeroOpHandler(EmitterViewerSPI::ANECElementwiseGreaterThanEqualZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988690;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 28)
    {
      BOOL v35 = *(void *)AttrData == 0x6572672E63656E61 && *(void *)(AttrData + 8) == 0x6168745F72657461;
      BOOL v36 = v35 && *(void *)(AttrData + 16) == 0x5F6C617571655F6ELL;
      if (v36 && *(_DWORD *)(AttrData + 24) == 1869768058)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.greater_than_equal_zero";
        v42[3] = 28;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqualZero,void>::id) {
    goto LABEL_37;
  }
  __int16 v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE5418(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler *EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler::ANECElementwiseGreaterThanZeroOpHandler(EmitterViewerSPI::ANECElementwiseGreaterThanZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9885B8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 22)
    {
      BOOL v35 = *AttrData == 0x6572672E63656E61 && AttrData[1] == 0x6168745F72657461;
      if (v35 && *(void *)((char *)AttrData + 14) == 0x6F72657A5F6E6168)
      {
        __int16 v42 = 1283;
        v41[0] = (uint64_t)"classof on '";
        v41[2] = (uint64_t)"anec.greater_than_zero";
        v41[3] = 22;
        __int16 v39 = "' failed due to the operation not being registered";
        __int16 v40 = 259;
        llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanZero,void>::id) {
    goto LABEL_34;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE5974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseLessThanOpHandler *EmitterViewerSPI::ANECElementwiseLessThanOpHandler::ANECElementwiseLessThanOpHandler(EmitterViewerSPI::ANECElementwiseLessThanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988330;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 14 && *AttrData == 0x73656C2E63656E61 && *(void *)((char *)AttrData + 6) == 0x6E6168745F737365)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.less_than";
      v41[3] = 14;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThan,void>::id) {
    goto LABEL_33;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v37 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE5EF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE6008(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler *EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler::ANECElementwiseLessThanEqualOpHandler(EmitterViewerSPI::ANECElementwiseLessThanEqualOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988540;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      BOOL v36 = *(void *)AttrData == 0x73656C2E63656E61 && *(void *)(AttrData + 8) == 0x655F6E6168745F73;
      if (v36 && *(_DWORD *)(AttrData + 16) == 1818326385)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.less_than_equal";
        v42[3] = 20;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqual,void>::id) {
    goto LABEL_36;
  }
  __int16 v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v38 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE6494(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE65AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler *EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler::ANECElementwiseLessThanEqualZeroOpHandler(EmitterViewerSPI::ANECElementwiseLessThanEqualZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988630;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 25)
    {
      BOOL v35 = *(void *)AttrData == 0x73656C2E63656E61 && *(void *)(AttrData + 8) == 0x655F6E6168745F73;
      BOOL v36 = v35 && *(void *)(AttrData + 16) == 0x72657A5F6C617571;
      if (v36 && *(unsigned char *)(AttrData + 24) == 111)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.less_than_equal_zero";
        v42[3] = 25;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqualZero,void>::id) {
    goto LABEL_37;
  }
  __int16 v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE6A18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler *EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler::ANECElementwiseLessThanZeroOpHandler(EmitterViewerSPI::ANECElementwiseLessThanZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988510;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 19)
    {
      BOOL v35 = *AttrData == 0x73656C2E63656E61 && AttrData[1] == 0x7A5F6E6168745F73;
      if (v35 && *(void *)((char *)AttrData + 11) == 0x6F72657A5F6E6168)
      {
        __int16 v42 = 1283;
        v41[0] = (uint64_t)"classof on '";
        v41[2] = (uint64_t)"anec.less_than_zero";
        v41[3] = 19;
        __int16 v39 = "' failed due to the operation not being registered";
        __int16 v40 = 259;
        llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanZero,void>::id) {
    goto LABEL_34;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE6F74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseMaxOpHandler *EmitterViewerSPI::ANECElementwiseMaxOpHandler::ANECElementwiseMaxOpHandler(EmitterViewerSPI::ANECElementwiseMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987E38;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x78616D2E63656E61)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.max";
      v40[3] = 8;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMax,void>::id) {
    goto LABEL_29;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v36 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE74D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE75F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseMinOpHandler *EmitterViewerSPI::ANECElementwiseMinOpHandler::ANECElementwiseMinOpHandler(EmitterViewerSPI::ANECElementwiseMinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987E50;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6E696D2E63656E61)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.min";
      v40[3] = 8;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMin,void>::id) {
    goto LABEL_29;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v36 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE7A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE7B70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseMultOpHandler *EmitterViewerSPI::ANECElementwiseMultOpHandler::ANECElementwiseMultOpHandler(EmitterViewerSPI::ANECElementwiseMultOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988030;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x6C756D2E63656E61 && *(unsigned char *)(AttrData + 8) == 116)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.mult";
      v41[3] = 9;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id) {
    goto LABEL_33;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v37 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE7FE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE80FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseNotEqualOpHandler *EmitterViewerSPI::ANECElementwiseNotEqualOpHandler::ANECElementwiseNotEqualOpHandler(EmitterViewerSPI::ANECElementwiseNotEqualOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988348;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 14 && *AttrData == 0x746F6E2E63656E61 && *(void *)((char *)AttrData + 6) == 0x6C617571655F746FLL)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.not_equal";
      v41[3] = 14;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqual,void>::id) {
    goto LABEL_33;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v37 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE857C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE8694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler *EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler::ANECElementwiseNotEqualZeroOpHandler(EmitterViewerSPI::ANECElementwiseNotEqualZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988528;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 19)
    {
      BOOL v35 = *AttrData == 0x746F6E2E63656E61 && AttrData[1] == 0x7A5F6C617571655FLL;
      if (v35 && *(void *)((char *)AttrData + 11) == 0x6F72657A5F6C6175)
      {
        __int16 v42 = 1283;
        v41[0] = (uint64_t)"classof on '";
        v41[2] = (uint64_t)"anec.not_equal_zero";
        v41[3] = 19;
        __int16 v39 = "' failed due to the operation not being registered";
        __int16 v40 = 259;
        llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqualZero,void>::id) {
    goto LABEL_34;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE8AF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwisePowerOpHandler *EmitterViewerSPI::ANECElementwisePowerOpHandler::ANECElementwisePowerOpHandler(EmitterViewerSPI::ANECElementwisePowerOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988120;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 10 && *(void *)AttrData == 0x776F702E63656E61 && *(_WORD *)(AttrData + 8) == 29285)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"anec.power";
      v41[3] = 10;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwisePower,void>::id) {
    goto LABEL_33;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v37 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE9064(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE917C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseSquareOpHandler *EmitterViewerSPI::ANECElementwiseSquareOpHandler::ANECElementwiseSquareOpHandler(EmitterViewerSPI::ANECElementwiseSquareOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9881F8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 11 && *AttrData == 0x7571732E63656E61 && *(void *)((char *)AttrData + 3) == 0x6572617571732E63)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.square";
      v40[3] = 11;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSquare,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE95C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECElementwiseSubOpHandler *EmitterViewerSPI::ANECElementwiseSubOpHandler::ANECElementwiseSubOpHandler(EmitterViewerSPI::ANECElementwiseSubOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987E68;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6275732E63656E61)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.sub";
      v40[3] = 8;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSub,void>::id) {
    goto LABEL_29;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v37);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v36 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DE9B2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DE9C44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECEluOpHandler *EmitterViewerSPI::ANECEluOpHandler::ANECEluOpHandler(EmitterViewerSPI::ANECEluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v49[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986860;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v47 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v47);
    if (v38 == 8 && *AttrData == 0x756C652E63656E61)
    {
      __int16 v46 = 1283;
      __dst[0] = "classof on '";
      int64_t v44 = "anec.elu";
      uint64_t v45 = 8;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v41, (uint64_t)&v47);
      llvm::report_fatal_error((llvm::Twine *)&v47, 1);
    }
LABEL_32:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Elu,void>::id) {
    goto LABEL_32;
  }
  __int16 v40 = a3;
  uint64_t v47 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v47);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v44) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v39 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::Rsqrt::getEpsilon(&v40, (uint64_t)&v47);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"alpha" dataType:268435488 shape:&unk_1EC9F0260];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v47 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }

  uint64_t v26 = v48;
  if (llvm::APFloatBase::PPCDoubleDouble(v27) == v26) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v49);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v48);
  }
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v39 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEA148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECErfOpHandler *EmitterViewerSPI::ANECErfOpHandler::ANECErfOpHandler(EmitterViewerSPI::ANECErfOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986878;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x6672652E63656E61)
    {
      __int16 v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.erf";
      v39[3] = 8;
      uint64_t v37 = "' failed due to the operation not being registered";
      __int16 v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Erf,void>::id) {
    goto LABEL_27;
  }
  BOOL v36 = a3;
  v39[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v42 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v35 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v35 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEA698(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECExp2OpHandler *EmitterViewerSPI::ANECExp2OpHandler::ANECExp2OpHandler(EmitterViewerSPI::ANECExp2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986B60;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(void *)AttrData == 0x7078652E63656E61 && *(unsigned char *)(AttrData + 8) == 50)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.exp2";
      v40[3] = 9;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEABD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECFlattenOpHandler *EmitterViewerSPI::ANECFlattenOpHandler::ANECFlattenOpHandler(EmitterViewerSPI::ANECFlattenOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987268;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 12 && *(void *)AttrData == 0x616C662E63656E61 && *(_DWORD *)(AttrData + 8) == 1852142708)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"anec.flatten";
      v45[3] = 12;
      int64_t v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Flatten,void>::id) {
    goto LABEL_33;
  }
  int64_t v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Flattenuint64_t Mode = mlir::anec::Flatten::getFlattenMode(&v42);
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:1];
  [v25 addObject:v26];

  uint64_t v27 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:2];
  [v25 addObject:v27];

  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"flatten_mode" type:@"ANECFlattenMode" cases:v25 value:FlattenMode];
  if (v28) {
    [v23 addObject:v28];
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v35 = [(MPSGraphViewerNodeSPI *)v30 initWithType:v41 inputs:v31 outputs:v32 properties:v33 regions:v34];
  BOOL v36 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v35;

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEB1D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECFloorOpHandler *EmitterViewerSPI::ANECFloorOpHandler::ANECFloorOpHandler(EmitterViewerSPI::ANECFloorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986DD0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 10 && *(void *)AttrData == 0x6F6C662E63656E61 && *(_WORD *)(AttrData + 8) == 29295)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.floor";
      v40[3] = 10;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEB738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECGOCOpHandler *EmitterViewerSPI::ANECGOCOpHandler::ANECGOCOpHandler(EmitterViewerSPI::ANECGOCOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986890;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 24)
    {
      BOOL v38 = *AttrData == 0x6961672E63656E61 && AttrData[1] == 0x74657366666F5F6ELL;
      if (v38 && AttrData[2] == 0x6C6F72746E6F635FLL)
      {
        __int16 v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        uint64_t v44[2] = (uint64_t)"anec.gain_offset_control";
        v44[3] = 24;
        int64_t v42 = "' failed due to the operation not being registered";
        __int16 v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id) {
    goto LABEL_38;
  }
  __int16 v41 = a3;
  v44[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v40 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"scale", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v41);
  unint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"bias", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v22 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v22->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v22->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v22)];

    if (v22) {
      [v21 addObject:v22];
    }
  }
  else
  {
  }
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  uint64_t v33 = [(MPSGraphViewerNodeSPI *)v28 initWithType:v40 inputs:v29 outputs:v30 properties:v31 regions:v32];
  uint64_t v34 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v33;

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEBD00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DEBE30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECGatherNDOpHandler *EmitterViewerSPI::ANECGatherNDOpHandler::ANECGatherNDOpHandler(EmitterViewerSPI::ANECGatherNDOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9874C0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v44 == 14 && *AttrData == 0x7461672E63656E61 && *(void *)((char *)AttrData + 6) == 0x646E5F7265687461)
    {
      __int16 v51 = 1283;
      v50[0] = (uint64_t)"classof on '";
      v50[2] = (uint64_t)"anec.gather_nd";
      v50[3] = 14;
      int64_t v48 = "' failed due to the operation not being registered";
      __int16 v49 = 259;
      llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::GatherND,void>::id) {
    goto LABEL_44;
  }
  int64_t v47 = a3;
  v50[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v53 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v46 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"data", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v47);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"index", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v47);
  uint64_t v27 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v30 = 692;
    uint64_t v31 = "Casting.h";
    size_t v32 = "cast_if_present";
    goto LABEL_35;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    uint64_t v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v30 = 566;
    uint64_t v31 = "Casting.h";
    size_t v32 = "cast";
LABEL_35:
    __assert_rtn(v32, v31, v30, v29);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    uint64_t v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v30 = 98;
    uint64_t v31 = "InterfaceSupport.h";
    size_t v32 = "Interface";
    goto LABEL_35;
  }
LABEL_28:
  uint64_t v33 = EmitViewerSPI::emitElementsAttrProperty(@"axes", (uint64_t)v27, InterfaceFor);
  if (v33) {
    [v25 addObject:v33];
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v35 = [MPSGraphViewerNodeSPI alloc];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  BOOL v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v46 inputs:v36 outputs:v37 properties:v38 regions:v39];
  __int16 v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;

  if (SHIBYTE(v53) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEC380(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECGeluOpHandler *EmitterViewerSPI::ANECGeluOpHandler::ANECGeluOpHandler(EmitterViewerSPI::ANECGeluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986B78;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(void *)AttrData == 0x6C65672E63656E61 && *(unsigned char *)(AttrData + 8) == 117)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.gelu";
      v40[3] = 9;
      BOOL v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Gelu,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEC8E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler *EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler::ANECGlobalArgMinMaxOpHandler(EmitterViewerSPI::ANECGlobalArgMinMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988048;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 23)
    {
      BOOL v42 = *AttrData == 0x6F6C672E63656E61 && AttrData[1] == 0x5F6772615F6C6162;
      if (v42 && *(void *)((char *)AttrData + 15) == 0x78616D5F6E696D5FLL)
      {
        __int16 v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"anec.global_arg_min_max";
        v48[3] = 23;
        __int16 v46 = "' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::GlobalArgMinMax,void>::id) {
    goto LABEL_38;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v44 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v48[0]) = 0;
  LODWORD(v48[0]) = mlir::anec::GlobalArgMinMax::getAxis(&v45);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"axis" dataType:32 shape:&unk_1EC9F0278];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }
  Flattenuint64_t Mode = mlir::anec::Unflatten::getFlattenMode(&v45);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Min" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Max" value:1];
  [v27 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"mode" type:@"ANECArgMinMaxMode" cases:v27 value:FlattenMode];
  if (v30) {
    [v23 addObject:v30];
  }

  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  size_t v32 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  uint64_t v37 = [(MPSGraphViewerNodeSPI *)v32 initWithType:v44 inputs:v33 outputs:v34 properties:v35 regions:v36];
  BOOL v38 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v37;

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DECF74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler *EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler::ANECHighPrecisionSigmoidOpHandler(EmitterViewerSPI::ANECHighPrecisionSigmoidOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9883F0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 27)
    {
      BOOL v35 = *AttrData == 0x6769682E63656E61 && AttrData[1] == 0x7369636572705F68;
      BOOL v36 = v35 && AttrData[2] == 0x6D6769735F6E6F69;
      if (v36 && *(void *)((char *)AttrData + 19) == 0x64696F6D6769735FLL)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.high_precision_sigmoid";
        v42[3] = 27;
        uint64_t v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::HighPrecisionSigmoid,void>::id) {
    goto LABEL_37;
  }
  __int16 v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DED538(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECInputViewOpHandler *EmitterViewerSPI::ANECInputViewOpHandler::ANECInputViewOpHandler(EmitterViewerSPI::ANECInputViewOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9875F8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 15 && *AttrData == 0x706E692E63656E61 && *(void *)((char *)AttrData + 7) == 0x776569765F747570)
    {
      __int16 v51 = 1283;
      v50[0] = (uint64_t)"classof on '";
      v50[2] = (uint64_t)"anec.input_view";
      v50[3] = 15;
      v48[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v49 = 259;
      llvm::operator+(v50, v48, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::InputView,void>::id) {
    goto LABEL_39;
  }
  __int16 v47 = a3;
  v50[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v53 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v43 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v44 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  unint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v44 addObject:v15];
  }

  unint64_t v16 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v17 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  uint64_t v18 = @"result";
  if (v17)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v20 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v20 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v17)];

    if (v21) {
      [v16 addObject:v21];
    }
  }
  else
  {

    unint64_t v21 = 0;
  }

  unint64_t v22 = [MEMORY[0x1E4F1CA48] array];
  v50[0] = 0;
  v50[0] = (uint64_t)mlir::anec::Resize::getHeight(&v47);
  uint64_t v23 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"dimension" dataType:64 shape:&unk_1EC9F0290];
  if (v23)
  {
    uint64_t v24 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v50 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v23 setValue:v24];

    [v22 addObject:v23];
  }
  v48[0] = 0;
  v48[0] = (uint64_t)mlir::anec::InputView::getOffset(&v47);
  uint64_t v25 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"offset" dataType:64 shape:&unk_1EC9F02A8];
  if (v25)
  {
    uint64_t v26 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v25 setValue:v26];

    [v22 addObject:v25];
  }
  Size = mlir::anec::InputView::getSize(&v47);
  uint64_t v27 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"size" dataType:64 shape:&unk_1EC9F02C0];
  if (v27)
  {
    uint64_t v28 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&Size length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v27 setValue:v28];

    [v22 addObject:v27];
  }
  Step = mlir::anec::InputView::getStep(&v47);
  uint64_t v29 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"step" dataType:64 shape:&unk_1EC9F02D8];
  if (v29)
  {
    uint64_t v30 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&Step length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v29 setValue:v30];

    [v22 addObject:v29];
  }

  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  size_t v32 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v44];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v16];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v22];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  uint64_t v37 = [(MPSGraphViewerNodeSPI *)v32 initWithType:v43 inputs:v33 outputs:v34 properties:v35 regions:v36];
  BOOL v38 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v37;

  if (SHIBYTE(v53) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEDC4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180DEDDAC()
{
}

void sub_180DEDDB4()
{
}

void sub_180DEDDBC()
{
}

void sub_180DEDDC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECInstanceNormOpHandler *EmitterViewerSPI::ANECInstanceNormOpHandler::ANECInstanceNormOpHandler(EmitterViewerSPI::ANECInstanceNormOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v59[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987AF0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v57 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v57);
    if (v46 == 18)
    {
      BOOL v47 = *(void *)AttrData == 0x736E692E63656E61 && *(void *)(AttrData + 8) == 0x6F6E5F65636E6174;
      if (v47 && *(_WORD *)(AttrData + 16) == 28018)
      {
        __int16 v56 = 1283;
        __dst[0] = "classof on '";
        int64_t v54 = "anec.instance_norm";
        uint64_t v55 = 18;
        __int16 v51 = "' failed due to the operation not being registered";
        __int16 v52 = 259;
        llvm::operator+((uint64_t *)__dst, (uint64_t *)&v51, (uint64_t)&v57);
        llvm::report_fatal_error((llvm::Twine *)&v57, 1);
      }
    }
LABEL_50:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::InstanceNorm,void>::id) {
    goto LABEL_50;
  }
  uint64_t v50 = a3;
  uint64_t v57 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v57);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v54 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v54) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v54) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v49 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v50);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v50);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  DestinationSize = (uint64_t **)mlir::anec::Unflatten::getDestinationSize((mlir::anec::Unflatten *)&v50);
  uint64_t v25 = DestinationSize;
  if (!DestinationSize)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(DestinationSize))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_38:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_38;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"axes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  mlir::anec::InstanceNorm::getEpsilon(&v50, (uint64_t)&v57);
  size_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"epsilon" dataType:268435488 shape:&unk_1EC9F02F0];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v57 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v23 addObject:v32];
  }

  uint64_t v34 = v58;
  if (llvm::APFloatBase::PPCDoubleDouble(v35) == v34) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v59);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v58);
  }

  BOOL v36 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v37 = [MPSGraphViewerNodeSPI alloc];
  BOOL v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v36];
  uint64_t v42 = [(MPSGraphViewerNodeSPI *)v37 initWithType:v49 inputs:v38 outputs:v39 properties:v40 regions:v41];
  __int16 v43 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v42;

  if (SHIBYTE(v54) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEE3B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECInvertOpHandler *EmitterViewerSPI::ANECInvertOpHandler::ANECInvertOpHandler(EmitterViewerSPI::ANECInvertOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v50[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986FE0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v48 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
    if (v38 == 11 && *AttrData == 0x766E692E63656E61 && *(void *)((char *)AttrData + 3) == 0x747265766E692E63)
    {
      __int16 v47 = 1283;
      __dst[0] = "classof on '";
      int64_t v45 = "anec.invert";
      uint64_t v46 = 11;
      uint64_t v42 = "' failed due to the operation not being registered";
      __int16 v43 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v42, (uint64_t)&v48);
      llvm::report_fatal_error((llvm::Twine *)&v48, 1);
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id) {
    goto LABEL_36;
  }
  uint64_t v41 = a3;
  uint64_t v48 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v45) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v40 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::Rsqrt::getEpsilon(&v41, (uint64_t)&v48);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"epsilon" dataType:268435488 shape:&unk_1EC9F0308];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v48 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }

  uint64_t v26 = v49;
  if (llvm::APFloatBase::PPCDoubleDouble(v27) == v26) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  }
  int v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v40 inputs:v30 outputs:v31 properties:v32 regions:v33];
  BOOL v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEEA04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECL2NormPoolOpHandler *EmitterViewerSPI::ANECL2NormPoolOpHandler::ANECL2NormPoolOpHandler(EmitterViewerSPI::ANECL2NormPoolOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987820;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v58 == 16 && *AttrData == 0x6E326C2E63656E61 && AttrData[1] == 0x6C6F6F705F6D726FLL)
    {
      __int16 v65 = 1283;
      v64[0] = (uint64_t)"classof on '";
      v64[2] = (uint64_t)"anec.l2norm_pool";
      v64[3] = 16;
      __int16 v62 = "' failed due to the operation not being registered";
      __int16 v63 = 259;
      llvm::operator+(v64, (uint64_t *)&v62, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_64:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::L2NormPool,void>::id) {
    goto LABEL_64;
  }
  __int16 v61 = a3;
  v64[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v64);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v67 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v67) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v67 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v60 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v61);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v61);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Stride = (uint64_t **)mlir::anec::MaxPool::getStride((mlir::anec::MaxPool *)&v61);
  uint64_t v25 = Stride;
  if (!Stride)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_49;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_49:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_49;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"stride", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  Padding = (uint64_t **)mlir::anec::MaxPool::getPadding((mlir::anec::MaxPool *)&v61);
  uint64_t v33 = Padding;
  if (!Padding)
  {
    uint64_t v34 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    BOOL v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    uint64_t v37 = "Casting.h";
    uint64_t v38 = "cast_if_present";
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    BOOL v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    uint64_t v37 = "Casting.h";
    uint64_t v38 = "cast";
LABEL_52:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    BOOL v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    uint64_t v37 = "InterfaceSupport.h";
    uint64_t v38 = "Interface";
    goto LABEL_52;
  }
LABEL_34:
  __int16 v39 = EmitViewerSPI::emitElementsAttrProperty(@"padding", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  Ksize = (uint64_t **)mlir::anec::MaxPool::getKsize((mlir::anec::MaxPool *)&v61);
  uint64_t v41 = Ksize;
  if (!Ksize)
  {
    uint64_t v42 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Ksize))
  {
    __int16 v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int64_t v45 = "Casting.h";
    uint64_t v46 = "cast_if_present";
    goto LABEL_55;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    __int16 v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int64_t v45 = "Casting.h";
    uint64_t v46 = "cast";
LABEL_55:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    __int16 v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int64_t v45 = "InterfaceSupport.h";
    uint64_t v46 = "Interface";
    goto LABEL_55;
  }
LABEL_42:
  __int16 v47 = EmitViewerSPI::emitElementsAttrProperty(@"ksize", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }

  uint64_t v48 = [MEMORY[0x1E4F1CA48] array];
  __int16 v49 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v50 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v51 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  __int16 v52 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int64_t v53 = [MEMORY[0x1E4F1C978] arrayWithArray:v48];
  uint64_t v54 = [(MPSGraphViewerNodeSPI *)v49 initWithType:v60 inputs:v50 outputs:v51 properties:v52 regions:v53];
  uint64_t v55 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v54;

  if (SHIBYTE(v67) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEF1CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECLeakyReluOpHandler *EmitterViewerSPI::ANECLeakyReluOpHandler::ANECLeakyReluOpHandler(EmitterViewerSPI::ANECLeakyReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v54[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987610;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v52 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
    if (v41 == 15 && *AttrData == 0x61656C2E63656E61 && *(void *)((char *)AttrData + 7) == 0x756C65725F796B61)
    {
      __int16 v51 = 1283;
      uint64_t v48 = "classof on '";
      v50[0] = "anec.leaky_relu";
      v50[1] = 15;
      __dst[0] = "' failed due to the operation not being registered";
      __int16 v47 = 259;
      llvm::operator+((uint64_t *)&v48, (uint64_t *)__dst, (uint64_t)&v52);
      llvm::report_fatal_error((llvm::Twine *)&v52, 1);
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::LeakyRelu,void>::id) {
    goto LABEL_41;
  }
  int v44 = a3;
  uint64_t v52 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v43 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::DeQuant::getScale(&v44, (uint64_t)&v52);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"offset" dataType:268435488 shape:&unk_1EC9F0320];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v52 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }
  mlir::anec::InstanceNorm::getEpsilon(&v44, (uint64_t)&v48);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"slope" dataType:268435488 shape:&unk_1EC9F0338];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v48 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v23 addObject:v26];
  }

  int v28 = v49;
  uint64_t v30 = llvm::APFloatBase::PPCDoubleDouble(v29);
  if (v30 == v28) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  }

  if (v30 == v53) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v54);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v53);
  }
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  size_t v32 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  uint64_t v37 = [(MPSGraphViewerNodeSPI *)v32 initWithType:v43 inputs:v33 outputs:v34 properties:v35 regions:v36];
  uint64_t v38 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v37;

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DEF8A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECLinearOpHandler *EmitterViewerSPI::ANECLinearOpHandler::ANECLinearOpHandler(EmitterViewerSPI::ANECLinearOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986FF8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v54 == 11 && *AttrData == 0x6E696C2E63656E61 && *(void *)((char *)AttrData + 3) == 0x7261656E696C2E63)
    {
      __int16 v61 = 1283;
      v60[0] = (uint64_t)"classof on '";
      v60[2] = (uint64_t)"anec.linear";
      v60[3] = 11;
      uint64_t v58 = "' failed due to the operation not being registered";
      __int16 v59 = 259;
      llvm::operator+(v60, (uint64_t *)&v58, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_59:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Linear,void>::id) {
    goto LABEL_59;
  }
  uint64_t v57 = a3;
  v60[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v63 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v56 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v57);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"kernel", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  KernelScale = (uint64_t **)mlir::anec::Linear::getKernelScale(&v57);
  if (v27)
  {
    int v28 = KernelScale;
    if (KernelScale)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelScale))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28))
        {
          uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28);
          if (!InterfaceFor)
          {
            uint64_t v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v31 = 98;
            size_t v32 = "InterfaceSupport.h";
            uint64_t v33 = "Interface";
            goto LABEL_47;
          }
          goto LABEL_29;
        }
        uint64_t v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v31 = 566;
        size_t v32 = "Casting.h";
        uint64_t v33 = "cast";
      }
      else
      {
        uint64_t v30 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v31 = 692;
        size_t v32 = "Casting.h";
        uint64_t v33 = "cast_if_present";
      }
LABEL_47:
      __assert_rtn(v33, v32, v31, v30);
    }
    uint64_t InterfaceFor = 0;
LABEL_29:
    uint64_t v34 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_scale", (uint64_t)v28, InterfaceFor);
    if (v34) {
      [v25 addObject:v34];
    }
  }
  KernelZeroPoint = (uint64_t **)mlir::anec::Linear::getKernelZeroPoint(&v57);
  if (!v36) {
    goto LABEL_42;
  }
  uint64_t v37 = KernelZeroPoint;
  if (KernelZeroPoint)
  {
    if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelZeroPoint))
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v37))
      {
        uint64_t v38 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v37);
        if (!v38)
        {
          __int16 v39 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
          int v40 = 98;
          uint64_t v41 = "InterfaceSupport.h";
          uint64_t v42 = "Interface";
          goto LABEL_50;
        }
        goto LABEL_39;
      }
      __int16 v39 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v40 = 566;
      uint64_t v41 = "Casting.h";
      uint64_t v42 = "cast";
    }
    else
    {
      __int16 v39 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
      int v40 = 692;
      uint64_t v41 = "Casting.h";
      uint64_t v42 = "cast_if_present";
    }
LABEL_50:
    __assert_rtn(v42, v41, v40, v39);
  }
  uint64_t v38 = 0;
LABEL_39:
  __int16 v43 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_zero_point", (uint64_t)v37, v38);
  if (v43) {
    [v25 addObject:v43];
  }

LABEL_42:
  int v44 = [MEMORY[0x1E4F1CA48] array];
  int64_t v45 = [MPSGraphViewerNodeSPI alloc];
  int64_t v46 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v47 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v48 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v49 = [MEMORY[0x1E4F1C978] arrayWithArray:v44];
  uint64_t v50 = [(MPSGraphViewerNodeSPI *)v45 initWithType:v56 inputs:v46 outputs:v47 properties:v48 regions:v49];
  __int16 v51 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v50;

  if (SHIBYTE(v63) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF0020(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECLog2OpHandler *EmitterViewerSPI::ANECLog2OpHandler::ANECLog2OpHandler(EmitterViewerSPI::ANECLog2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v50[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986B90;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v48 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
    if (v38 == 9 && *(void *)AttrData == 0x676F6C2E63656E61 && *(unsigned char *)(AttrData + 8) == 50)
    {
      __int16 v47 = 1283;
      __dst[0] = "classof on '";
      int64_t v45 = "anec.log2";
      uint64_t v46 = 9;
      uint64_t v42 = "' failed due to the operation not being registered";
      __int16 v43 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v42, (uint64_t)&v48);
      llvm::report_fatal_error((llvm::Twine *)&v48, 1);
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Log2,void>::id) {
    goto LABEL_36;
  }
  uint64_t v41 = a3;
  uint64_t v48 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v45) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v40 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::Rsqrt::getEpsilon(&v41, (uint64_t)&v48);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"epsilon" dataType:268435488 shape:&unk_1EC9F0350];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v48 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }

  uint64_t v26 = v49;
  if (llvm::APFloatBase::PPCDoubleDouble(v27) == v26) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  }
  int v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v40 inputs:v30 outputs:v31 properties:v32 regions:v33];
  BOOL v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF0660(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECMatMulOpHandler *EmitterViewerSPI::ANECMatMulOpHandler::ANECMatMulOpHandler(EmitterViewerSPI::ANECMatMulOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987010;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v50 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
    if (v40 == 11 && *AttrData == 0x74616D2E63656E61 && *(void *)((char *)AttrData + 3) == 0x6C756D74616D2E63)
    {
      __int16 v49 = 1283;
      __dst[0] = "classof on '";
      __int16 v47 = "anec.matmul";
      uint64_t v48 = 11;
      int v44 = "' failed due to the operation not being registered";
      __int16 v45 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v44, (uint64_t)&v50);
      llvm::report_fatal_error((llvm::Twine *)&v50, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::MatMul,void>::id) {
    goto LABEL_42;
  }
  __int16 v43 = a3;
  uint64_t v50 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    __int16 v47 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v47) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v42 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::MatMul::getBias(&v43, (uint64_t)&v50);
  if (v53)
  {
    uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"bias" dataType:268435488 shape:&unk_1EC9F0368];
    if (v26)
    {
      if (!v53) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v50 length:40];
      [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

      [v25 addObject:v26];
    }

    if (v53)
    {
      uint64_t v29 = v51;
      if (llvm::APFloatBase::PPCDoubleDouble(v28) == v29) {
        std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v52);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v51);
      }
    }
  }
  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  int v31 = [MPSGraphViewerNodeSPI alloc];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v42 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF0CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  std::optional<llvm::APFloat>::~optional(&a24);
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

unsigned char *std::optional<llvm::APFloat>::~optional(unsigned char *a1)
{
  if (!a1[32]) {
    return a1;
  }
  int8x8_t v2 = (void *)*((void *)a1 + 1);
  if (llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1) != v2)
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)(a1 + 8));
    return a1;
  }
  std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)(a1 + 16));
  return a1;
}

EmitterViewerSPI::ANECMaxPoolOpHandler *EmitterViewerSPI::ANECMaxPoolOpHandler::ANECMaxPoolOpHandler(EmitterViewerSPI::ANECMaxPoolOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987280;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v58 == 13 && *AttrData == 0x78616D2E63656E61 && *(void *)((char *)AttrData + 5) == 0x6C6F6F705F78616DLL)
    {
      __int16 v65 = 1283;
      v64[0] = (uint64_t)"classof on '";
      v64[2] = (uint64_t)"anec.max_pool";
      v64[3] = 13;
      __int16 v62 = "' failed due to the operation not being registered";
      __int16 v63 = 259;
      llvm::operator+(v64, (uint64_t *)&v62, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_64:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::MaxPool,void>::id) {
    goto LABEL_64;
  }
  __int16 v61 = a3;
  v64[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v64);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v67 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v67) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v67 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v60 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v61);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v61);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Stride = (uint64_t **)mlir::anec::MaxPool::getStride((mlir::anec::MaxPool *)&v61);
  uint64_t v25 = Stride;
  if (!Stride)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_49;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_49:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_49;
  }
LABEL_26:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"stride", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  Padding = (uint64_t **)mlir::anec::MaxPool::getPadding((mlir::anec::MaxPool *)&v61);
  uint64_t v33 = Padding;
  if (!Padding)
  {
    uint64_t v34 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    BOOL v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    uint64_t v37 = "Casting.h";
    uint64_t v38 = "cast_if_present";
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    BOOL v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    uint64_t v37 = "Casting.h";
    uint64_t v38 = "cast";
LABEL_52:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    BOOL v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    uint64_t v37 = "InterfaceSupport.h";
    uint64_t v38 = "Interface";
    goto LABEL_52;
  }
LABEL_34:
  __int16 v39 = EmitViewerSPI::emitElementsAttrProperty(@"padding", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  Ksize = (uint64_t **)mlir::anec::MaxPool::getKsize((mlir::anec::MaxPool *)&v61);
  uint64_t v41 = Ksize;
  if (!Ksize)
  {
    uint64_t v42 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Ksize))
  {
    __int16 v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    __int16 v45 = "Casting.h";
    uint64_t v46 = "cast_if_present";
    goto LABEL_55;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    __int16 v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    __int16 v45 = "Casting.h";
    uint64_t v46 = "cast";
LABEL_55:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    __int16 v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    __int16 v45 = "InterfaceSupport.h";
    uint64_t v46 = "Interface";
    goto LABEL_55;
  }
LABEL_42:
  __int16 v47 = EmitViewerSPI::emitElementsAttrProperty(@"ksize", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }

  uint64_t v48 = [MEMORY[0x1E4F1CA48] array];
  __int16 v49 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v50 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v51 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v52 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  char v53 = [MEMORY[0x1E4F1C978] arrayWithArray:v48];
  uint64_t v54 = [(MPSGraphViewerNodeSPI *)v49 initWithType:v60 inputs:v50 outputs:v51 properties:v52 regions:v53];
  uint64_t v55 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v54;

  if (SHIBYTE(v67) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF1540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECNReluOpHandler *EmitterViewerSPI::ANECNReluOpHandler::ANECNReluOpHandler(EmitterViewerSPI::ANECNReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v54[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986DE8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v52 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
    if (v41 == 11 && *AttrData == 0x725F6E2E63656E61 && *(void *)((char *)AttrData + 3) == 0x756C65725F6E2E63)
    {
      __int16 v51 = 1283;
      uint64_t v48 = "classof on '";
      v50[0] = "anec.n_relu";
      v50[1] = 11;
      __dst[0] = "' failed due to the operation not being registered";
      __int16 v47 = 259;
      llvm::operator+((uint64_t *)&v48, (uint64_t *)__dst, (uint64_t)&v52);
      llvm::report_fatal_error((llvm::Twine *)&v52, 1);
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::NRelu,void>::id) {
    goto LABEL_41;
  }
  int v44 = a3;
  uint64_t v52 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v43 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::DeQuant::getScale(&v44, (uint64_t)&v52);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"max_value" dataType:268435488 shape:&unk_1EC9F0380];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v52 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }
  mlir::anec::InstanceNorm::getEpsilon(&v44, (uint64_t)&v48);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"slope" dataType:268435488 shape:&unk_1EC9F0398];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v48 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v23 addObject:v26];
  }

  int v28 = v49;
  uint64_t v30 = llvm::APFloatBase::PPCDoubleDouble(v29);
  if (v30 == v28) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  }

  if (v30 == v53) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v54);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v53);
  }
  int v31 = [MEMORY[0x1E4F1CA48] array];
  size_t v32 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  uint64_t v37 = [(MPSGraphViewerNodeSPI *)v32 initWithType:v43 inputs:v33 outputs:v34 properties:v35 regions:v36];
  uint64_t v38 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v37;

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF1C1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECPaddingOpHandler *EmitterViewerSPI::ANECPaddingOpHandler::ANECPaddingOpHandler(EmitterViewerSPI::ANECPaddingOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v66[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987298;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v64 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v64);
    if (v54 == 12 && *(void *)AttrData == 0x6461702E63656E61 && *(_DWORD *)(AttrData + 8) == 1735289188)
    {
      __int16 v63 = 1283;
      __dst[0] = "classof on '";
      __int16 v61 = "anec.padding";
      uint64_t v62 = 12;
      uint64_t v58 = "' failed due to the operation not being registered";
      __int16 v59 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v58, (uint64_t)&v64);
      llvm::report_fatal_error((llvm::Twine *)&v64, 1);
    }
LABEL_58:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Padding,void>::id) {
    goto LABEL_58;
  }
  uint64_t v57 = a3;
  uint64_t v64 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v64);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    __int16 v61 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v61) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v61) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v56 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Padding = (uint64_t **)mlir::anec::MaxPool::getPadding((mlir::anec::MaxPool *)&v57);
  uint64_t v25 = Padding;
  if (!Padding)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Padding))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_46:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_46;
  }
LABEL_26:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"padding_modes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  Stride = (uint64_t **)mlir::anec::MaxPool::getStride((mlir::anec::MaxPool *)&v57);
  uint64_t v33 = Stride;
  if (!Stride)
  {
    uint64_t v34 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Stride))
  {
    BOOL v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    uint64_t v37 = "Casting.h";
    uint64_t v38 = "cast_if_present";
    goto LABEL_49;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    BOOL v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    uint64_t v37 = "Casting.h";
    uint64_t v38 = "cast";
LABEL_49:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    BOOL v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    uint64_t v37 = "InterfaceSupport.h";
    uint64_t v38 = "Interface";
    goto LABEL_49;
  }
LABEL_34:
  __int16 v39 = EmitViewerSPI::emitElementsAttrProperty(@"padding_sizes", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  mlir::anec::Padding::getBackgroundValue(&v57, (uint64_t)&v64);
  uint64_t v40 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"background_value" dataType:268435488 shape:&unk_1EC9F03B0];
  if (v40)
  {
    uint64_t v41 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v64 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v40 setValue:v41];

    [v23 addObject:v40];
  }

  uint64_t v42 = v65;
  if (llvm::APFloatBase::PPCDoubleDouble(v43) == v42) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v66);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v65);
  }

  int v44 = [MEMORY[0x1E4F1CA48] array];
  __int16 v45 = [MPSGraphViewerNodeSPI alloc];
  int64_t v46 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v47 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v48 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  __int16 v49 = [MEMORY[0x1E4F1C978] arrayWithArray:v44];
  uint64_t v50 = [(MPSGraphViewerNodeSPI *)v45 initWithType:v56 inputs:v46 outputs:v47 properties:v48 regions:v49];
  __int16 v51 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v50;

  if (SHIBYTE(v61) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF2414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECPixelShuffleOpHandler *EmitterViewerSPI::ANECPixelShuffleOpHandler::ANECPixelShuffleOpHandler(EmitterViewerSPI::ANECPixelShuffleOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987B08;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 18)
    {
      BOOL v43 = *(void *)AttrData == 0x7869702E63656E61 && *(void *)(AttrData + 8) == 0x66667568735F6C65;
      if (v43 && *(_WORD *)(AttrData + 16) == 25964)
      {
        __int16 v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.pixel_shuffle";
        v49[3] = 18;
        __int16 v47 = "' failed due to the operation not being registered";
        __int16 v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id) {
    goto LABEL_45;
  }
  int64_t v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v45 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"factors", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v45 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF2A7C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECPixelUnshuffleOpHandler *EmitterViewerSPI::ANECPixelUnshuffleOpHandler::ANECPixelUnshuffleOpHandler(EmitterViewerSPI::ANECPixelUnshuffleOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987E80;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 20)
    {
      BOOL v43 = *(void *)AttrData == 0x7869702E63656E61 && *(void *)(AttrData + 8) == 0x7568736E755F6C65;
      if (v43 && *(_DWORD *)(AttrData + 16) == 1701602918)
      {
        __int16 v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.pixel_unshuffle";
        v49[3] = 20;
        __int16 v47 = "' failed due to the operation not being registered";
        __int16 v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id) {
    goto LABEL_45;
  }
  int64_t v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v45 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"factors", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v45 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF30AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECQuantOpHandler *EmitterViewerSPI::ANECQuantOpHandler::ANECQuantOpHandler(EmitterViewerSPI::ANECQuantOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v52[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986E00;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v50 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
    if (v40 == 10 && *(void *)AttrData == 0x6175712E63656E61 && *(_WORD *)(AttrData + 8) == 29806)
    {
      __int16 v49 = 1283;
      __dst[0] = "classof on '";
      __int16 v47 = "anec.quant";
      uint64_t v48 = 10;
      v44[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v45 = 259;
      llvm::operator+((uint64_t *)__dst, v44, (uint64_t)&v50);
      llvm::report_fatal_error((llvm::Twine *)&v50, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Quant,void>::id) {
    goto LABEL_38;
  }
  BOOL v43 = a3;
  uint64_t v50 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    __int16 v47 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v47) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v42 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::DeQuant::getScale(&v43, (uint64_t)&v50);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"scale" dataType:268435488 shape:&unk_1EC9F03C8];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v50 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }
  LODWORD(v44[0]) = 0;
  LODWORD(v44[0]) = mlir::anec::DeQuant::getZeroPoint(&v43);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"zero_point" dataType:536870944 shape:&unk_1EC9F03E0];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v44 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v23 addObject:v26];
  }

  int v28 = v51;
  if (llvm::APFloatBase::PPCDoubleDouble(v29) == v28) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v52);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v51);
  }
  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  int v31 = [MPSGraphViewerNodeSPI alloc];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v42 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF373C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReduceAvgOpHandler *EmitterViewerSPI::ANECReduceAvgOpHandler::ANECReduceAvgOpHandler(EmitterViewerSPI::ANECReduceAvgOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987628;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 15 && *AttrData == 0x6465722E63656E61 && *(void *)((char *)AttrData + 7) == 0x6776615F65637564)
    {
      __int16 v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.reduce_avg";
      v48[3] = 15;
      int64_t v46 = "' failed due to the operation not being registered";
      __int16 v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceAvg,void>::id) {
    goto LABEL_42;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v44 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"axes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v44 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF3D90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReduceMaxOpHandler *EmitterViewerSPI::ANECReduceMaxOpHandler::ANECReduceMaxOpHandler(EmitterViewerSPI::ANECReduceMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987640;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 15 && *AttrData == 0x6465722E63656E61 && *(void *)((char *)AttrData + 7) == 0x78616D5F65637564)
    {
      __int16 v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.reduce_max";
      v48[3] = 15;
      int64_t v46 = "' failed due to the operation not being registered";
      __int16 v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceMax,void>::id) {
    goto LABEL_42;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v44 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"axes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v44 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF43B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReduceMinOpHandler *EmitterViewerSPI::ANECReduceMinOpHandler::ANECReduceMinOpHandler(EmitterViewerSPI::ANECReduceMinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987658;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 15 && *AttrData == 0x6465722E63656E61 && *(void *)((char *)AttrData + 7) == 0x6E696D5F65637564)
    {
      __int16 v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.reduce_min";
      v48[3] = 15;
      int64_t v46 = "' failed due to the operation not being registered";
      __int16 v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceMin,void>::id) {
    goto LABEL_42;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v44 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"axes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v44 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF49D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReduceSumOpHandler *EmitterViewerSPI::ANECReduceSumOpHandler::ANECReduceSumOpHandler(EmitterViewerSPI::ANECReduceSumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987670;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 15 && *AttrData == 0x6465722E63656E61 && *(void *)((char *)AttrData + 7) == 0x6D75735F65637564)
    {
      __int16 v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.reduce_sum";
      v48[3] = 15;
      int64_t v46 = "' failed due to the operation not being registered";
      __int16 v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceSum,void>::id) {
    goto LABEL_42;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v44 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"axes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v44 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF4FFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECRegionReturnOpHandler *EmitterViewerSPI::ANECRegionReturnOpHandler::ANECRegionReturnOpHandler(EmitterViewerSPI::ANECRegionReturnOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987B20;
  uint64_t v3 = *((void *)a3 + 6);
  uint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 18)
    {
      BOOL v36 = *(void *)AttrData == 0x6765722E63656E61 && *(void *)(AttrData + 8) == 0x757465725F6E6F69;
      if (v36 && *(_WORD *)(AttrData + 16) == 28274)
      {
        __int16 v44 = 1283;
        v43[0] = (uint64_t)"classof on '";
        v43[2] = (uint64_t)"anec.region_return";
        v43[3] = 18;
        uint64_t v41 = "' failed due to the operation not being registered";
        __int16 v42 = 259;
        llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::anec::RegionReturn,void>::id) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  v43[0] = *(void *)(v3 + 8);
  uint8x8_t v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    __int16 v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    int64_t v46 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v46) = v7;
  __int16 v9 = __dst;
  if (v7) {
LABEL_10:
  }
    memmove(v9, v6, (size_t)v8);
  *((unsigned char *)v8 + (void)v9) = 0;
  if (v46 >= 0) {
    uint64_t v12 = __dst;
  }
  else {
    uint64_t v12 = (void **)__dst[0];
  }
  uint64_t v38 = [NSString stringWithCString:v12 encoding:4];
  unint64_t v13 = [MEMORY[0x1E4F1CA48] array];
  uint64_t Inputs = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v40);
  unint64_t v16 = v15;
  if (v15)
  {
    uint64_t v17 = Inputs;
    unint64_t v18 = 0;
    unsigned int v19 = 1;
    do
    {
      unint64_t v20 = *(void *)(v17 + 32 * v18 + 24);
      unint64_t v21 = objc_msgSend(NSString, "stringWithFormat:", @"inputs%d", v19 - 1);
      unint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v21, v20);

      if (v22) {
        [v13 addObject:v22];
      }

      unint64_t v18 = v19++;
    }
    while (v16 > v18);
  }
  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v13];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v38 inputs:v27 outputs:v28 properties:v29 regions:v30];
  size_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF54E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReluOpHandler *EmitterViewerSPI::ANECReluOpHandler::ANECReluOpHandler(EmitterViewerSPI::ANECReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986BA8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(void *)AttrData == 0x6C65722E63656E61 && *(unsigned char *)(AttrData + 8) == 117)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.relu";
      v40[3] = 9;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF5A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECReshapeOpHandler *EmitterViewerSPI::ANECReshapeOpHandler::ANECReshapeOpHandler(EmitterViewerSPI::ANECReshapeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9872B0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 12 && *(void *)AttrData == 0x7365722E63656E61 && *(_DWORD *)(AttrData + 8) == 1701863784)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.reshape";
      v40[3] = 12;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF5F40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECResizeOpHandler *EmitterViewerSPI::ANECResizeOpHandler::ANECResizeOpHandler(EmitterViewerSPI::ANECResizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v76[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987028;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v74 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v74);
    if (v60 == 11 && *AttrData == 0x7365722E63656E61 && *(void *)((char *)AttrData + 3) == 0x657A697365722E63)
    {
      __int16 v73 = 1283;
      int64_t v70 = "classof on '";
      v72[0] = "anec.resize";
      v72[1] = 11;
      __dst[0] = "' failed due to the operation not being registered";
      __int16 v69 = 259;
      llvm::operator+((uint64_t *)&v70, (uint64_t *)__dst, (uint64_t)&v74);
      llvm::report_fatal_error((llvm::Twine *)&v74, 1);
    }
LABEL_67:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Resize,void>::id) {
    goto LABEL_67;
  }
  __int16 v66 = a3;
  uint64_t v74 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v74);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v68 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v68) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v68 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v62 = [NSString stringWithCString:v13 encoding:4];
  __int16 v63 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v66);
  unint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v63 addObject:v15];
  }

  unint64_t v16 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v17 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v66);
  uint64_t v18 = @"result";
  if (v17)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v20 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v17)];

    if (v21) {
      [v16 addObject:v21];
    }
  }
  else
  {

    unint64_t v21 = 0;
  }

  unint64_t v22 = [MEMORY[0x1E4F1CA48] array];
  Height = mlir::anec::Resize::getHeight(&v66);
  uint64_t v23 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"height" dataType:64 shape:&unk_1EC9F03F8];
  if (v23)
  {
    uint64_t v24 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&Height length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v23 setValue:v24];

    [v22 addObject:v23];
  }
  Width = mlir::anec::Resize::getWidth(&v66);
  uint64_t v25 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"width" dataType:64 shape:&unk_1EC9F0410];
  if (v25)
  {
    uint64_t v26 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&Width length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v25 setValue:v26];

    [v22 addObject:v25];
  }
  mlir::anec::Resize::getScaleFactorX(&v66, (uint64_t)&v74);
  uint64_t v27 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"scale_factor_x" dataType:268435488 shape:&unk_1EC9F0428];
  if (v27)
  {
    int v28 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v74 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v27 setValue:v28];

    [v22 addObject:v27];
  }
  mlir::anec::Resize::getScaleFactorY(&v66, (uint64_t)&v70);
  uint64_t v29 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"scale_factor_y" dataType:268435488 shape:&unk_1EC9F0440];
  if (v29)
  {
    uint64_t v30 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v70 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v29 setValue:v30];

    [v22 addObject:v29];
  }
  SamplingMethods = (uint64_t **)mlir::anec::Resize::getSamplingMethods((mlir::anec::Resize *)&v66);
  size_t v32 = SamplingMethods;
  if (!SamplingMethods)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(SamplingMethods))
  {
    uint64_t v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v35 = 692;
    BOOL v36 = "Casting.h";
    uint64_t v37 = "cast_if_present";
    goto LABEL_55;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    uint64_t v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v35 = 566;
    BOOL v36 = "Casting.h";
    uint64_t v37 = "cast";
LABEL_55:
    __assert_rtn(v37, v36, v35, v34);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!InterfaceFor)
  {
    uint64_t v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v35 = 98;
    BOOL v36 = "InterfaceSupport.h";
    uint64_t v37 = "Interface";
    goto LABEL_55;
  }
LABEL_34:
  uint64_t v38 = EmitViewerSPI::emitElementsAttrProperty(@"sampling_methods", (uint64_t)v32, InterfaceFor);
  if (v38) {
    [v22 addObject:v38];
  }
  SamplingModes = (uint64_t **)mlir::anec::Resize::getSamplingModes((mlir::anec::Resize *)&v66);
  uint64_t v40 = SamplingModes;
  if (!SamplingModes)
  {
    uint64_t v41 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(SamplingModes))
  {
    __int16 v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v43 = 692;
    __int16 v44 = "Casting.h";
    __int16 v45 = "cast_if_present";
    goto LABEL_58;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    __int16 v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v43 = 566;
    __int16 v44 = "Casting.h";
    __int16 v45 = "cast";
LABEL_58:
    __assert_rtn(v45, v44, v43, v42);
  }
  uint64_t v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    __int16 v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v43 = 98;
    __int16 v44 = "InterfaceSupport.h";
    __int16 v45 = "Interface";
    goto LABEL_58;
  }
LABEL_42:
  int64_t v46 = EmitViewerSPI::emitElementsAttrProperty(@"sampling_modes", (uint64_t)v40, v41);
  if (v46) {
    [v22 addObject:v46];
  }

  __int16 v47 = v71;
  __int16 v49 = llvm::APFloatBase::PPCDoubleDouble(v48);
  if (v49 == v47) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v72);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v71);
  }

  if (v49 == v75) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v76);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v75);
  }

  uint64_t v50 = [MEMORY[0x1E4F1CA48] array];
  int64_t v51 = [MPSGraphViewerNodeSPI alloc];
  int64_t v52 = [MEMORY[0x1E4F1C978] arrayWithArray:v63];
  char v53 = [MEMORY[0x1E4F1C978] arrayWithArray:v16];
  uint64_t v54 = [MEMORY[0x1E4F1C978] arrayWithArray:v22];
  uint64_t v55 = [MEMORY[0x1E4F1C978] arrayWithArray:v50];
  uint64_t v56 = [(MPSGraphViewerNodeSPI *)v51 initWithType:v62 inputs:v52 outputs:v53 properties:v54 regions:v55];
  uint64_t v57 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v56;

  if (SHIBYTE(v68) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF6870(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  if (a19 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECRoundNearestOpHandler *EmitterViewerSPI::ANECRoundNearestOpHandler::ANECRoundNearestOpHandler(EmitterViewerSPI::ANECRoundNearestOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987B38;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 18)
    {
      BOOL v35 = *(void *)AttrData == 0x756F722E63656E61 && *(void *)(AttrData + 8) == 0x657261656E5F646ELL;
      if (v35 && *(_WORD *)(AttrData + 16) == 29811)
      {
        __int16 v42 = 1283;
        v41[0] = (uint64_t)"classof on '";
        v41[2] = (uint64_t)"anec.round_nearest";
        v41[3] = 18;
        __int16 v39 = "' failed due to the operation not being registered";
        __int16 v40 = 259;
        llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::RoundNearest,void>::id) {
    goto LABEL_34;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF6E90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECRsqrtOpHandler *EmitterViewerSPI::ANECRsqrtOpHandler::ANECRsqrtOpHandler(EmitterViewerSPI::ANECRsqrtOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v50[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986E18;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v48 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
    if (v38 == 11 && *AttrData == 0x735F722E63656E61 && *(void *)((char *)AttrData + 3) == 0x747271735F722E63)
    {
      __int16 v47 = 1283;
      __dst[0] = "classof on '";
      __int16 v45 = "anec.r_sqrt";
      uint64_t v46 = 11;
      __int16 v42 = "' failed due to the operation not being registered";
      __int16 v43 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v42, (uint64_t)&v48);
      llvm::report_fatal_error((llvm::Twine *)&v48, 1);
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Rsqrt,void>::id) {
    goto LABEL_36;
  }
  uint64_t v41 = a3;
  uint64_t v48 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    __int16 v45 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v45) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v40 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::anec::Rsqrt::getEpsilon(&v41, (uint64_t)&v48);
  uint64_t v24 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"epsilon" dataType:268435488 shape:&unk_1EC9F0458];
  if (v24)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v48 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v24 setValue:v25];

    [v23 addObject:v24];
  }

  uint64_t v26 = v49;
  if (llvm::APFloatBase::PPCDoubleDouble(v27) == v26) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v50);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  }
  int v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  size_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v40 inputs:v30 outputs:v31 properties:v32 regions:v33];
  BOOL v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF74A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSigmoidOpHandler *EmitterViewerSPI::ANECSigmoidOpHandler::ANECSigmoidOpHandler(EmitterViewerSPI::ANECSigmoidOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9872C8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 12 && *(void *)AttrData == 0x6769732E63656E61 && *(_DWORD *)(AttrData + 8) == 1684631405)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.sigmoid";
      v40[3] = 12;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sigmoid,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF7A08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSignOpHandler *EmitterViewerSPI::ANECSignOpHandler::ANECSignOpHandler(EmitterViewerSPI::ANECSignOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986BC0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(void *)AttrData == 0x6769732E63656E61 && *(unsigned char *)(AttrData + 8) == 110)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.sign";
      v40[3] = 9;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sign,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF7F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSinOpHandler *EmitterViewerSPI::ANECSinOpHandler::ANECSinOpHandler(EmitterViewerSPI::ANECSinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9868A8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x6E69732E63656E61)
    {
      __int16 v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.sin";
      v39[3] = 8;
      uint64_t v37 = "' failed due to the operation not being registered";
      __int16 v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sin,void>::id) {
    goto LABEL_27;
  }
  BOOL v36 = a3;
  v39[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v42 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v35 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v35 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF8474(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSoftmaxOpHandler *EmitterViewerSPI::ANECSoftmaxOpHandler::ANECSoftmaxOpHandler(EmitterViewerSPI::ANECSoftmaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9872E0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v44 == 12 && *(void *)AttrData == 0x666F732E63656E61 && *(_DWORD *)(AttrData + 8) == 2019650932)
    {
      __int16 v51 = 1283;
      v50[0] = (uint64_t)"classof on '";
      void v50[2] = (uint64_t)"anec.softmax";
      v50[3] = 12;
      uint64_t v48 = "' failed due to the operation not being registered";
      __int16 v49 = 259;
      llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Softmax,void>::id) {
    goto LABEL_44;
  }
  __int16 v47 = a3;
  v50[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v53 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v46 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v47);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_35;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_35:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_35;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"axes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::anec::Softmax::getSubtractMax(&v47);
  size_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"subtractMax" dataType:2147483656 shape:&unk_1EC9F0470];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v50 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v23 addObject:v32];
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  BOOL v35 = [MPSGraphViewerNodeSPI alloc];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  __int16 v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v46 inputs:v36 outputs:v37 properties:v38 regions:v39];
  __int16 v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;

  if (SHIBYTE(v53) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF8AFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSpaceToBatchOpHandler *EmitterViewerSPI::ANECSpaceToBatchOpHandler::ANECSpaceToBatchOpHandler(EmitterViewerSPI::ANECSpaceToBatchOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987B50;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 19)
    {
      BOOL v43 = *AttrData == 0x6170732E63656E61 && AttrData[1] == 0x61625F6F745F6563;
      if (v43 && *(void *)((char *)AttrData + 11) == 0x68637461625F6F74)
      {
        __int16 v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.space_to_batch";
        v49[3] = 19;
        __int16 v47 = "' failed due to the operation not being registered";
        __int16 v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
    goto LABEL_45;
  }
  uint64_t v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v45 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"factors", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v45 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF9144(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSpaceToChannelOpHandler *EmitterViewerSPI::ANECSpaceToChannelOpHandler::ANECSpaceToChannelOpHandler(EmitterViewerSPI::ANECSpaceToChannelOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987E98;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 21)
    {
      BOOL v43 = *AttrData == 0x6170732E63656E61 && AttrData[1] == 0x68635F6F745F6563;
      if (v43 && *(void *)((char *)AttrData + 13) == 0x6C656E6E6168635FLL)
      {
        __int16 v50 = 1283;
        v49[0] = (uint64_t)"classof on '";
        v49[2] = (uint64_t)"anec.space_to_channel";
        v49[3] = 21;
        __int16 v47 = "' failed due to the operation not being registered";
        __int16 v48 = 259;
        llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id) {
    goto LABEL_45;
  }
  uint64_t v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v45 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v46);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"factors", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v45 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF977C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSqrOpHandler *EmitterViewerSPI::ANECSqrOpHandler::ANECSqrOpHandler(EmitterViewerSPI::ANECSqrOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9868C0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x7271732E63656E61)
    {
      __int16 v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"anec.sqr";
      v39[3] = 8;
      uint64_t v37 = "' failed due to the operation not being registered";
      __int16 v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sqr,void>::id) {
    goto LABEL_27;
  }
  BOOL v36 = a3;
  v39[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v42 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v35 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v35 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DF9CBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSqrtOpHandler *EmitterViewerSPI::ANECSqrtOpHandler::ANECSqrtOpHandler(EmitterViewerSPI::ANECSqrtOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986BD8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(void *)AttrData == 0x7271732E63656E61 && *(unsigned char *)(AttrData + 8) == 116)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.sqrt";
      v40[3] = 9;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Sqrt,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFA1F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECSwishOpHandler *EmitterViewerSPI::ANECSwishOpHandler::ANECSwishOpHandler(EmitterViewerSPI::ANECSwishOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986E30;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 10 && *(void *)AttrData == 0x6977732E63656E61 && *(_WORD *)(AttrData + 8) == 26739)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.swish";
      v40[3] = 10;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Swish,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFA734(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECT0OpHandler *EmitterViewerSPI::ANECT0OpHandler::ANECT0OpHandler(EmitterViewerSPI::ANECT0OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986680;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v52 == 10 && *(void *)AttrData == 0x3231412E63656E61 && *(_WORD *)(AttrData + 8) == 12402)
    {
      __int16 v62 = 1283;
      v61[0] = (uint64_t)"classof on '";
      v61[2] = (uint64_t)"anec.A12r0";
      v61[3] = 10;
      __int16 v59 = "' failed due to the operation not being registered";
      __int16 v60 = 259;
      llvm::operator+(v61, (uint64_t *)&v59, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_58:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::T0,void>::id) {
    goto LABEL_58;
  }
  uint64_t v58 = a3;
  v61[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v61);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v64 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v64) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v64 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v14 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v57 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v15 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v55 = [MEMORY[0x1E4F1CA48] array];
  SymName = (const void *)mlir::anec::A11Legacy::getSymName(&v58);
  uint64_t v18 = EmitViewerSPI::emitStringProperty(@"sym_name", SymName, v17);
  if (v18) {
    [v55 addObject:v18];
  }
  unint64_t v19 = 0;
  v61[0] = mlir::anec::A11Legacy::getFunctionType(&v58);
  while (v19 < mlir::FunctionType::getNumResults((mlir::FunctionType *)v61))
  {
    uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)v61);
    if (v21 <= v19) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    unint64_t v22 = *(uint64_t ***)(Results + 8 * v19);
    uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"result%d", v19);
    uint64_t v24 = EmitViewerSPI::emitNodeOutputPort(v23, v22);

    if (v24) {
      [v15 addObject:v24];
    }

    ++v19;
  }

  uint64_t v56 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v54 = (void *)v14;
  unint64_t Body = (void *)mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v58);
  uint64_t v26 = (void *)*Body;
  if ((void *)*Body != Body)
  {
    unint64_t v27 = 0;
    do
    {
      uint64_t v28 = Body[1];
      uint64_t v29 = v28 - 8;
      if (!v28) {
        uint64_t v29 = 0;
      }
      uint64_t v30 = *(void *)(v29 + 48);
      uint64_t v31 = *(void *)(v29 + 56) - v30;
      if (v27 >= ((unint64_t)v31 >> 3)) {
        break;
      }
      if (v27 >= v31 >> 3) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      size_t v32 = *(MPSGraphViewerNodePortSPI **)(v30 + 8 * v27);
      if (v32)
      {
        if (std::__hash_table<std::__hash_value_type<void *,unsigned long long>,std::__unordered_map_hasher<void *,std::__hash_value_type<void *,unsigned long long>,std::hash<void *>,std::equal_to<void *>,true>,std::__unordered_map_equal<void *,std::__hash_value_type<void *,unsigned long long>,std::equal_to<void *>,std::hash<void *>,true>,std::allocator<std::__hash_value_type<void *,unsigned long long>>>::find<void *>((void *)a2 + 29, *(void *)(v30 + 8 * v27)))
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v33, (unint64_t)v32);
        }
        else
        {
          uint64_t v33 = objc_msgSend(NSString, "stringWithFormat:", @"body_arg%d", v27);
          EmitViewerSPI::emitNodeOutputPort((uint64_t)a2, v33, v32);
        uint64_t v34 = };

        if (v34) {
          [v57 addObject:v34];
        }

        uint64_t v26 = (void *)*Body;
      }
      ++v27;
    }
    while (v26 != Body);
  }
  id v35 = objc_alloc_init(MEMORY[0x1E4F1CA48]);
  for (uint64_t i = (void *)Body[1]; i != Body; uint64_t i = (void *)i[1])
  {
    uint64_t v46 = i - 1;
    if (!i) {
      uint64_t v46 = 0;
    }
    __int16 v47 = (mlir::GenericProgramPoint *)(v46 + 4);
    for (uint64_t j = (mlir::GenericProgramPoint *)v46[5]; j != v47; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(j);
      __int16 v50 = EmitViewerSPI::emitNode(a2, v49);
      if (v50) {
        [v35 addObject:v50];
      }
    }
  }
  uint64_t v37 = [[MPSGraphViewerNodeRegionSPI alloc] initWithName:@"body" returnType:@"anec.region_return" nodes:v35];
  [v56 addObject:v37];

  __int16 v38 = [MPSGraphViewerNodeSPI alloc];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v57];
  __int16 v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  __int16 v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  int64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v54 inputs:v39 outputs:v40 properties:v41 regions:v42];
  uint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v64) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFAE58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v16 - 105) < 0) {
    operator delete(*(void **)(v16 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECTanhOpHandler *EmitterViewerSPI::ANECTanhOpHandler::ANECTanhOpHandler(EmitterViewerSPI::ANECTanhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986BF0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 9 && *(void *)AttrData == 0x6E61742E63656E61 && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.tanh";
      v40[3] = 9;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Tanh,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  unint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFB3FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECTileOpHandler *EmitterViewerSPI::ANECTileOpHandler::ANECTileOpHandler(EmitterViewerSPI::ANECTileOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986C08;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 9 && *(void *)AttrData == 0x6C69742E63656E61 && *(unsigned char *)(AttrData + 8) == 101)
    {
      __int16 v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.tile";
      v48[3] = 9;
      uint64_t v46 = "' failed due to the operation not being registered";
      __int16 v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Tile,void>::id) {
    goto LABEL_42;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v44 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"data", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"multipliers", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  id v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v44 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFBA04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECTransposeOpHandler *EmitterViewerSPI::ANECTransposeOpHandler::ANECTransposeOpHandler(EmitterViewerSPI::ANECTransposeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987688;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v42 == 14 && *AttrData == 0x6172742E63656E61 && *(void *)((char *)AttrData + 6) == 0x65736F70736E6172)
    {
      __int16 v49 = 1283;
      v48[0] = (uint64_t)"classof on '";
      v48[2] = (uint64_t)"anec.transpose";
      v48[3] = 14;
      uint64_t v46 = "' failed due to the operation not being registered";
      __int16 v47 = 259;
      llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id) {
    goto LABEL_42;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v44 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Axes = (uint64_t **)mlir::anec::Softmax::getAxes((mlir::anec::Softmax *)&v45);
  uint64_t v25 = Axes;
  if (!Axes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Axes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_33;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_33:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_33;
  }
LABEL_26:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"transpose_list", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }

  size_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  id v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v44 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFC028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECTruncOpHandler *EmitterViewerSPI::ANECTruncOpHandler::ANECTruncOpHandler(EmitterViewerSPI::ANECTruncOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986E48;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 10 && *(void *)AttrData == 0x7572742E63656E61 && *(_WORD *)(AttrData + 8) == 25454)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"anec.trunc";
      v40[3] = 10;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Trunc,void>::id) {
    goto LABEL_31;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFC574(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECUnflattenOpHandler *EmitterViewerSPI::ANECUnflattenOpHandler::ANECUnflattenOpHandler(EmitterViewerSPI::ANECUnflattenOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9876A0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v47 == 14 && *AttrData == 0x666E752E63656E61 && *(void *)((char *)AttrData + 6) == 0x6E657474616C666ELL)
    {
      __int16 v54 = 1283;
      v53[0] = (uint64_t)"classof on '";
      v53[2] = (uint64_t)"anec.unflatten";
      v53[3] = 14;
      int64_t v51 = "' failed due to the operation not being registered";
      __int16 v52 = 259;
      llvm::operator+(v53, (uint64_t *)&v51, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Unflatten,void>::id) {
    goto LABEL_44;
  }
  __int16 v50 = a3;
  v53[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v53);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v56 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v56) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v56 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v49 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v50);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v50);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Flattenuint64_t Mode = mlir::anec::Unflatten::getFlattenMode(&v50);
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:1];
  [v25 addObject:v26];

  uint64_t v27 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:2];
  [v25 addObject:v27];

  int v28 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"flatten_mode" type:@"ANECFlattenMode" cases:v25 value:FlattenMode];
  if (v28) {
    [v23 addObject:v28];
  }

  DestinationSize = (uint64_t **)mlir::anec::Unflatten::getDestinationSize((mlir::anec::Unflatten *)&v50);
  uint64_t v30 = DestinationSize;
  if (!DestinationSize)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(DestinationSize))
  {
    size_t v32 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v33 = 692;
    uint64_t v34 = "Casting.h";
    id v35 = "cast_if_present";
    goto LABEL_35;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v30))
  {
    size_t v32 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v33 = 566;
    uint64_t v34 = "Casting.h";
    id v35 = "cast";
LABEL_35:
    __assert_rtn(v35, v34, v33, v32);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v30);
  if (!InterfaceFor)
  {
    size_t v32 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v33 = 98;
    uint64_t v34 = "InterfaceSupport.h";
    id v35 = "Interface";
    goto LABEL_35;
  }
LABEL_28:
  BOOL v36 = EmitViewerSPI::emitElementsAttrProperty(@"destination_size", (uint64_t)v30, InterfaceFor);
  if (v36) {
    [v23 addObject:v36];
  }

  uint64_t v37 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v38 = [MPSGraphViewerNodeSPI alloc];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  __int16 v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v37];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v49 inputs:v39 outputs:v40 properties:v41 regions:v42];
  uint64_t v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  if (SHIBYTE(v56) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFCC44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler *EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler::ANECUnrealizedConversionCastOpHandler(EmitterViewerSPI::ANECUnrealizedConversionCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988558;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 31)
    {
      BOOL v35 = *AttrData == 0x726E752E63656E61 && AttrData[1] == 0x5F64657A696C6165;
      BOOL v36 = v35 && AttrData[2] == 0x69737265766E6F63;
      if (v36 && *(void *)((char *)AttrData + 23) == 0x747361635F6E6F69)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"anec.unrealized_conversion_cast";
        v42[3] = 31;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::UnrealizedConversionCast,void>::id) {
    goto LABEL_37;
  }
  __int16 v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unint64_t v19 = @"output";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"output" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFD1EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSACosOpHandler *EmitterViewerSPI::MPSACosOpHandler::MPSACosOpHandler(EmitterViewerSPI::MPSACosOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9868D8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x736F63612E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.acos";
      v40[3] = 8;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ACosOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  size_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFD748(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSACoshOpHandler *EmitterViewerSPI::MPSACoshOpHandler::MPSACoshOpHandler(EmitterViewerSPI::MPSACoshOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986C20;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x736F63612E73706DLL && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.acosh";
      v41[3] = 9;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ACoshOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  size_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFDCC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSASinOpHandler *EmitterViewerSPI::MPSASinOpHandler::MPSASinOpHandler(EmitterViewerSPI::MPSASinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9868F0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6E6973612E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.asin";
      v40[3] = 8;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ASinOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  size_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFE22C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSASinhOpHandler *EmitterViewerSPI::MPSASinhOpHandler::MPSASinhOpHandler(EmitterViewerSPI::MPSASinhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986C38;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x6E6973612E73706DLL && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.asinh";
      v41[3] = 9;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ASinhOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  size_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFE7A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSATan2OpHandler *EmitterViewerSPI::MPSATan2OpHandler::MPSATan2OpHandler(EmitterViewerSPI::MPSATan2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986C50;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 9 && *(void *)AttrData == 0x6E6174612E73706DLL && *(unsigned char *)(AttrData + 8) == 50)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.atan2";
      v43[3] = 9;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ATan2Op,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v39 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFED54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSATanOpHandler *EmitterViewerSPI::MPSATanOpHandler::MPSATanOpHandler(EmitterViewerSPI::MPSATanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986908;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6E6174612E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.atan";
      v40[3] = 8;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ATanOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFF2D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSATanhOpHandler *EmitterViewerSPI::MPSATanhOpHandler::MPSATanhOpHandler(EmitterViewerSPI::MPSATanhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986C68;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x6E6174612E73706DLL && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.atanh";
      v41[3] = 9;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ATanhOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFF850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAbsoluteOpHandler *EmitterViewerSPI::MPSAbsoluteOpHandler::MPSAbsoluteOpHandler(EmitterViewerSPI::MPSAbsoluteOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9872F8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(void *)AttrData == 0x6F7362612E73706DLL && *(_DWORD *)(AttrData + 8) == 1702131052)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.absolute";
      v41[3] = 12;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180DFFDCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAbsoluteSquareOpHandler *EmitterViewerSPI::MPSAbsoluteSquareOpHandler::MPSAbsoluteSquareOpHandler(EmitterViewerSPI::MPSAbsoluteSquareOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987CE8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 19)
    {
      BOOL v36 = *AttrData == 0x6F7362612E73706DLL && AttrData[1] == 0x7571735F6574756CLL;
      if (v36 && *(void *)((char *)AttrData + 11) == 0x6572617571735F65)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.absolute_square";
        v42[3] = 19;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AbsoluteSquareOp,void>::id) {
    goto LABEL_34;
  }
  __int16 v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Returns absolute square element-wise"];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E00364(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAddOpHandler *EmitterViewerSPI::MPSAddOpHandler::MPSAddOpHandler(EmitterViewerSPI::MPSAddOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986698;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684300078)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.add";
      v43[3] = 7;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AddOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v39 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E00910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAndOpHandler *EmitterViewerSPI::MPSAndOpHandler::MPSAndOpHandler(EmitterViewerSPI::MPSAndOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9866B0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684955438)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.and";
      v43[3] = 7;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AndOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v39 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E00ED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSAssignVariableOpHandler *EmitterViewerSPI::MPSAssignVariableOpHandler::MPSAssignVariableOpHandler(EmitterViewerSPI::MPSAssignVariableOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987D00;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v32 == 19)
    {
      BOOL v33 = *AttrData == 0x697373612E73706DLL && AttrData[1] == 0x61697261765F6E67;
      if (v33 && *(void *)((char *)AttrData + 11) == 0x656C626169726176)
      {
        __int16 v40 = 1283;
        v39[0] = (uint64_t)"classof on '";
        v39[2] = (uint64_t)"mps.assign_variable";
        v39[3] = 19;
        uint64_t v37 = "' failed due to the operation not being registered";
        __int16 v38 = 259;
        llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_32:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::AssignVariableOp,void>::id) {
    goto LABEL_32;
  }
  BOOL v36 = a3;
  v39[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v42 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v35 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"resource", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v36);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v22 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v23 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v24 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v25 = [MEMORY[0x1E4F1C978] arrayWithArray:v20];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v27 = [(MPSGraphViewerNodeSPI *)v22 initWithType:v35 inputs:v23 outputs:v24 properties:v25 regions:v26];
  int v28 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v27;

  uint64_t v29 = [NSString stringWithUTF8String:"Inserts a variableHandle for a tensor resource."];
  [*((id *)this + 3) setLocalizedDescription:v29];

  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E013E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBandPartOpHandler *EmitterViewerSPI::MPSBandPartOpHandler::MPSBandPartOpHandler(EmitterViewerSPI::MPSBandPartOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987310;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 13 && *AttrData == 0x646E61622E73706DLL && *(void *)((char *)AttrData + 5) == 0x747261705F646E61)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.band_part";
      v45[3] = 13;
      __int16 v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BandPartOp,void>::id) {
    goto LABEL_35;
  }
  int64_t v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"num_lower", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"num_upper", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  int v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  BOOL v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v41 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;

  BOOL v36 = objc_msgSend(NSString, "stringWithUTF8String:", "Copy a tensor setting everything outside a central band in each innermost matrix to zero. For rank one and rank zero inputs this operation behaves as it would if the missing dimensions had extent of one. This means that for rank one the values after 'num_upper' are zeroed out and for rank zero the input is simply copied to the output. If num_lower or num_upper are negative, keep entire lower or upper triangle, respectively.");
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E019BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBatchToSpaceOpHandler *EmitterViewerSPI::MPSBatchToSpaceOpHandler::MPSBatchToSpaceOpHandler(EmitterViewerSPI::MPSBatchToSpaceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987970;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 18)
    {
      BOOL v44 = *(void *)AttrData == 0x637461622E73706DLL && *(void *)(AttrData + 8) == 0x6170735F6F745F68;
      if (v44 && *(_WORD *)(AttrData + 16) == 25955)
      {
        __int16 v51 = 1283;
        v50[0] = (uint64_t)"classof on '";
        void v50[2] = (uint64_t)"mps.batch_to_space";
        v50[3] = 18;
        int64_t v48 = "' failed due to the operation not being registered";
        __int16 v49 = 259;
        llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BatchToSpaceOp,void>::id) {
    goto LABEL_42;
  }
  uint64_t v47 = a3;
  v50[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v53 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v46 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v47);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"spatial_axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v47);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"batch_axis", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v47);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"block_dimensions", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    int v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v47);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"pixel_shuffle" dataType:2147483656 shape:&unk_1EC9F0488];
  if (v30)
  {
    uint64_t v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v50 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v29 addObject:v30];
  }

  uint64_t v32 = [MEMORY[0x1E4F1CA48] array];
  BOOL v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v46 inputs:v34 outputs:v35 properties:v36 regions:v37];
  uint64_t v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;
  __int16 v40 = ;
  [*((id *)this + 3) setLocalizedDescription:v40];

  if (SHIBYTE(v53) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E0209C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBiasAddGradOpHandler *EmitterViewerSPI::MPSBiasAddGradOpHandler::MPSBiasAddGradOpHandler(EmitterViewerSPI::MPSBiasAddGradOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987838;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v48 == 17)
    {
      BOOL v49 = *(void *)AttrData == 0x736169622E73706DLL && *(void *)(AttrData + 8) == 0x6172675F6464615FLL;
      if (v49 && *(unsigned char *)(AttrData + 16) == 100)
      {
        __int16 v56 = 1283;
        v55[0] = (uint64_t)"classof on '";
        v55[2] = (uint64_t)"mps.bias_add_grad";
        v55[3] = 17;
        int64_t v53 = "' failed due to the operation not being registered";
        __int16 v54 = 259;
        llvm::operator+(v55, (uint64_t *)&v53, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BiasAddGradOp,void>::id) {
    goto LABEL_36;
  }
  __int16 v52 = a3;
  v55[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v55);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v58 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v58) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v58 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v51 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v52);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"out_backprop", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v52);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v52);
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v25 addObject:v26];

  uint64_t v27 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v25 addObject:v27];

  int v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v25 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v25 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v25 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v25 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v25 addObject:v32];

  BOOL v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v25 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v25 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v25 addObject:v35];

  BOOL v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v25 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_format" type:@"MPSTensorDataLayout" cases:v25 value:StorageType];
  if (v37) {
    [v23 addObject:v37];
  }

  uint64_t v38 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v39 = [MPSGraphViewerNodeSPI alloc];
  __int16 v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v38];
  uint64_t v44 = [(MPSGraphViewerNodeSPI *)v39 initWithType:v51 inputs:v40 outputs:v41 properties:v42 regions:v43];
  int64_t v45 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v44;

  if (SHIBYTE(v58) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E028B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBiasAddOpHandler *EmitterViewerSPI::MPSBiasAddOpHandler::MPSBiasAddOpHandler(EmitterViewerSPI::MPSBiasAddOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987040;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v51 == 12 && *(void *)AttrData == 0x736169622E73706DLL && *(_DWORD *)(AttrData + 8) == 1684300127)
    {
      __int16 v58 = 1283;
      v57[0] = (uint64_t)"classof on '";
      v57[2] = (uint64_t)"mps.bias_add";
      v57[3] = 12;
      uint64_t v55 = "' failed due to the operation not being registered";
      __int16 v56 = 259;
      llvm::operator+(v57, (uint64_t *)&v55, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BiasAddOp,void>::id) {
    goto LABEL_35;
  }
  __int16 v54 = a3;
  v57[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v57);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v60 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v60) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v60 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v53 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"value", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v54);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"bias", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v54);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  int v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v27 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v27 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v27 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v27 addObject:v32];

  BOOL v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v27 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v27 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v27 addObject:v35];

  BOOL v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v27 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v27 addObject:v37];

  uint64_t v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v27 addObject:v38];

  uint64_t v39 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_format" type:@"MPSTensorDataLayout" cases:v27 value:StorageType];
  if (v39) {
    [v25 addObject:v39];
  }

  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  __int16 v41 = [MPSGraphViewerNodeSPI alloc];
  int64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  int64_t v45 = [MEMORY[0x1E4F1C978] arrayWithArray:v40];
  uint64_t v46 = [(MPSGraphViewerNodeSPI *)v41 initWithType:v53 inputs:v42 outputs:v43 properties:v44 regions:v45];
  uint64_t v47 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v46;
  uint64_t v48 = ;
  [*((id *)this + 3) setLocalizedDescription:v48];

  if (SHIBYTE(v60) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E030EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseAndOpHandler *EmitterViewerSPI::MPSBitwiseAndOpHandler::MPSBitwiseAndOpHandler(EmitterViewerSPI::MPSBitwiseAndOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9876B8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 15 && *AttrData == 0x777469622E73706DLL && *(void *)((char *)AttrData + 7) == 0x646E615F65736977)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.bitwise_and";
      v43[3] = 15;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseAndOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  BOOL v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E03708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler *EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler::MPSBitwiseLeftShiftOpHandler(EmitterViewerSPI::MPSBitwiseLeftShiftOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988060;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 22)
    {
      BOOL v38 = *AttrData == 0x777469622E73706DLL && AttrData[1] == 0x7466656C5F657369;
      if (v38 && *(void *)((char *)AttrData + 14) == 0x74666968735F7466)
      {
        __int16 v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        uint64_t v44[2] = (uint64_t)"mps.bitwise_left_shift";
        v44[3] = 22;
        __int16 v42 = "' failed due to the operation not being registered";
        __int16 v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseLeftShiftOp,void>::id) {
    goto LABEL_36;
  }
  __int16 v41 = a3;
  v44[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v40 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v40 inputs:v28 outputs:v29 properties:v30 regions:v31];
  BOOL v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E03CF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseNotOpHandler *EmitterViewerSPI::MPSBitwiseNotOpHandler::MPSBitwiseNotOpHandler(EmitterViewerSPI::MPSBitwiseNotOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9876D0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 15 && *AttrData == 0x777469622E73706DLL && *(void *)((char *)AttrData + 7) == 0x746F6E5F65736977)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.bitwise_not";
      v41[3] = 15;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseNotOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E0428C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseOrOpHandler *EmitterViewerSPI::MPSBitwiseOrOpHandler::MPSBitwiseOrOpHandler(EmitterViewerSPI::MPSBitwiseOrOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9874D8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 14 && *AttrData == 0x777469622E73706DLL && *(void *)((char *)AttrData + 6) == 0x726F5F6573697774)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.bitwise_or";
      v43[3] = 14;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseOrOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  BOOL v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E04848(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwisePopcountOpHandler *EmitterViewerSPI::MPSBitwisePopcountOpHandler::MPSBitwisePopcountOpHandler(EmitterViewerSPI::MPSBitwisePopcountOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987EB0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      BOOL v36 = *(void *)AttrData == 0x777469622E73706DLL && *(void *)(AttrData + 8) == 0x63706F705F657369;
      if (v36 && *(_DWORD *)(AttrData + 16) == 1953396079)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.bitwise_popcount";
        v42[3] = 20;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwisePopcountOp,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  size_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Returns number of ON bits element-wise"];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E04DF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseRightShiftOpHandler *EmitterViewerSPI::MPSBitwiseRightShiftOpHandler::MPSBitwiseRightShiftOpHandler(EmitterViewerSPI::MPSBitwiseRightShiftOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988138;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 23)
    {
      BOOL v38 = *AttrData == 0x777469622E73706DLL && AttrData[1] == 0x686769725F657369;
      if (v38 && *(void *)((char *)AttrData + 15) == 0x74666968735F7468)
      {
        __int16 v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        uint64_t v44[2] = (uint64_t)"mps.bitwise_right_shift";
        v44[3] = 23;
        __int16 v42 = "' failed due to the operation not being registered";
        __int16 v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseRightShiftOp,void>::id) {
    goto LABEL_36;
  }
  __int16 v41 = a3;
  v44[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v40 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v40 inputs:v28 outputs:v29 properties:v30 regions:v31];
  BOOL v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E053C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBitwiseXorOpHandler *EmitterViewerSPI::MPSBitwiseXorOpHandler::MPSBitwiseXorOpHandler(EmitterViewerSPI::MPSBitwiseXorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9876E8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 15 && *AttrData == 0x777469622E73706DLL && *(void *)((char *)AttrData + 7) == 0x726F785F65736977)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.bitwise_xor";
      v43[3] = 15;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BitwiseXorOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  BOOL v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E05994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler *EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler::MPSBroadcastGradientArgsOpHandler(EmitterViewerSPI::MPSBroadcastGradientArgsOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988408;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 27)
    {
      BOOL v38 = *AttrData == 0x616F72622E73706DLL && AttrData[1] == 0x72675F7473616364;
      BOOL v39 = v38 && AttrData[2] == 0x615F746E65696461;
      if (v39 && *(void *)((char *)AttrData + 19) == 0x736772615F746E65)
      {
        __int16 v46 = 1283;
        v45[0] = (uint64_t)"classof on '";
        v45[2] = (uint64_t)"mps.broadcast_gradient_args";
        v45[3] = 27;
        __int16 v43 = "' failed due to the operation not being registered";
        __int16 v44 = 259;
        llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BroadcastGradientArgsOp,void>::id) {
    goto LABEL_39;
  }
  __int16 v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input0", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input1", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  unint64_t v21 = @"reductionAxes";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"reductionAxes" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v41 inputs:v28 outputs:v29 properties:v30 regions:v31];
  BOOL v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;

  uint64_t v34 = [NSString stringWithUTF8String:"This is typically used by gradient computations for a broadcasting operation."];
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E05F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSBroadcastToOpHandler *EmitterViewerSPI::MPSBroadcastToOpHandler::MPSBroadcastToOpHandler(EmitterViewerSPI::MPSBroadcastToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987850;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 16 && *AttrData == 0x616F72622E73706DLL && AttrData[1] == 0x6F745F7473616364)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.broadcast_to";
      v43[3] = 16;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::BroadcastToOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v39 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"shape", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  BOOL v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;

  uint64_t v34 = objc_msgSend(NSString, "stringWithUTF8String:", "Broadcast will transform the input shape to be the one specified. Note that the input shape and the desired shape need to be broadcast compatible. Two shapes are broadcast compatible if, for each dimension pair, they are either equal or one of them is one.");
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E06564(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCallOpHandler *EmitterViewerSPI::MPSCallOpHandler::MPSCallOpHandler(EmitterViewerSPI::MPSCallOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986920;
  uint64_t v3 = *((void *)a3 + 6);
  uint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v55 == 8 && *AttrData == 0x6C6C61632E73706DLL)
    {
      __int16 v64 = 1283;
      v63[0] = (uint64_t)"classof on '";
      v63[2] = (uint64_t)"mps.call";
      v63[3] = 8;
      __int16 v61 = "' failed due to the operation not being registered";
      __int16 v62 = 259;
      llvm::operator+(v63, (uint64_t *)&v61, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::CallOp,void>::id) {
    goto LABEL_38;
  }
  int64_t v60 = a3;
  v63[0] = *(void *)(v3 + 8);
  uint8x8_t v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    __int16 v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    int64_t v66 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v66) = v7;
  __int16 v9 = __dst;
  if (v7) {
LABEL_10:
  }
    memmove(v9, v6, (size_t)v8);
  *((unsigned char *)v8 + (void)v9) = 0;
  if (v66 >= 0) {
    uint64_t v12 = __dst;
  }
  else {
    uint64_t v12 = (void **)__dst[0];
  }
  __int16 v56 = [NSString stringWithCString:v12 encoding:4];
  __int16 v59 = [MEMORY[0x1E4F1CA48] array];
  uint64_t Inputs = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v60);
  unint64_t v15 = v14;
  if (v14)
  {
    uint64_t v16 = Inputs;
    unint64_t v17 = 0;
    unsigned int v18 = 1;
    do
    {
      unint64_t v19 = *(void *)(v16 + 32 * v17 + 24);
      uint64_t v20 = objc_msgSend(NSString, "stringWithFormat:", @"inputs%d", v18 - 1);
      unint64_t v21 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v20, v19);

      if (v21) {
        [v59 addObject:v21];
      }

      unint64_t v17 = v18++;
    }
    while (v15 > v17);
  }
  __int16 v58 = [MEMORY[0x1E4F1CA48] array];
  uint64_t Results = mlir::pdl::ApplyNativeRewriteOp::getResults((mlir::pdl::ApplyNativeRewriteOp *)&v60);
  unint64_t v24 = v23;
  if (v23)
  {
    uint64_t v25 = Results;
    unint64_t v26 = 0;
    unsigned int v27 = 1;
    do
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v25, v26);
      objc_msgSend(NSString, "stringWithFormat:", @"outputs%d", v27 - 1);
      id v30 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v31 = v30;
      if (NextResultAtOffset)
      {
        uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        BOOL v33 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        int v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:v31 dataType:MPSDataType shape:v33 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, NextResultAtOffset)];

        if (v28) {
          [v58 addObject:v28];
        }
      }
      else
      {
        int v28 = 0;
      }
      unint64_t v26 = v27++;
    }
    while (v24 > v26);
  }
  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  Name = (const void *)mlir::pdl::ApplyNativeConstraintOp::getName((mlir::pdl::ApplyNativeConstraintOp *)&v60);
  uint64_t v37 = EmitViewerSPI::emitStringProperty(@"symbolName", Name, v36);
  if (v37) {
    [v34 addObject:v37];
  }
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v60);
  BOOL v39 = [MEMORY[0x1E4F1CA48] array];
  __int16 v40 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"off" value:0];
  [v39 addObject:v40];

  __int16 v41 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"on" value:1];
  [v39 addObject:v41];

  __int16 v42 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"automatic" value:2];
  [v39 addObject:v42];

  __int16 v43 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"inlineMode" type:@"MPSCallInlineMode" cases:v39 value:StorageType];
  if (v43) {
    [v34 addObject:v43];
  }

  __int16 v44 = [MEMORY[0x1E4F1CA48] array];
  __int16 v45 = [MPSGraphViewerNodeSPI alloc];
  int64_t v46 = [MEMORY[0x1E4F1C978] arrayWithArray:v59];
  int64_t v47 = [MEMORY[0x1E4F1C978] arrayWithArray:v58];
  int64_t v48 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  BOOL v49 = [MEMORY[0x1E4F1C978] arrayWithArray:v44];
  uint64_t v50 = [(MPSGraphViewerNodeSPI *)v45 initWithType:v56 inputs:v46 outputs:v47 properties:v48 regions:v49];
  uint64_t v51 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v50;
  __int16 v52 = ;
  [*((id *)this + 3) setLocalizedDescription:v52];

  if (SHIBYTE(v66) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E06CD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCastOpHandler *EmitterViewerSPI::MPSCastOpHandler::MPSCastOpHandler(EmitterViewerSPI::MPSCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986938;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x747361632E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.cast";
      v40[3] = 8;
      BOOL v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CastOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  size_t v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v37);
  unint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  unint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  unsigned int v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Returns a tensor with the same shape and set resultElementType."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E072BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCeilOpHandler *EmitterViewerSPI::MPSCeilOpHandler::MPSCeilOpHandler(EmitterViewerSPI::MPSCeilOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986950;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6C6965632E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.ceil";
      v40[3] = 8;
      BOOL v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CeilOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  size_t v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  unint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  int v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E07830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSClampOpHandler *EmitterViewerSPI::MPSClampOpHandler::MPSClampOpHandler(EmitterViewerSPI::MPSClampOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986C80;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 9 && *(void *)AttrData == 0x6D616C632E73706DLL && *(unsigned char *)(AttrData + 8) == 112)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.clamp";
      v45[3] = 9;
      int64_t v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ClampOp,void>::id) {
    goto LABEL_35;
  }
  __int16 v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"primary", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"secondary", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"tertiary", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  unint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    unint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  int v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  BOOL v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v41 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  size_t v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E07E18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSColToImOpHandler *EmitterViewerSPI::MPSColToImOpHandler::MPSColToImOpHandler(EmitterViewerSPI::MPSColToImOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987058;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v80 == 13 && *AttrData == 0x5F6C6F632E73706DLL && *(void *)((char *)AttrData + 5) == 0x6D695F6F745F6C6FLL)
    {
      __int16 v89 = 1283;
      v88[0] = (uint64_t)"classof on '";
      v88[2] = (uint64_t)"mps.col_to_im";
      v88[3] = 13;
      int8x8_t v86 = "' failed due to the operation not being registered";
      __int16 v87 = 259;
      llvm::operator+(v88, (uint64_t *)&v86, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_79:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ColToImOp,void>::id) {
    goto LABEL_79;
  }
  v85 = a3;
  v88[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v88);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v91 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v91) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v91 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v82 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v84 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v85);
  unint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v84 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v85);
  unint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"shape", Filter);
  if (v17) {
    [v84 addObject:v17];
  }

  unint64_t v83 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v85);
  unint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v18->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v18->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v18 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v18)];

    if (v18) {
      [v83 addObject:v18];
    }
  }
  else
  {
  }
  uint64_t v22 = [MEMORY[0x1E4F1CA48] array];
  KernelSizes = (uint64_t **)mlir::mps::ColToImOp::getKernelSizes((mlir::mps::ColToImOp *)&v85);
  unint64_t v24 = KernelSizes;
  if (!KernelSizes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelSizes))
  {
    unint64_t v26 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v27 = 692;
    int v28 = "Casting.h";
    uint64_t v29 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24))
  {
    unint64_t v26 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v27 = 566;
    int v28 = "Casting.h";
    uint64_t v29 = "cast";
LABEL_61:
    __assert_rtn(v29, v28, v27, v26);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v24);
  if (!InterfaceFor)
  {
    unint64_t v26 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v27 = 98;
    int v28 = "InterfaceSupport.h";
    uint64_t v29 = "Interface";
    goto LABEL_61;
  }
LABEL_28:
  uint64_t v30 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_sizes", (uint64_t)v24, InterfaceFor);
  if (v30) {
    [v22 addObject:v30];
  }
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v85);
  uint64_t v32 = Strides;
  if (!Strides)
  {
    uint64_t v33 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v35 = 692;
    size_t v36 = "Casting.h";
    uint64_t v37 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    uint64_t v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v35 = 566;
    size_t v36 = "Casting.h";
    uint64_t v37 = "cast";
LABEL_64:
    __assert_rtn(v37, v36, v35, v34);
  }
  uint64_t v33 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!v33)
  {
    uint64_t v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v35 = 98;
    size_t v36 = "InterfaceSupport.h";
    uint64_t v37 = "Interface";
    goto LABEL_64;
  }
LABEL_36:
  BOOL v38 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v32, v33);
  if (v38) {
    [v22 addObject:v38];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v85);
  __int16 v40 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v41 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    __int16 v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v43 = 692;
    __int16 v44 = "Casting.h";
    __int16 v45 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    __int16 v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v43 = 566;
    __int16 v44 = "Casting.h";
    __int16 v45 = "cast";
LABEL_67:
    __assert_rtn(v45, v44, v43, v42);
  }
  uint64_t v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    __int16 v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v43 = 98;
    __int16 v44 = "InterfaceSupport.h";
    __int16 v45 = "Interface";
    goto LABEL_67;
  }
LABEL_44:
  __int16 v46 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v40, v41);
  if (v46) {
    [v22 addObject:v46];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v85);
  int64_t v48 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v49 = 0;
    goto LABEL_52;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    uint64_t v50 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v51 = 692;
    __int16 v52 = "Casting.h";
    int64_t v53 = "cast_if_present";
    goto LABEL_70;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v48))
  {
    uint64_t v50 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v51 = 566;
    __int16 v52 = "Casting.h";
    int64_t v53 = "cast";
LABEL_70:
    __assert_rtn(v53, v52, v51, v50);
  }
  uint64_t v49 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v48);
  if (!v49)
  {
    uint64_t v50 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v51 = 98;
    __int16 v52 = "InterfaceSupport.h";
    int64_t v53 = "Interface";
    goto LABEL_70;
  }
LABEL_52:
  __int16 v54 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v48, v49);
  if (v54) {
    [v22 addObject:v54];
  }
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v85);
  __int16 v56 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v56 addObject:v57];

  __int16 v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v56 addObject:v58];

  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v56 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v56 addObject:v60];

  __int16 v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v56 addObject:v61];

  __int16 v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v56 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v56 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v56 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v56 addObject:v65];

  int64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v56 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v56 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v56 value:StorageType];
  if (v68) {
    [v22 addObject:v68];
  }

  __int16 v69 = [MEMORY[0x1E4F1CA48] array];
  int64_t v70 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v71 = [MEMORY[0x1E4F1C978] arrayWithArray:v84];
  char v72 = [MEMORY[0x1E4F1C978] arrayWithArray:v83];
  __int16 v73 = [MEMORY[0x1E4F1C978] arrayWithArray:v22];
  uint64_t v74 = [MEMORY[0x1E4F1C978] arrayWithArray:v69];
  uint64_t v75 = [(MPSGraphViewerNodeSPI *)v70 initWithType:v82 inputs:v71 outputs:v72 properties:v73 regions:v74];
  uint64_t v76 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v75;
  uint64_t v77 = ;
  [*((id *)this + 3) setLocalizedDescription:v77];

  if (SHIBYTE(v91) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E08990(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConcatOpHandler *EmitterViewerSPI::MPSConcatOpHandler::MPSConcatOpHandler(EmitterViewerSPI::MPSConcatOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986E78;
  uint64_t v3 = *((void *)a3 + 6);
  uint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 10 && *(void *)AttrData == 0x636E6F632E73706DLL && *(_WORD *)(AttrData + 8) == 29793)
    {
      __int16 v53 = 1283;
      v52[0] = (uint64_t)"classof on '";
      v52[2] = (uint64_t)"mps.concat";
      v52[3] = 10;
      uint64_t v50 = "' failed due to the operation not being registered";
      __int16 v51 = 259;
      llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id) {
    goto LABEL_38;
  }
  uint64_t v49 = a3;
  v52[0] = *(void *)(v3 + 8);
  uint8x8_t v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    __int16 v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    int64_t v55 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v55) = v7;
  __int16 v9 = __dst;
  if (v7) {
LABEL_10:
  }
    memmove(v9, v6, (size_t)v8);
  *((unsigned char *)v8 + (void)v9) = 0;
  if (v55 >= 0) {
    uint64_t v12 = __dst;
  }
  else {
    uint64_t v12 = (void **)__dst[0];
  }
  int64_t v47 = [NSString stringWithCString:v12 encoding:4];
  unint64_t v13 = [MEMORY[0x1E4F1CA48] array];
  uint64_t Values = mlir::mps::ConcatOp::getValues((mlir::mps::ConcatOp *)&v49);
  unint64_t v16 = v15;
  if (v15)
  {
    uint64_t v17 = Values;
    unint64_t v18 = 0;
    unsigned int v19 = 1;
    do
    {
      unint64_t v20 = *(void *)(v17 + 32 * v18 + 24);
      unint64_t v21 = objc_msgSend(NSString, "stringWithFormat:", @"values%d", v19 - 1);
      uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v21, v20);

      if (v22) {
        [v13 addObject:v22];
      }

      unint64_t v18 = v19++;
    }
    while (v16 > v18);
  }
  unint64_t Axis = mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v49);
  unint64_t v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Axis);
  if (v24) {
    [v13 addObject:v24];
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  int v27 = @"result";
  if (v26)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v29 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v30 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v29 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v26)];

    if (v30) {
      [v25 addObject:v30];
    }
  }
  else
  {

    uint64_t v30 = 0;
  }

  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v52[0]) = 0;
  LOBYTE(v52[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v49);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"interleave" dataType:2147483656 shape:&unk_1EC9F04A0];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v52 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v31 addObject:v32];
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  int v35 = [MPSGraphViewerNodeSPI alloc];
  size_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v13];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  BOOL v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v47 inputs:v36 outputs:v37 properties:v38 regions:v39];
  uint64_t v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;
  __int16 v42 = ;
  [*((id *)this + 3) setLocalizedDescription:v42];

  if (SHIBYTE(v55) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E090DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConjugateOpHandler *EmitterViewerSPI::MPSConjugateOpHandler::MPSConjugateOpHandler(EmitterViewerSPI::MPSConjugateOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9874F0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x6A6E6F632E73706DLL && *(void *)((char *)AttrData + 5) == 0x65746167756A6E6FLL)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.conjugate";
      v41[3] = 13;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ConjugateOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Calculates the complex complex conjugate of a tensor. For non-complex type tensors this is equivelent to an identity operation."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E096A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConstantOpHandler *EmitterViewerSPI::MPSConstantOpHandler::MPSConstantOpHandler(EmitterViewerSPI::MPSConstantOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987328;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v36 == 12 && *(void *)AttrData == 0x736E6F632E73706DLL && *(_DWORD *)(AttrData + 8) == 1953390964)
    {
      __int16 v43 = 1283;
      v42[0] = (uint64_t)"classof on '";
      v42[2] = (uint64_t)"mps.constant";
      v42[3] = 12;
      __int16 v40 = "' failed due to the operation not being registered";
      __int16 v41 = 259;
      llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    goto LABEL_33;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v15 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  uint64_t v17 = @"result";
  if (v16)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v19 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v19 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v16)];

    if (v20) {
      [v15 addObject:v20];
    }
  }
  else
  {

    unint64_t v20 = 0;
  }

  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  if (*((unsigned char *)v39 + 47))
  {
    Value = mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v39);
    unint64_t v24 = EmitViewerSPI::emitElementsAttrProperty(@"value", (uint64_t)Value, v23);
    if (v24) {
      [v21 addObject:v24];
    }
  }
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v38 inputs:v27 outputs:v28 properties:v29 regions:v30];
  uint64_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  uint64_t v33 = [NSString stringWithUTF8String:"Turn a literal into an SSA value. The data is attached to the operation as an attribute."];
  [*((id *)this + 3) setLocalizedDescription:v33];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E09C34(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv2DDataGradientOpHandler *EmitterViewerSPI::MPSConv2DDataGradientOpHandler::MPSConv2DDataGradientOpHandler(EmitterViewerSPI::MPSConv2DDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988210;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 25)
    {
      BOOL v97 = *(void *)AttrData == 0x766E6F632E73706DLL && *(void *)(AttrData + 8) == 0x617461645F64325FLL;
      BOOL v98 = v97 && *(void *)(AttrData + 16) == 0x6E6569646172675FLL;
      if (v98 && *(unsigned char *)(AttrData + 24) == 116)
      {
        __int16 v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.conv_2d_data_gradient";
        v108[3] = 25;
        uint64_t v106 = "' failed due to the operation not being registered";
        __int16 v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_82:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id) {
    goto LABEL_82;
  }
  __int16 v105 = a3;
  v108[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v111 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v102 = [NSString stringWithCString:v13 encoding:4];
  int64_t v104 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  unint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v104 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v104 addObject:v17];
  }
  unint64_t SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v105);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"outputShape", SplitSizes);
  if (v19) {
    [v104 addObject:v19];
  }

  int64_t v103 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v103 addObject:v20];
    }
  }
  else
  {
  }
  unint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  v108[0] = 0;
  v108[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v105);
  __int16 v101 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"groups" dataType:64 shape:&unk_1EC9F04B8];
  if (v101)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v108 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v101 setValue:v25];

    [v24 addObject:v101];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v105);
  uint64_t v27 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v30 = 692;
    uint64_t v31 = "Casting.h";
    uint64_t v32 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    uint64_t v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v30 = 566;
    uint64_t v31 = "Casting.h";
    uint64_t v32 = "cast";
LABEL_61:
    __assert_rtn(v32, v31, v30, v29);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    uint64_t v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v30 = 98;
    uint64_t v31 = "InterfaceSupport.h";
    uint64_t v32 = "Interface";
    goto LABEL_61;
  }
LABEL_32:
  __int16 v100 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v27, InterfaceFor);
  if (v100) {
    [v24 addObject:v100];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  uint64_t v34 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v35 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v37 = 692;
    BOOL v38 = "Casting.h";
    uint64_t v39 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    uint64_t v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v37 = 566;
    BOOL v38 = "Casting.h";
    uint64_t v39 = "cast";
LABEL_64:
    __assert_rtn(v39, v38, v37, v36);
  }
  uint64_t v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    uint64_t v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v37 = 98;
    BOOL v38 = "InterfaceSupport.h";
    uint64_t v39 = "Interface";
    goto LABEL_64;
  }
LABEL_40:
  __int16 v40 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v34, v35);
  if (v40) {
    [v24 addObject:v40];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  __int16 v42 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v43 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    int64_t v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v45 = 692;
    __int16 v46 = "Casting.h";
    int64_t v47 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    int64_t v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v45 = 566;
    __int16 v46 = "Casting.h";
    int64_t v47 = "cast";
LABEL_67:
    __assert_rtn(v47, v46, v45, v44);
  }
  uint64_t v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    int64_t v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v45 = 98;
    __int16 v46 = "InterfaceSupport.h";
    int64_t v47 = "Interface";
    goto LABEL_67;
  }
LABEL_48:
  int64_t v48 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v42, v43);
  if (v48) {
    [v24 addObject:v48];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  uint64_t v50 = [MEMORY[0x1E4F1CA48] array];
  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v50 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v50 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v50 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v50 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v50 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v50 value:PaddingStyle];
  if (v56) {
    [v24 addObject:v56];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  __int16 v58 = [MEMORY[0x1E4F1CA48] array];
  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v58 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v58 addObject:v60];

  __int16 v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v58 addObject:v61];

  __int16 v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v58 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v58 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v58 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v58 addObject:v65];

  int64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v58 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v58 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v58 addObject:v68];

  __int16 v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v58 addObject:v69];

  int64_t v70 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v58 value:StorageType];
  if (v70) {
    [v24 addObject:v70];
  }

  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  char v72 = [MEMORY[0x1E4F1CA48] array];
  __int16 v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v72 addObject:v73];

  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v72 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v72 addObject:v75];

  uint64_t v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v72 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v72 addObject:v77];

  int v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v72 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v72 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v72 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v72 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v72 addObject:v82];

  unint64_t v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v72 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v72 value:WeightsLayout];
  if (v84) {
    [v24 addObject:v84];
  }

  v85 = [MEMORY[0x1E4F1CA48] array];
  int8x8_t v86 = [MPSGraphViewerNodeSPI alloc];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v104];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v103];
  __int16 v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  unint64_t v90 = [MEMORY[0x1E4F1C978] arrayWithArray:v85];
  uint64_t v91 = [(MPSGraphViewerNodeSPI *)v86 initWithType:v102 inputs:v87 outputs:v88 properties:v89 regions:v90];
  uint64_t v92 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v91;

  BOOL v93 = [NSString stringWithUTF8String:"conv2DDataGradient operation"];
  [*((id *)this + 3) setLocalizedDescription:v93];

  if (SHIBYTE(v111) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E0AAF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v17 - 105) < 0) {
    operator delete(*(void **)(v17 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv2DOpHandler *EmitterViewerSPI::MPSConv2DOpHandler::MPSConv2DOpHandler(EmitterViewerSPI::MPSConv2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986E90;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v95 == 11 && *AttrData == 0x766E6F632E73706DLL && *(void *)((char *)AttrData + 3) == 0x64325F766E6F632ELL)
    {
      __int16 v106 = 1283;
      v105[0] = (uint64_t)"classof on '";
      v105[2] = (uint64_t)"mps.conv_2d";
      v105[3] = 11;
      int64_t v103 = "' failed due to the operation not being registered";
      __int16 v104 = 259;
      llvm::operator+(v105, (uint64_t *)&v103, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_74:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id) {
    goto LABEL_74;
  }
  __int16 v102 = a3;
  v105[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v105);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v108 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v108) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v108 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v99 = [NSString stringWithCString:v13 encoding:4];
  __int16 v101 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v102);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v101 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v102);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v101 addObject:v17];
  }

  __int16 v100 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v102);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v100 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  v105[0] = 0;
  v105[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v102);
  BOOL v98 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"groups" dataType:64 shape:&unk_1EC9F04D0];
  if (v98)
  {
    unint64_t v24 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v105 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v98 setValue:v24];

    [v23 addObject:v98];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v102);
  uint64_t v26 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v28 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v29 = 692;
    int v30 = "Casting.h";
    uint64_t v31 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26))
  {
    uint64_t v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v29 = 566;
    int v30 = "Casting.h";
    uint64_t v31 = "cast";
LABEL_59:
    __assert_rtn(v31, v30, v29, v28);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26);
  if (!InterfaceFor)
  {
    uint64_t v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v29 = 98;
    int v30 = "InterfaceSupport.h";
    uint64_t v31 = "Interface";
    goto LABEL_59;
  }
LABEL_30:
  BOOL v97 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v26, InterfaceFor);
  if (v97) {
    [v23 addObject:v97];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v102);
  uint64_t v33 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v34 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    int v37 = "Casting.h";
    BOOL v38 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    uint64_t v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    int v37 = "Casting.h";
    BOOL v38 = "cast";
LABEL_62:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    uint64_t v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    int v37 = "InterfaceSupport.h";
    BOOL v38 = "Interface";
    goto LABEL_62;
  }
LABEL_38:
  uint64_t v39 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v102);
  __int16 v41 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v42 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    uint64_t v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int v45 = "Casting.h";
    __int16 v46 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    uint64_t v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int v45 = "Casting.h";
    __int16 v46 = "cast";
LABEL_65:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    uint64_t v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int v45 = "InterfaceSupport.h";
    __int16 v46 = "Interface";
    goto LABEL_65;
  }
LABEL_46:
  int64_t v47 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v102);
  uint64_t v49 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v49 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v49 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v49 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v49 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v49 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v49 value:PaddingStyle];
  if (v55) {
    [v23 addObject:v55];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v102);
  uint64_t v57 = [MEMORY[0x1E4F1CA48] array];
  __int16 v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v57 addObject:v58];

  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v57 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v57 addObject:v60];

  __int16 v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v57 addObject:v61];

  __int16 v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v57 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v57 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v57 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v57 addObject:v65];

  int64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v57 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v57 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v57 addObject:v68];

  __int16 v69 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v57 value:StorageType];
  if (v69) {
    [v23 addObject:v69];
  }

  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v102);
  uint64_t v71 = [MEMORY[0x1E4F1CA48] array];
  char v72 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v71 addObject:v72];

  __int16 v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v71 addObject:v73];

  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v71 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v71 addObject:v75];

  uint64_t v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v71 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v71 addObject:v77];

  int v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v71 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v71 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v71 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v71 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v71 addObject:v82];

  unint64_t v83 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v71 value:WeightsLayout];
  if (v83) {
    [v23 addObject:v83];
  }

  unint64_t v84 = [MEMORY[0x1E4F1CA48] array];
  v85 = [MPSGraphViewerNodeSPI alloc];
  int8x8_t v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v101];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v100];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  __int16 v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v84];
  uint64_t v90 = [(MPSGraphViewerNodeSPI *)v85 initWithType:v99 inputs:v86 outputs:v87 properties:v88 regions:v89];
  uint64_t v91 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v90;
  uint64_t v92 = ;
  [*((id *)this + 3) setLocalizedDescription:v92];

  if (SHIBYTE(v108) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E0BB0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler *EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler::MPSConv2DWeightsGradientOpHandler(EmitterViewerSPI::MPSConv2DWeightsGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988420;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 28)
    {
      BOOL v97 = *(void *)AttrData == 0x766E6F632E73706DLL && *(void *)(AttrData + 8) == 0x676965775F64325FLL;
      BOOL v98 = v97 && *(void *)(AttrData + 16) == 0x646172675F737468;
      if (v98 && *(_DWORD *)(AttrData + 24) == 1953391977)
      {
        __int16 v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.conv_2d_weights_gradient";
        v108[3] = 28;
        __int16 v106 = "' failed due to the operation not being registered";
        __int16 v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_82:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv2DWeightsGradientOp,void>::id) {
    goto LABEL_82;
  }
  __int16 v105 = a3;
  v108[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v111 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v102 = [NSString stringWithCString:v13 encoding:4];
  __int16 v104 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v104 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v17) {
    [v104 addObject:v17];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v105);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"outputShape", Bias);
  if (v19) {
    [v104 addObject:v19];
  }

  int64_t v103 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v103 addObject:v20];
    }
  }
  else
  {
  }
  unint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  v108[0] = 0;
  v108[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v105);
  __int16 v101 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"groups" dataType:64 shape:&unk_1EC9F04E8];
  if (v101)
  {
    uint64_t v25 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v108 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v101 setValue:v25];

    [v24 addObject:v101];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v105);
  uint64_t v27 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    int v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v30 = 692;
    uint64_t v31 = "Casting.h";
    uint64_t v32 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    int v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v30 = 566;
    uint64_t v31 = "Casting.h";
    uint64_t v32 = "cast";
LABEL_61:
    __assert_rtn(v32, v31, v30, v29);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    int v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v30 = 98;
    uint64_t v31 = "InterfaceSupport.h";
    uint64_t v32 = "Interface";
    goto LABEL_61;
  }
LABEL_32:
  __int16 v100 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v27, InterfaceFor);
  if (v100) {
    [v24 addObject:v100];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  uint64_t v34 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v35 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    int v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v37 = 692;
    BOOL v38 = "Casting.h";
    uint64_t v39 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    int v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v37 = 566;
    BOOL v38 = "Casting.h";
    uint64_t v39 = "cast";
LABEL_64:
    __assert_rtn(v39, v38, v37, v36);
  }
  uint64_t v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    int v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v37 = 98;
    BOOL v38 = "InterfaceSupport.h";
    uint64_t v39 = "Interface";
    goto LABEL_64;
  }
LABEL_40:
  __int16 v40 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v34, v35);
  if (v40) {
    [v24 addObject:v40];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  uint64_t v42 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v43 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    int v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v45 = 692;
    __int16 v46 = "Casting.h";
    int64_t v47 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    int v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v45 = 566;
    __int16 v46 = "Casting.h";
    int64_t v47 = "cast";
LABEL_67:
    __assert_rtn(v47, v46, v45, v44);
  }
  uint64_t v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    int v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v45 = 98;
    __int16 v46 = "InterfaceSupport.h";
    int64_t v47 = "Interface";
    goto LABEL_67;
  }
LABEL_48:
  int64_t v48 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v42, v43);
  if (v48) {
    [v24 addObject:v48];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  uint64_t v50 = [MEMORY[0x1E4F1CA48] array];
  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v50 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v50 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v50 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v50 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v50 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v50 value:PaddingStyle];
  if (v56) {
    [v24 addObject:v56];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  __int16 v58 = [MEMORY[0x1E4F1CA48] array];
  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v58 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v58 addObject:v60];

  __int16 v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v58 addObject:v61];

  __int16 v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v58 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v58 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v58 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v58 addObject:v65];

  int64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v58 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v58 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v58 addObject:v68];

  __int16 v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v58 addObject:v69];

  int64_t v70 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v58 value:StorageType];
  if (v70) {
    [v24 addObject:v70];
  }

  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  char v72 = [MEMORY[0x1E4F1CA48] array];
  __int16 v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v72 addObject:v73];

  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v72 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v72 addObject:v75];

  uint64_t v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v72 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v72 addObject:v77];

  int v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v72 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v72 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v72 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v72 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v72 addObject:v82];

  unint64_t v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v72 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v72 value:WeightsLayout];
  if (v84) {
    [v24 addObject:v84];
  }

  v85 = [MEMORY[0x1E4F1CA48] array];
  int8x8_t v86 = [MPSGraphViewerNodeSPI alloc];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v104];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v103];
  __int16 v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v90 = [MEMORY[0x1E4F1C978] arrayWithArray:v85];
  uint64_t v91 = [(MPSGraphViewerNodeSPI *)v86 initWithType:v102 inputs:v87 outputs:v88 properties:v89 regions:v90];
  uint64_t v92 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v91;

  BOOL v93 = [NSString stringWithUTF8String:"conv2DDataGradient operation"];
  [*((id *)this + 3) setLocalizedDescription:v93];

  if (SHIBYTE(v111) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E0CB50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  if (*(char *)(v17 - 105) < 0) {
    operator delete(*(void **)(v17 - 128));
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv3DDataGradientOpHandler *EmitterViewerSPI::MPSConv3DDataGradientOpHandler::MPSConv3DDataGradientOpHandler(EmitterViewerSPI::MPSConv3DDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988228;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 25)
    {
      BOOL v97 = *(void *)AttrData == 0x766E6F632E73706DLL && *(void *)(AttrData + 8) == 0x617461645F64335FLL;
      BOOL v98 = v97 && *(void *)(AttrData + 16) == 0x6E6569646172675FLL;
      if (v98 && *(unsigned char *)(AttrData + 24) == 116)
      {
        __int16 v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.conv_3d_data_gradient";
        v108[3] = 25;
        __int16 v106 = "' failed due to the operation not being registered";
        __int16 v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_82:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id) {
    goto LABEL_82;
  }
  __int16 v105 = a3;
  v108[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v111 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v100 = [NSString stringWithCString:v13 encoding:4];
  __int16 v104 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v104 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v104 addObject:v17];
  }
  unint64_t SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v105);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"outputShape", SplitSizes);
  if (v19) {
    [v104 addObject:v19];
  }

  int64_t v103 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v103 addObject:v24];
    }
  }
  else
  {

    unint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  v108[0] = 0;
  v108[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v105);
  __int16 v102 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"groups" dataType:64 shape:&unk_1EC9F0500];
  if (v102)
  {
    uint64_t v26 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v108 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v102 setValue:v26];

    [v25 addObject:v102];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v105);
  uint64_t v28 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    int v30 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v31 = 692;
    uint64_t v32 = "Casting.h";
    uint64_t v33 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28))
  {
    int v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v31 = 566;
    uint64_t v32 = "Casting.h";
    uint64_t v33 = "cast";
LABEL_61:
    __assert_rtn(v33, v32, v31, v30);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28);
  if (!InterfaceFor)
  {
    int v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v31 = 98;
    uint64_t v32 = "InterfaceSupport.h";
    uint64_t v33 = "Interface";
    goto LABEL_61;
  }
LABEL_32:
  __int16 v101 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v28, InterfaceFor);
  if (v101) {
    [v25 addObject:v101];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  uint64_t v35 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v36 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    int v37 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v38 = 692;
    uint64_t v39 = "Casting.h";
    __int16 v40 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35))
  {
    int v37 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v38 = 566;
    uint64_t v39 = "Casting.h";
    __int16 v40 = "cast";
LABEL_64:
    __assert_rtn(v40, v39, v38, v37);
  }
  uint64_t v36 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35);
  if (!v36)
  {
    int v37 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v38 = 98;
    uint64_t v39 = "InterfaceSupport.h";
    __int16 v40 = "Interface";
    goto LABEL_64;
  }
LABEL_40:
  __int16 v41 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v35, v36);
  if (v41) {
    [v25 addObject:v41];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  uint64_t v43 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v44 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    int v45 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v46 = 692;
    int64_t v47 = "Casting.h";
    int64_t v48 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43))
  {
    int v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v46 = 566;
    int64_t v47 = "Casting.h";
    int64_t v48 = "cast";
LABEL_67:
    __assert_rtn(v48, v47, v46, v45);
  }
  uint64_t v44 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43);
  if (!v44)
  {
    int v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v46 = 98;
    int64_t v47 = "InterfaceSupport.h";
    int64_t v48 = "Interface";
    goto LABEL_67;
  }
LABEL_48:
  uint64_t v49 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v43, v44);
  if (v49) {
    [v25 addObject:v49];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  __int16 v51 = [MEMORY[0x1E4F1CA48] array];
  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v51 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v51 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v51 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v51 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v51 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v51 value:PaddingStyle];
  if (v57) {
    [v25 addObject:v57];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  __int16 v59 = [MEMORY[0x1E4F1CA48] array];
  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v59 addObject:v60];

  __int16 v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v59 addObject:v61];

  __int16 v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v59 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v59 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v59 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v59 addObject:v65];

  int64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v59 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v59 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v59 addObject:v68];

  __int16 v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v59 addObject:v69];

  int64_t v70 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v59 addObject:v70];

  uint64_t v71 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v59 value:StorageType];
  if (v71) {
    [v25 addObject:v71];
  }

  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  __int16 v73 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v73 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v73 addObject:v75];

  uint64_t v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v73 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v73 addObject:v77];

  int v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v73 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v73 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v73 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v73 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v73 addObject:v82];

  unint64_t v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v73 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v73 addObject:v84];

  v85 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v73 value:WeightsLayout];
  if (v85) {
    [v25 addObject:v85];
  }

  int8x8_t v86 = [MEMORY[0x1E4F1CA48] array];
  __int16 v87 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v104];
  __int16 v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v103];
  uint64_t v90 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v91 = [MEMORY[0x1E4F1C978] arrayWithArray:v86];
  uint64_t v92 = [(MPSGraphViewerNodeSPI *)v87 initWithType:v100 inputs:v88 outputs:v89 properties:v90 regions:v91];
  BOOL v93 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v92;

  if (SHIBYTE(v111) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E0DB94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv3DOpHandler *EmitterViewerSPI::MPSConv3DOpHandler::MPSConv3DOpHandler(EmitterViewerSPI::MPSConv3DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986EA8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v95 == 11 && *AttrData == 0x766E6F632E73706DLL && *(void *)((char *)AttrData + 3) == 0x64335F766E6F632ELL)
    {
      __int16 v106 = 1283;
      v105[0] = (uint64_t)"classof on '";
      v105[2] = (uint64_t)"mps.conv_3d";
      v105[3] = 11;
      int64_t v103 = "' failed due to the operation not being registered";
      __int16 v104 = 259;
      llvm::operator+(v105, (uint64_t *)&v103, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_74:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id) {
    goto LABEL_74;
  }
  __int16 v102 = a3;
  v105[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v105);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v108 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v108) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v108 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v99 = [NSString stringWithCString:v13 encoding:4];
  __int16 v101 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v102);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v101 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v102);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v101 addObject:v17];
  }

  __int16 v100 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v102);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v100 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  v105[0] = 0;
  v105[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v102);
  BOOL v98 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"groups" dataType:64 shape:&unk_1EC9F0518];
  if (v98)
  {
    unint64_t v24 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v105 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v98 setValue:v24];

    [v23 addObject:v98];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v102);
  uint64_t v26 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v28 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v29 = 692;
    uint64_t v30 = "Casting.h";
    int v31 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26))
  {
    uint64_t v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v29 = 566;
    uint64_t v30 = "Casting.h";
    int v31 = "cast";
LABEL_59:
    __assert_rtn(v31, v30, v29, v28);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26);
  if (!InterfaceFor)
  {
    uint64_t v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v29 = 98;
    uint64_t v30 = "InterfaceSupport.h";
    int v31 = "Interface";
    goto LABEL_59;
  }
LABEL_30:
  BOOL v97 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v26, InterfaceFor);
  if (v97) {
    [v23 addObject:v97];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v102);
  uint64_t v33 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v34 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    int v37 = "Casting.h";
    int v38 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    uint64_t v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    int v37 = "Casting.h";
    int v38 = "cast";
LABEL_62:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    uint64_t v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    int v37 = "InterfaceSupport.h";
    int v38 = "Interface";
    goto LABEL_62;
  }
LABEL_38:
  uint64_t v39 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v102);
  __int16 v41 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v42 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    uint64_t v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int v45 = "Casting.h";
    int v46 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    uint64_t v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int v45 = "Casting.h";
    int v46 = "cast";
LABEL_65:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    uint64_t v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int v45 = "InterfaceSupport.h";
    int v46 = "Interface";
    goto LABEL_65;
  }
LABEL_46:
  int64_t v47 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v102);
  uint64_t v49 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v49 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v49 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v49 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v49 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v49 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v49 value:PaddingStyle];
  if (v55) {
    [v23 addObject:v55];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v102);
  uint64_t v57 = [MEMORY[0x1E4F1CA48] array];
  __int16 v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v57 addObject:v58];

  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v57 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v57 addObject:v60];

  __int16 v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v57 addObject:v61];

  __int16 v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v57 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v57 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v57 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v57 addObject:v65];

  int64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v57 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v57 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v57 addObject:v68];

  __int16 v69 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v57 value:StorageType];
  if (v69) {
    [v23 addObject:v69];
  }

  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v102);
  uint64_t v71 = [MEMORY[0x1E4F1CA48] array];
  char v72 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v71 addObject:v72];

  __int16 v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v71 addObject:v73];

  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v71 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v71 addObject:v75];

  uint64_t v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v71 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v71 addObject:v77];

  int v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v71 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v71 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v71 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v71 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v71 addObject:v82];

  unint64_t v83 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v71 value:WeightsLayout];
  if (v83) {
    [v23 addObject:v83];
  }

  unint64_t v84 = [MEMORY[0x1E4F1CA48] array];
  v85 = [MPSGraphViewerNodeSPI alloc];
  int8x8_t v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v101];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v100];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  __int16 v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v84];
  uint64_t v90 = [(MPSGraphViewerNodeSPI *)v85 initWithType:v99 inputs:v86 outputs:v87 properties:v88 regions:v89];
  uint64_t v91 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v90;
  uint64_t v92 = ;
  [*((id *)this + 3) setLocalizedDescription:v92];

  if (SHIBYTE(v108) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E0EB9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler *EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler::MPSConv3DWeightsGradientOpHandler(EmitterViewerSPI::MPSConv3DWeightsGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988438;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 28)
    {
      BOOL v97 = *(void *)AttrData == 0x766E6F632E73706DLL && *(void *)(AttrData + 8) == 0x676965775F64335FLL;
      BOOL v98 = v97 && *(void *)(AttrData + 16) == 0x646172675F737468;
      if (v98 && *(_DWORD *)(AttrData + 24) == 1953391977)
      {
        __int16 v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.conv_3d_weights_gradient";
        v108[3] = 28;
        __int16 v106 = "' failed due to the operation not being registered";
        __int16 v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_82:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Conv3DWeightsGradientOp,void>::id) {
    goto LABEL_82;
  }
  __int16 v105 = a3;
  v108[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v111 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v100 = [NSString stringWithCString:v13 encoding:4];
  __int16 v104 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v104 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v17) {
    [v104 addObject:v17];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v105);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"outputShape", Bias);
  if (v19) {
    [v104 addObject:v19];
  }

  int64_t v103 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v103 addObject:v24];
    }
  }
  else
  {

    unint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  v108[0] = 0;
  v108[0] = (uint64_t)mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v105);
  __int16 v102 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"groups" dataType:64 shape:&unk_1EC9F0530];
  if (v102)
  {
    uint64_t v26 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v108 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v102 setValue:v26];

    [v25 addObject:v102];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v105);
  uint64_t v28 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v30 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v31 = 692;
    uint64_t v32 = "Casting.h";
    uint64_t v33 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28))
  {
    uint64_t v30 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v31 = 566;
    uint64_t v32 = "Casting.h";
    uint64_t v33 = "cast";
LABEL_61:
    __assert_rtn(v33, v32, v31, v30);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v28);
  if (!InterfaceFor)
  {
    uint64_t v30 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v31 = 98;
    uint64_t v32 = "InterfaceSupport.h";
    uint64_t v33 = "Interface";
    goto LABEL_61;
  }
LABEL_32:
  __int16 v101 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v28, InterfaceFor);
  if (v101) {
    [v25 addObject:v101];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  uint64_t v35 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v36 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    int v37 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v38 = 692;
    uint64_t v39 = "Casting.h";
    __int16 v40 = "cast_if_present";
    goto LABEL_64;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35))
  {
    int v37 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v38 = 566;
    uint64_t v39 = "Casting.h";
    __int16 v40 = "cast";
LABEL_64:
    __assert_rtn(v40, v39, v38, v37);
  }
  uint64_t v36 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35);
  if (!v36)
  {
    int v37 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v38 = 98;
    uint64_t v39 = "InterfaceSupport.h";
    __int16 v40 = "Interface";
    goto LABEL_64;
  }
LABEL_40:
  __int16 v41 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v35, v36);
  if (v41) {
    [v25 addObject:v41];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  uint64_t v43 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v44 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    int v45 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v46 = 692;
    int64_t v47 = "Casting.h";
    int64_t v48 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43))
  {
    int v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v46 = 566;
    int64_t v47 = "Casting.h";
    int64_t v48 = "cast";
LABEL_67:
    __assert_rtn(v48, v47, v46, v45);
  }
  uint64_t v44 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43);
  if (!v44)
  {
    int v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v46 = 98;
    int64_t v47 = "InterfaceSupport.h";
    int64_t v48 = "Interface";
    goto LABEL_67;
  }
LABEL_48:
  uint64_t v49 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v43, v44);
  if (v49) {
    [v25 addObject:v49];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  __int16 v51 = [MEMORY[0x1E4F1CA48] array];
  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v51 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v51 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v51 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v51 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v51 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v51 value:PaddingStyle];
  if (v57) {
    [v25 addObject:v57];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  __int16 v59 = [MEMORY[0x1E4F1CA48] array];
  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v59 addObject:v60];

  __int16 v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v59 addObject:v61];

  __int16 v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v59 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v59 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v59 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v59 addObject:v65];

  int64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v59 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v59 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v59 addObject:v68];

  __int16 v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v59 addObject:v69];

  int64_t v70 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v59 addObject:v70];

  uint64_t v71 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v59 value:StorageType];
  if (v71) {
    [v25 addObject:v71];
  }

  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  __int16 v73 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v73 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v73 addObject:v75];

  uint64_t v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v73 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v73 addObject:v77];

  int v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v73 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v73 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v73 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v73 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v73 addObject:v82];

  unint64_t v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v73 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v73 addObject:v84];

  v85 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v73 value:WeightsLayout];
  if (v85) {
    [v25 addObject:v85];
  }

  int8x8_t v86 = [MEMORY[0x1E4F1CA48] array];
  __int16 v87 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v104];
  __int16 v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v103];
  uint64_t v90 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v91 = [MEMORY[0x1E4F1C978] arrayWithArray:v86];
  uint64_t v92 = [(MPSGraphViewerNodeSPI *)v87 initWithType:v100 inputs:v88 outputs:v89 properties:v90 regions:v91];
  BOOL v93 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v92;

  if (SHIBYTE(v111) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E0FBB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCosOpHandler *EmitterViewerSPI::MPSCosOpHandler::MPSCosOpHandler(EmitterViewerSPI::MPSCosOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9866C8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1936679726)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.cos";
      v41[3] = 7;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CosOp,void>::id) {
    goto LABEL_31;
  }
  int v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  int v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E102C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCoshOpHandler *EmitterViewerSPI::MPSCoshOpHandler::MPSCoshOpHandler(EmitterViewerSPI::MPSCoshOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986968;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x68736F632E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.cosh";
      v40[3] = 8;
      int v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CoshOp,void>::id) {
    goto LABEL_27;
  }
  int v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  int v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E10834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCostVolumeOpHandler *EmitterViewerSPI::MPSCostVolumeOpHandler::MPSCostVolumeOpHandler(EmitterViewerSPI::MPSCostVolumeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987700;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v66 == 15 && *AttrData == 0x74736F632E73706DLL && *(void *)((char *)AttrData + 7) == 0x656D756C6F765F74)
    {
      __int16 v78 = 1283;
      v77[0] = (uint64_t)"classof on '";
      v77[2] = (uint64_t)"mps.cost_volume";
      v77[3] = 15;
      v75[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v76 = 259;
      llvm::operator+(v77, v75, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_53:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CostVolumeOp,void>::id) {
    goto LABEL_53;
  }
  uint64_t v74 = a3;
  v77[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v77);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v80 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v80) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v80 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v68 = [NSString stringWithCString:v13 encoding:4];
  int64_t v70 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v74);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"ref", Input);
  if (v15) {
    [v70 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v74);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v17) {
    [v70 addObject:v17];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v74);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"coordinates", Bias);
  if (v19) {
    [v70 addObject:v19];
  }

  __int16 v69 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v74);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v69 addObject:v24];
    }
  }
  else
  {

    unint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  BOOL NormalizeCoordinates = mlir::mps::CostVolumeOp::getNormalizeCoordinates((mlir::mps::CostVolumeOp *)&v74);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"normalize_coordinates" dataType:2147483656 shape:&unk_1EC9F0548];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&NormalizeCoordinates length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  BOOL ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v74);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"relative_coordinates" dataType:2147483656 shape:&unk_1EC9F0560];
  if (v28)
  {
    int v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&ResetAfter length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }
  v77[0] = 0;
  v77[0] = (uint64_t)mlir::mps::CostVolumeOp::getWindowHeight((mlir::mps::CostVolumeOp *)&v74);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"window_height" dataType:64 shape:&unk_1EC9F0578];
  if (v30)
  {
    int v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v77 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v25 addObject:v30];
  }
  v75[0] = 0;
  v75[0] = (uint64_t)mlir::mps::CostVolumeOp::getWindowWidth((mlir::mps::CostVolumeOp *)&v74);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"window_width" dataType:64 shape:&unk_1EC9F0590];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v75 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v25 addObject:v32];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v74);
  uint64_t v35 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"dot_product" value:0];
  [v35 addObject:v36];

  int v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"abs_diff" value:1];
  [v35 addObject:v37];

  int v38 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"similarity_type" type:@"MPSSimilarityType" cases:v35 value:PaddingStyle];
  if (v38) {
    [v25 addObject:v38];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v74);
  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  __int16 v41 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v40 addObject:v41];

  __int16 v42 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v40 addObject:v42];

  int64_t v43 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v40 addObject:v43];

  int64_t v44 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v40 addObject:v44];

  int v45 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v40 addObject:v45];

  int v46 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v40 addObject:v46];

  int64_t v47 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v40 addObject:v47];

  int64_t v48 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v40 addObject:v48];

  uint64_t v49 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v40 addObject:v49];

  uint64_t v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v40 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v40 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v40 value:Layout];
  if (v52) {
    [v25 addObject:v52];
  }

  unsigned __int16 IsXOnly = mlir::mps::CostVolumeOp::getCoordIsXOnly((mlir::mps::CostVolumeOp *)&v74);
  if (IsXOnly >= 0x100u)
  {
    __int16 v53 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"coord_is_x_only" dataType:2147483656 shape:&unk_1EC9F05A8];
    if (v53)
    {
      if (!HIBYTE(IsXOnly)) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      __int16 v54 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&IsXOnly length:2];
      [(MPSGraphViewerNodePropertyDataSPI *)v53 setValue:v54];

      [v25 addObject:v53];
    }
  }
  int64_t v55 = [MEMORY[0x1E4F1CA48] array];
  __int16 v56 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v57 = [MEMORY[0x1E4F1C978] arrayWithArray:v70];
  __int16 v58 = [MEMORY[0x1E4F1C978] arrayWithArray:v69];
  __int16 v59 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  int64_t v60 = [MEMORY[0x1E4F1C978] arrayWithArray:v55];
  uint64_t v61 = [(MPSGraphViewerNodeSPI *)v56 initWithType:v68 inputs:v57 outputs:v58 properties:v59 regions:v60];
  __int16 v62 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v61;

    "rue, sampling_mode=\"bilinear\"\n"
    "\n"
    "Data type: float\n"
    "\n"
    "\n"
    "put HW. Otherwise, the coordinates are absolute and directly used for sampling. Note that if the final coordinate fo"
    "r sampling (absolute or relative + fixed) exceeds pixel boundaries, the sampled data will be 0 prior to doing any ca"
    "\n"
    " Similarity computation method between two feature vectors A, B. \"dot_product\" or \"absolute difference\" only. De"
    "fault: \"dot_product\". \"dot_product\": dot_product(A,B) \"abs_diff\": sum(abs(A-B))\n"
    "\n"
    "fault: NCHW.\n"
    "\n"
    " is along W dimension. Otherwise, it is along H dimension.\n"
    "\n"
    "When C2 = 2, it should not be provided and will be ignored. Data type: BoolAttr.\n"
    "\n"
    "\n"
    "Core Computation Code:\n"
    "For 2D case, i.e., C = 2 in coordinates. \n"
    "\n"
  __int16 v63 = "For 1D case, i.e., C = 1 in coordinates. window_height = 1 max_displacement = window_width - 1");;
  [*((id *)this + 3) setLocalizedDescription:v63];

  if (SHIBYTE(v80) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E113C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCreateComplexOpHandler *EmitterViewerSPI::MPSCreateComplexOpHandler::MPSCreateComplexOpHandler(EmitterViewerSPI::MPSCreateComplexOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987B68;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 18)
    {
      BOOL v38 = *(void *)AttrData == 0x616572632E73706DLL && *(void *)(AttrData + 8) == 0x6C706D6F635F6574;
      if (v38 && *(_WORD *)(AttrData + 16) == 30821)
      {
        __int16 v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        uint64_t v44[2] = (uint64_t)"mps.create_complex";
        v44[3] = 18;
        __int16 v42 = "' failed due to the operation not being registered";
        __int16 v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CreateComplexOp,void>::id) {
    goto LABEL_36;
  }
  __int16 v41 = a3;
  v44[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v40 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"real", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"imag", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unint64_t v21 = @"output";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"output" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    unint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  int v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v40 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E11B1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCreateTextureTensorOpHandler *EmitterViewerSPI::MPSCreateTextureTensorOpHandler::MPSCreateTextureTensorOpHandler(EmitterViewerSPI::MPSCreateTextureTensorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988318;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 25)
    {
      BOOL v51 = *(void *)AttrData == 0x616572632E73706DLL && *(void *)(AttrData + 8) == 0x75747865745F6574;
      BOOL v52 = v51 && *(void *)(AttrData + 16) == 0x6F736E65745F6572;
      if (v52 && *(unsigned char *)(AttrData + 24) == 114)
      {
        __int16 v59 = 1283;
        v58[0] = (uint64_t)"classof on '";
        uint64_t v58[2] = (uint64_t)"mps.create_texture_tensor";
        v58[3] = 25;
        __int16 v56 = "' failed due to the operation not being registered";
        __int16 v57 = 259;
        llvm::operator+(v58, (uint64_t *)&v56, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CreateTextureTensorOp,void>::id) {
    goto LABEL_41;
  }
  int64_t v55 = a3;
  v58[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v58);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v61 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v61) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v61 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v54 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v55);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v55);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v55);
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"R8Unorm" value:0];
  [v25 addObject:v26];

  uint64_t v27 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"RG8Unorm" value:1];
  [v25 addObject:v27];

  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"RGBA8Unorm" value:2];
  [v25 addObject:v28];

  int v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"BGRA8Unorm" value:3];
  [v25 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"R16Float" value:4];
  [v25 addObject:v30];

  int v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"RG16Float" value:5];
  [v25 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"RGBA16Float" value:6];
  [v25 addObject:v32];

  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"R32Float" value:7];
  [v25 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"RG32Float" value:8];
  [v25 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"RGBA32Float" value:9];
  [v25 addObject:v35];

  uint64_t v36 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"pixel_format" type:@"MPSMetalPixelFormat" cases:v25 value:Layout];
  if (v36) {
    [v23 addObject:v36];
  }

  LOBYTE(v58[0]) = 0;
  LOBYTE(v58[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v55);
  uint64_t v37 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"compressed" dataType:2147483656 shape:&unk_1EC9F05C0];
  if (v37)
  {
    BOOL v38 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v58 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v37 setValue:v38];

    [v23 addObject:v37];
  }

  __int16 v39 = [MEMORY[0x1E4F1CA48] array];
  __int16 v40 = [MPSGraphViewerNodeSPI alloc];
  __int16 v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  __int16 v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int64_t v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v39];
  uint64_t v45 = [(MPSGraphViewerNodeSPI *)v40 initWithType:v54 inputs:v41 outputs:v42 properties:v43 regions:v44];
  int v46 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v45;

  int64_t v47 = [NSString stringWithUTF8String:"Creates a textureTensor op with a specified pixel format format from a tensor. The input is expected to be in NHWC data layout."];
  [*((id *)this + 3) setLocalizedDescription:v47];

  if (SHIBYTE(v61) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E12370(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCropOpHandler *EmitterViewerSPI::MPSCropOpHandler::MPSCropOpHandler(EmitterViewerSPI::MPSCropOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986980;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 8 && *AttrData == 0x706F72632E73706DLL)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.crop";
      v45[3] = 8;
      __int16 v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"amount_before", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v42);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"amount_after", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v24)];

    if (v24) {
      [v23 addObject:v24];
    }
  }
  else
  {
  }
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  int v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [MPSGraphViewerNodeSPI alloc];
  int v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v35 = [(MPSGraphViewerNodeSPI *)v30 initWithType:v41 inputs:v31 outputs:v32 properties:v33 regions:v34];
  uint64_t v36 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v35;
  uint64_t v37 = ;
  [*((id *)this + 3) setLocalizedDescription:v37];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E129DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCropResizeOpHandler *EmitterViewerSPI::MPSCropResizeOpHandler::MPSCropResizeOpHandler(EmitterViewerSPI::MPSCropResizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v79[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987718;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v77 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v77);
    if (v62 == 15 && *AttrData == 0x706F72632E73706DLL && *(void *)((char *)AttrData + 7) == 0x657A697365725F70)
    {
      __int16 v76 = 1283;
      __dst[0] = "classof on '";
      uint64_t v74 = "mps.crop_resize";
      uint64_t v75 = 15;
      v71[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v72 = 259;
      llvm::operator+((uint64_t *)__dst, v71, (uint64_t)&v77);
      llvm::report_fatal_error((llvm::Twine *)&v77, 1);
    }
LABEL_50:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeOp,void>::id) {
    goto LABEL_50;
  }
  int64_t v70 = a3;
  uint64_t v77 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v77);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    uint64_t v74 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v74) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v74) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v64 = [NSString stringWithCString:v13 encoding:4];
  int64_t v67 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v70);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"images", Input);
  if (v15) {
    [v67 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v70);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"boxes", Filter);
  if (v17) {
    [v67 addObject:v17];
  }

  uint64_t v66 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v70);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v66 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v71[0]) = 0;
  LODWORD(v71[0]) = mlir::mps::CropResizeOp::getResizeHeight((mlir::mps::CropResizeOp *)&v70);
  __int16 v65 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"resize_height" dataType:32 shape:&unk_1EC9F05D8];
  if (v65)
  {
    unint64_t v24 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v71 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v65 setValue:v24];

    [v23 addObject:v65];
  }
  unsigned int WindowHeight = mlir::mps::CostVolumeOp::getWindowHeight((mlir::mps::CostVolumeOp *)&v70);
  uint64_t v25 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"resize_width" dataType:32 shape:&unk_1EC9F05F0];
  if (v25)
  {
    uint64_t v26 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&WindowHeight length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v25 setValue:v26];

    [v23 addObject:v25];
  }
  BOOL ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v70);
  uint64_t v27 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"normalize_coordinates" dataType:2147483656 shape:&unk_1EC9F0608];
  if (v27)
  {
    uint64_t v28 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&ResetAfter length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v27 setValue:v28];

    [v23 addObject:v27];
  }
  mlir::mps::CropResizeOp::getSpatialScale((mlir::mps::CropResizeOp *)&v70, (uint64_t)&v77);
  int v29 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"spatial_scale" dataType:268435488 shape:&unk_1EC9F0620];
  if (v29)
  {
    uint64_t v30 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v77 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v29 setValue:v30];

    [v23 addObject:v29];
  }
  Gateunsigned int Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v70);
  uint64_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"nearest" value:0];
  [v32 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"bilinear" value:1];
  [v32 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"interpolation_mode" type:@"MPSSamplingMode" cases:v32 value:GateLayout];
  if (v35) {
    [v23 addObject:v35];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v70);
  uint64_t v37 = [MEMORY[0x1E4F1CA48] array];
  BOOL v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"defaultAlignment" value:0];
  [v37 addObject:v38];

  __int16 v39 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"alignCorners" value:1];
  [v37 addObject:v39];

  uint64_t v40 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"offsetCorners" value:2];
  [v37 addObject:v40];

  __int16 v41 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"alignment_mode" type:@"MPSCropResizeAlignmentMode" cases:v37 value:StorageType];
  if (v41) {
    [v23 addObject:v41];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v70);
  __int16 v43 = [MEMORY[0x1E4F1CA48] array];
  __int16 v44 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"cornersHeightFirst" value:0];
  [v43 addObject:v44];

  uint64_t v45 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"cornersWidthFirst" value:1];
  [v43 addObject:v45];

  __int16 v46 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"centersHeightFirst" value:2];
  [v43 addObject:v46];

  int64_t v47 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"centersWidthFirst" value:3];
  [v43 addObject:v47];

  int64_t v48 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"coordinate_mode" type:@"MPSCropResizeCoordinateMode" cases:v43 value:Layout];
  if (v48) {
    [v23 addObject:v48];
  }

  uint64_t v49 = v78;
  if (llvm::APFloatBase::PPCDoubleDouble(v50) == v49) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v79);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v78);
  }

  BOOL v51 = [MEMORY[0x1E4F1CA48] array];
  BOOL v52 = [MPSGraphViewerNodeSPI alloc];
  __int16 v53 = [MEMORY[0x1E4F1C978] arrayWithArray:v67];
  __int16 v54 = [MEMORY[0x1E4F1C978] arrayWithArray:v66];
  int64_t v55 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  __int16 v56 = [MEMORY[0x1E4F1C978] arrayWithArray:v51];
  uint64_t v57 = [(MPSGraphViewerNodeSPI *)v52 initWithType:v64 inputs:v53 outputs:v54 properties:v55 regions:v56];
  __int16 v58 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v57;

    "follows Default:\n"
    "spacing = (Xin - Xin/Xout) / (Xout - 1)\n"
    "grid_point[i] = min(Xin-1, max(0, i*spacing)), for i=0,1,...,Xout-1\n"
    "\n"
    "Align Corners: spacing = (Xin - 1) / (Xout - 1) grid_point[0] = (Xin-1) / 2, if Xout==1 grid_point[i] = min(Xin-1, m"
    "ax(0, i*spacing)), for i=0,1,...,Xout-1\n"
    "\n"
    "Offset Corners: delta = max(1, Xin - 1) / Xout spacing = ((Xout - 1) * delta) / (Xout - 1) grid_point[i] = min(Xin-1"
    ", max(0, 0.5*delta + i*spacing)), for i=0,1,...,Xout-1\n"
    "\n"
    "d ending at end point. End coordinates less than start coordinates are supported, and in such cases input images are"
    " flipped along that axis. Center coordinate modes define a box with center point and provided height and width. Corn"
    "ersHeightFirst:\n"
    "[h_start, w_start, h_end, w_end]\n"
    "\n"
    "CornersWidthFirst: [w_start, h_start, w_end, h_end]\n"
    "\n"
    "CentersHeightFirst: [h_center, w_center, box_height, box_width]\n"
    "\n"
  __int16 v59 = "CentersWidthFirst: [w_center, h_center, box_width, box_height]");
  [*((id *)this + 3) setLocalizedDescription:v59];

  if (SHIBYTE(v74) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E134C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,char a29)
{
  if (a26 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCumulativeMaximumOpHandler *EmitterViewerSPI::MPSCumulativeMaximumOpHandler::MPSCumulativeMaximumOpHandler(EmitterViewerSPI::MPSCumulativeMaximumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988150;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 22)
    {
      BOOL v42 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x6D5F65766974616CLL;
      if (v42 && *(void *)((char *)AttrData + 14) == 0x6D756D6978616D5FLL)
      {
        __int16 v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.cumulative_maximum";
        v48[3] = 22;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id) {
    goto LABEL_40;
  }
  uint64_t v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v44 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    unint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"exclusive" dataType:2147483656 shape:&unk_1EC9F0638];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"reverse" dataType:2147483656 shape:&unk_1EC9F0650];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  int v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v44 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  BOOL v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E13D24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCumulativeMinimumOpHandler *EmitterViewerSPI::MPSCumulativeMinimumOpHandler::MPSCumulativeMinimumOpHandler(EmitterViewerSPI::MPSCumulativeMinimumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988168;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 22)
    {
      BOOL v42 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x6D5F65766974616CLL;
      if (v42 && *(void *)((char *)AttrData + 14) == 0x6D756D696E696D5FLL)
      {
        __int16 v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.cumulative_minimum";
        v48[3] = 22;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id) {
    goto LABEL_40;
  }
  uint64_t v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v44 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    unint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"exclusive" dataType:2147483656 shape:&unk_1EC9F0668];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"reverse" dataType:2147483656 shape:&unk_1EC9F0680];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  int v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v44 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  BOOL v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E14438(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCumulativeProductOpHandler *EmitterViewerSPI::MPSCumulativeProductOpHandler::MPSCumulativeProductOpHandler(EmitterViewerSPI::MPSCumulativeProductOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988180;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 22)
    {
      BOOL v42 = *AttrData == 0x756D75632E73706DLL && AttrData[1] == 0x705F65766974616CLL;
      if (v42 && *(void *)((char *)AttrData + 14) == 0x746375646F72705FLL)
      {
        __int16 v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.cumulative_product";
        v48[3] = 22;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id) {
    goto LABEL_40;
  }
  uint64_t v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v44 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    unint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"exclusive" dataType:2147483656 shape:&unk_1EC9F0698];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"reverse" dataType:2147483656 shape:&unk_1EC9F06B0];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  int v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v44 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  BOOL v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E14B4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSCumulativeSumOpHandler *EmitterViewerSPI::MPSCumulativeSumOpHandler::MPSCumulativeSumOpHandler(EmitterViewerSPI::MPSCumulativeSumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987B80;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 18)
    {
      BOOL v42 = *(void *)AttrData == 0x756D75632E73706DLL && *(void *)(AttrData + 8) == 0x735F65766974616CLL;
      if (v42 && *(_WORD *)(AttrData + 16) == 28021)
      {
        __int16 v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.cumulative_sum";
        v48[3] = 18;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id) {
    goto LABEL_40;
  }
  uint64_t v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v44 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    unint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"exclusive" dataType:2147483656 shape:&unk_1EC9F06C8];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"reverse" dataType:2147483656 shape:&unk_1EC9F06E0];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  int v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v44 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  BOOL v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E15254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDegammaOpHandler *EmitterViewerSPI::MPSDegammaOpHandler::MPSDegammaOpHandler(EmitterViewerSPI::MPSDegammaOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987070;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 11 && *AttrData == 0x616765642E73706DLL && *(void *)((char *)AttrData + 3) == 0x616D6D616765642ELL)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.degamma";
      v41[3] = 11;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DegammaOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  int v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1582C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthToSpace2DOpHandler *EmitterViewerSPI::MPSDepthToSpace2DOpHandler::MPSDepthToSpace2DOpHandler(EmitterViewerSPI::MPSDepthToSpace2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987D18;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 21)
    {
      BOOL v46 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6170735F6F745F68;
      if (v46 && *(void *)((char *)AttrData + 13) == 0x64325F6563617073)
      {
        __int16 v53 = 1283;
        v52[0] = (uint64_t)"classof on '";
        v52[2] = (uint64_t)"mps.depth_to_space_2d";
        v52[3] = 21;
        v50[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v51 = 259;
        llvm::operator+(v52, v50, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthToSpace2DOp,void>::id) {
    goto LABEL_44;
  }
  __int16 v49 = a3;
  v52[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v55 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v48 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"width_axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"height_axis", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v49);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"depth_axis", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v52[0]) = 0;
  LODWORD(v52[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v49);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"block_size" dataType:32 shape:&unk_1EC9F06F8];
  if (v30)
  {
    int v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v52 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v29 addObject:v30];
  }
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v49);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"pixel_shuffle" dataType:2147483656 shape:&unk_1EC9F0710];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v50 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v29 addObject:v32];
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v35 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  BOOL v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v48 inputs:v36 outputs:v37 properties:v38 regions:v39];
  uint64_t v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;
  __int16 v42 = ;
  [*((id *)this + 3) setLocalizedDescription:v42];

  if (SHIBYTE(v55) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E15F58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler *EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler::MPSDepthwiseConv2DDataGradientOpHandler(EmitterViewerSPI::MPSDepthwiseConv2DDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9885D0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 35)
    {
      BOOL v97 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      BOOL v98 = v97 && AttrData[2] == 0x61645F64325F766ELL;
      BOOL v99 = v98 && AttrData[3] == 0x69646172675F6174;
      if (v99 && *(void *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        __int16 v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.depthwise_conv_2d_data_gradient";
        v108[3] = 35;
        __int16 v106 = "' failed due to the operation not being registered";
        __int16 v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_83:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id) {
    goto LABEL_83;
  }
  __int16 v105 = a3;
  v108[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v111 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v102 = [NSString stringWithCString:v13 encoding:4];
  __int16 v104 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v104 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v104 addObject:v17];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v105);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"outputShape", Bias);
  if (v19) {
    [v104 addObject:v19];
  }

  int64_t v103 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v103 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v105);
  uint64_t v27 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v30 = 692;
    int v31 = "Casting.h";
    uint64_t v32 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    uint64_t v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v30 = 566;
    int v31 = "Casting.h";
    uint64_t v32 = "cast";
LABEL_59:
    __assert_rtn(v32, v31, v30, v29);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    uint64_t v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v30 = 98;
    int v31 = "InterfaceSupport.h";
    uint64_t v32 = "Interface";
    goto LABEL_59;
  }
LABEL_30:
  __int16 v101 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v27, InterfaceFor);
  if (v101) {
    [v25 addObject:v101];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  uint64_t v34 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v35 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v37 = 692;
    BOOL v38 = "Casting.h";
    __int16 v39 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    uint64_t v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v37 = 566;
    BOOL v38 = "Casting.h";
    __int16 v39 = "cast";
LABEL_62:
    __assert_rtn(v39, v38, v37, v36);
  }
  uint64_t v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    uint64_t v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v37 = 98;
    BOOL v38 = "InterfaceSupport.h";
    __int16 v39 = "Interface";
    goto LABEL_62;
  }
LABEL_38:
  uint64_t v40 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v34, v35);
  if (v40) {
    [v25 addObject:v40];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  __int16 v42 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v43 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    int64_t v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v45 = 692;
    BOOL v46 = "Casting.h";
    __int16 v47 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    int64_t v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v45 = 566;
    BOOL v46 = "Casting.h";
    __int16 v47 = "cast";
LABEL_65:
    __assert_rtn(v47, v46, v45, v44);
  }
  uint64_t v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    int64_t v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v45 = 98;
    BOOL v46 = "InterfaceSupport.h";
    __int16 v47 = "Interface";
    goto LABEL_65;
  }
LABEL_46:
  int64_t v48 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v42, v43);
  if (v48) {
    [v25 addObject:v48];
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v105);
  uint64_t v50 = [MEMORY[0x1E4F1CA48] array];
  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v50 addObject:v51];

  BOOL v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v50 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v50 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v50 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v50 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v50 value:PaddingStyle];
  if (v56) {
    [v25 addObject:v56];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  __int16 v58 = [MEMORY[0x1E4F1CA48] array];
  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v58 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v58 addObject:v60];

  int64_t v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v58 addObject:v61];

  uint64_t v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v58 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v58 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v58 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v58 addObject:v65];

  uint64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v58 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v58 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v58 addObject:v68];

  __int16 v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v58 addObject:v69];

  int64_t v70 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v58 value:StorageType];
  if (v70) {
    [v25 addObject:v70];
  }

  unsigned int v71 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v105);
  __int16 v72 = [MEMORY[0x1E4F1CA48] array];
  __int16 v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v72 addObject:v73];

  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v72 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v72 addObject:v75];

  __int16 v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v72 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v72 addObject:v77];

  __int16 v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v72 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v72 addObject:v79];

  int64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v72 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v72 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v72 addObject:v82];

  unint64_t v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v72 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v72 value:v71];
  if (v84) {
    [v25 addObject:v84];
  }

  v85 = [MEMORY[0x1E4F1CA48] array];
  int8x8_t v86 = [MPSGraphViewerNodeSPI alloc];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v104];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v103];
  __int16 v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v90 = [MEMORY[0x1E4F1C978] arrayWithArray:v85];
  uint64_t v91 = [(MPSGraphViewerNodeSPI *)v86 initWithType:v102 inputs:v87 outputs:v88 properties:v89 regions:v90];
  uint64_t v92 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v91;

  BOOL v93 = [NSString stringWithUTF8String:"Depthwise Conv2D operation"];
  [*((id *)this + 3) setLocalizedDescription:v93];

  if (SHIBYTE(v111) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E16E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv2DOpHandler *EmitterViewerSPI::MPSDepthwiseConv2DOpHandler::MPSDepthwiseConv2DOpHandler(EmitterViewerSPI::MPSDepthwiseConv2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987EC8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v94 == 21)
    {
      BOOL v95 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v95 && *(void *)((char *)AttrData + 13) == 0x64325F766E6F635FLL)
      {
        __int16 v105 = 1283;
        v104[0] = (uint64_t)"classof on '";
        v104[2] = (uint64_t)"mps.depthwise_conv_2d";
        v104[3] = 21;
        __int16 v102 = "' failed due to the operation not being registered";
        __int16 v103 = 259;
        llvm::operator+(v104, (uint64_t *)&v102, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_75:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id) {
    goto LABEL_75;
  }
  __int16 v101 = a3;
  v104[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v104);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v107 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v107) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v107 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v98 = [NSString stringWithCString:v13 encoding:4];
  __int16 v100 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v101);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v100 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v101);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v100 addObject:v17];
  }

  BOOL v99 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v101);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v99 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v101);
  uint64_t v25 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_57;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_57:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_57;
  }
LABEL_28:
  BOOL v97 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v25, InterfaceFor);
  if (v97) {
    [v23 addObject:v97];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v101);
  uint64_t v32 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v33 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v34 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v35 = 692;
    uint64_t v36 = "Casting.h";
    int v37 = "cast_if_present";
    goto LABEL_60;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32))
  {
    uint64_t v34 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v35 = 566;
    uint64_t v36 = "Casting.h";
    int v37 = "cast";
LABEL_60:
    __assert_rtn(v37, v36, v35, v34);
  }
  uint64_t v33 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v32);
  if (!v33)
  {
    uint64_t v34 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v35 = 98;
    uint64_t v36 = "InterfaceSupport.h";
    int v37 = "Interface";
    goto LABEL_60;
  }
LABEL_36:
  BOOL v38 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v32, v33);
  if (v38) {
    [v23 addObject:v38];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v101);
  uint64_t v40 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v41 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    __int16 v42 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v43 = 692;
    int64_t v44 = "Casting.h";
    int v45 = "cast_if_present";
    goto LABEL_63;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40))
  {
    __int16 v42 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v43 = 566;
    int64_t v44 = "Casting.h";
    int v45 = "cast";
LABEL_63:
    __assert_rtn(v45, v44, v43, v42);
  }
  uint64_t v41 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v40);
  if (!v41)
  {
    __int16 v42 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v43 = 98;
    int64_t v44 = "InterfaceSupport.h";
    int v45 = "Interface";
    goto LABEL_63;
  }
LABEL_44:
  BOOL v46 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v40, v41);
  if (v46) {
    [v23 addObject:v46];
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v101);
  int64_t v48 = [MEMORY[0x1E4F1CA48] array];
  __int16 v49 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v48 addObject:v49];

  uint64_t v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v48 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v48 addObject:v51];

  BOOL v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v48 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v48 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v48 value:PaddingStyle];
  if (v54) {
    [v23 addObject:v54];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v101);
  __int16 v56 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v56 addObject:v57];

  __int16 v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v56 addObject:v58];

  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v56 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v56 addObject:v60];

  int64_t v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v56 addObject:v61];

  uint64_t v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v56 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v56 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v56 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v56 addObject:v65];

  uint64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v56 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v56 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v56 value:StorageType];
  if (v68) {
    [v23 addObject:v68];
  }

  unsigned int v69 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v101);
  int64_t v70 = [MEMORY[0x1E4F1CA48] array];
  unsigned int v71 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v70 addObject:v71];

  __int16 v72 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v70 addObject:v72];

  __int16 v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v70 addObject:v73];

  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v70 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v70 addObject:v75];

  __int16 v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v70 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v70 addObject:v77];

  __int16 v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v70 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v70 addObject:v79];

  int64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v70 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v70 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v70 value:v69];
  if (v82) {
    [v23 addObject:v82];
  }

  unint64_t v83 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v84 = [MPSGraphViewerNodeSPI alloc];
  v85 = [MEMORY[0x1E4F1C978] arrayWithArray:v100];
  int8x8_t v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v99];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v83];
  uint64_t v89 = [(MPSGraphViewerNodeSPI *)v84 initWithType:v98 inputs:v85 outputs:v86 properties:v87 regions:v88];
  uint64_t v90 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v89;

  uint64_t v91 = [NSString stringWithUTF8String:"Depthwise Conv2D operation"];
  [*((id *)this + 3) setLocalizedDescription:v91];

  if (SHIBYTE(v107) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E17D9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler *EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler::MPSDepthwiseConv2DWeightsGradientOpHandler(EmitterViewerSPI::MPSDepthwiseConv2DWeightsGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988648;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v96 == 38)
    {
      BOOL v97 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      BOOL v98 = v97 && AttrData[2] == 0x65775F64325F766ELL;
      BOOL v99 = v98 && AttrData[3] == 0x72675F7374686769;
      if (v99 && *(void *)((char *)AttrData + 30) == 0x746E656964617267)
      {
        __int16 v109 = 1283;
        v108[0] = (uint64_t)"classof on '";
        v108[2] = (uint64_t)"mps.depthwise_conv_2d_weights_gradient";
        v108[3] = 38;
        __int16 v106 = "' failed due to the operation not being registered";
        __int16 v107 = 259;
        llvm::operator+(v108, (uint64_t *)&v106, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_83:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DWeightsGradientOp,void>::id) {
    goto LABEL_83;
  }
  __int16 v105 = a3;
  v108[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v108);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v111 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v111) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v111 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v102 = [NSString stringWithCString:v13 encoding:4];
  __int16 v104 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v104 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v17) {
    [v104 addObject:v17];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v105);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"outputShape", Bias);
  if (v19) {
    [v104 addObject:v19];
  }

  __int16 v103 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v103 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v105);
  uint64_t v27 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v30 = 692;
    int v31 = "Casting.h";
    uint64_t v32 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    uint64_t v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v30 = 566;
    int v31 = "Casting.h";
    uint64_t v32 = "cast";
LABEL_59:
    __assert_rtn(v32, v31, v30, v29);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    uint64_t v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v30 = 98;
    int v31 = "InterfaceSupport.h";
    uint64_t v32 = "Interface";
    goto LABEL_59;
  }
LABEL_30:
  __int16 v101 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v27, InterfaceFor);
  if (v101) {
    [v25 addObject:v101];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v105);
  uint64_t v34 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v35 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v37 = 692;
    BOOL v38 = "Casting.h";
    __int16 v39 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    uint64_t v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v37 = 566;
    BOOL v38 = "Casting.h";
    __int16 v39 = "cast";
LABEL_62:
    __assert_rtn(v39, v38, v37, v36);
  }
  uint64_t v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    uint64_t v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v37 = 98;
    BOOL v38 = "InterfaceSupport.h";
    __int16 v39 = "Interface";
    goto LABEL_62;
  }
LABEL_38:
  uint64_t v40 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v34, v35);
  if (v40) {
    [v25 addObject:v40];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v105);
  __int16 v42 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v43 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    int64_t v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v45 = 692;
    BOOL v46 = "Casting.h";
    __int16 v47 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    int64_t v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v45 = 566;
    BOOL v46 = "Casting.h";
    __int16 v47 = "cast";
LABEL_65:
    __assert_rtn(v47, v46, v45, v44);
  }
  uint64_t v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    int64_t v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v45 = 98;
    BOOL v46 = "InterfaceSupport.h";
    __int16 v47 = "Interface";
    goto LABEL_65;
  }
LABEL_46:
  int64_t v48 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v42, v43);
  if (v48) {
    [v25 addObject:v48];
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v105);
  uint64_t v50 = [MEMORY[0x1E4F1CA48] array];
  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v50 addObject:v51];

  BOOL v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v50 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v50 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v50 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v50 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v50 value:PaddingStyle];
  if (v56) {
    [v25 addObject:v56];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v105);
  __int16 v58 = [MEMORY[0x1E4F1CA48] array];
  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v58 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v58 addObject:v60];

  int64_t v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v58 addObject:v61];

  uint64_t v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v58 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v58 addObject:v63];

  __int16 v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v58 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v58 addObject:v65];

  uint64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v58 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v58 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v58 addObject:v68];

  unsigned int v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v58 addObject:v69];

  int64_t v70 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v58 value:StorageType];
  if (v70) {
    [v25 addObject:v70];
  }

  unsigned int v71 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v105);
  __int16 v72 = [MEMORY[0x1E4F1CA48] array];
  __int16 v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v72 addObject:v73];

  uint64_t v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v72 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v72 addObject:v75];

  __int16 v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v72 addObject:v76];

  uint64_t v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v72 addObject:v77];

  __int16 v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v72 addObject:v78];

  v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v72 addObject:v79];

  int64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v72 addObject:v80];

  float v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v72 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v72 addObject:v82];

  unint64_t v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v72 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"weights_layout" type:@"MPSTensorDataLayout" cases:v72 value:v71];
  if (v84) {
    [v25 addObject:v84];
  }

  v85 = [MEMORY[0x1E4F1CA48] array];
  int8x8_t v86 = [MPSGraphViewerNodeSPI alloc];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v104];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v103];
  uint64_t v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v90 = [MEMORY[0x1E4F1C978] arrayWithArray:v85];
  uint64_t v91 = [(MPSGraphViewerNodeSPI *)v86 initWithType:v102 inputs:v87 outputs:v88 properties:v89 regions:v90];
  uint64_t v92 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v91;

  BOOL v93 = [NSString stringWithUTF8String:"DepthwiseConv2DWeightsGradient operation"];
  [*((id *)this + 3) setLocalizedDescription:v93];

  if (SHIBYTE(v111) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E18D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler *EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler::MPSDepthwiseConv3DDataGradientOpHandler(EmitterViewerSPI::MPSDepthwiseConv3DDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9885E8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v71 == 35)
    {
      BOOL v72 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      BOOL v73 = v72 && AttrData[2] == 0x61645F64335F766ELL;
      BOOL v74 = v73 && AttrData[3] == 0x69646172675F6174;
      if (v74 && *(void *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        __int16 v83 = 1283;
        v82[0] = (uint64_t)"classof on '";
        v82[2] = (uint64_t)"mps.depthwise_conv_3d_data_gradient";
        v82[3] = 35;
        int64_t v80 = "' failed due to the operation not being registered";
        __int16 v81 = 259;
        llvm::operator+(v82, (uint64_t *)&v80, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_81:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id) {
    goto LABEL_81;
  }
  v79 = a3;
  v82[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v82);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v85 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v85) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v85 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v76 = [NSString stringWithCString:v13 encoding:4];
  __int16 v78 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v79);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v78 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v79);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v78 addObject:v17];
  }
  unint64_t SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v79);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"output_shape", SplitSizes);
  if (v19) {
    [v78 addObject:v19];
  }

  uint64_t v77 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v79);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v77 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v79);
  uint64_t v27 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v30 = 692;
    int v31 = "Casting.h";
    uint64_t v32 = "cast_if_present";
    goto LABEL_57;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    uint64_t v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v30 = 566;
    int v31 = "Casting.h";
    uint64_t v32 = "cast";
LABEL_57:
    __assert_rtn(v32, v31, v30, v29);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    uint64_t v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v30 = 98;
    int v31 = "InterfaceSupport.h";
    uint64_t v32 = "Interface";
    goto LABEL_57;
  }
LABEL_30:
  uint64_t v33 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v27, InterfaceFor);
  if (v33) {
    [v25 addObject:v33];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v79);
  uint64_t v35 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v36 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    int v37 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v38 = 692;
    __int16 v39 = "Casting.h";
    uint64_t v40 = "cast_if_present";
    goto LABEL_60;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35))
  {
    int v37 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v38 = 566;
    __int16 v39 = "Casting.h";
    uint64_t v40 = "cast";
LABEL_60:
    __assert_rtn(v40, v39, v38, v37);
  }
  uint64_t v36 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35);
  if (!v36)
  {
    int v37 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v38 = 98;
    __int16 v39 = "InterfaceSupport.h";
    uint64_t v40 = "Interface";
    goto LABEL_60;
  }
LABEL_38:
  uint64_t v41 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v35, v36);
  if (v41) {
    [v25 addObject:v41];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v79);
  uint64_t v43 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v44 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    int v45 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v46 = 692;
    __int16 v47 = "Casting.h";
    int64_t v48 = "cast_if_present";
    goto LABEL_63;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43))
  {
    int v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v46 = 566;
    __int16 v47 = "Casting.h";
    int64_t v48 = "cast";
LABEL_63:
    __assert_rtn(v48, v47, v46, v45);
  }
  uint64_t v44 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43);
  if (!v44)
  {
    int v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v46 = 98;
    __int16 v47 = "InterfaceSupport.h";
    int64_t v48 = "Interface";
    goto LABEL_63;
  }
LABEL_46:
  __int16 v49 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v43, v44);
  if (v49) {
    [v25 addObject:v49];
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v79);
  __int16 v51 = [MEMORY[0x1E4F1CA48] array];
  BOOL v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v51 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v51 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v51 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v51 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v51 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v51 value:PaddingStyle];
  if (v57) {
    [v25 addObject:v57];
  }

  LODWORD(v82[0]) = 0;
  LODWORD(v82[0]) = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v79);
  __int16 v58 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"channelAxis" dataType:536870944 shape:&unk_1EC9F0728];
  if (v58)
  {
    __int16 v59 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v82 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v58 setValue:v59];

    [v25 addObject:v58];
  }

  int64_t v60 = [MEMORY[0x1E4F1CA48] array];
  int64_t v61 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v62 = [MEMORY[0x1E4F1C978] arrayWithArray:v78];
  __int16 v63 = [MEMORY[0x1E4F1C978] arrayWithArray:v77];
  __int16 v64 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v65 = [MEMORY[0x1E4F1C978] arrayWithArray:v60];
  uint64_t v66 = [(MPSGraphViewerNodeSPI *)v61 initWithType:v76 inputs:v62 outputs:v63 properties:v64 regions:v65];
  int64_t v67 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v66;
  int64_t v68 = ;
  [*((id *)this + 3) setLocalizedDescription:v68];

  if (SHIBYTE(v85) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E198D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv3DOpHandler *EmitterViewerSPI::MPSDepthwiseConv3DOpHandler::MPSDepthwiseConv3DOpHandler(EmitterViewerSPI::MPSDepthwiseConv3DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987EE0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v69 == 21)
    {
      BOOL v70 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      if (v70 && *(void *)((char *)AttrData + 13) == 0x64335F766E6F635FLL)
      {
        __int16 v79 = 1283;
        v78[0] = (uint64_t)"classof on '";
        v78[2] = (uint64_t)"mps.depthwise_conv_3d";
        v78[3] = 21;
        __int16 v76 = "' failed due to the operation not being registered";
        __int16 v77 = 259;
        llvm::operator+(v78, (uint64_t *)&v76, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_73:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id) {
    goto LABEL_73;
  }
  uint64_t v75 = a3;
  v78[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v78);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v81 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v81) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v81 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v72 = [NSString stringWithCString:v13 encoding:4];
  BOOL v74 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v75);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v74 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v75);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v74 addObject:v17];
  }

  BOOL v73 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v75);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v73 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v75);
  uint64_t v25 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    int v30 = "cast_if_present";
    goto LABEL_55;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    int v30 = "cast";
LABEL_55:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    int v30 = "Interface";
    goto LABEL_55;
  }
LABEL_28:
  int v31 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v75);
  uint64_t v33 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    int v37 = "Casting.h";
    int v38 = "cast_if_present";
    goto LABEL_58;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    uint64_t v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    int v37 = "Casting.h";
    int v38 = "cast";
LABEL_58:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    uint64_t v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    int v37 = "InterfaceSupport.h";
    int v38 = "Interface";
    goto LABEL_58;
  }
LABEL_36:
  __int16 v39 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v75);
  uint64_t v41 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    uint64_t v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int v45 = "Casting.h";
    int v46 = "cast_if_present";
    goto LABEL_61;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    uint64_t v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int v45 = "Casting.h";
    int v46 = "cast";
LABEL_61:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    uint64_t v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int v45 = "InterfaceSupport.h";
    int v46 = "Interface";
    goto LABEL_61;
  }
LABEL_44:
  __int16 v47 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v75);
  __int16 v49 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v49 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v49 addObject:v51];

  BOOL v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v49 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v49 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v49 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v49 value:PaddingStyle];
  if (v55) {
    [v23 addObject:v55];
  }

  LODWORD(v78[0]) = 0;
  LODWORD(v78[0]) = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v75);
  __int16 v56 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"channelAxis" dataType:536870944 shape:&unk_1EC9F0740];
  if (v56)
  {
    uint64_t v57 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v78 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v56 setValue:v57];

    [v23 addObject:v56];
  }

  __int16 v58 = [MEMORY[0x1E4F1CA48] array];
  __int16 v59 = [MPSGraphViewerNodeSPI alloc];
  int64_t v60 = [MEMORY[0x1E4F1C978] arrayWithArray:v74];
  int64_t v61 = [MEMORY[0x1E4F1C978] arrayWithArray:v73];
  uint64_t v62 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  __int16 v63 = [MEMORY[0x1E4F1C978] arrayWithArray:v58];
  uint64_t v64 = [(MPSGraphViewerNodeSPI *)v59 initWithType:v72 inputs:v60 outputs:v61 properties:v62 regions:v63];
  __int16 v65 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v64;
  uint64_t v66 = ;
  [*((id *)this + 3) setLocalizedDescription:v66];

  if (SHIBYTE(v81) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1A3A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler *EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler::MPSDepthwiseConv3DWeightsGradientOpHandler(EmitterViewerSPI::MPSDepthwiseConv3DWeightsGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988660;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v71 == 38)
    {
      BOOL v72 = *AttrData == 0x747065642E73706DLL && AttrData[1] == 0x6F635F6573697768;
      BOOL v73 = v72 && AttrData[2] == 0x65775F64335F766ELL;
      BOOL v74 = v73 && AttrData[3] == 0x72675F7374686769;
      if (v74 && *(void *)((char *)AttrData + 30) == 0x746E656964617267)
      {
        __int16 v83 = 1283;
        v82[0] = (uint64_t)"classof on '";
        v82[2] = (uint64_t)"mps.depthwise_conv_3d_weights_gradient";
        v82[3] = 38;
        int64_t v80 = "' failed due to the operation not being registered";
        __int16 v81 = 259;
        llvm::operator+(v82, (uint64_t *)&v80, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_81:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DWeightsGradientOp,void>::id) {
    goto LABEL_81;
  }
  __int16 v79 = a3;
  v82[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v82);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v85 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v85) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v85 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v76 = [NSString stringWithCString:v13 encoding:4];
  __int16 v78 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v79);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v78 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v79);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v17) {
    [v78 addObject:v17];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v79);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"output_shape", Bias);
  if (v19) {
    [v78 addObject:v19];
  }

  __int16 v77 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v79);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v77 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v79);
  uint64_t v27 = Strides;
  if (!Strides)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v30 = 692;
    int v31 = "Casting.h";
    uint64_t v32 = "cast_if_present";
    goto LABEL_57;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    uint64_t v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v30 = 566;
    int v31 = "Casting.h";
    uint64_t v32 = "cast";
LABEL_57:
    __assert_rtn(v32, v31, v30, v29);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    uint64_t v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v30 = 98;
    int v31 = "InterfaceSupport.h";
    uint64_t v32 = "Interface";
    goto LABEL_57;
  }
LABEL_30:
  uint64_t v33 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v27, InterfaceFor);
  if (v33) {
    [v25 addObject:v33];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v79);
  uint64_t v35 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v36 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    int v37 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v38 = 692;
    __int16 v39 = "Casting.h";
    uint64_t v40 = "cast_if_present";
    goto LABEL_60;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35))
  {
    int v37 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v38 = 566;
    __int16 v39 = "Casting.h";
    uint64_t v40 = "cast";
LABEL_60:
    __assert_rtn(v40, v39, v38, v37);
  }
  uint64_t v36 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v35);
  if (!v36)
  {
    int v37 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v38 = 98;
    __int16 v39 = "InterfaceSupport.h";
    uint64_t v40 = "Interface";
    goto LABEL_60;
  }
LABEL_38:
  uint64_t v41 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v35, v36);
  if (v41) {
    [v25 addObject:v41];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v79);
  uint64_t v43 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v44 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    int v45 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v46 = 692;
    __int16 v47 = "Casting.h";
    int64_t v48 = "cast_if_present";
    goto LABEL_63;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43))
  {
    int v45 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v46 = 566;
    __int16 v47 = "Casting.h";
    int64_t v48 = "cast";
LABEL_63:
    __assert_rtn(v48, v47, v46, v45);
  }
  uint64_t v44 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v43);
  if (!v44)
  {
    int v45 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v46 = 98;
    __int16 v47 = "InterfaceSupport.h";
    int64_t v48 = "Interface";
    goto LABEL_63;
  }
LABEL_46:
  __int16 v49 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v43, v44);
  if (v49) {
    [v25 addObject:v49];
  }
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v79);
  __int16 v51 = [MEMORY[0x1E4F1CA48] array];
  BOOL v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v51 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v51 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v51 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v51 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v51 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v51 value:PaddingStyle];
  if (v57) {
    [v25 addObject:v57];
  }

  LODWORD(v82[0]) = 0;
  LODWORD(v82[0]) = mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis((mlir::mps::DepthwiseConv3DDataGradientOp *)&v79);
  __int16 v58 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"channelAxis" dataType:536870944 shape:&unk_1EC9F0758];
  if (v58)
  {
    __int16 v59 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v82 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v58 setValue:v59];

    [v25 addObject:v58];
  }

  int64_t v60 = [MEMORY[0x1E4F1CA48] array];
  int64_t v61 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v62 = [MEMORY[0x1E4F1C978] arrayWithArray:v78];
  __int16 v63 = [MEMORY[0x1E4F1C978] arrayWithArray:v77];
  uint64_t v64 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v65 = [MEMORY[0x1E4F1C978] arrayWithArray:v60];
  uint64_t v66 = [(MPSGraphViewerNodeSPI *)v61 initWithType:v76 inputs:v62 outputs:v63 properties:v64 regions:v65];
  int64_t v67 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v66;
  int64_t v68 = ;
  [*((id *)this + 3) setLocalizedDescription:v68];

  if (SHIBYTE(v85) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1AEA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDequantizeLUTOpHandler *EmitterViewerSPI::MPSDequantizeLUTOpHandler::MPSDequantizeLUTOpHandler(EmitterViewerSPI::MPSDequantizeLUTOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987B98;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 18)
    {
      BOOL v40 = *(void *)AttrData == 0x757165642E73706DLL && *(void *)(AttrData + 8) == 0x6C5F657A69746E61;
      if (v40 && *(_WORD *)(AttrData + 16) == 29813)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.dequantize_lut";
        v46[3] = 18;
        uint64_t v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id) {
    goto LABEL_42;
  }
  uint64_t v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"palette_lut", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  v46[0] = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v43);
  if ((v46[0] & 0xFF00000000) != 0)
  {
    uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"axis" dataType:536870944 shape:&unk_1EC9F0770];
    if (v26)
    {
      if (!BYTE4(v46[0])) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:8];
      [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

      [v25 addObject:v26];
    }
  }
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  int v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;

    ", -3.0, -2.0].\n"
    "\n"
    "ow on which dim the vector is mapped to. out_shape[axis] = in_shape[axis] * vec_size.\n"
    "\n"
    "Example:\n"
    "\n"
    "0, 3.0, 2.0], [4.5, 1.5, 3.5, 3.5, 2.5]].\n"
    "\n"
    "Conv Weights example:\n"
    "If the weights shape are (O, I, H, W) = (36, 8, 3, 3), and the LUT has 16 entries, each of vec size 2,\n"
    "Then the quantized weights will be of shape (18, 8, 3, 3) and element type ui4 (16 entries).\n"
  uint64_t v36 = "Each quantized entry o set the corresponding weight FP value for the output channels [2*o, 2*o+1].");
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1B5CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDequantizeOpHandler *EmitterViewerSPI::MPSDequantizeOpHandler::MPSDequantizeOpHandler(EmitterViewerSPI::MPSDequantizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987730;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 14 && *AttrData == 0x757165642E73706DLL && *(void *)((char *)AttrData + 6) == 0x657A69746E617571)
    {
      __int16 v50 = 1283;
      v49[0] = (uint64_t)"classof on '";
      v49[2] = (uint64_t)"mps.dequantize";
      v49[3] = 14;
      __int16 v47 = "' failed due to the operation not being registered";
      __int16 v48 = 259;
      llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_43:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id) {
    goto LABEL_43;
  }
  int v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v45 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v46);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"scale", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v46);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"zero_point", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v46);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"min", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v46);
  v49[0] = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v46);
  if ((v49[0] & 0xFF00000000) != 0)
  {
    int v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"axis" dataType:536870944 shape:&unk_1EC9F0788];
    if (v30)
    {
      if (!BYTE4(v49[0])) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      int v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v49 length:8];
      [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

      [v29 addObject:v30];
    }
  }
  uint64_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  int v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v45 inputs:v34 outputs:v35 properties:v36 regions:v37];
  uint64_t v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;
  BOOL v40 = ;
  [*((id *)this + 3) setLocalizedDescription:v40];

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1BCC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDimensionSizeOpHandler *EmitterViewerSPI::MPSDimensionSizeOpHandler::MPSDimensionSizeOpHandler(EmitterViewerSPI::MPSDimensionSizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987BB0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 18)
    {
      BOOL v36 = *(void *)AttrData == 0x656D69642E73706DLL && *(void *)(AttrData + 8) == 0x69735F6E6F69736ELL;
      if (v36 && *(_WORD *)(AttrData + 16) == 25978)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.dimension_size";
        v42[3] = 18;
        BOOL v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DimensionSizeOp,void>::id) {
    goto LABEL_36;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  int v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v38 inputs:v27 outputs:v28 properties:v29 regions:v30];
  uint64_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1C2C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180E1C3E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDiracOpHandler *EmitterViewerSPI::MPSDiracOpHandler::MPSDiracOpHandler(EmitterViewerSPI::MPSDiracOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986C98;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x617269642E73706DLL && *(unsigned char *)(AttrData + 8) == 99)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.dirac";
      v41[3] = 9;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DiracOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1C84C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDivideOpHandler *EmitterViewerSPI::MPSDivideOpHandler::MPSDivideOpHandler(EmitterViewerSPI::MPSDivideOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986EC0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 10 && *(void *)AttrData == 0x697669642E73706DLL && *(_WORD *)(AttrData + 8) == 25956)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.divide";
      v43[3] = 10;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1CDFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSDynamicShapeCastOpHandler *EmitterViewerSPI::MPSDynamicShapeCastOpHandler::MPSDynamicShapeCastOpHandler(EmitterViewerSPI::MPSDynamicShapeCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988078;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 22)
    {
      BOOL v40 = *AttrData == 0x616E79642E73706DLL && AttrData[1] == 0x706168735F63696DLL;
      if (v40 && *(void *)((char *)AttrData + 14) == 0x747361635F657061)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.dynamic_shape_cast";
        v46[3] = 22;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::DynamicShapeCastOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"unranked" dataType:2147483656 shape:&unk_1EC9F07A0];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1D460(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSEluOpHandler *EmitterViewerSPI::MPSEluOpHandler::MPSEluOpHandler(EmitterViewerSPI::MPSEluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9866E0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970038062)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.elu";
      v43[3] = 7;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::EluOp,void>::id) {
    goto LABEL_33;
  }
  BOOL v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1DA3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSEqualToOpHandler *EmitterViewerSPI::MPSEqualToOpHandler::MPSEqualToOpHandler(EmitterViewerSPI::MPSEqualToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987088;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 9 && *(void *)AttrData == 0x617571652E73706DLL && *(unsigned char *)(AttrData + 8) == 108)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.equal";
      v43[3] = 9;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::EqualToOp,void>::id) {
    goto LABEL_33;
  }
  BOOL v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1E004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSErfOpHandler *EmitterViewerSPI::MPSErfOpHandler::MPSErfOpHandler(EmitterViewerSPI::MPSErfOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9866F8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1718773038)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.erf";
      v41[3] = 7;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ErfOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1E590(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExpandDimsOpHandler *EmitterViewerSPI::MPSExpandDimsOpHandler::MPSExpandDimsOpHandler(EmitterViewerSPI::MPSExpandDimsOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987748;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 15 && *AttrData == 0x617078652E73706DLL && *(void *)((char *)AttrData + 7) == 0x736D69645F646E61)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.expand_dims";
      v43[3] = 15;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;

  uint64_t v34 = objc_msgSend(NSString, "stringWithUTF8String:", "Insert a single-dimension at each axis in axes of the result tensor. Valid axis values must be in range - |result| <= axis < |result| |result| = |input| + K, where K = axes.shape[0].");
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1EB4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExponentBase2OpHandler *EmitterViewerSPI::MPSExponentBase2OpHandler::MPSExponentBase2OpHandler(EmitterViewerSPI::MPSExponentBase2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987BC8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 19)
    {
      BOOL v36 = *AttrData == 0x6F7078652E73706DLL && AttrData[1] == 0x7361625F746E656ELL;
      if (v36 && *(void *)((char *)AttrData + 11) == 0x325F657361625F74)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.exponent_base_2";
        v42[3] = 19;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ExponentBase2Op,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1F0FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExponentBase10OpHandler *EmitterViewerSPI::MPSExponentBase10OpHandler::MPSExponentBase10OpHandler(EmitterViewerSPI::MPSExponentBase10OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987D30;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      BOOL v36 = *(void *)AttrData == 0x6F7078652E73706DLL && *(void *)(AttrData + 8) == 0x7361625F746E656ELL;
      if (v36 && *(_DWORD *)(AttrData + 16) == 808542053)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.exponent_base_10";
        v42[3] = 20;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ExponentBase10Op,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1F68C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSExponentOpHandler *EmitterViewerSPI::MPSExponentOpHandler::MPSExponentOpHandler(EmitterViewerSPI::MPSExponentOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987340;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(void *)AttrData == 0x6F7078652E73706DLL && *(_DWORD *)(AttrData + 8) == 1953391982)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.exponent";
      v41[3] = 12;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E1FC08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSFastFourierTransformOpHandler *EmitterViewerSPI::MPSFastFourierTransformOpHandler::MPSFastFourierTransformOpHandler(EmitterViewerSPI::MPSFastFourierTransformOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988360;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 26)
    {
      BOOL v46 = *(void *)AttrData == 0x747361662E73706DLL && *(void *)(AttrData + 8) == 0x72656972756F665FLL;
      BOOL v47 = v46 && *(void *)(AttrData + 16) == 0x6F66736E6172745FLL;
      if (v47 && *(_WORD *)(AttrData + 24) == 28018)
      {
        __int16 v54 = 1283;
        v53[0] = (uint64_t)"classof on '";
        v53[2] = (uint64_t)"mps.fast_fourier_transform";
        v53[3] = 26;
        __int16 v51 = "' failed due to the operation not being registered";
        __int16 v52 = 259;
        llvm::operator+(v53, (uint64_t *)&v51, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_43:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id) {
    goto LABEL_43;
  }
  __int16 v50 = a3;
  v53[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v53);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v56 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v56) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v56 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v49 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v50);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v50);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v50);
  unint64_t v21 = @"output";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"output" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v50);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"size" value:1];
  [v27 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"unitary" value:2];
  [v27 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"scaling_mode" type:@"MPSFFTScalingMode" cases:v27 value:Layout];
  if (v31) {
    [v25 addObject:v31];
  }

  LOBYTE(v53[0]) = 0;
  LOBYTE(v53[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v50);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"inverse" dataType:2147483656 shape:&unk_1EC9F07B8];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v53 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v25 addObject:v32];
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v35 = [MPSGraphViewerNodeSPI alloc];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v49 inputs:v36 outputs:v37 properties:v38 regions:v39];
  __int16 v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;
  __int16 v42 = ;
  [*((id *)this + 3) setLocalizedDescription:v42];

  if (SHIBYTE(v56) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E20348(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSFlatten2DOpHandler *EmitterViewerSPI::MPSFlatten2DOpHandler::MPSFlatten2DOpHandler(EmitterViewerSPI::MPSFlatten2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987508;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 14 && *AttrData == 0x74616C662E73706DLL && *(void *)((char *)AttrData + 6) == 0x64325F6E65747461)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.flatten_2d";
      v43[3] = 14;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Flatten2DOp,void>::id) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2095C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSFloorDivideOpHandler *EmitterViewerSPI::MPSFloorDivideOpHandler::MPSFloorDivideOpHandler(EmitterViewerSPI::MPSFloorDivideOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987868;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 16 && *AttrData == 0x6F6F6C662E73706DLL && AttrData[1] == 0x6564697669645F72)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.floor_divide";
      v43[3] = 16;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FloorDivideOp,void>::id) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E20F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSFloorOpHandler *EmitterViewerSPI::MPSFloorOpHandler::MPSFloorOpHandler(EmitterViewerSPI::MPSFloorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986CB0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x6F6F6C662E73706DLL && *(unsigned char *)(AttrData + 8) == 114)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.floor";
      v41[3] = 9;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FloorOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E214BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGRUGradientOpHandler *EmitterViewerSPI::MPSGRUGradientOpHandler::MPSGRUGradientOpHandler(EmitterViewerSPI::MPSGRUGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987880;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v95 == 16 && *AttrData == 0x5F7572672E73706DLL && AttrData[1] == 0x746E656964617267)
    {
      __int16 v103 = 1283;
      v102[0] = (uint64_t)"classof on '";
      v102[2] = (uint64_t)"mps.gru_gradient";
      v102[3] = 16;
      v100[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v101 = 259;
      llvm::operator+(v102, v100, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_67:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GRUGradientOp,void>::id) {
    goto LABEL_67;
  }
  BOOL v99 = a3;
  v102[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v102);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v105 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v105) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v105 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v97 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v99);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient_input_sequence", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t RecurrentWeight = mlir::mps::LSTMGradientOp::getRecurrentWeight((mlir::mps::LSTMGradientOp *)&v99);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"recurrent_weight", RecurrentWeight);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t TrainingState = mlir::mps::LSTMGradientOp::getTrainingState((mlir::mps::LSTMGradientOp *)&v99);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"training_state", TrainingState);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t OutputCellFwd = mlir::mps::LSTMGradientOp::getOutputCellFwd((mlir::mps::LSTMGradientOp *)&v99);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"result_forward", OutputCellFwd);
  if (v22) {
    [v14 addObject:v22];
  }
  unint64_t InputState = mlir::mps::LSTMGradientOp::getInputState((mlir::mps::LSTMGradientOp *)&v99);
  uint64_t v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_state", InputState);
  if (v24) {
    [v14 addObject:v24];
  }

  unint64_t InputCell = mlir::mps::LSTMGradientOp::getInputCell((mlir::mps::LSTMGradientOp *)&v99);
  uint64_t v26 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"mask", InputCell);
  if (v26) {
    [v14 addObject:v26];
  }

  unint64_t Mask = mlir::mps::LSTMGradientOp::getMask((mlir::mps::LSTMGradientOp *)&v99);
  uint64_t v28 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"bias", Mask);
  if (v28) {
    [v14 addObject:v28];
  }

  BOOL v98 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v99);
  uint64_t v30 = @"gradient_output_sequence";
  if (v29)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v29->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v32 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v29->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v29 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_output_sequence" dataType:MPSDataType shape:v32 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v29)];

    if (v29) {
      [v98 addObject:v29];
    }
  }
  else
  {
  }
  Element = (MPSGraphViewerNodePortSPI *)mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v99);
  uint64_t v34 = @"gradient_recurrent_weight";
  if (Element)
  {
    uint64_t v35 = getMPSDataType((void *)(*(void *)&Element->_dataType & 0xFFFFFFFFFFFFFFF8));
    BOOL v36 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&Element->_dataType & 0xFFFFFFFFFFFFFFF8));
    Element = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_recurrent_weight" dataType:v35 shape:v36 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, Element)];

    if (Element) {
      [v98 addObject:Element];
    }
  }
  else
  {
  }
  Gradientunint64_t InputState = (MPSGraphViewerNodePortSPI *)mlir::mps::GRUGradientOp::getGradientInputState((mlir::mps::GRUGradientOp *)&v99);
  uint64_t v38 = @"gradient_input_state";
  if (GradientInputState)
  {
    uint64_t v39 = getMPSDataType((void *)(*(void *)&GradientInputState->_dataType & 0xFFFFFFFFFFFFFFF8));
    __int16 v40 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&GradientInputState->_dataType & 0xFFFFFFFFFFFFFFF8));
    Gradientunint64_t InputState = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_input_state" dataType:v39 shape:v40 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, GradientInputState)];

    if (GradientInputState) {
      [v98 addObject:GradientInputState];
    }
  }
  else
  {
  }
  Gradientunint64_t Bias = mlir::mps::GRUGradientOp::getGradientBias((mlir::mps::GRUGradientOp *)&v99);
  __int16 v42 = @"gradient_bias";
  if (GradientBias)
  {
    uint64_t v43 = getMPSDataType((void *)(*(void *)(GradientBias + 8) & 0xFFFFFFFFFFFFFFF8));
    int64_t v44 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(GradientBias + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v45 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_bias" dataType:v43 shape:v44 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, GradientBias)];

    if (v45) {
      [v98 addObject:v45];
    }
  }
  else
  {

    uint64_t v45 = 0;
  }

  int64_t v46 = [MEMORY[0x1E4F1CA48] array];
  unsigned int PaddingStyle = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v99);
  __int16 v48 = [MEMORY[0x1E4F1CA48] array];
  int64_t v49 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v48 addObject:v49];

  __int16 v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v48 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v48 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v48 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v48 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v48 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"zgate_activation" type:@"MPSRNNActivation" cases:v48 value:PaddingStyle];
  if (v55) {
    [v46 addObject:v55];
  }

  unsigned int v56 = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v99);
  uint64_t v57 = [MEMORY[0x1E4F1CA48] array];
  __int16 v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v57 addObject:v58];

  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v57 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v57 addObject:v60];

  int64_t v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v57 addObject:v61];

  uint64_t v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v57 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v57 addObject:v63];

  uint64_t v64 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"rgate_activation" type:@"MPSRNNActivation" cases:v57 value:v56];
  if (v64) {
    [v46 addObject:v64];
  }

  Gateunsigned int Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v99);
  uint64_t v66 = [MEMORY[0x1E4F1CA48] array];
  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v66 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v66 addObject:v68];

  uint64_t v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v66 addObject:v69];

  BOOL v70 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v66 addObject:v70];

  uint64_t v71 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v66 addObject:v71];

  BOOL v72 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v66 addObject:v72];

  BOOL v73 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"ogate_activation" type:@"MPSRNNActivation" cases:v66 value:GateLayout];
  if (v73) {
    [v46 addObject:v73];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v99);
  uint64_t v75 = [MEMORY[0x1E4F1CA48] array];
  __int16 v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ZRO" value:0];
  [v75 addObject:v76];

  __int16 v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"RZO" value:1];
  [v75 addObject:v77];

  __int16 v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ROZ" value:2];
  [v75 addObject:v78];

  __int16 v79 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"gate_layout" type:@"MPSGRUGateLayout" cases:v75 value:Layout];
  if (v79) {
    [v46 addObject:v79];
  }

  LOBYTE(v102[0]) = 0;
  LOBYTE(v102[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v99);
  int64_t v80 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"reset_after" dataType:2147483656 shape:&unk_1EC9F07D0];
  if (v80)
  {
    __int16 v81 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v102 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v80 setValue:v81];

    [v46 addObject:v80];
  }
  LOBYTE(v100[0]) = 0;
  LOBYTE(v100[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v99);
  BOOL v82 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"flip_z" dataType:2147483656 shape:&unk_1EC9F07E8];
  if (v82)
  {
    __int16 v83 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v100 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v82 setValue:v83];

    [v46 addObject:v82];
  }

  unint64_t v84 = [MEMORY[0x1E4F1CA48] array];
  int64_t v85 = [MPSGraphViewerNodeSPI alloc];
  int8x8_t v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v98];
  uint64_t v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v46];
  uint64_t v89 = [MEMORY[0x1E4F1C978] arrayWithArray:v84];
  uint64_t v90 = [(MPSGraphViewerNodeSPI *)v85 initWithType:v97 inputs:v86 outputs:v87 properties:v88 regions:v89];
  uint64_t v91 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v90;
  uint64_t v92 = ;
  [*((id *)this + 3) setLocalizedDescription:v92];

  if (SHIBYTE(v105) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E22414(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGRUOpHandler *EmitterViewerSPI::MPSGRUOpHandler::MPSGRUOpHandler(EmitterViewerSPI::MPSGRUOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986710;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v85 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970431790)
    {
      __int16 v94 = 1283;
      v93[0] = (uint64_t)"classof on '";
      v93[2] = (uint64_t)"mps.gru";
      v93[3] = 7;
      v91[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v92 = 259;
      llvm::operator+(v93, v91, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_57:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GRUOp,void>::id) {
    goto LABEL_57;
  }
  uint64_t v90 = a3;
  v93[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v93);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v96 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v96) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v96 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v87 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v90);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_sequence", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t RecurrentWeight = mlir::mps::LSTMOp::getRecurrentWeight((mlir::mps::LSTMOp *)&v90);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"recurrent_weight", RecurrentWeight);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t InputState = mlir::mps::LSTMOp::getInputState((mlir::mps::LSTMOp *)&v90);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_state", InputState);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t InputCell = mlir::mps::LSTMOp::getInputCell((mlir::mps::LSTMOp *)&v90);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"mask", InputCell);
  if (v22) {
    [v14 addObject:v22];
  }

  unint64_t Mask = mlir::mps::LSTMOp::getMask((mlir::mps::LSTMOp *)&v90);
  uint64_t v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"bias", Mask);
  if (v24) {
    [v14 addObject:v24];
  }

  uint64_t v88 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v90);
  uint64_t v26 = @"result";
  if (v25)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v25->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v25->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v28 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v25)];

    if (v25) {
      [v88 addObject:v25];
    }
  }
  else
  {
  }
  uint64_t TrainingState = mlir::mps::GRUOp::getTrainingState((mlir::mps::GRUOp *)&v90);
  uint64_t v30 = @"training_state";
  if (TrainingState)
  {
    uint64_t v31 = getMPSDataType((void *)(*(void *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v32 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v33 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"training_state" dataType:v31 shape:v32 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, TrainingState)];

    if (v33) {
      [v88 addObject:v33];
    }
  }
  else
  {

    uint64_t v33 = 0;
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v90);
  BOOL v36 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v36 addObject:v37];

  uint64_t v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v36 addObject:v38];

  uint64_t v39 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v36 addObject:v39];

  __int16 v40 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v36 addObject:v40];

  __int16 v41 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v36 addObject:v41];

  __int16 v42 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v36 addObject:v42];

  uint64_t v43 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"zgate_activation" type:@"MPSRNNActivation" cases:v36 value:WeightsLayout];
  if (v43) {
    [v34 addObject:v43];
  }

  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v90);
  uint64_t v45 = [MEMORY[0x1E4F1CA48] array];
  int64_t v46 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v45 addObject:v46];

  BOOL v47 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v45 addObject:v47];

  __int16 v48 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v45 addObject:v48];

  int64_t v49 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v45 addObject:v49];

  __int16 v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v45 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v45 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"rgate_activation" type:@"MPSRNNActivation" cases:v45 value:PaddingStyle];
  if (v52) {
    [v34 addObject:v52];
  }

  Gateunsigned int Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v90);
  __int16 v54 = [MEMORY[0x1E4F1CA48] array];
  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v54 addObject:v55];

  unsigned int v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v54 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v54 addObject:v57];

  __int16 v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v54 addObject:v58];

  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v54 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v54 addObject:v60];

  int64_t v61 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"ogate_activation" type:@"MPSRNNActivation" cases:v54 value:GateLayout];
  if (v61) {
    [v34 addObject:v61];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v90);
  __int16 v63 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ZRO" value:0];
  [v63 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"RZO" value:1];
  [v63 addObject:v65];

  uint64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ROZ" value:2];
  [v63 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"gate_layout" type:@"MPSGRUGateLayout" cases:v63 value:Layout];
  if (v67) {
    [v34 addObject:v67];
  }

  LOBYTE(v93[0]) = 0;
  LOBYTE(v93[0]) = mlir::mps::GRUOp::getTraining((mlir::mps::GRUOp *)&v90);
  int64_t v68 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"training" dataType:2147483656 shape:&unk_1EC9F0800];
  if (v68)
  {
    uint64_t v69 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v93 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v68 setValue:v69];

    [v34 addObject:v68];
  }
  LOBYTE(v91[0]) = 0;
  LOBYTE(v91[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v90);
  BOOL v70 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"reset_after" dataType:2147483656 shape:&unk_1EC9F0818];
  if (v70)
  {
    uint64_t v71 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v91 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v70 setValue:v71];

    [v34 addObject:v70];
  }
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v90);
  BOOL v72 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"flip_z" dataType:2147483656 shape:&unk_1EC9F0830];
  if (v72)
  {
    BOOL v73 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&InferredResultTypes length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v72 setValue:v73];

    [v34 addObject:v72];
  }

  BOOL v74 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v75 = [MPSGraphViewerNodeSPI alloc];
  __int16 v76 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v77 = [MEMORY[0x1E4F1C978] arrayWithArray:v88];
  __int16 v78 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  __int16 v79 = [MEMORY[0x1E4F1C978] arrayWithArray:v74];
  uint64_t v80 = [(MPSGraphViewerNodeSPI *)v75 initWithType:v87 inputs:v76 outputs:v77 properties:v78 regions:v79];
  __int16 v81 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v80;
  BOOL v82 = ;
  [*((id *)this + 3) setLocalizedDescription:v82];

  if (SHIBYTE(v96) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E23404(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGatherAlongAxisOpHandler *EmitterViewerSPI::MPSGatherAlongAxisOpHandler::MPSGatherAlongAxisOpHandler(EmitterViewerSPI::MPSGatherAlongAxisOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987EF8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 21)
    {
      BOOL v42 = *AttrData == 0x687461672E73706DLL && AttrData[1] == 0x676E6F6C615F7265;
      if (v42 && *(void *)((char *)AttrData + 13) == 0x736978615F676E6FLL)
      {
        __int16 v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.gather_along_axis";
        v48[3] = 21;
        int64_t v46 = "' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+(v48, (uint64_t *)&v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GatherAlongAxisOp,void>::id) {
    goto LABEL_40;
  }
  uint64_t v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v44 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"updates", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"indices", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v45);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"allow_negative_indices" dataType:2147483656 shape:&unk_1EC9F0848];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v27 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v44 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  uint64_t v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E23C50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGatherNDOpHandler *EmitterViewerSPI::MPSGatherNDOpHandler::MPSGatherNDOpHandler(EmitterViewerSPI::MPSGatherNDOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987358;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 13 && *AttrData == 0x687461672E73706DLL && *(void *)((char *)AttrData + 5) == 0x646E5F7265687461)
    {
      __int16 v47 = 1283;
      v46[0] = (uint64_t)"classof on '";
      v46[2] = (uint64_t)"mps.gather_nd";
      v46[3] = 13;
      v44[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v45 = 259;
      llvm::operator+(v46, v44, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GatherNDOp,void>::id) {
    goto LABEL_37;
  }
  uint64_t v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"updates", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"indices", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v46[0]) = 0;
  LODWORD(v46[0]) = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v43);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"batch_dims" dataType:32 shape:&unk_1EC9F0860];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v44[0]) = 0;
  LOBYTE(v44[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"allow_negative_indices" dataType:2147483656 shape:&unk_1EC9F0878];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v44 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v42 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E24314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180E24458()
{
}

void sub_180E24460(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGatherOpHandler *EmitterViewerSPI::MPSGatherOpHandler::MPSGatherOpHandler(EmitterViewerSPI::MPSGatherOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986ED8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 10 && *(void *)AttrData == 0x687461672E73706DLL && *(_WORD *)(AttrData + 8) == 29285)
    {
      __int16 v50 = 1283;
      v49[0] = (uint64_t)"classof on '";
      v49[2] = (uint64_t)"mps.gather";
      v49[3] = 10;
      v47[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v48 = 259;
      llvm::operator+(v49, v47, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GatherOp,void>::id) {
    goto LABEL_39;
  }
  int64_t v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v45 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"updates", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v46);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"indices", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v46);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v49[0]) = 0;
  LODWORD(v49[0]) = mlir::pdl_interp::CheckOperandCountOp::getCount((mlir::pdl_interp::CheckOperandCountOp *)&v46);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"batch_dims" dataType:32 shape:&unk_1EC9F0890];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v49 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v27 addObject:v28];
  }
  LOBYTE(v47[0]) = 0;
  LOBYTE(v47[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v46);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"allow_negative_indices" dataType:2147483656 shape:&unk_1EC9F08A8];
  if (v30)
  {
    uint64_t v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v47 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v27 addObject:v30];
  }

  uint64_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v45 inputs:v34 outputs:v35 properties:v36 regions:v37];
  uint64_t v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;
  uint64_t v40 = ;
  [*((id *)this + 3) setLocalizedDescription:v40];

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E24A28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGeluOpHandler *EmitterViewerSPI::MPSGeluOpHandler::MPSGeluOpHandler(EmitterViewerSPI::MPSGeluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9869B0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x756C65672E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.gelu";
      v40[3] = 8;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GeluOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E25000(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGetCoordOpHandler *EmitterViewerSPI::MPSGetCoordOpHandler::MPSGetCoordOpHandler(EmitterViewerSPI::MPSGetCoordOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987370;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 19)
    {
      BOOL v38 = *AttrData == 0x5F7465672E73706DLL && AttrData[1] == 0x616E6964726F6F63;
      if (v38 && *(void *)((char *)AttrData + 11) == 0x736574616E696472)
      {
        __int16 v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        uint64_t v44[2] = (uint64_t)"mps.get_coordinates";
        v44[3] = 19;
        BOOL v42 = "' failed due to the operation not being registered";
        __int16 v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GetCoordOp,void>::id) {
    goto LABEL_36;
  }
  __int16 v41 = a3;
  v44[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v40 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"shape", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  mlir::mps::GetCoordOp::getResultType((mlir::mps::GetCoordOp *)&v41);
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v40 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;

  uint64_t v34 = [NSString stringWithUTF8String:"The generated values start from zero on a given axis and increase with stride of one along that axis."];
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E255D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGreaterThanOpHandler *EmitterViewerSPI::MPSGreaterThanOpHandler::MPSGreaterThanOpHandler(EmitterViewerSPI::MPSGreaterThanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987898;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x616572672E73706DLL && *(void *)((char *)AttrData + 3) == 0x726574616572672ELL)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.greater";
      v43[3] = 11;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E25BB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler *EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler::MPSGreaterThanOrEqualToOpHandler(EmitterViewerSPI::MPSGreaterThanOrEqualToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988378;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 17)
    {
      BOOL v38 = *(void *)AttrData == 0x616572672E73706DLL && *(void *)(AttrData + 8) == 0x617571655F726574;
      if (v38 && *(unsigned char *)(AttrData + 16) == 108)
      {
        __int16 v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        uint64_t v44[2] = (uint64_t)"mps.greater_equal";
        v44[3] = 17;
        __int16 v42 = "' failed due to the operation not being registered";
        __int16 v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOrEqualToOp,void>::id) {
    goto LABEL_36;
  }
  __int16 v41 = a3;
  v44[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v40 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v40 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E26190(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSHammingDistanceOpHandler *EmitterViewerSPI::MPSHammingDistanceOpHandler::MPSHammingDistanceOpHandler(EmitterViewerSPI::MPSHammingDistanceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987F10;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 20)
    {
      BOOL v38 = *(void *)AttrData == 0x6D6D61682E73706DLL && *(void *)(AttrData + 8) == 0x747369645F676E69;
      if (v38 && *(_DWORD *)(AttrData + 16) == 1701015137)
      {
        __int16 v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        uint64_t v44[2] = (uint64_t)"mps.hamming_distance";
        v44[3] = 20;
        __int16 v42 = "' failed due to the operation not being registered";
        __int16 v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::HammingDistanceOp,void>::id) {
    goto LABEL_36;
  }
  __int16 v41 = a3;
  v44[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v40 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v41);
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v40 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E26778(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler *EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler::MPSHermiteanToRealFFTOpHandler(EmitterViewerSPI::MPSHermiteanToRealFFTOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988240;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v47 == 25)
    {
      BOOL v48 = *(void *)AttrData == 0x6D7265682E73706DLL && *(void *)(AttrData + 8) == 0x6F745F6E61657469;
      BOOL v49 = v48 && *(void *)(AttrData + 16) == 0x66665F6C6165725FLL;
      if (v49 && *(unsigned char *)(AttrData + 24) == 116)
      {
        __int16 v56 = 1283;
        v55[0] = (uint64_t)"classof on '";
        v55[2] = (uint64_t)"mps.hermitean_to_real_fft";
        v55[3] = 25;
        v53[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v54 = 259;
        llvm::operator+(v55, v53, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::HermiteanToRealFFTOp,void>::id) {
    goto LABEL_45;
  }
  int64_t v52 = a3;
  v55[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v55);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v58 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v58) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v58 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v51 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v52);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v52);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v52);
  unint64_t v21 = @"output";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"output" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  Gateunsigned int Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v52);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"size" value:1];
  [v27 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"unitary" value:2];
  [v27 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"scaling_mode" type:@"MPSFFTScalingMode" cases:v27 value:GateLayout];
  if (v31) {
    [v25 addObject:v31];
  }

  LOBYTE(v55[0]) = 0;
  LOBYTE(v55[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v52);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"inverse" dataType:2147483656 shape:&unk_1EC9F08C0];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v55 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v25 addObject:v32];
  }
  LOBYTE(v53[0]) = 0;
  LOBYTE(v53[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v52);
  uint64_t v34 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"round_to_odd" dataType:2147483656 shape:&unk_1EC9F08D8];
  if (v34)
  {
    uint64_t v35 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v53 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v34 setValue:v35];

    [v25 addObject:v34];
  }

  uint64_t v36 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v37 = [MPSGraphViewerNodeSPI alloc];
  BOOL v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v36];
  uint64_t v42 = [(MPSGraphViewerNodeSPI *)v37 initWithType:v51 inputs:v38 outputs:v39 properties:v40 regions:v41];
  __int16 v43 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v42;
  __int16 v44 = ;
  [*((id *)this + 3) setLocalizedDescription:v44];

  if (SHIBYTE(v58) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E26F4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSIdentityOpHandler *EmitterViewerSPI::MPSIdentityOpHandler::MPSIdentityOpHandler(EmitterViewerSPI::MPSIdentityOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987388;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(void *)AttrData == 0x6E6564692E73706DLL && *(_DWORD *)(AttrData + 8) == 2037672308)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.identity";
      v41[3] = 12;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::IdentityOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Returns a tensor with the same shape and contents as input."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E27544(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSImToColOpHandler *EmitterViewerSPI::MPSImToColOpHandler::MPSImToColOpHandler(EmitterViewerSPI::MPSImToColOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9870B8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v78 == 13 && *AttrData == 0x745F6D692E73706DLL && *(void *)((char *)AttrData + 5) == 0x6C6F635F6F745F6DLL)
    {
      __int16 v87 = 1283;
      v86[0] = (uint64_t)"classof on '";
      v86[2] = (uint64_t)"mps.im_to_col";
      v86[3] = 13;
      unint64_t v84 = "' failed due to the operation not being registered";
      __int16 v85 = 259;
      llvm::operator+(v86, (uint64_t *)&v84, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_77:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ImToColOp,void>::id) {
    goto LABEL_77;
  }
  __int16 v83 = a3;
  v86[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v86);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v89 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v89) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v89 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v80 = [NSString stringWithCString:v13 encoding:4];
  BOOL v82 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v83);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v82 addObject:v15];
  }

  __int16 v81 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v16 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v83);
  uint64_t v17 = @"result";
  if (v16)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v16->_dataType & 0xFFFFFFFFFFFFFFF8));
    unsigned int v19 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v16->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v16 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v19 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v16)];

    if (v16) {
      [v81 addObject:v16];
    }
  }
  else
  {
  }
  uint64_t v20 = [MEMORY[0x1E4F1CA48] array];
  KernelSizes = (uint64_t **)mlir::mps::ColToImOp::getKernelSizes((mlir::mps::ColToImOp *)&v83);
  uint64_t v22 = KernelSizes;
  if (!KernelSizes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(KernelSizes))
  {
    uint64_t v24 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v25 = 692;
    uint64_t v26 = "Casting.h";
    uint64_t v27 = "cast_if_present";
    goto LABEL_59;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v22))
  {
    uint64_t v24 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v25 = 566;
    uint64_t v26 = "Casting.h";
    uint64_t v27 = "cast";
LABEL_59:
    __assert_rtn(v27, v26, v25, v24);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v22);
  if (!InterfaceFor)
  {
    uint64_t v24 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v25 = 98;
    uint64_t v26 = "InterfaceSupport.h";
    uint64_t v27 = "Interface";
    goto LABEL_59;
  }
LABEL_26:
  uint64_t v28 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_sizes", (uint64_t)v22, InterfaceFor);
  if (v28) {
    [v20 addObject:v28];
  }
  Strides = (uint64_t **)mlir::mps::ColToImOp::getStrides((mlir::mps::ColToImOp *)&v83);
  uint64_t v30 = Strides;
  if (!Strides)
  {
    uint64_t v31 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v32 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v33 = 692;
    uint64_t v34 = "Casting.h";
    uint64_t v35 = "cast_if_present";
    goto LABEL_62;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v30))
  {
    uint64_t v32 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v33 = 566;
    uint64_t v34 = "Casting.h";
    uint64_t v35 = "cast";
LABEL_62:
    __assert_rtn(v35, v34, v33, v32);
  }
  uint64_t v31 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v30);
  if (!v31)
  {
    uint64_t v32 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v33 = 98;
    uint64_t v34 = "InterfaceSupport.h";
    uint64_t v35 = "Interface";
    goto LABEL_62;
  }
LABEL_34:
  uint64_t v36 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v30, v31);
  if (v36) {
    [v20 addObject:v36];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v83);
  BOOL v38 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v39 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    __int16 v40 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v41 = 692;
    __int16 v42 = "Casting.h";
    __int16 v43 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v38))
  {
    __int16 v40 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v41 = 566;
    __int16 v42 = "Casting.h";
    __int16 v43 = "cast";
LABEL_65:
    __assert_rtn(v43, v42, v41, v40);
  }
  uint64_t v39 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v38);
  if (!v39)
  {
    __int16 v40 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v41 = 98;
    __int16 v42 = "InterfaceSupport.h";
    __int16 v43 = "Interface";
    goto LABEL_65;
  }
LABEL_42:
  int64_t v44 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v38, v39);
  if (v44) {
    [v20 addObject:v44];
  }
  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v83);
  int64_t v46 = Rewriter;
  if (!Rewriter)
  {
    uint64_t v47 = 0;
    goto LABEL_50;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    BOOL v48 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v49 = 692;
    __int16 v50 = "Casting.h";
    int64_t v51 = "cast_if_present";
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v46))
  {
    BOOL v48 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v49 = 566;
    __int16 v50 = "Casting.h";
    int64_t v51 = "cast";
LABEL_68:
    __assert_rtn(v51, v50, v49, v48);
  }
  uint64_t v47 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v46);
  if (!v47)
  {
    BOOL v48 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v49 = 98;
    __int16 v50 = "InterfaceSupport.h";
    int64_t v51 = "Interface";
    goto LABEL_68;
  }
LABEL_50:
  int64_t v52 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v46, v47);
  if (v52) {
    [v20 addObject:v52];
  }
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v83);
  __int16 v54 = [MEMORY[0x1E4F1CA48] array];
  int64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v54 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v54 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v54 addObject:v57];

  int64_t v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v54 addObject:v58];

  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v54 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v54 addObject:v60];

  int64_t v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v54 addObject:v61];

  uint64_t v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v54 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v54 addObject:v63];

  uint64_t v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v54 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v54 addObject:v65];

  uint64_t v66 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v54 value:StorageType];
  if (v66) {
    [v20 addObject:v66];
  }

  int64_t v67 = [MEMORY[0x1E4F1CA48] array];
  int64_t v68 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v69 = [MEMORY[0x1E4F1C978] arrayWithArray:v82];
  BOOL v70 = [MEMORY[0x1E4F1C978] arrayWithArray:v81];
  uint64_t v71 = [MEMORY[0x1E4F1C978] arrayWithArray:v20];
  BOOL v72 = [MEMORY[0x1E4F1C978] arrayWithArray:v67];
  uint64_t v73 = [(MPSGraphViewerNodeSPI *)v68 initWithType:v80 inputs:v69 outputs:v70 properties:v71 regions:v72];
  BOOL v74 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v73;
  uint64_t v75 = ;
  [*((id *)this + 3) setLocalizedDescription:v75];

  if (SHIBYTE(v89) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E28054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSImaginaryPartOpHandler *EmitterViewerSPI::MPSImaginaryPartOpHandler::MPSImaginaryPartOpHandler(EmitterViewerSPI::MPSImaginaryPartOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987BE0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 18)
    {
      BOOL v36 = *(void *)AttrData == 0x67616D692E73706DLL && *(void *)(AttrData + 8) == 0x61705F7972616E69;
      if (v36 && *(_WORD *)(AttrData + 16) == 29810)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.imaginary_part";
        v42[3] = 18;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ImaginaryPartOp,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v19 = @"output";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"output" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Extracts the imaginary part of the input tensor."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2868C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler *EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler::MPSInitRandomPhiloxStateOpHandler(EmitterViewerSPI::MPSInitRandomPhiloxStateOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988450;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 28)
    {
      BOOL v40 = *(void *)AttrData == 0x74696E692E73706DLL && *(void *)(AttrData + 8) == 0x5F6D6F646E61725FLL;
      BOOL v41 = v40 && *(void *)(AttrData + 16) == 0x735F786F6C696870;
      if (v41 && *(_DWORD *)(AttrData + 24) == 1702125940)
      {
        __int16 v48 = 1283;
        v47[0] = (uint64_t)"classof on '";
        v47[2] = (uint64_t)"mps.init_random_philox_state";
        v47[3] = 28;
        int64_t v45 = "' failed due to the operation not being registered";
        __int16 v46 = 259;
        llvm::operator+(v47, (uint64_t *)&v45, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::InitRandomPhiloxStateOp,void>::id) {
    goto LABEL_41;
  }
  int64_t v44 = a3;
  v47[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v50 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v43 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"counter_low", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"counter_high", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v44);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"key", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  int v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v43 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v50) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E28CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSInstanceNormOpHandler *EmitterViewerSPI::MPSInstanceNormOpHandler::MPSInstanceNormOpHandler(EmitterViewerSPI::MPSInstanceNormOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v54[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9879A0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v52 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
    if (v41 == 17)
    {
      BOOL v42 = *(void *)AttrData == 0x74736E692E73706DLL && *(void *)(AttrData + 8) == 0x726F6E5F65636E61;
      if (v42 && *(unsigned char *)(AttrData + 16) == 109)
      {
        __int16 v51 = 1283;
        __dst[0] = "classof on '";
        int v49 = "mps.instance_norm";
        uint64_t v50 = 17;
        __int16 v46 = "' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+((uint64_t *)__dst, (uint64_t *)&v46, (uint64_t)&v52);
        llvm::report_fatal_error((llvm::Twine *)&v52, 1);
      }
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::InstanceNormOp,void>::id) {
    goto LABEL_41;
  }
  int64_t v45 = a3;
  uint64_t v52 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v52);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int v49 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v49) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v44 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v45);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v45, (uint64_t)&v52);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"epsilon" dataType:268435488 shape:&unk_1EC9F08F0];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v52 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = v53;
  if (llvm::APFloatBase::PPCDoubleDouble(v29) == v28) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v54);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v53);
  }
  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v44 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  BOOL v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E29368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSIsFiniteOpHandler *EmitterViewerSPI::MPSIsFiniteOpHandler::MPSIsFiniteOpHandler(EmitterViewerSPI::MPSIsFiniteOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9873A0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x665F73692E73706DLL && *(void *)((char *)AttrData + 5) == 0x6574696E69665F73)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.is_finite";
      v41[3] = 13;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::IsFiniteOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E29920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSIsInfiniteOpHandler *EmitterViewerSPI::MPSIsInfiniteOpHandler::MPSIsInfiniteOpHandler(EmitterViewerSPI::MPSIsInfiniteOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987760;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 15 && *AttrData == 0x695F73692E73706DLL && *(void *)((char *)AttrData + 7) == 0x6574696E69666E69)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.is_infinite";
      v41[3] = 15;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::IsInfiniteOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E29EA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSIsNaNOpHandler *EmitterViewerSPI::MPSIsNaNOpHandler::MPSIsNaNOpHandler(EmitterViewerSPI::MPSIsNaNOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986CC8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 10 && *(void *)AttrData == 0x6E5F73692E73706DLL && *(_WORD *)(AttrData + 8) == 28257)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.is_nan";
      v41[3] = 10;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::IsNaNOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2A41C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLPNormOpHandler *EmitterViewerSPI::MPSLPNormOpHandler::MPSLPNormOpHandler(EmitterViewerSPI::MPSLPNormOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986EF0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 11 && *AttrData == 0x6E5F706C2E73706DLL && *(void *)((char *)AttrData + 3) == 0x6D726F6E5F706C2ELL)
    {
      __int16 v47 = 1283;
      v46[0] = (uint64_t)"classof on '";
      v46[2] = (uint64_t)"mps.lp_norm";
      v46[3] = 11;
      int64_t v44 = "' failed due to the operation not being registered";
      __int16 v45 = 259;
      llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LPNormOp,void>::id) {
    goto LABEL_37;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"p", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v43);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"epsilon", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  int v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v24)];

    if (v24) {
      [v23 addObject:v24];
    }
  }
  else
  {
  }
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v35 = [(MPSGraphViewerNodeSPI *)v30 initWithType:v42 inputs:v31 outputs:v32 properties:v33 regions:v34];
  uint64_t v36 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v35;

  objc_msgSend(NSString, "stringWithUTF8String:", "Computes x = x / ||x||_{p} elementwise, where:\n* ||x||_{p} =\n(pow(pow(abs(x0), p) + pow(abs(x1), p) + ... + pow(abs(xn), p), 1/p);\n"
    "\n"
  uint64_t v37 = "* p > 0.");
  [*((id *)this + 3) setLocalizedDescription:v37];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2AA44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLSTMGradientOpHandler *EmitterViewerSPI::MPSLSTMGradientOpHandler::MPSLSTMGradientOpHandler(EmitterViewerSPI::MPSLSTMGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9879B8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v121 == 17)
    {
      BOOL v122 = *(void *)AttrData == 0x6D74736C2E73706DLL && *(void *)(AttrData + 8) == 0x6E6569646172675FLL;
      if (v122 && *(unsigned char *)(AttrData + 16) == 116)
      {
        __int16 v131 = 1283;
        v130[0] = (uint64_t)"classof on '";
        v130[2] = (uint64_t)"mps.lstm_gradient";
        v130[3] = 17;
        uint64_t v128 = "' failed due to the operation not being registered";
        __int16 v129 = 259;
        llvm::operator+(v130, (uint64_t *)&v128, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_80:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGradientOp,void>::id) {
    goto LABEL_80;
  }
  v127 = a3;
  v130[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v130);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v133 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v133) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v133 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  v124 = [NSString stringWithCString:v13 encoding:4];
  v126 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v127);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient_input_sequence", Input);
  if (v15) {
    [v126 addObject:v15];
  }
  unint64_t RecurrentWeight = mlir::mps::LSTMGradientOp::getRecurrentWeight((mlir::mps::LSTMGradientOp *)&v127);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"recurrent_weight", RecurrentWeight);
  if (v17) {
    [v126 addObject:v17];
  }
  unint64_t TrainingState = mlir::mps::LSTMGradientOp::getTrainingState((mlir::mps::LSTMGradientOp *)&v127);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"training_state", TrainingState);
  if (v19) {
    [v126 addObject:v19];
  }
  unint64_t OutputCellFwd = mlir::mps::LSTMGradientOp::getOutputCellFwd((mlir::mps::LSTMGradientOp *)&v127);
  unint64_t v21 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"output_cell_fwd", OutputCellFwd);
  if (v21) {
    [v126 addObject:v21];
  }
  unint64_t InputState = mlir::mps::LSTMGradientOp::getInputState((mlir::mps::LSTMGradientOp *)&v127);
  uint64_t v23 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_state", InputState);
  if (v23) {
    [v126 addObject:v23];
  }

  unint64_t InputCell = mlir::mps::LSTMGradientOp::getInputCell((mlir::mps::LSTMGradientOp *)&v127);
  int v25 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_cell", InputCell);
  if (v25) {
    [v126 addObject:v25];
  }

  unint64_t Mask = mlir::mps::LSTMGradientOp::getMask((mlir::mps::LSTMGradientOp *)&v127);
  uint64_t v27 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"mask", Mask);
  if (v27) {
    [v126 addObject:v27];
  }

  unint64_t Peephole = mlir::mps::LSTMGradientOp::getPeephole((mlir::mps::LSTMGradientOp *)&v127);
  uint64_t v29 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"peephole", Peephole);
  if (v29) {
    [v126 addObject:v29];
  }

  unint64_t CellClip = mlir::mps::LSTMGradientOp::getCellClip((mlir::mps::LSTMGradientOp *)&v127);
  uint64_t v31 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"cell_clip", CellClip);
  if (v31) {
    [v126 addObject:v31];
  }

  unint64_t CellGradient = mlir::mps::LSTMGradientOp::getCellGradient((mlir::mps::LSTMGradientOp *)&v127);
  int v33 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"cell_gradient", CellGradient);
  if (v33) {
    [v126 addObject:v33];
  }

  v125 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v34 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v127);
  uint64_t v35 = @"gradient_output_sequence";
  if (v34)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v34 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v37 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v34 + 8) & 0xFFFFFFFFFFFFFFF8));
    BOOL v38 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_output_sequence" dataType:MPSDataType shape:v37 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v34)];

    if (v38) {
      [v125 addObject:v38];
    }
  }
  else
  {

    BOOL v38 = 0;
  }
  uint64_t Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v127);
  uint64_t v40 = @"gradient_recurrent_weight";
  if (Element)
  {
    uint64_t v41 = getMPSDataType((void *)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    __int16 v42 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    __int16 v43 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_recurrent_weight" dataType:v41 shape:v42 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, Element)];

    if (v43) {
      [v125 addObject:v43];
    }
  }
  else
  {

    __int16 v43 = 0;
  }
  Gradientunint64_t InputState = mlir::mps::GRUGradientOp::getGradientInputState((mlir::mps::GRUGradientOp *)&v127);
  __int16 v45 = @"gradient_input_state";
  if (GradientInputState)
  {
    uint64_t v46 = getMPSDataType((void *)(*(void *)(GradientInputState + 8) & 0xFFFFFFFFFFFFFFF8));
    __int16 v47 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(GradientInputState + 8) & 0xFFFFFFFFFFFFFFF8));
    __int16 v48 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_input_state" dataType:v46 shape:v47 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, GradientInputState)];

    if (v48) {
      [v125 addObject:v48];
    }
  }
  else
  {

    __int16 v48 = 0;
  }
  Gradientunint64_t InputCell = (MPSGraphViewerNodePortSPI *)mlir::mps::LSTMGradientOp::getGradientInputCell((mlir::mps::LSTMGradientOp *)&v127);
  uint64_t v50 = @"gradient_input_cell";
  if (GradientInputCell)
  {
    uint64_t v51 = getMPSDataType((void *)(*(void *)&GradientInputCell->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v52 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&GradientInputCell->_dataType & 0xFFFFFFFFFFFFFFF8));
    Gradientunint64_t InputCell = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_input_cell" dataType:v51 shape:v52 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, GradientInputCell)];

    if (GradientInputCell) {
      [v125 addObject:GradientInputCell];
    }
  }
  else
  {
  }
  Gradientunint64_t Peephole = (MPSGraphViewerNodePortSPI *)mlir::mps::LSTMGradientOp::getGradientPeephole((mlir::mps::LSTMGradientOp *)&v127);
  __int16 v54 = @"gradient_peephole";
  if (GradientPeephole)
  {
    uint64_t v55 = getMPSDataType((void *)(*(void *)&GradientPeephole->_dataType & 0xFFFFFFFFFFFFFFF8));
    __int16 v56 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&GradientPeephole->_dataType & 0xFFFFFFFFFFFFFFF8));
    Gradientunint64_t Peephole = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_peephole" dataType:v55 shape:v56 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, GradientPeephole)];

    if (GradientPeephole) {
      [v125 addObject:GradientPeephole];
    }
  }
  else
  {
  }
  uint64_t v57 = [MEMORY[0x1E4F1CA48] array];
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v127);
  __int16 v59 = [MEMORY[0x1E4F1CA48] array];
  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v59 addObject:v60];

  int64_t v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v59 addObject:v61];

  uint64_t v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v59 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v59 addObject:v63];

  uint64_t v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v59 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v59 addObject:v65];

  uint64_t v66 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"igate_activation" type:@"MPSRNNActivation" cases:v59 value:PaddingStyle];
  if (v66) {
    [v57 addObject:v66];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v127);
  int64_t v68 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v68 addObject:v69];

  BOOL v70 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v68 addObject:v70];

  uint64_t v71 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v68 addObject:v71];

  BOOL v72 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v68 addObject:v72];

  uint64_t v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v68 addObject:v73];

  BOOL v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v68 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"fgate_activation" type:@"MPSRNNActivation" cases:v68 value:Layout];
  if (v75) {
    [v57 addObject:v75];
  }

  unsigned int v76 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v127);
  __int16 v77 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v77 addObject:v78];

  __int16 v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v77 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v77 addObject:v80];

  __int16 v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v77 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v77 addObject:v82];

  __int16 v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v77 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"zgate_activation" type:@"MPSRNNActivation" cases:v77 value:v76];
  if (v84) {
    [v57 addObject:v84];
  }

  unsigned int v85 = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v127);
  int8x8_t v86 = [MEMORY[0x1E4F1CA48] array];
  __int16 v87 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v86 addObject:v87];

  uint64_t v88 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v86 addObject:v88];

  int64_t v89 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v86 addObject:v89];

  uint64_t v90 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v86 addObject:v90];

  uint64_t v91 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v86 addObject:v91];

  __int16 v92 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v86 addObject:v92];

  BOOL v93 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"ogate_activation" type:@"MPSRNNActivation" cases:v86 value:v85];
  if (v93) {
    [v57 addObject:v93];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v127);
  uint64_t v95 = [MEMORY[0x1E4F1CA48] array];
  int64_t v96 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v95 addObject:v96];

  BOOL v97 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v95 addObject:v97];

  BOOL v98 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v95 addObject:v98];

  BOOL v99 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v95 addObject:v99];

  __int16 v100 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v95 addObject:v100];

  __int16 v101 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v95 addObject:v101];

  __int16 v102 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"cell_activation" type:@"MPSRNNActivation" cases:v95 value:StorageType];
  if (v102) {
    [v57 addObject:v102];
  }

  Gateunsigned int Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v127);
  __int16 v104 = [MEMORY[0x1E4F1CA48] array];
  int64_t v105 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"IFZO" value:0];
  [v104 addObject:v105];

  __int16 v106 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"IZFO" value:1];
  [v104 addObject:v106];

  __int16 v107 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"IFOZ" value:2];
  [v104 addObject:v107];

  int64_t v108 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"IOFZ" value:3];
  [v104 addObject:v108];

  __int16 v109 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"gate_layout" type:@"MPSLSTMGateLayout" cases:v104 value:GateLayout];
  if (v109) {
    [v57 addObject:v109];
  }

  unint64_t v110 = [MEMORY[0x1E4F1CA48] array];
  int64_t v111 = [MPSGraphViewerNodeSPI alloc];
  v112 = [MEMORY[0x1E4F1C978] arrayWithArray:v126];
  uint64_t v113 = [MEMORY[0x1E4F1C978] arrayWithArray:v125];
  uint64_t v114 = [MEMORY[0x1E4F1C978] arrayWithArray:v57];
  v115 = [MEMORY[0x1E4F1C978] arrayWithArray:v110];
  uint64_t v116 = [(MPSGraphViewerNodeSPI *)v111 initWithType:v124 inputs:v112 outputs:v113 properties:v114 regions:v115];
  uint64_t v117 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v116;
  uint64_t v118 = ;
  [*((id *)this + 3) setLocalizedDescription:v118];

  if (SHIBYTE(v133) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2BD6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLSTMOpHandler *EmitterViewerSPI::MPSLSTMOpHandler::MPSLSTMOpHandler(EmitterViewerSPI::MPSLSTMOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9869C8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v109 == 8 && *AttrData == 0x6D74736C2E73706DLL)
    {
      __int16 v117 = 1283;
      v116[0] = (uint64_t)"classof on '";
      v116[2] = (uint64_t)"mps.lstm";
      v116[3] = 8;
      uint64_t v114 = "' failed due to the operation not being registered";
      __int16 v115 = 259;
      llvm::operator+(v116, (uint64_t *)&v114, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_61:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMOp,void>::id) {
    goto LABEL_61;
  }
  uint64_t v113 = a3;
  v116[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v116);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v119 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v119) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v119 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  unint64_t v110 = [NSString stringWithCString:v13 encoding:4];
  v112 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v113);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_sequence", Input);
  if (v15) {
    [v112 addObject:v15];
  }
  unint64_t RecurrentWeight = mlir::mps::LSTMOp::getRecurrentWeight((mlir::mps::LSTMOp *)&v113);
  uint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"recurrent_weight", RecurrentWeight);
  if (v17) {
    [v112 addObject:v17];
  }
  unint64_t InputState = mlir::mps::LSTMOp::getInputState((mlir::mps::LSTMOp *)&v113);
  unsigned int v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_state", InputState);
  if (v19) {
    [v112 addObject:v19];
  }

  unint64_t InputCell = mlir::mps::LSTMOp::getInputCell((mlir::mps::LSTMOp *)&v113);
  unint64_t v21 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_cell", InputCell);
  if (v21) {
    [v112 addObject:v21];
  }

  unint64_t Mask = mlir::mps::LSTMOp::getMask((mlir::mps::LSTMOp *)&v113);
  uint64_t v23 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"mask", Mask);
  if (v23) {
    [v112 addObject:v23];
  }

  unint64_t Peephole = mlir::mps::LSTMOp::getPeephole((mlir::mps::LSTMOp *)&v113);
  int v25 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"peephole", Peephole);
  if (v25) {
    [v112 addObject:v25];
  }

  unint64_t CellClip = mlir::mps::LSTMOp::getCellClip((mlir::mps::LSTMOp *)&v113);
  uint64_t v27 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"cell_clip", CellClip);
  if (v27) {
    [v112 addObject:v27];
  }

  int64_t v111 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v113);
  uint64_t v29 = @"result";
  if (v28)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v28 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v31 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v28 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v32 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v31 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v28)];

    if (v32) {
      [v111 addObject:v32];
    }
  }
  else
  {

    uint64_t v32 = 0;
  }
  uint64_t Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v113);
  uint64_t v34 = @"output_cell";
  if (Element)
  {
    uint64_t v35 = getMPSDataType((void *)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v36 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v37 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"output_cell" dataType:v35 shape:v36 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, Element)];

    if (v37) {
      [v111 addObject:v37];
    }
  }
  else
  {

    uint64_t v37 = 0;
  }
  uint64_t TrainingState = mlir::mps::LSTMOp::getTrainingState((mlir::mps::LSTMOp *)&v113);
  uint64_t v39 = @"training_state";
  if (TrainingState)
  {
    uint64_t v40 = getMPSDataType((void *)(*(void *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v41 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    __int16 v42 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"training_state" dataType:v40 shape:v41 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, TrainingState)];

    if (v42) {
      [v111 addObject:v42];
    }
  }
  else
  {

    __int16 v42 = 0;
  }

  __int16 v43 = [MEMORY[0x1E4F1CA48] array];
  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v113);
  __int16 v45 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v46 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v45 addObject:v46];

  __int16 v47 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v45 addObject:v47];

  __int16 v48 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v45 addObject:v48];

  int64_t v49 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v45 addObject:v49];

  uint64_t v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v45 addObject:v50];

  uint64_t v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v45 addObject:v51];

  uint64_t v52 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"igate_activation" type:@"MPSRNNActivation" cases:v45 value:PaddingStyle];
  if (v52) {
    [v43 addObject:v52];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v113);
  __int16 v54 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v54 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v54 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v54 addObject:v57];

  int64_t v58 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v54 addObject:v58];

  __int16 v59 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v54 addObject:v59];

  int64_t v60 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v54 addObject:v60];

  int64_t v61 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"fgate_activation" type:@"MPSRNNActivation" cases:v54 value:Layout];
  if (v61) {
    [v43 addObject:v61];
  }

  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v113);
  __int16 v63 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v63 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v63 addObject:v65];

  uint64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v63 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v63 addObject:v67];

  int64_t v68 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v63 addObject:v68];

  uint64_t v69 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v63 addObject:v69];

  BOOL v70 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"zgate_activation" type:@"MPSRNNActivation" cases:v63 value:WeightsLayout];
  if (v70) {
    [v43 addObject:v70];
  }

  unsigned int v71 = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v113);
  BOOL v72 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v72 addObject:v73];

  BOOL v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v72 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v72 addObject:v75];

  unsigned int v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v72 addObject:v76];

  __int16 v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v72 addObject:v77];

  uint64_t v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v72 addObject:v78];

  __int16 v79 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"ogate_activation" type:@"MPSRNNActivation" cases:v72 value:v71];
  if (v79) {
    [v43 addObject:v79];
  }

  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v113);
  __int16 v81 = [MEMORY[0x1E4F1CA48] array];
  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v81 addObject:v82];

  __int16 v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v81 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v81 addObject:v84];

  unsigned int v85 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v81 addObject:v85];

  int8x8_t v86 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v81 addObject:v86];

  __int16 v87 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v81 addObject:v87];

  uint64_t v88 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"cell_activation" type:@"MPSRNNActivation" cases:v81 value:StorageType];
  if (v88) {
    [v43 addObject:v88];
  }

  Gateunsigned int Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v113);
  uint64_t v90 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v91 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"IFZO" value:0];
  [v90 addObject:v91];

  __int16 v92 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"IZFO" value:1];
  [v90 addObject:v92];

  BOOL v93 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"IFOZ" value:2];
  [v90 addObject:v93];

  __int16 v94 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"IOFZ" value:3];
  [v90 addObject:v94];

  uint64_t v95 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"gate_layout" type:@"MPSLSTMGateLayout" cases:v90 value:GateLayout];
  if (v95) {
    [v43 addObject:v95];
  }

  LOBYTE(v116[0]) = 0;
  LOBYTE(v116[0]) = mlir::mps::GRUOp::getTraining((mlir::mps::GRUOp *)&v113);
  int64_t v96 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"training" dataType:2147483656 shape:&unk_1EC9F0908];
  if (v96)
  {
    BOOL v97 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v116 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v96 setValue:v97];

    [v43 addObject:v96];
  }

  BOOL v98 = [MEMORY[0x1E4F1CA48] array];
  BOOL v99 = [MPSGraphViewerNodeSPI alloc];
  __int16 v100 = [MEMORY[0x1E4F1C978] arrayWithArray:v112];
  __int16 v101 = [MEMORY[0x1E4F1C978] arrayWithArray:v111];
  __int16 v102 = [MEMORY[0x1E4F1C978] arrayWithArray:v43];
  __int16 v103 = [MEMORY[0x1E4F1C978] arrayWithArray:v98];
  uint64_t v104 = [(MPSGraphViewerNodeSPI *)v99 initWithType:v110 inputs:v100 outputs:v101 properties:v102 regions:v103];
  int64_t v105 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v104;
  __int16 v106 = ;
  [*((id *)this + 3) setLocalizedDescription:v106];

  if (SHIBYTE(v119) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2D138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLeakyReluOpHandler *EmitterViewerSPI::MPSLeakyReluOpHandler::MPSLeakyReluOpHandler(EmitterViewerSPI::MPSLeakyReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987520;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 14 && *AttrData == 0x6B61656C2E73706DLL && *(void *)((char *)AttrData + 6) == 0x756C65725F796B61)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.leaky_relu";
      v43[3] = 14;
      uint64_t v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LeakyReluOp,void>::id) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2D934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLessThanOpHandler *EmitterViewerSPI::MPSLessThanOpHandler::MPSLessThanOpHandler(EmitterViewerSPI::MPSLessThanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9873B8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 8 && *AttrData == 0x7373656C2E73706DLL)
    {
      __int16 v43 = 1283;
      v42[0] = (uint64_t)"classof on '";
      v42[2] = (uint64_t)"mps.less";
      v42[3] = 8;
      uint64_t v40 = "' failed due to the operation not being registered";
      __int16 v41 = 259;
      llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LessThanOp,void>::id) {
    goto LABEL_29;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v38 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2DEF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLessThanOrEqualToOpHandler *EmitterViewerSPI::MPSLessThanOrEqualToOpHandler::MPSLessThanOrEqualToOpHandler(EmitterViewerSPI::MPSLessThanOrEqualToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988198;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 14 && *AttrData == 0x7373656C2E73706DLL && *(void *)((char *)AttrData + 6) == 0x6C617571655F7373)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.less_equal";
      v43[3] = 14;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LessThanOrEqualToOp,void>::id) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2E4C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler *EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler::MPSLocalConvolutionDataGradientOpHandler(EmitterViewerSPI::MPSLocalConvolutionDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988618;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v67 == 35)
    {
      BOOL v68 = *AttrData == 0x61636F6C2E73706DLL && AttrData[1] == 0x6C6F766E6F635F6CLL;
      BOOL v69 = v68 && AttrData[2] == 0x61645F6E6F697475;
      BOOL v70 = v69 && AttrData[3] == 0x69646172675F6174;
      if (v70 && *(void *)((char *)AttrData + 27) == 0x746E656964617267)
      {
        __int16 v77 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v76[2] = (uint64_t)"mps.local_convolution_data_gradient";
        v76[3] = 35;
        BOOL v74 = "' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, (uint64_t *)&v74, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_66:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LocalConvolutionDataGradientOp,void>::id) {
    goto LABEL_66;
  }
  uint64_t v73 = a3;
  v76[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v76);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v79 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v79) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v79 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v72 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v73);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v73);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v27 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v27 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v27 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v27 addObject:v32];

  int v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v27 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v27 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v27 addObject:v35];

  uint64_t v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v27 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v27 addObject:v37];

  BOOL v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v27 addObject:v38];

  uint64_t v39 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v27 value:StorageType];
  if (v39) {
    [v25 addObject:v39];
  }

  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v73);
  __int16 v41 = Rewriter;
  if (!Rewriter)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    __int16 v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast_if_present";
    goto LABEL_45;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    __int16 v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast";
LABEL_45:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!InterfaceFor)
  {
    __int16 v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int64_t v45 = "InterfaceSupport.h";
    int64_t v46 = "Interface";
    goto LABEL_45;
  }
LABEL_30:
  __int16 v47 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_sizes", (uint64_t)v41, InterfaceFor);
  if (v47) {
    [v25 addObject:v47];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v73);
  int64_t v49 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v50 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v51 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v52 = 692;
    __int16 v53 = "Casting.h";
    __int16 v54 = "cast_if_present";
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49))
  {
    uint64_t v51 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v52 = 566;
    __int16 v53 = "Casting.h";
    __int16 v54 = "cast";
LABEL_48:
    __assert_rtn(v54, v53, v52, v51);
  }
  uint64_t v50 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49);
  if (!v50)
  {
    uint64_t v51 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v52 = 98;
    __int16 v53 = "InterfaceSupport.h";
    __int16 v54 = "Interface";
    goto LABEL_48;
  }
LABEL_38:
  uint64_t v55 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v49, v50);
  if (v55) {
    [v25 addObject:v55];
  }

  __int16 v56 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v57 = [MPSGraphViewerNodeSPI alloc];
  int64_t v58 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v59 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  int64_t v60 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  int64_t v61 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  uint64_t v62 = [(MPSGraphViewerNodeSPI *)v57 initWithType:v72 inputs:v58 outputs:v59 properties:v60 regions:v61];
  __int16 v63 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v62;

  uint64_t v64 = [NSString stringWithUTF8String:"returns the gradient of the local_convolution operation relative to the input tensor."];
  [*((id *)this + 3) setLocalizedDescription:v64];

  if (SHIBYTE(v79) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2EEB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLocalConvolutionOpHandler *EmitterViewerSPI::MPSLocalConvolutionOpHandler::MPSLocalConvolutionOpHandler(EmitterViewerSPI::MPSLocalConvolutionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988090;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v67 == 21)
    {
      BOOL v68 = *AttrData == 0x61636F6C2E73706DLL && AttrData[1] == 0x6C6F766E6F635F6CLL;
      if (v68 && *(void *)((char *)AttrData + 13) == 0x6E6F6974756C6F76)
      {
        __int16 v75 = 1283;
        v74[0] = (uint64_t)"classof on '";
        v74[2] = (uint64_t)"mps.local_convolution";
        v74[3] = 21;
        BOOL v72 = "' failed due to the operation not being registered";
        __int16 v73 = 259;
        llvm::operator+(v74, (uint64_t *)&v72, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_60:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LocalConvolutionOp,void>::id) {
    goto LABEL_60;
  }
  unsigned int v71 = a3;
  v74[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v74);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v77 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v77) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v77 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v70 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v71);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v71);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v71);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v71);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v27 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v27 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v27 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v27 addObject:v32];

  int v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v27 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v27 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v27 addObject:v35];

  uint64_t v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v27 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v27 addObject:v37];

  BOOL v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v27 addObject:v38];

  uint64_t v39 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v27 value:StorageType];
  if (v39) {
    [v25 addObject:v39];
  }

  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v71);
  __int16 v41 = Rewriter;
  if (!Rewriter)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    __int16 v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast_if_present";
    goto LABEL_45;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    __int16 v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast";
LABEL_45:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!InterfaceFor)
  {
    __int16 v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int64_t v45 = "InterfaceSupport.h";
    int64_t v46 = "Interface";
    goto LABEL_45;
  }
LABEL_30:
  __int16 v47 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_sizes", (uint64_t)v41, InterfaceFor);
  if (v47) {
    [v25 addObject:v47];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v71);
  int64_t v49 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v50 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v51 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v52 = 692;
    __int16 v53 = "Casting.h";
    __int16 v54 = "cast_if_present";
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49))
  {
    uint64_t v51 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v52 = 566;
    __int16 v53 = "Casting.h";
    __int16 v54 = "cast";
LABEL_48:
    __assert_rtn(v54, v53, v52, v51);
  }
  uint64_t v50 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49);
  if (!v50)
  {
    uint64_t v51 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v52 = 98;
    __int16 v53 = "InterfaceSupport.h";
    __int16 v54 = "Interface";
    goto LABEL_48;
  }
LABEL_38:
  uint64_t v55 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v49, v50);
  if (v55) {
    [v25 addObject:v55];
  }

  __int16 v56 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v57 = [MPSGraphViewerNodeSPI alloc];
  int64_t v58 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v59 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  int64_t v60 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  int64_t v61 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  uint64_t v62 = [(MPSGraphViewerNodeSPI *)v57 initWithType:v70 inputs:v58 outputs:v59 properties:v60 regions:v61];
  __int16 v63 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v62;

  uint64_t v64 = objc_msgSend(NSString, "stringWithUTF8String:", "For each pixel of the input image, a different set of weights is provided in the channels of the weight tensor and form a 2d filter for that pixel. The weights are arranged in HW order inside the channels of the weight tensor. The destination pixel is calculated as the weighted sum of the pixels surrounding the pixel at the same location of the input image. The input image is zero padded when the filter reaches outside of the input.");
  [*((id *)this + 3) setLocalizedDescription:v64];

  if (SHIBYTE(v77) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E2F8D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler *EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler::MPSLocalConvolutionWeightGradientOpHandler(EmitterViewerSPI::MPSLocalConvolutionWeightGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988678;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v67 == 37)
    {
      BOOL v68 = *AttrData == 0x61636F6C2E73706DLL && AttrData[1] == 0x6C6F766E6F635F6CLL;
      BOOL v69 = v68 && AttrData[2] == 0x65775F6E6F697475;
      BOOL v70 = v69 && AttrData[3] == 0x6172675F74686769;
      if (v70 && *(void *)((char *)AttrData + 29) == 0x746E656964617267)
      {
        __int16 v77 = 1283;
        v76[0] = (uint64_t)"classof on '";
        v76[2] = (uint64_t)"mps.local_convolution_weight_gradient";
        v76[3] = 37;
        BOOL v74 = "' failed due to the operation not being registered";
        __int16 v75 = 259;
        llvm::operator+(v76, (uint64_t *)&v74, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_66:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LocalConvolutionWeightGradientOp,void>::id) {
    goto LABEL_66;
  }
  __int16 v73 = a3;
  v76[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v76);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v79 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v79) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v79 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v72 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v73);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v73);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v73);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v73);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v27 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v27 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v27 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v27 addObject:v32];

  int v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v27 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v27 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v27 addObject:v35];

  uint64_t v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v27 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v27 addObject:v37];

  BOOL v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v27 addObject:v38];

  uint64_t v39 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"data_layout" type:@"MPSTensorDataLayout" cases:v27 value:StorageType];
  if (v39) {
    [v25 addObject:v39];
  }

  Rewriter = (uint64_t **)mlir::pdl_interp::RecordMatchOp::getRewriter((mlir::pdl_interp::RecordMatchOp *)&v73);
  __int16 v41 = Rewriter;
  if (!Rewriter)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Rewriter))
  {
    __int16 v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast_if_present";
    goto LABEL_45;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    __int16 v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast";
LABEL_45:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!InterfaceFor)
  {
    __int16 v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int64_t v45 = "InterfaceSupport.h";
    int64_t v46 = "Interface";
    goto LABEL_45;
  }
LABEL_30:
  __int16 v47 = EmitViewerSPI::emitElementsAttrProperty(@"kernel_sizes", (uint64_t)v41, InterfaceFor);
  if (v47) {
    [v25 addObject:v47];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v73);
  int64_t v49 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v50 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v51 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v52 = 692;
    __int16 v53 = "Casting.h";
    __int16 v54 = "cast_if_present";
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49))
  {
    uint64_t v51 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v52 = 566;
    __int16 v53 = "Casting.h";
    __int16 v54 = "cast";
LABEL_48:
    __assert_rtn(v54, v53, v52, v51);
  }
  uint64_t v50 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v49);
  if (!v50)
  {
    uint64_t v51 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v52 = 98;
    __int16 v53 = "InterfaceSupport.h";
    __int16 v54 = "Interface";
    goto LABEL_48;
  }
LABEL_38:
  uint64_t v55 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v49, v50);
  if (v55) {
    [v25 addObject:v55];
  }

  __int16 v56 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v57 = [MPSGraphViewerNodeSPI alloc];
  int64_t v58 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v59 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  int64_t v60 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  int64_t v61 = [MEMORY[0x1E4F1C978] arrayWithArray:v56];
  uint64_t v62 = [(MPSGraphViewerNodeSPI *)v57 initWithType:v72 inputs:v58 outputs:v59 properties:v60 regions:v61];
  __int16 v63 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v62;

  uint64_t v64 = [NSString stringWithUTF8String:"returns the gradient of the local_convolution operation relative to the weight tensor."];
  [*((id *)this + 3) setLocalizedDescription:v64];

  if (SHIBYTE(v79) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3031C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLogarithmBase2OpHandler *EmitterViewerSPI::MPSLogarithmBase2OpHandler::MPSLogarithmBase2OpHandler(EmitterViewerSPI::MPSLogarithmBase2OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987D48;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      BOOL v36 = *(void *)AttrData == 0x61676F6C2E73706DLL && *(void *)(AttrData + 8) == 0x61625F6D68746972;
      if (v36 && *(_DWORD *)(AttrData + 16) == 845112691)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.logarithm_base_2";
        v42[3] = 20;
        uint64_t v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LogarithmBase2Op,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E30918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLogarithmBase10OpHandler *EmitterViewerSPI::MPSLogarithmBase10OpHandler::MPSLogarithmBase10OpHandler(EmitterViewerSPI::MPSLogarithmBase10OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987F28;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 21)
    {
      BOOL v36 = *AttrData == 0x61676F6C2E73706DLL && AttrData[1] == 0x61625F6D68746972;
      if (v36 && *(void *)((char *)AttrData + 13) == 0x30315F657361625FLL)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.logarithm_base_10";
        v42[3] = 21;
        uint64_t v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LogarithmBase10Op,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E30EB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSLogarithmOpHandler *EmitterViewerSPI::MPSLogarithmOpHandler::MPSLogarithmOpHandler(EmitterViewerSPI::MPSLogarithmOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987538;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x61676F6C2E73706DLL && *(void *)((char *)AttrData + 5) == 0x6D6874697261676FLL)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.logarithm";
      v41[3] = 13;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LogarithmOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  uint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E31434(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMatMulOpHandler *EmitterViewerSPI::MPSMatMulOpHandler::MPSMatMulOpHandler(EmitterViewerSPI::MPSMatMulOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986F08;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 10 && *(void *)AttrData == 0x6D74616D2E73706DLL && *(_WORD *)(AttrData + 8) == 27765)
    {
      __int16 v48 = 1283;
      v47[0] = (uint64_t)"classof on '";
      v47[2] = (uint64_t)"mps.matmul";
      v47[3] = 10;
      v45[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v46 = 259;
      llvm::operator+(v47, v45, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatMulOp,void>::id) {
    goto LABEL_37;
  }
  int64_t v44 = a3;
  v47[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v50 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v43 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  unsigned int v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v47[0]) = 0;
  LOBYTE(v47[0]) = mlir::pdl::ApplyNativeConstraintOp::getIsNegated((mlir::pdl::ApplyNativeConstraintOp *)&v44);
  uint64_t v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"transpose_lhs" dataType:2147483656 shape:&unk_1EC9F0920];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v47 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v45[0]) = 0;
  LOBYTE(v45[0]) = mlir::mps::MatMulOp::getTransposeRhs((mlir::mps::MatMulOp *)&v44);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"transpose_rhs" dataType:2147483656 shape:&unk_1EC9F0938];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v45 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v43 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  BOOL v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v50) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E31AD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler *EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler::MPSMaterializeSparseTensorOpHandler(EmitterViewerSPI::MPSMaterializeSparseTensorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9884F8;
  uint64_t v3 = *((void *)a3 + 6);
  uint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v49 == 29)
    {
      BOOL v50 = *AttrData == 0x6574616D2E73706DLL && AttrData[1] == 0x5F657A696C616972;
      BOOL v51 = v50 && AttrData[2] == 0x745F657372617073;
      if (v51 && *(void *)((char *)AttrData + 21) == 0x726F736E65745F65)
      {
        __int16 v59 = 1283;
        v58[0] = (uint64_t)"classof on '";
        uint64_t v58[2] = (uint64_t)"mps.materialize_sparse_tensor";
        v58[3] = 29;
        __int16 v56 = "' failed due to the operation not being registered";
        __int16 v57 = 259;
        llvm::operator+(v58, (uint64_t *)&v56, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::MaterializeSparseTensorOp,void>::id) {
    goto LABEL_44;
  }
  uint64_t v55 = a3;
  v58[0] = *(void *)(v3 + 8);
  uint8x8_t v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v58);
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    __int16 v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    int64_t v61 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v61) = v7;
  __int16 v9 = __dst;
  if (v7) {
LABEL_10:
  }
    memmove(v9, v6, (size_t)v8);
  *((unsigned char *)v8 + (void)v9) = 0;
  if (v61 >= 0) {
    uint64_t v12 = __dst;
  }
  else {
    uint64_t v12 = (void **)__dst[0];
  }
  __int16 v53 = [NSString stringWithCString:v12 encoding:4];
  unint64_t v13 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v55);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"sparse_values", Input);
  if (v15) {
    [v13 addObject:v15];
  }
  uint64_t Indices = mlir::memref::LoadOp::getIndices((mlir::memref::LoadOp *)&v55);
  unint64_t v18 = v17;
  if (v17)
  {
    uint64_t v19 = Indices;
    unint64_t v20 = 0;
    unsigned int v21 = 1;
    do
    {
      unint64_t v22 = *(void *)(v19 + 32 * v20 + 24);
      uint64_t v23 = objc_msgSend(NSString, "stringWithFormat:", @"index_tensors%d", v21 - 1);
      uint64_t v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, v23, v22);

      if (v24) {
        [v13 addObject:v24];
      }

      unint64_t v20 = v21++;
    }
    while (v18 > v20);
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v55);
  uint64_t v27 = @"result";
  if (v26)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v29 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v30 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v29 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v26)];

    if (v30) {
      [v25 addObject:v30];
    }
  }
  else
  {

    uint64_t v30 = 0;
  }

  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v55);
  int v33 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"COO" value:0];
  [v33 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CSC" value:1];
  [v33 addObject:v35];

  uint64_t v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CSR" value:2];
  [v33 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"storage_type" type:@"MPSSparseTensorStorage" cases:v33 value:StorageType];
  if (v37) {
    [v31 addObject:v37];
  }

  BOOL v38 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v39 = [MPSGraphViewerNodeSPI alloc];
  __int16 v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v13];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  __int16 v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v38];
  uint64_t v44 = [(MPSGraphViewerNodeSPI *)v39 initWithType:v53 inputs:v40 outputs:v41 properties:v42 regions:v43];
  int64_t v45 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v44;
  __int16 v46 = ;
  [*((id *)this + 3) setLocalizedDescription:v46];

  if (SHIBYTE(v61) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E32258(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler *EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler::MPSMatrixDecompositionLUOpHandler(EmitterViewerSPI::MPSMatrixDecompositionLUOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988468;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 27)
    {
      BOOL v42 = *AttrData == 0x7274616D2E73706DLL && AttrData[1] == 0x6D6F6365645F7869;
      BOOL v43 = v42 && AttrData[2] == 0x6E6F697469736F70;
      if (v43 && *(void *)((char *)AttrData + 19) == 0x756C5F6E6F697469)
      {
        __int16 v51 = 1283;
        v50[0] = (uint64_t)"classof on '";
        void v50[2] = (uint64_t)"mps.matrix_decomposition_lu";
        v50[3] = 27;
        __int16 v48 = "' failed due to the operation not being registered";
        __int16 v49 = 259;
        llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatrixDecompositionLUOp,void>::id) {
    goto LABEL_45;
  }
  __int16 v47 = a3;
  v50[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v53 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v45 = [NSString stringWithCString:v13 encoding:4];
  __int16 v46 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v46 addObject:v15];
  }

  uint64_t v16 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v17 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  unint64_t v18 = @"lu_matrix";
  if (v17)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v17->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v20 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v17->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v17 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"lu_matrix" dataType:MPSDataType shape:v20 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v17)];

    if (v17) {
      [v16 addObject:v17];
    }
  }
  else
  {
  }
  uint64_t Element = (MPSGraphViewerNodePortSPI *)mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v47);
  unint64_t v22 = @"pivot_indices";
  if (Element)
  {
    uint64_t v23 = getMPSDataType((void *)(*(void *)&Element->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&Element->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t Element = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"pivot_indices" dataType:v23 shape:v24 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, Element)];

    if (Element) {
      [v16 addObject:Element];
    }
  }
  else
  {
  }
  Gradientunint64_t InputState = (MPSGraphViewerNodePortSPI *)mlir::mps::GRUGradientOp::getGradientInputState((mlir::mps::GRUGradientOp *)&v47);
  uint64_t v26 = @"lu_status";
  if (GradientInputState)
  {
    uint64_t v27 = getMPSDataType((void *)(*(void *)&GradientInputState->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&GradientInputState->_dataType & 0xFFFFFFFFFFFFFFF8));
    Gradientunint64_t InputState = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"lu_status" dataType:v27 shape:v28 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, GradientInputState)];

    if (GradientInputState) {
      [v16 addObject:GradientInputState];
    }
  }
  else
  {
  }
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v46];
  int v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v16];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v45 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;

  BOOL v38 = objc_msgSend(NSString, "stringWithUTF8String:", "Return the LU decomposition of an input matrix A as A = P*L*U The result contains the LU decomposition in packed form, a pivot_indices matrix to track matrix pivots and a status");
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v53) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E32A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMatrixInverseOpHandler *EmitterViewerSPI::MPSMatrixInverseOpHandler::MPSMatrixInverseOpHandler(EmitterViewerSPI::MPSMatrixInverseOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987BF8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 18)
    {
      BOOL v36 = *(void *)AttrData == 0x7274616D2E73706DLL && *(void *)(AttrData + 8) == 0x7265766E695F7869;
      if (v36 && *(_WORD *)(AttrData + 16) == 25971)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.matrix_inverse";
        v42[3] = 18;
        __int16 v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatrixInverseOp,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_matrix", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  uint64_t v19 = @"inverse_matrix";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"inverse_matrix" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    unint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Computes inverse for a square input"];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E32FFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMatrixSolverLUOpHandler *EmitterViewerSPI::MPSMatrixSolverLUOpHandler::MPSMatrixSolverLUOpHandler(EmitterViewerSPI::MPSMatrixSolverLUOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987D60;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 20)
    {
      BOOL v40 = *(void *)AttrData == 0x7274616D2E73706DLL && *(void *)(AttrData + 8) == 0x65766C6F735F7869;
      if (v40 && *(_DWORD *)(AttrData + 16) == 1970036594)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.matrix_solver_lu";
        v46[3] = 20;
        uint64_t v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MatrixSolverLUOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lu_matrix", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"pivot_indices", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  unint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs_matrix", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  uint64_t v23 = @"solution_matrix";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"solution_matrix" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  int v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;

  BOOL v36 = objc_msgSend(NSString, "stringWithUTF8String:", "Solves for x, in the equation Ax = b. Inputs are LU factorized matrix of A, permutation matrix (P), rhs matrix (b). Returns x");
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E335FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMaximumOpHandler *EmitterViewerSPI::MPSMaximumOpHandler::MPSMaximumOpHandler(EmitterViewerSPI::MPSMaximumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9870D0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x6978616D2E73706DLL && *(void *)((char *)AttrData + 3) == 0x6D756D6978616D2ELL)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.maximum";
      v43[3] = 11;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MaximumOp,void>::id) {
    goto LABEL_33;
  }
  BOOL v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E33BE8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMinimumOpHandler *EmitterViewerSPI::MPSMinimumOpHandler::MPSMinimumOpHandler(EmitterViewerSPI::MPSMinimumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9870E8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x696E696D2E73706DLL && *(void *)((char *)AttrData + 3) == 0x6D756D696E696D2ELL)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.minimum";
      v43[3] = 11;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MinimumOp,void>::id) {
    goto LABEL_33;
  }
  BOOL v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E341BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSModuloOpHandler *EmitterViewerSPI::MPSModuloOpHandler::MPSModuloOpHandler(EmitterViewerSPI::MPSModuloOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986F38;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 10 && *(void *)AttrData == 0x75646F6D2E73706DLL && *(_WORD *)(AttrData + 8) == 28524)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.modulo";
      v43[3] = 10;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ModuloOp,void>::id) {
    goto LABEL_33;
  }
  BOOL v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E34784(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSMultiplyOpHandler *EmitterViewerSPI::MPSMultiplyOpHandler::MPSMultiplyOpHandler(EmitterViewerSPI::MPSMultiplyOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9873D0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 12 && *(void *)AttrData == 0x746C756D2E73706DLL && *(_DWORD *)(AttrData + 8) == 2037149801)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.multiply";
      v43[3] = 12;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MultiplyOp,void>::id) {
    goto LABEL_33;
  }
  BOOL v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E34D50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNReluOpHandler *EmitterViewerSPI::MPSNReluOpHandler::MPSNReluOpHandler(EmitterViewerSPI::MPSNReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986CE0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 10 && *(void *)AttrData == 0x65725F6E2E73706DLL && *(_WORD *)(AttrData + 8) == 30060)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.n_relu";
      v45[3] = 10;
      __int16 v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NReluOp,void>::id) {
    goto LABEL_35;
  }
  __int16 v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"primary", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"secondary", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"tertiary", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  int v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v41 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E35350(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNandOpHandler *EmitterViewerSPI::MPSNandOpHandler::MPSNandOpHandler(EmitterViewerSPI::MPSNandOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9869E0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 8 && *AttrData == 0x646E616E2E73706DLL)
    {
      __int16 v43 = 1283;
      v42[0] = (uint64_t)"classof on '";
      v42[2] = (uint64_t)"mps.nand";
      v42[3] = 8;
      BOOL v40 = "' failed due to the operation not being registered";
      __int16 v41 = 259;
      llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NandOp,void>::id) {
    goto LABEL_29;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v39);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v38 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E35924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNegativeOpHandler *EmitterViewerSPI::MPSNegativeOpHandler::MPSNegativeOpHandler(EmitterViewerSPI::MPSNegativeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9873E8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(void *)AttrData == 0x6167656E2E73706DLL && *(_DWORD *)(AttrData + 8) == 1702259060)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.negative";
      v41[3] = 12;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NegativeOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E35EB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler *EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler::MPSNonMaximumSuppressionOpHandler(EmitterViewerSPI::MPSNonMaximumSuppressionOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988480;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v57 == 27)
    {
      BOOL v58 = *AttrData == 0x5F6E6F6E2E73706DLL && AttrData[1] == 0x5F6D756D6978616DLL;
      BOOL v59 = v58 && AttrData[2] == 0x7373657270707573;
      if (v59 && *(void *)((char *)AttrData + 19) == 0x6E6F697373657270)
      {
        __int16 v67 = 1283;
        v66[0] = (uint64_t)"classof on '";
        v66[2] = (uint64_t)"mps.non_maximum_suppression";
        v66[3] = 27;
        v64[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v65 = 259;
        llvm::operator+(v66, v64, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_59:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NonMaximumSuppressionOp,void>::id) {
    goto LABEL_59;
  }
  __int16 v63 = a3;
  v66[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v66);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v69 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v69) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v69 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v61 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v63);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"boxes", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v63);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"scores", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  Classuint64_t Indices = mlir::mps::NonMaximumSuppressionOp::getClassIndices((mlir::mps::NonMaximumSuppressionOp *)&v63);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"class_indices", ClassIndices);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t IouThreshold = mlir::mps::NonMaximumSuppressionOp::getIouThreshold((mlir::mps::NonMaximumSuppressionOp *)&v63);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"iou_threshold", IouThreshold);
  if (v22) {
    [v14 addObject:v22];
  }
  unint64_t Axis = mlir::mps::ConcatOp::getAxis((mlir::mps::ConcatOp *)&v63);
  uint64_t v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"score_threshold", Axis);
  if (v24) {
    [v14 addObject:v24];
  }

  uint64_t v62 = [MEMORY[0x1E4F1CA48] array];
  int v25 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v63);
  uint64_t v26 = @"selected_indices";
  if (v25)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v25->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v25->_dataType & 0xFFFFFFFFFFFFFFF8));
    int v25 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"selected_indices" dataType:MPSDataType shape:v28 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v25)];

    if (v25) {
      [v62 addObject:v25];
    }
  }
  else
  {
  }
  uint64_t Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v63);
  uint64_t v30 = @"num_boxes";
  if (Element)
  {
    uint64_t v31 = getMPSDataType((void *)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v32 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    int v33 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"num_boxes" dataType:v31 shape:v32 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, Element)];

    if (v33) {
      [v62 addObject:v33];
    }
  }
  else
  {

    int v33 = 0;
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v64[0]) = 0;
  LOBYTE(v64[0]) = mlir::mps::CostVolumeOp::getNormalizeCoordinates((mlir::mps::CostVolumeOp *)&v63);
  uint64_t v35 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"per_class_suppression" dataType:2147483656 shape:&unk_1EC9F0950];
  if (v35)
  {
    BOOL v36 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v64 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v35 setValue:v36];

    [v34 addObject:v35];
  }
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v63);
  BOOL v38 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v39 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"cornersHeightFirst" value:0];
  [v38 addObject:v39];

  __int16 v40 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"cornersWidthFirst" value:1];
  [v38 addObject:v40];

  __int16 v41 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"centersHeightFirst" value:2];
  [v38 addObject:v41];

  __int16 v42 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"centersWidthFirst" value:3];
  [v38 addObject:v42];

  __int16 v43 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"coordinate_mode" type:@"MPSCropResizeCoordinateMode" cases:v38 value:StorageType];
  if (v43) {
    [v34 addObject:v43];
  }

  v66[0] = mlir::mps::NonMaximumSuppressionOp::getMaxBoxes((mlir::mps::NonMaximumSuppressionOp *)&v63);
  if ((v66[0] & 0xFF00000000) != 0)
  {
    int64_t v44 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"max_boxes" dataType:32 shape:&unk_1EC9F0968];
    if (v44)
    {
      if (!BYTE4(v66[0])) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      int64_t v45 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v66 length:8];
      [(MPSGraphViewerNodePropertyDataSPI *)v44 setValue:v45];

      [v34 addObject:v44];
    }
  }
  __int16 v46 = [MEMORY[0x1E4F1CA48] array];
  __int16 v47 = [MPSGraphViewerNodeSPI alloc];
  int64_t v48 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int64_t v49 = [MEMORY[0x1E4F1C978] arrayWithArray:v62];
  BOOL v50 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  __int16 v51 = [MEMORY[0x1E4F1C978] arrayWithArray:v46];
  uint64_t v52 = [(MPSGraphViewerNodeSPI *)v47 initWithType:v61 inputs:v48 outputs:v49 properties:v50 regions:v51];
  int64_t v53 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v52;

    "f it is already known.\n"
    "\n"
    "Non maximum suppression is performed by sorting the boxes by their maximum score across all classes. A box will be s"
    "ppress other boxes with a maximum score in the same class.\n"
    "\n"
    "\n"
    " the selected box within the batch, in range [0,B), and the second index is the index of the box's' maximum score, i"
  __int16 v54 = "\n";
  [*((id *)this + 3) setLocalizedDescription:v54];

  if (SHIBYTE(v69) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E36830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNonZeroOpHandler *EmitterViewerSPI::MPSNonZeroOpHandler::MPSNonZeroOpHandler(EmitterViewerSPI::MPSNonZeroOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987100;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(void *)AttrData == 0x5F6E6F6E2E73706DLL && *(_DWORD *)(AttrData + 8) == 1869768058)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.non_zero";
      v41[3] = 12;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NonZeroOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E36EC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNorOpHandler *EmitterViewerSPI::MPSNorOpHandler::MPSNorOpHandler(EmitterViewerSPI::MPSNorOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986728;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1919905326)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.nor";
      v43[3] = 7;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NorOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E37470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNormalizationOpHandler *EmitterViewerSPI::MPSNormalizationOpHandler::MPSNormalizationOpHandler(EmitterViewerSPI::MPSNormalizationOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v60[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987C10;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v58 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v58);
    if (v47 == 17)
    {
      BOOL v48 = *(void *)AttrData == 0x6D726F6E2E73706DLL && *(void *)(AttrData + 8) == 0x6F6974617A696C61;
      if (v48 && *(unsigned char *)(AttrData + 16) == 110)
      {
        __int16 v57 = 1283;
        __dst[0] = "classof on '";
        uint64_t v55 = "mps.normalization";
        uint64_t v56 = 17;
        uint64_t v52 = "' failed due to the operation not being registered";
        __int16 v53 = 259;
        llvm::operator+((uint64_t *)__dst, (uint64_t *)&v52, (uint64_t)&v58);
        llvm::report_fatal_error((llvm::Twine *)&v58, 1);
      }
    }
LABEL_47:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NormalizationOp,void>::id) {
    goto LABEL_47;
  }
  __int16 v51 = a3;
  uint64_t v58 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v58);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    uint64_t v55 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v55) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v50 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v51);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v51);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"mean", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v51);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"variance", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v51);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gamma", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }
  unint64_t Dense = mlir::mpsx::SparseDenseMatMulOp::getDense((mlir::mpsx::SparseDenseMatMulOp *)&v51);
  uint64_t v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"beta", Dense);
  if (v24) {
    [v14 addObject:v24];
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51);
  uint64_t v27 = @"result";
  if (v26)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v29 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v30 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v29 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v26)];

    if (v30) {
      [v25 addObject:v30];
    }
  }
  else
  {

    uint64_t v30 = 0;
  }

  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v51, (uint64_t)&v58);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"epsilon" dataType:268435488 shape:&unk_1EC9F0980];
  if (v32)
  {
    int v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v58 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v31 addObject:v32];
  }

  uint64_t v34 = v59;
  if (llvm::APFloatBase::PPCDoubleDouble(v35) == v34) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v60);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v59);
  }
  BOOL v36 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v37 = [MPSGraphViewerNodeSPI alloc];
  BOOL v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  __int16 v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v36];
  uint64_t v42 = [(MPSGraphViewerNodeSPI *)v37 initWithType:v50 inputs:v38 outputs:v39 properties:v40 regions:v41];
  __int16 v43 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v42;
  __int16 v44 = ;
  [*((id *)this + 3) setLocalizedDescription:v44];

  if (SHIBYTE(v55) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E37BC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a21 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNotEqualToOpHandler *EmitterViewerSPI::MPSNotEqualToOpHandler::MPSNotEqualToOpHandler(EmitterViewerSPI::MPSNotEqualToOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987778;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 13 && *AttrData == 0x5F746F6E2E73706DLL && *(void *)((char *)AttrData + 5) == 0x6C617571655F746FLL)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.not_equal";
      v43[3] = 13;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NotEqualToOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E381F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSNotOpHandler *EmitterViewerSPI::MPSNotOpHandler::MPSNotOpHandler(EmitterViewerSPI::MPSNotOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986740;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1953459758)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.not";
      v41[3] = 7;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::NotOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  int v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3877C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSOneHotOpHandler *EmitterViewerSPI::MPSOneHotOpHandler::MPSOneHotOpHandler(EmitterViewerSPI::MPSOneHotOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986F50;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 11 && *AttrData == 0x5F656E6F2E73706DLL && *(void *)((char *)AttrData + 3) == 0x746F685F656E6F2ELL)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.one_hot";
      v45[3] = 11;
      __int16 v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::OneHotOp,void>::id) {
    goto LABEL_35;
  }
  __int16 v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"indices", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"depth", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v42);
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  int v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v41 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E38D78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSOrOpHandler *EmitterViewerSPI::MPSOrOpHandler::MPSOrOpHandler(EmitterViewerSPI::MPSOrOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986638;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 6 && *(_DWORD *)AttrData == 779317357 && *(_WORD *)(AttrData + 4) == 29295)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.or";
      v43[3] = 6;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::OrOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E39358(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPReluOpHandler *EmitterViewerSPI::MPSPReluOpHandler::MPSPReluOpHandler(EmitterViewerSPI::MPSPReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986CF8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 9 && *(void *)AttrData == 0x6C6572702E73706DLL && *(unsigned char *)(AttrData + 8) == 117)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.prelu";
      v43[3] = 9;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PReluOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;

  uint64_t v34 = objc_msgSend(NSString, "stringWithUTF8String:", "Where i = 1 ... C, if x_i > 0, return x_i, otherwise return alpha_i * x_i.");
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E39920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPadGradientOpHandler *EmitterViewerSPI::MPSPadGradientOpHandler::MPSPadGradientOpHandler(EmitterViewerSPI::MPSPadGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9878B0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v46 == 16 && *AttrData == 0x5F6461702E73706DLL && AttrData[1] == 0x746E656964617267)
    {
      __int16 v53 = 1283;
      v52[0] = (uint64_t)"classof on '";
      v52[2] = (uint64_t)"mps.pad_gradient";
      v52[3] = 16;
      BOOL v50 = "' failed due to the operation not being registered";
      __int16 v51 = 259;
      llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PadGradientOp,void>::id) {
    goto LABEL_37;
  }
  int64_t v49 = a3;
  v52[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v55 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v48 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"paddings", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v49);
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"constant" value:0];
  [v29 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"reflect" value:1];
  [v29 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"symmetric" value:2];
  [v29 addObject:v32];

  int v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"clampToEdge" value:3];
  [v29 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"paddingMode" type:@"MPSPaddingMode" cases:v29 value:StorageType];
  if (v34) {
    [v27 addObject:v34];
  }

  uint64_t v35 = [MEMORY[0x1E4F1CA48] array];
  BOOL v36 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  __int16 v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v35];
  uint64_t v41 = [(MPSGraphViewerNodeSPI *)v36 initWithType:v48 inputs:v37 outputs:v38 properties:v39 regions:v40];
  __int16 v42 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v41;
  __int16 v43 = ;
  [*((id *)this + 3) setLocalizedDescription:v43];

  if (SHIBYTE(v55) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3A03C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPadOpHandler *EmitterViewerSPI::MPSPadOpHandler::MPSPadOpHandler(EmitterViewerSPI::MPSPadOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986758;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v46 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1684107310)
    {
      __int16 v53 = 1283;
      v52[0] = (uint64_t)"classof on '";
      v52[2] = (uint64_t)"mps.pad";
      v52[3] = 7;
      BOOL v50 = "' failed due to the operation not being registered";
      __int16 v51 = 259;
      llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PadOp,void>::id) {
    goto LABEL_37;
  }
  int64_t v49 = a3;
  v52[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v55 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v48 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"paddings", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"constant_values", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v49);
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"constant" value:0];
  [v29 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"reflect" value:1];
  [v29 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"symmetric" value:2];
  [v29 addObject:v32];

  int v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"clampToEdge" value:3];
  [v29 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"paddingMode" type:@"MPSPaddingMode" cases:v29 value:StorageType];
  if (v34) {
    [v27 addObject:v34];
  }

  uint64_t v35 = [MEMORY[0x1E4F1CA48] array];
  BOOL v36 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  __int16 v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v35];
  uint64_t v41 = [(MPSGraphViewerNodeSPI *)v36 initWithType:v48 inputs:v37 outputs:v38 properties:v39 regions:v40];
  __int16 v42 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v41;

  __int16 v43 = [NSString stringWithUTF8String:"Pad the input tensor specifying padding values and padding mode"];
  [*((id *)this + 3) setLocalizedDescription:v43];

  if (SHIBYTE(v55) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3A790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPermuteOpHandler *EmitterViewerSPI::MPSPermuteOpHandler::MPSPermuteOpHandler(EmitterViewerSPI::MPSPermuteOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987118;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x6D7265702E73706DLL && *(void *)((char *)AttrData + 3) == 0x6574756D7265702ELL)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.permute";
      v43[3] = 11;
      uint64_t v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PermuteOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"perm", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  int v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3ADA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPlaceholderOpHandler *EmitterViewerSPI::MPSPlaceholderOpHandler::MPSPlaceholderOpHandler(EmitterViewerSPI::MPSPlaceholderOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9878C8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v33 == 15 && *AttrData == 0x63616C702E73706DLL && *(void *)((char *)AttrData + 7) == 0x7265646C6F686563)
    {
      __int16 v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"mps.placeholder";
      v39[3] = 15;
      uint64_t v37 = "' failed due to the operation not being registered";
      __int16 v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_29:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PlaceholderOp,void>::id) {
    goto LABEL_29;
  }
  BOOL v36 = a3;
  v39[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v42 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v35 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v15 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  unint64_t v17 = @"result";
  if (v16)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v19 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v19 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v16)];

    if (v20) {
      [v15 addObject:v20];
    }
  }
  else
  {

    uint64_t v20 = 0;
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v23 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v24 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v25 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v22];
  uint64_t v28 = [(MPSGraphViewerNodeSPI *)v23 initWithType:v35 inputs:v24 outputs:v25 properties:v26 regions:v27];
  uint64_t v29 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v28;

  uint64_t v30 = [NSString stringWithUTF8String:"Inserts a placeholder for a tensor that will be always fed."];
  [*((id *)this + 3) setLocalizedDescription:v30];

  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3B30C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolAvgGradientOpHandler *EmitterViewerSPI::MPSPoolAvgGradientOpHandler::MPSPoolAvgGradientOpHandler(EmitterViewerSPI::MPSPoolAvgGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987F40;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v80 == 28)
    {
      BOOL v81 = *(void *)AttrData == 0x6C6F6F702E73706DLL && *(void *)(AttrData + 8) == 0x726576615F676E69;
      BOOL v82 = v81 && *(void *)(AttrData + 16) == 0x646172675F656761;
      if (v82 && *(_DWORD *)(AttrData + 24) == 1953391977)
      {
        __int16 v91 = 1283;
        v90[0] = (uint64_t)"classof on '";
        v90[2] = (uint64_t)"mps.pooling_average_gradient";
        v90[3] = 28;
        v88[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v89 = 259;
        llvm::operator+(v90, v88, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_91:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgGradientOp,void>::id) {
    goto LABEL_91;
  }
  __int16 v87 = a3;
  v90[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v90);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v93 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v93) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v93 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  unint64_t v84 = [NSString stringWithCString:v13 encoding:4];
  int8x8_t v86 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v87);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v86 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v87);
  unint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v17) {
    [v86 addObject:v17];
  }

  unsigned int v85 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v87);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v85 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  WindowSizes = (uint64_t **)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v87);
  int v25 = WindowSizes;
  if (!WindowSizes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_67:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_67;
  }
LABEL_28:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"window_sizes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v87);
  uint64_t v33 = Strides;
  if (!Strides)
  {
    uint64_t v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    uint64_t v37 = "Casting.h";
    __int16 v38 = "cast_if_present";
    goto LABEL_70;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    uint64_t v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    uint64_t v37 = "Casting.h";
    __int16 v38 = "cast";
LABEL_70:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    uint64_t v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    uint64_t v37 = "InterfaceSupport.h";
    __int16 v38 = "Interface";
    goto LABEL_70;
  }
LABEL_36:
  uint64_t v39 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v87);
  uint64_t v41 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    __int16 v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast_if_present";
    goto LABEL_73;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    __int16 v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast";
LABEL_73:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    __int16 v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int64_t v45 = "InterfaceSupport.h";
    int64_t v46 = "Interface";
    goto LABEL_73;
  }
LABEL_44:
  uint64_t v47 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v87);
  int64_t v49 = [MEMORY[0x1E4F1CA48] array];
  BOOL v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v49 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v49 addObject:v51];

  uint64_t v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v49 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v49 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v49 addObject:v54];

  int64_t v55 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v49 value:PaddingStyle];
  if (v55) {
    [v23 addObject:v55];
  }

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v87);
  if (v57)
  {
    uint64_t v58 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v58))
        {
          uint64_t v59 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v58);
          if (!v59)
          {
            int64_t v60 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v61 = 98;
            uint64_t v62 = "InterfaceSupport.h";
            __int16 v63 = "Interface";
            goto LABEL_76;
          }
          goto LABEL_55;
        }
        int64_t v60 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v61 = 566;
        uint64_t v62 = "Casting.h";
        __int16 v63 = "cast";
      }
      else
      {
        int64_t v60 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v61 = 692;
        uint64_t v62 = "Casting.h";
        __int16 v63 = "cast_if_present";
      }
LABEL_76:
      __assert_rtn(v63, v62, v61, v60);
    }
    uint64_t v59 = 0;
LABEL_55:
    uint64_t v64 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v58, v59);
    if (v64) {
      [v23 addObject:v64];
    }
  }
  LOBYTE(v90[0]) = 0;
  LOBYTE(v90[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v87);
  __int16 v65 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"ceil_mode" dataType:2147483656 shape:&unk_1EC9F0998];
  if (v65)
  {
    uint64_t v66 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v90 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v65 setValue:v66];

    [v23 addObject:v65];
  }
  LOBYTE(v88[0]) = 0;
  LOBYTE(v88[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v87);
  __int16 v67 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"include_zero_pad" dataType:2147483656 shape:&unk_1EC9F09B0];
  if (v67)
  {
    BOOL v68 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v88 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v67 setValue:v68];

    [v23 addObject:v67];
  }

  int64_t v69 = [MEMORY[0x1E4F1CA48] array];
  BOOL v70 = [MPSGraphViewerNodeSPI alloc];
  unsigned int v71 = [MEMORY[0x1E4F1C978] arrayWithArray:v86];
  BOOL v72 = [MEMORY[0x1E4F1C978] arrayWithArray:v85];
  __int16 v73 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  BOOL v74 = [MEMORY[0x1E4F1C978] arrayWithArray:v69];
  uint64_t v75 = [(MPSGraphViewerNodeSPI *)v70 initWithType:v84 inputs:v71 outputs:v72 properties:v73 regions:v74];
  unsigned int v76 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v75;

  __int16 v77 = objc_msgSend(NSString, "stringWithUTF8String:", "Computes the gradient backpropagation for the pooling operation in four dimensions. If indices are provided, then output_shape should be provided too and input should not be provided. If input is provided, then indices and output_shape should not be provided.");
  [*((id *)this + 3) setLocalizedDescription:v77];

  if (SHIBYTE(v93) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3BE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolAvgOpHandler *EmitterViewerSPI::MPSPoolAvgOpHandler::MPSPoolAvgOpHandler(EmitterViewerSPI::MPSPoolAvgOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987130;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v78 == 19)
    {
      BOOL v79 = *AttrData == 0x6C6F6F702E73706DLL && AttrData[1] == 0x726576615F676E69;
      if (v79 && *(void *)((char *)AttrData + 11) == 0x656761726576615FLL)
      {
        __int16 v88 = 1283;
        v87[0] = (uint64_t)"classof on '";
        v87[2] = (uint64_t)"mps.pooling_average";
        v87[3] = 19;
        v85[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v86 = 259;
        llvm::operator+(v87, v85, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_86:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolAvgOp,void>::id) {
    goto LABEL_86;
  }
  unint64_t v84 = a3;
  v87[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v87);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v90 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v90) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v90 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v81 = [NSString stringWithCString:v13 encoding:4];
  __int16 v83 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v84);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v83 addObject:v15];
  }

  BOOL v82 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v84);
  unint64_t v17 = @"result";
  if (v16)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v19 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v19 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v16)];

    if (v20) {
      [v82 addObject:v20];
    }
  }
  else
  {

    uint64_t v20 = 0;
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  WindowSizes = (uint64_t **)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v84);
  uint64_t v23 = WindowSizes;
  if (!WindowSizes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    int v25 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v26 = 692;
    uint64_t v27 = "Casting.h";
    uint64_t v28 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v23))
  {
    int v25 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v26 = 566;
    uint64_t v27 = "Casting.h";
    uint64_t v28 = "cast";
LABEL_65:
    __assert_rtn(v28, v27, v26, v25);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v23);
  if (!InterfaceFor)
  {
    int v25 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v26 = 98;
    uint64_t v27 = "InterfaceSupport.h";
    uint64_t v28 = "Interface";
    goto LABEL_65;
  }
LABEL_26:
  uint64_t v29 = EmitViewerSPI::emitElementsAttrProperty(@"window_sizes", (uint64_t)v23, InterfaceFor);
  if (v29) {
    [v21 addObject:v29];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v84);
  uint64_t v31 = Strides;
  if (!Strides)
  {
    uint64_t v32 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v33 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v34 = 692;
    uint64_t v35 = "Casting.h";
    int v36 = "cast_if_present";
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v31))
  {
    uint64_t v33 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v34 = 566;
    uint64_t v35 = "Casting.h";
    int v36 = "cast";
LABEL_68:
    __assert_rtn(v36, v35, v34, v33);
  }
  uint64_t v32 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v31);
  if (!v32)
  {
    uint64_t v33 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v34 = 98;
    uint64_t v35 = "InterfaceSupport.h";
    int v36 = "Interface";
    goto LABEL_68;
  }
LABEL_34:
  uint64_t v37 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v31, v32);
  if (v37) {
    [v21 addObject:v37];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v84);
  uint64_t v39 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v40 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v41 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v42 = 692;
    __int16 v43 = "Casting.h";
    int v44 = "cast_if_present";
    goto LABEL_71;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v39))
  {
    uint64_t v41 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v42 = 566;
    __int16 v43 = "Casting.h";
    int v44 = "cast";
LABEL_71:
    __assert_rtn(v44, v43, v42, v41);
  }
  uint64_t v40 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v39);
  if (!v40)
  {
    uint64_t v41 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v42 = 98;
    __int16 v43 = "InterfaceSupport.h";
    int v44 = "Interface";
    goto LABEL_71;
  }
LABEL_42:
  int64_t v45 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v39, v40);
  if (v45) {
    [v21 addObject:v45];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v84);
  uint64_t v47 = [MEMORY[0x1E4F1CA48] array];
  int64_t v48 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v47 addObject:v48];

  int64_t v49 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v47 addObject:v49];

  BOOL v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v47 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v47 addObject:v51];

  uint64_t v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v47 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v47 value:PaddingStyle];
  if (v53) {
    [v21 addObject:v53];
  }

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v84);
  if (v55)
  {
    uint64_t v56 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56))
        {
          uint64_t v57 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56);
          if (!v57)
          {
            uint64_t v58 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v59 = 98;
            int64_t v60 = "InterfaceSupport.h";
            int v61 = "Interface";
            goto LABEL_74;
          }
          goto LABEL_53;
        }
        uint64_t v58 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v59 = 566;
        int64_t v60 = "Casting.h";
        int v61 = "cast";
      }
      else
      {
        uint64_t v58 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v59 = 692;
        int64_t v60 = "Casting.h";
        int v61 = "cast_if_present";
      }
LABEL_74:
      __assert_rtn(v61, v60, v59, v58);
    }
    uint64_t v57 = 0;
LABEL_53:
    uint64_t v62 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v56, v57);
    if (v62) {
      [v21 addObject:v62];
    }
  }
  LOBYTE(v87[0]) = 0;
  LOBYTE(v87[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v84);
  __int16 v63 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"ceil_mode" dataType:2147483656 shape:&unk_1EC9F09C8];
  if (v63)
  {
    uint64_t v64 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v87 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v63 setValue:v64];

    [v21 addObject:v63];
  }
  LOBYTE(v85[0]) = 0;
  LOBYTE(v85[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v84);
  __int16 v65 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"include_zero_pad" dataType:2147483656 shape:&unk_1EC9F09E0];
  if (v65)
  {
    uint64_t v66 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v85 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v65 setValue:v66];

    [v21 addObject:v65];
  }

  __int16 v67 = [MEMORY[0x1E4F1CA48] array];
  BOOL v68 = [MPSGraphViewerNodeSPI alloc];
  int64_t v69 = [MEMORY[0x1E4F1C978] arrayWithArray:v83];
  BOOL v70 = [MEMORY[0x1E4F1C978] arrayWithArray:v82];
  unsigned int v71 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  BOOL v72 = [MEMORY[0x1E4F1C978] arrayWithArray:v67];
  uint64_t v73 = [(MPSGraphViewerNodeSPI *)v68 initWithType:v81 inputs:v69 outputs:v70 properties:v71 regions:v72];
  BOOL v74 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v73;
  uint64_t v75 = ;
  [*((id *)this + 3) setLocalizedDescription:v75];

  if (SHIBYTE(v90) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3CA1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolL2NormGradientOpHandler *EmitterViewerSPI::MPSPoolL2NormGradientOpHandler::MPSPoolL2NormGradientOpHandler(EmitterViewerSPI::MPSPoolL2NormGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988258;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v80 == 28)
    {
      BOOL v81 = *(void *)AttrData == 0x6C6F6F702E73706DLL && *(void *)(AttrData + 8) == 0x6E5F326C5F676E69;
      BOOL v82 = v81 && *(void *)(AttrData + 16) == 0x646172675F6D726FLL;
      if (v82 && *(_DWORD *)(AttrData + 24) == 1953391977)
      {
        __int16 v91 = 1283;
        v90[0] = (uint64_t)"classof on '";
        v90[2] = (uint64_t)"mps.pooling_l2_norm_gradient";
        v90[3] = 28;
        v88[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v89 = 259;
        llvm::operator+(v90, v88, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_91:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormGradientOp,void>::id) {
    goto LABEL_91;
  }
  __int16 v87 = a3;
  v90[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v90);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v93 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v93) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v93 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  unint64_t v84 = [NSString stringWithCString:v13 encoding:4];
  __int16 v86 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v87);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v86 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v87);
  unint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v17) {
    [v86 addObject:v17];
  }

  unsigned int v85 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v87);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v85 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  WindowSizes = (uint64_t **)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v87);
  int v25 = WindowSizes;
  if (!WindowSizes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_28;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    uint64_t v27 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v28 = 692;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast_if_present";
    goto LABEL_67;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25))
  {
    uint64_t v27 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v28 = 566;
    uint64_t v29 = "Casting.h";
    uint64_t v30 = "cast";
LABEL_67:
    __assert_rtn(v30, v29, v28, v27);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v25);
  if (!InterfaceFor)
  {
    uint64_t v27 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v28 = 98;
    uint64_t v29 = "InterfaceSupport.h";
    uint64_t v30 = "Interface";
    goto LABEL_67;
  }
LABEL_28:
  uint64_t v31 = EmitViewerSPI::emitElementsAttrProperty(@"window_sizes", (uint64_t)v25, InterfaceFor);
  if (v31) {
    [v23 addObject:v31];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v87);
  uint64_t v33 = Strides;
  if (!Strides)
  {
    uint64_t v34 = 0;
    goto LABEL_36;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v35 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v36 = 692;
    uint64_t v37 = "Casting.h";
    __int16 v38 = "cast_if_present";
    goto LABEL_70;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33))
  {
    uint64_t v35 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v36 = 566;
    uint64_t v37 = "Casting.h";
    __int16 v38 = "cast";
LABEL_70:
    __assert_rtn(v38, v37, v36, v35);
  }
  uint64_t v34 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v33);
  if (!v34)
  {
    uint64_t v35 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v36 = 98;
    uint64_t v37 = "InterfaceSupport.h";
    __int16 v38 = "Interface";
    goto LABEL_70;
  }
LABEL_36:
  uint64_t v39 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v33, v34);
  if (v39) {
    [v23 addObject:v39];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v87);
  uint64_t v41 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v42 = 0;
    goto LABEL_44;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    __int16 v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast_if_present";
    goto LABEL_73;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    __int16 v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    int64_t v45 = "Casting.h";
    int64_t v46 = "cast";
LABEL_73:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    __int16 v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    int64_t v45 = "InterfaceSupport.h";
    int64_t v46 = "Interface";
    goto LABEL_73;
  }
LABEL_44:
  uint64_t v47 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v87);
  int64_t v49 = [MEMORY[0x1E4F1CA48] array];
  BOOL v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v49 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v49 addObject:v51];

  uint64_t v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v49 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v49 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v49 addObject:v54];

  char v55 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v49 value:PaddingStyle];
  if (v55) {
    [v23 addObject:v55];
  }

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v87);
  if (v57)
  {
    uint64_t v58 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v58))
        {
          uint64_t v59 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v58);
          if (!v59)
          {
            int64_t v60 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v61 = 98;
            uint64_t v62 = "InterfaceSupport.h";
            __int16 v63 = "Interface";
            goto LABEL_76;
          }
          goto LABEL_55;
        }
        int64_t v60 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v61 = 566;
        uint64_t v62 = "Casting.h";
        __int16 v63 = "cast";
      }
      else
      {
        int64_t v60 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v61 = 692;
        uint64_t v62 = "Casting.h";
        __int16 v63 = "cast_if_present";
      }
LABEL_76:
      __assert_rtn(v63, v62, v61, v60);
    }
    uint64_t v59 = 0;
LABEL_55:
    uint64_t v64 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v58, v59);
    if (v64) {
      [v23 addObject:v64];
    }
  }
  LOBYTE(v90[0]) = 0;
  LOBYTE(v90[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v87);
  __int16 v65 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"ceil_mode" dataType:2147483656 shape:&unk_1EC9F09F8];
  if (v65)
  {
    uint64_t v66 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v90 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v65 setValue:v66];

    [v23 addObject:v65];
  }
  LOBYTE(v88[0]) = 0;
  LOBYTE(v88[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v87);
  __int16 v67 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"include_zero_pad" dataType:2147483656 shape:&unk_1EC9F0A10];
  if (v67)
  {
    BOOL v68 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v88 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v67 setValue:v68];

    [v23 addObject:v67];
  }

  int64_t v69 = [MEMORY[0x1E4F1CA48] array];
  BOOL v70 = [MPSGraphViewerNodeSPI alloc];
  unsigned int v71 = [MEMORY[0x1E4F1C978] arrayWithArray:v86];
  BOOL v72 = [MEMORY[0x1E4F1C978] arrayWithArray:v85];
  uint64_t v73 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  BOOL v74 = [MEMORY[0x1E4F1C978] arrayWithArray:v69];
  uint64_t v75 = [(MPSGraphViewerNodeSPI *)v70 initWithType:v84 inputs:v71 outputs:v72 properties:v73 regions:v74];
  unsigned int v76 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v75;

  __int16 v77 = objc_msgSend(NSString, "stringWithUTF8String:", "Computes the gradient backpropagation for the pooling operation in four dimensions. If indices are provided, then output_shape should be provided too and input should not be provided. If input is provided, then indices and output_shape should not be provided.");
  [*((id *)this + 3) setLocalizedDescription:v77];

  if (SHIBYTE(v93) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3D628(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolL2NormOpHandler *EmitterViewerSPI::MPSPoolL2NormOpHandler::MPSPoolL2NormOpHandler(EmitterViewerSPI::MPSPoolL2NormOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987790;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v78 == 19)
    {
      BOOL v79 = *AttrData == 0x6C6F6F702E73706DLL && AttrData[1] == 0x6E5F326C5F676E69;
      if (v79 && *(void *)((char *)AttrData + 11) == 0x6D726F6E5F326C5FLL)
      {
        __int16 v88 = 1283;
        v87[0] = (uint64_t)"classof on '";
        v87[2] = (uint64_t)"mps.pooling_l2_norm";
        v87[3] = 19;
        v85[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v86 = 259;
        llvm::operator+(v87, v85, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_86:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolL2NormOp,void>::id) {
    goto LABEL_86;
  }
  unint64_t v84 = a3;
  v87[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v87);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v90 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v90) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v90 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v81 = [NSString stringWithCString:v13 encoding:4];
  __int16 v83 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v84);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v83 addObject:v15];
  }

  BOOL v82 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v84);
  unint64_t v17 = @"result";
  if (v16)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v19 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v19 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v16)];

    if (v20) {
      [v82 addObject:v20];
    }
  }
  else
  {

    uint64_t v20 = 0;
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  WindowSizes = (uint64_t **)mlir::mps::PoolAvgGradientOp::getWindowSizes((mlir::mps::PoolAvgGradientOp *)&v84);
  uint64_t v23 = WindowSizes;
  if (!WindowSizes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_26;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    int v25 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v26 = 692;
    uint64_t v27 = "Casting.h";
    uint64_t v28 = "cast_if_present";
    goto LABEL_65;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v23))
  {
    int v25 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v26 = 566;
    uint64_t v27 = "Casting.h";
    uint64_t v28 = "cast";
LABEL_65:
    __assert_rtn(v28, v27, v26, v25);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v23);
  if (!InterfaceFor)
  {
    int v25 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v26 = 98;
    uint64_t v27 = "InterfaceSupport.h";
    uint64_t v28 = "Interface";
    goto LABEL_65;
  }
LABEL_26:
  uint64_t v29 = EmitViewerSPI::emitElementsAttrProperty(@"window_sizes", (uint64_t)v23, InterfaceFor);
  if (v29) {
    [v21 addObject:v29];
  }
  Strides = (uint64_t **)mlir::mps::Conv3DOp::getStrides((mlir::mps::Conv3DOp *)&v84);
  uint64_t v31 = Strides;
  if (!Strides)
  {
    uint64_t v32 = 0;
    goto LABEL_34;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    uint64_t v33 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v34 = 692;
    uint64_t v35 = "Casting.h";
    int v36 = "cast_if_present";
    goto LABEL_68;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v31))
  {
    uint64_t v33 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v34 = 566;
    uint64_t v35 = "Casting.h";
    int v36 = "cast";
LABEL_68:
    __assert_rtn(v36, v35, v34, v33);
  }
  uint64_t v32 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v31);
  if (!v32)
  {
    uint64_t v33 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v34 = 98;
    uint64_t v35 = "InterfaceSupport.h";
    int v36 = "Interface";
    goto LABEL_68;
  }
LABEL_34:
  uint64_t v37 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v31, v32);
  if (v37) {
    [v21 addObject:v37];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v84);
  uint64_t v39 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v40 = 0;
    goto LABEL_42;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    uint64_t v41 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v42 = 692;
    __int16 v43 = "Casting.h";
    int v44 = "cast_if_present";
    goto LABEL_71;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v39))
  {
    uint64_t v41 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v42 = 566;
    __int16 v43 = "Casting.h";
    int v44 = "cast";
LABEL_71:
    __assert_rtn(v44, v43, v42, v41);
  }
  uint64_t v40 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v39);
  if (!v40)
  {
    uint64_t v41 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v42 = 98;
    __int16 v43 = "InterfaceSupport.h";
    int v44 = "Interface";
    goto LABEL_71;
  }
LABEL_42:
  int64_t v45 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v39, v40);
  if (v45) {
    [v21 addObject:v45];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v84);
  uint64_t v47 = [MEMORY[0x1E4F1CA48] array];
  int64_t v48 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v47 addObject:v48];

  int64_t v49 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v47 addObject:v49];

  BOOL v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v47 addObject:v50];

  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v47 addObject:v51];

  uint64_t v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v47 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v47 value:PaddingStyle];
  if (v53) {
    [v21 addObject:v53];
  }

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v84);
  if (v55)
  {
    uint64_t v56 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56))
        {
          uint64_t v57 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v56);
          if (!v57)
          {
            uint64_t v58 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v59 = 98;
            int64_t v60 = "InterfaceSupport.h";
            int v61 = "Interface";
            goto LABEL_74;
          }
          goto LABEL_53;
        }
        uint64_t v58 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v59 = 566;
        int64_t v60 = "Casting.h";
        int v61 = "cast";
      }
      else
      {
        uint64_t v58 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v59 = 692;
        int64_t v60 = "Casting.h";
        int v61 = "cast_if_present";
      }
LABEL_74:
      __assert_rtn(v61, v60, v59, v58);
    }
    uint64_t v57 = 0;
LABEL_53:
    uint64_t v62 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v56, v57);
    if (v62) {
      [v21 addObject:v62];
    }
  }
  LOBYTE(v87[0]) = 0;
  LOBYTE(v87[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v84);
  __int16 v63 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"ceil_mode" dataType:2147483656 shape:&unk_1EC9F0A28];
  if (v63)
  {
    uint64_t v64 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v87 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v63 setValue:v64];

    [v21 addObject:v63];
  }
  LOBYTE(v85[0]) = 0;
  LOBYTE(v85[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v84);
  __int16 v65 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"include_zero_pad" dataType:2147483656 shape:&unk_1EC9F0A40];
  if (v65)
  {
    uint64_t v66 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v85 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v65 setValue:v66];

    [v21 addObject:v65];
  }

  __int16 v67 = [MEMORY[0x1E4F1CA48] array];
  BOOL v68 = [MPSGraphViewerNodeSPI alloc];
  int64_t v69 = [MEMORY[0x1E4F1C978] arrayWithArray:v83];
  BOOL v70 = [MEMORY[0x1E4F1C978] arrayWithArray:v82];
  unsigned int v71 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  BOOL v72 = [MEMORY[0x1E4F1C978] arrayWithArray:v67];
  uint64_t v73 = [(MPSGraphViewerNodeSPI *)v68 initWithType:v81 inputs:v69 outputs:v70 properties:v71 regions:v72];
  BOOL v74 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v73;
  uint64_t v75 = ;
  [*((id *)this + 3) setLocalizedDescription:v75];

  if (SHIBYTE(v90) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3E204(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolMaxGradientOpHandler *EmitterViewerSPI::MPSPoolMaxGradientOpHandler::MPSPoolMaxGradientOpHandler(EmitterViewerSPI::MPSPoolMaxGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987F58;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v94 == 24)
    {
      BOOL v95 = *AttrData == 0x6C6F6F702E73706DLL && AttrData[1] == 0x5F78616D5F676E69;
      if (v95 && AttrData[2] == 0x746E656964617267)
      {
        __int16 v105 = 1283;
        v104[0] = (uint64_t)"classof on '";
        v104[2] = (uint64_t)"mps.pooling_max_gradient";
        v104[3] = 24;
        v102[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v103 = 259;
        llvm::operator+(v104, v102, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_94:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolMaxGradientOp,void>::id) {
    goto LABEL_94;
  }
  __int16 v101 = a3;
  v104[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v104);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v107 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v107) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v107 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v98 = [NSString stringWithCString:v13 encoding:4];
  __int16 v100 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v101);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v100 addObject:v15];
  }
  unint64_t v16 = mlir::mps::PoolMaxGradientOp::getInput((mlir::mps::PoolMaxGradientOp *)&v101);
  unint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", v16);
  if (v17) {
    [v100 addObject:v17];
  }

  unint64_t Indices = mlir::mps::PoolMaxGradientOp::getIndices((mlir::mps::PoolMaxGradientOp *)&v101);
  uint64_t v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"indices", Indices);
  if (v19) {
    [v100 addObject:v19];
  }

  unint64_t OutputShape = mlir::mps::PoolMaxGradientOp::getOutputShape((mlir::mps::PoolMaxGradientOp *)&v101);
  unsigned int v21 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"output_shape", OutputShape);
  if (v21) {
    [v100 addObject:v21];
  }

  BOOL v99 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v101);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v99 addObject:v26];
    }
  }
  else
  {

    int v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  WindowSizes = (uint64_t **)mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v101);
  uint64_t v29 = WindowSizes;
  if (!WindowSizes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_32;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    uint64_t v31 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v32 = 692;
    uint64_t v33 = "Casting.h";
    int v34 = "cast_if_present";
    goto LABEL_73;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v29))
  {
    uint64_t v31 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v32 = 566;
    uint64_t v33 = "Casting.h";
    int v34 = "cast";
LABEL_73:
    __assert_rtn(v34, v33, v32, v31);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v29);
  if (!InterfaceFor)
  {
    uint64_t v31 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v32 = 98;
    uint64_t v33 = "InterfaceSupport.h";
    int v34 = "Interface";
    goto LABEL_73;
  }
LABEL_32:
  BOOL v97 = EmitViewerSPI::emitElementsAttrProperty(@"window_sizes", (uint64_t)v29, InterfaceFor);
  if (v97) {
    [v27 addObject:v97];
  }
  Strides = (uint64_t **)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v101);
  int v36 = Strides;
  if (!Strides)
  {
    uint64_t v37 = 0;
    goto LABEL_40;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    __int16 v38 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v39 = 692;
    uint64_t v40 = "Casting.h";
    uint64_t v41 = "cast_if_present";
    goto LABEL_76;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v36))
  {
    __int16 v38 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v39 = 566;
    uint64_t v40 = "Casting.h";
    uint64_t v41 = "cast";
LABEL_76:
    __assert_rtn(v41, v40, v39, v38);
  }
  uint64_t v37 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v36);
  if (!v37)
  {
    __int16 v38 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v39 = 98;
    uint64_t v40 = "InterfaceSupport.h";
    uint64_t v41 = "Interface";
    goto LABEL_76;
  }
LABEL_40:
  int v42 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v36, v37);
  if (v42) {
    [v27 addObject:v42];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v101);
  int v44 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v45 = 0;
    goto LABEL_48;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    int64_t v46 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v47 = 692;
    int64_t v48 = "Casting.h";
    int64_t v49 = "cast_if_present";
    goto LABEL_79;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v44))
  {
    int64_t v46 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v47 = 566;
    int64_t v48 = "Casting.h";
    int64_t v49 = "cast";
LABEL_79:
    __assert_rtn(v49, v48, v47, v46);
  }
  uint64_t v45 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v44);
  if (!v45)
  {
    int64_t v46 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v47 = 98;
    int64_t v48 = "InterfaceSupport.h";
    int64_t v49 = "Interface";
    goto LABEL_79;
  }
LABEL_48:
  BOOL v50 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v44, v45);
  if (v50) {
    [v27 addObject:v50];
  }
  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v101);
  uint64_t v52 = [MEMORY[0x1E4F1CA48] array];
  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v52 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v52 addObject:v54];

  char v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v52 addObject:v55];

  uint64_t v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v52 addObject:v56];

  uint64_t v57 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v52 addObject:v57];

  uint64_t v58 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v52 value:WeightsLayout];
  if (v58) {
    [v27 addObject:v58];
  }

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v101);
  if (v60)
  {
    int v61 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v61))
        {
          uint64_t v62 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v61);
          if (!v62)
          {
            __int16 v63 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v64 = 98;
            __int16 v65 = "InterfaceSupport.h";
            uint64_t v66 = "Interface";
            goto LABEL_82;
          }
          goto LABEL_59;
        }
        __int16 v63 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v64 = 566;
        __int16 v65 = "Casting.h";
        uint64_t v66 = "cast";
      }
      else
      {
        __int16 v63 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v64 = 692;
        __int16 v65 = "Casting.h";
        uint64_t v66 = "cast_if_present";
      }
LABEL_82:
      __assert_rtn(v66, v65, v64, v63);
    }
    uint64_t v62 = 0;
LABEL_59:
    __int16 v67 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v61, v62);
    if (v67) {
      [v27 addObject:v67];
    }
  }
  LOBYTE(v104[0]) = 0;
  LOBYTE(v104[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v101);
  BOOL v68 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"ceil_mode" dataType:2147483656 shape:&unk_1EC9F0A58];
  if (v68)
  {
    int64_t v69 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v104 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v68 setValue:v69];

    [v27 addObject:v68];
  }
  LOBYTE(v102[0]) = 0;
  LOBYTE(v102[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v101);
  BOOL v70 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"include_zero_pad" dataType:2147483656 shape:&unk_1EC9F0A70];
  if (v70)
  {
    unsigned int v71 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v102 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v70 setValue:v71];

    [v27 addObject:v70];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v101);
  uint64_t v73 = [MEMORY[0x1E4F1CA48] array];
  BOOL v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Global_Flatten1D" value:0];
  [v73 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Global_Flatten2D" value:1];
  [v73 addObject:v75];

  unsigned int v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Global_Flatten3D" value:2];
  [v73 addObject:v76];

  __int16 v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Global_Flatten4D" value:3];
  [v73 addObject:v77];

  uint64_t v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Local_Flatten1D" value:4];
  [v73 addObject:v78];

  BOOL v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Local_Flatten2D" value:5];
  [v73 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Local_Flatten3D" value:6];
  [v73 addObject:v80];

  BOOL v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Local_Flatten4D" value:7];
  [v73 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"indices_mode" type:@"MPSPoolIndicesMode" cases:v73 value:PaddingStyle];
  if (v82) {
    [v27 addObject:v82];
  }

  mlir::mps::PoolMaxGradientOp::getIndicesResultType((mlir::mps::PoolMaxGradientOp *)&v101);
  __int16 v83 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v84 = [MPSGraphViewerNodeSPI alloc];
  unsigned int v85 = [MEMORY[0x1E4F1C978] arrayWithArray:v100];
  __int16 v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v99];
  __int16 v87 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  __int16 v88 = [MEMORY[0x1E4F1C978] arrayWithArray:v83];
  uint64_t v89 = [(MPSGraphViewerNodeSPI *)v84 initWithType:v98 inputs:v85 outputs:v86 properties:v87 regions:v88];
  int64_t v90 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v89;

  __int16 v91 = objc_msgSend(NSString, "stringWithUTF8String:", "Computes the gradient backpropagation for the pooling operation in four dimensions. If indices are provided, then output_shape should be provided too and input should not be provided. If input is provided, then indices and output_shape should not be provided.");
  [*((id *)this + 3) setLocalizedDescription:v91];

  if (SHIBYTE(v107) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3F050(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPoolMaxOpHandler *EmitterViewerSPI::MPSPoolMaxOpHandler::MPSPoolMaxOpHandler(EmitterViewerSPI::MPSPoolMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987148;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v92 == 15 && *AttrData == 0x6C6F6F702E73706DLL && *(void *)((char *)AttrData + 7) == 0x78616D5F676E696CLL)
    {
      __int16 v102 = 1283;
      v101[0] = (uint64_t)"classof on '";
      v101[2] = (uint64_t)"mps.pooling_max";
      v101[3] = 15;
      v99[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v100 = 259;
      llvm::operator+(v101, v99, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_89:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PoolMaxOp,void>::id) {
    goto LABEL_89;
  }
  BOOL v98 = a3;
  v101[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v101);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v104 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v104) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v104 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v95 = [NSString stringWithCString:v13 encoding:4];
  int64_t v96 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v98);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v96 addObject:v15];
  }

  BOOL v97 = [MEMORY[0x1E4F1CA48] array];
  unint64_t v16 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v98);
  unint64_t v17 = @"result";
  if (v16)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v16->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v19 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v16->_dataType & 0xFFFFFFFFFFFFFFF8));
    unint64_t v16 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v19 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v16)];

    if (v16) {
      [v97 addObject:v16];
    }
  }
  else
  {
  }
  uint64_t Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v98);
  unsigned int v21 = @"indices";
  if (Element)
  {
    uint64_t v22 = getMPSDataType((void *)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"indices" dataType:v22 shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, Element)];

    if (v24) {
      [v97 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  WindowSizes = (uint64_t **)mlir::mps::PoolMaxGradientOp::getWindowSizes((mlir::mps::PoolMaxGradientOp *)&v98);
  uint64_t v27 = WindowSizes;
  if (!WindowSizes)
  {
    uint64_t InterfaceFor = 0;
    goto LABEL_30;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(WindowSizes))
  {
    uint64_t v29 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v30 = 692;
    uint64_t v31 = "Casting.h";
    int v32 = "cast_if_present";
    goto LABEL_71;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27))
  {
    uint64_t v29 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v30 = 566;
    uint64_t v31 = "Casting.h";
    int v32 = "cast";
LABEL_71:
    __assert_rtn(v32, v31, v30, v29);
  }
  uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v27);
  if (!InterfaceFor)
  {
    uint64_t v29 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v30 = 98;
    uint64_t v31 = "InterfaceSupport.h";
    int v32 = "Interface";
    goto LABEL_71;
  }
LABEL_30:
  uint64_t v94 = EmitViewerSPI::emitElementsAttrProperty(@"window_sizes", (uint64_t)v27, InterfaceFor);
  if (v94) {
    [v25 addObject:v94];
  }
  Strides = (uint64_t **)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v98);
  int v34 = Strides;
  if (!Strides)
  {
    uint64_t v35 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    int v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v37 = 692;
    __int16 v38 = "Casting.h";
    int v39 = "cast_if_present";
    goto LABEL_74;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    int v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v37 = 566;
    __int16 v38 = "Casting.h";
    int v39 = "cast";
LABEL_74:
    __assert_rtn(v39, v38, v37, v36);
  }
  uint64_t v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    int v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v37 = 98;
    __int16 v38 = "InterfaceSupport.h";
    int v39 = "Interface";
    goto LABEL_74;
  }
LABEL_38:
  uint64_t v40 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v34, v35);
  if (v40) {
    [v25 addObject:v40];
  }
  InputAttributeNames = (uint64_t **)mlir::pdl_interp::CreateOperationOp::getInputAttributeNames((mlir::pdl_interp::CreateOperationOp *)&v98);
  int v42 = InputAttributeNames;
  if (!InputAttributeNames)
  {
    uint64_t v43 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(InputAttributeNames))
  {
    int v44 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v45 = 692;
    int64_t v46 = "Casting.h";
    int v47 = "cast_if_present";
    goto LABEL_77;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42))
  {
    int v44 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v45 = 566;
    int64_t v46 = "Casting.h";
    int v47 = "cast";
LABEL_77:
    __assert_rtn(v47, v46, v45, v44);
  }
  uint64_t v43 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v42);
  if (!v43)
  {
    int v44 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v45 = 98;
    int64_t v46 = "InterfaceSupport.h";
    int v47 = "Interface";
    goto LABEL_77;
  }
LABEL_46:
  int64_t v48 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v42, v43);
  if (v48) {
    [v25 addObject:v48];
  }
  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v98);
  BOOL v50 = [MEMORY[0x1E4F1CA48] array];
  __int16 v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v50 addObject:v51];

  uint64_t v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v50 addObject:v52];

  __int16 v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v50 addObject:v53];

  __int16 v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v50 addObject:v54];

  char v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v50 addObject:v55];

  uint64_t v56 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v50 value:WeightsLayout];
  if (v56) {
    [v25 addObject:v56];
  }

  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v98);
  if (v58)
  {
    int v59 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v59))
        {
          uint64_t v60 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v59);
          if (!v60)
          {
            int v61 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v62 = 98;
            __int16 v63 = "InterfaceSupport.h";
            int v64 = "Interface";
            goto LABEL_80;
          }
          goto LABEL_57;
        }
        int v61 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v62 = 566;
        __int16 v63 = "Casting.h";
        int v64 = "cast";
      }
      else
      {
        int v61 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v62 = 692;
        __int16 v63 = "Casting.h";
        int v64 = "cast_if_present";
      }
LABEL_80:
      __assert_rtn(v64, v63, v62, v61);
    }
    uint64_t v60 = 0;
LABEL_57:
    __int16 v65 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v59, v60);
    if (v65) {
      [v25 addObject:v65];
    }
  }
  LOBYTE(v101[0]) = 0;
  LOBYTE(v101[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v98);
  uint64_t v66 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"ceil_mode" dataType:2147483656 shape:&unk_1EC9F0A88];
  if (v66)
  {
    __int16 v67 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v101 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v66 setValue:v67];

    [v25 addObject:v66];
  }
  LOBYTE(v99[0]) = 0;
  LOBYTE(v99[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v98);
  BOOL v68 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"include_zero_pad" dataType:2147483656 shape:&unk_1EC9F0AA0];
  if (v68)
  {
    int64_t v69 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v99 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v68 setValue:v69];

    [v25 addObject:v68];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v98);
  unsigned int v71 = [MEMORY[0x1E4F1CA48] array];
  BOOL v72 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Global_Flatten1D" value:0];
  [v71 addObject:v72];

  uint64_t v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Global_Flatten2D" value:1];
  [v71 addObject:v73];

  BOOL v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Global_Flatten3D" value:2];
  [v71 addObject:v74];

  uint64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Global_Flatten4D" value:3];
  [v71 addObject:v75];

  unsigned int v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Local_Flatten1D" value:4];
  [v71 addObject:v76];

  __int16 v77 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Local_Flatten2D" value:5];
  [v71 addObject:v77];

  uint64_t v78 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Local_Flatten3D" value:6];
  [v71 addObject:v78];

  BOOL v79 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"Local_Flatten4D" value:7];
  [v71 addObject:v79];

  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"indices_mode" type:@"MPSPoolIndicesMode" cases:v71 value:PaddingStyle];
  if (v80) {
    [v25 addObject:v80];
  }

  mlir::mps::PoolMaxGradientOp::getIndicesResultType((mlir::mps::PoolMaxGradientOp *)&v98);
  BOOL v81 = [MEMORY[0x1E4F1CA48] array];
  BOOL v82 = [MPSGraphViewerNodeSPI alloc];
  __int16 v83 = [MEMORY[0x1E4F1C978] arrayWithArray:v96];
  unint64_t v84 = [MEMORY[0x1E4F1C978] arrayWithArray:v97];
  unsigned int v85 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v86 = [MEMORY[0x1E4F1C978] arrayWithArray:v81];
  uint64_t v87 = [(MPSGraphViewerNodeSPI *)v82 initWithType:v95 inputs:v83 outputs:v84 properties:v85 regions:v86];
  __int16 v88 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v87;
  uint64_t v89 = ;
  [*((id *)this + 3) setLocalizedDescription:v89];

  if (SHIBYTE(v104) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E3FF50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPowerOpHandler *EmitterViewerSPI::MPSPowerOpHandler::MPSPowerOpHandler(EmitterViewerSPI::MPSPowerOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986D10;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 9 && *(void *)AttrData == 0x65776F702E73706DLL && *(unsigned char *)(AttrData + 8) == 114)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.power";
      v43[3] = 9;
      uint64_t v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PowerOp,void>::id) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  int v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  int v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E40674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPruningGradientOpHandler *EmitterViewerSPI::MPSPruningGradientOpHandler::MPSPruningGradientOpHandler(EmitterViewerSPI::MPSPruningGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v63[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987F70;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v61 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v61);
    if (v50 == 18)
    {
      BOOL v51 = *(void *)AttrData == 0x6E7572702E73706DLL && *(void *)(AttrData + 8) == 0x6569646172675F65;
      if (v51 && *(_WORD *)(AttrData + 16) == 29806)
      {
        __int16 v60 = 1283;
        __dst[0] = "classof on '";
        char v58 = "mps.prune_gradient";
        uint64_t v59 = 18;
        char v55 = "' failed due to the operation not being registered";
        __int16 v56 = 259;
        llvm::operator+((uint64_t *)__dst, (uint64_t *)&v55, (uint64_t)&v61);
        llvm::report_fatal_error((llvm::Twine *)&v61, 1);
      }
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PruningGradientOp,void>::id) {
    goto LABEL_45;
  }
  __int16 v54 = a3;
  uint64_t v61 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v61);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    char v58 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v58) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v58) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v53 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v54);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"incoming_gradient", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  int v25 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v54);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"magnitude_pruning" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"pruning_metric" type:@"MPSPruningMetric" cases:v27 value:StorageType];
  if (v29) {
    [v25 addObject:v29];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v54);
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"random_pruning" value:0];
  [v31 addObject:v32];

  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"block_1d_2_4_pruning" value:1];
  [v31 addObject:v33];

  int v34 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"pruning_structure" type:@"MPSPruningStructure" cases:v31 value:Layout];
  if (v34) {
    [v25 addObject:v34];
  }

  mlir::mps::PruningOp::getSparsity((mlir::mps::PruningOp *)&v54, (uint64_t)&v61);
  uint64_t v35 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"sparsity" dataType:268435488 shape:&unk_1EC9F0AB8];
  if (v35)
  {
    int v36 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v61 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v35 setValue:v36];

    [v25 addObject:v35];
  }

  uint64_t v37 = v62;
  if (llvm::APFloatBase::PPCDoubleDouble(v38) == v37) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v63);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v62);
  }
  int v39 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v40 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v39];
  uint64_t v45 = [(MPSGraphViewerNodeSPI *)v40 initWithType:v53 inputs:v41 outputs:v42 properties:v43 regions:v44];
  int64_t v46 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v45;

  int v47 = objc_msgSend(NSString, "stringWithUTF8String:", "Gradient of prune tensor. Computed based on a pruning metric, a target sparsity and a pruning structure.");
  [*((id *)this + 3) setLocalizedDescription:v47];

  if (SHIBYTE(v58) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E40E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a22 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSPruningOpHandler *EmitterViewerSPI::MPSPruningOpHandler::MPSPruningOpHandler(EmitterViewerSPI::MPSPruningOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v60[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987160;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v58 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v58);
    if (v48 == 9 && *(void *)AttrData == 0x6E7572702E73706DLL && *(unsigned char *)(AttrData + 8) == 101)
    {
      __int16 v57 = 1283;
      __dst[0] = "classof on '";
      char v55 = "mps.prune";
      uint64_t v56 = 9;
      uint64_t v52 = "' failed due to the operation not being registered";
      __int16 v53 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v52, (uint64_t)&v58);
      llvm::report_fatal_error((llvm::Twine *)&v58, 1);
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PruningOp,void>::id) {
    goto LABEL_40;
  }
  BOOL v51 = a3;
  uint64_t v58 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v58);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    char v55 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v55) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v50 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v51);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v51);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v51);
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  int v26 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"magnitude_pruning" value:0];
  [v25 addObject:v26];

  uint64_t v27 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"pruning_metric" type:@"MPSPruningMetric" cases:v25 value:StorageType];
  if (v27) {
    [v23 addObject:v27];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v51);
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"random_pruning" value:0];
  [v29 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"block_1d_2_4_pruning" value:1];
  [v29 addObject:v31];

  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"pruning_structure" type:@"MPSPruningStructure" cases:v29 value:Layout];
  if (v32) {
    [v23 addObject:v32];
  }

  mlir::mps::PruningOp::getSparsity((mlir::mps::PruningOp *)&v51, (uint64_t)&v58);
  uint64_t v33 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"sparsity" dataType:268435488 shape:&unk_1EC9F0AD0];
  if (v33)
  {
    int v34 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v58 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v33 setValue:v34];

    [v23 addObject:v33];
  }

  uint64_t v35 = v59;
  if (llvm::APFloatBase::PPCDoubleDouble(v36) == v35) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v60);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v59);
  }
  uint64_t v37 = [MEMORY[0x1E4F1CA48] array];
  __int16 v38 = [MPSGraphViewerNodeSPI alloc];
  int v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v37];
  uint64_t v43 = [(MPSGraphViewerNodeSPI *)v38 initWithType:v50 inputs:v39 outputs:v40 properties:v41 regions:v42];
  __int16 v44 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v43;

  uint64_t v45 = objc_msgSend(NSString, "stringWithUTF8String:", "Prune a tensor based on a pruning metric, a target sparsity and a pruning structure.");
  [*((id *)this + 3) setLocalizedDescription:v45];

  if (SHIBYTE(v55) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4169C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,char a25)
{
  if (a22 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSQuantizeOpHandler *EmitterViewerSPI::MPSQuantizeOpHandler::MPSQuantizeOpHandler(EmitterViewerSPI::MPSQuantizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987400;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 12 && *(void *)AttrData == 0x6E6175712E73706DLL && *(_DWORD *)(AttrData + 8) == 1702521204)
    {
      __int16 v48 = 1283;
      v47[0] = (uint64_t)"classof on '";
      v47[2] = (uint64_t)"mps.quantize";
      v47[3] = 12;
      uint64_t v45 = "' failed due to the operation not being registered";
      __int16 v46 = 259;
      llvm::operator+(v47, (uint64_t *)&v45, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_41:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::QuantizeOp,void>::id) {
    goto LABEL_41;
  }
  __int16 v44 = a3;
  v47[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v50 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v43 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"scale", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v44);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"zero_point", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  uint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    int v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v44);
  v47[0] = mlir::mps::DequantizeLUTOp::getAxis((mlir::mps::DequantizeLUTOp *)&v44);
  if ((v47[0] & 0xFF00000000) != 0)
  {
    uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"axis" dataType:536870944 shape:&unk_1EC9F0AE8];
    if (v28)
    {
      if (!BYTE4(v47[0])) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v47 length:8];
      [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

      [v27 addObject:v28];
    }
  }
  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  int v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v43 inputs:v32 outputs:v33 properties:v34 regions:v35];
  uint64_t v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  __int16 v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v50) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E41DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRandomNormalOpHandler *EmitterViewerSPI::MPSRandomNormalOpHandler::MPSRandomNormalOpHandler(EmitterViewerSPI::MPSRandomNormalOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v58[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9879D0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v56 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v56);
    if (v44 == 17)
    {
      BOOL v45 = *(void *)AttrData == 0x646E61722E73706DLL && *(void *)(AttrData + 8) == 0x616D726F6E5F6D6FLL;
      if (v45 && *(unsigned char *)(AttrData + 16) == 108)
      {
        __int16 v55 = 1283;
        uint64_t v52 = "classof on '";
        v54[0] = "mps.random_normal";
        v54[1] = 17;
        __dst[0] = "' failed due to the operation not being registered";
        __int16 v51 = 259;
        llvm::operator+((uint64_t *)&v52, (uint64_t *)__dst, (uint64_t)&v56);
        llvm::report_fatal_error((llvm::Twine *)&v56, 1);
      }
    }
LABEL_46:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RandomNormalOp,void>::id) {
    goto LABEL_46;
  }
  __int16 v48 = a3;
  uint64_t v56 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v56);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v50 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int v47 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v48);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"state", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v48);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"shape", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v48);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&v48);
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v48, (uint64_t)&v56);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"mean" dataType:268435488 shape:&unk_1EC9F0B00];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v56 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  mlir::mps::RandomNormalOp::getStdDev((mlir::mps::RandomNormalOp *)&v48, (uint64_t)&v52);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"std_dev" dataType:268435488 shape:&unk_1EC9F0B18];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v52 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }
  mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v48);

  uint64_t v30 = v53;
  uint64_t v32 = llvm::APFloatBase::PPCDoubleDouble(v31);
  if (v32 == v30) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v54);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v53);
  }

  if (v32 == v57) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v58);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v57);
  }
  uint64_t v33 = [MEMORY[0x1E4F1CA48] array];
  int v34 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v33];
  uint64_t v39 = [(MPSGraphViewerNodeSPI *)v34 initWithType:v47 inputs:v35 outputs:v36 properties:v37 regions:v38];
  uint64_t v40 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v39;
  uint64_t v41 = ;
  [*((id *)this + 3) setLocalizedDescription:v41];

  if (SHIBYTE(v50) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E42548(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24)
{
  if (a16 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler *EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler::MPSRandomTruncatedNormalOpHandler(EmitterViewerSPI::MPSRandomTruncatedNormalOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v68[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988498;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v66 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v66);
    if (v47 == 27)
    {
      BOOL v48 = *AttrData == 0x646E61722E73706DLL && AttrData[1] == 0x636E7572745F6D6FLL;
      BOOL v49 = v48 && AttrData[2] == 0x726F6E5F64657461;
      if (v49 && *(void *)((char *)AttrData + 19) == 0x6C616D726F6E5F64)
      {
        __int16 v65 = 1283;
        int v62 = "classof on '";
        v64[0] = "mps.random_truncated_normal";
        v64[1] = 27;
        uint64_t v59 = "' failed due to the operation not being registered";
        v61[8] = 259;
        llvm::operator+((uint64_t *)&v62, (uint64_t *)&v59, (uint64_t)&v66);
        llvm::report_fatal_error((llvm::Twine *)&v66, 1);
      }
    }
LABEL_59:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RandomTruncatedNormalOp,void>::id) {
    goto LABEL_59;
  }
  __int16 v55 = a3;
  uint64_t v66 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v66);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v54 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v54) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v54 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v51 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v55);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"state", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v55);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"shape", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v52 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v19 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v55);
  uint64_t v20 = @"result";
  if (v19)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v22 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v19)];

    if (v23) {
      [v52 addObject:v23];
    }
  }
  else
  {

    uint64_t v23 = 0;
  }

  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  mlir::mps::RandomTruncatedNormalOp::getResultElementType((mlir::mps::RandomTruncatedNormalOp *)&v55);
  mlir::mps::RandomTruncatedNormalOp::getMean((mlir::mps::RandomTruncatedNormalOp *)&v55, (uint64_t)&v66);
  uint64_t v25 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"mean" dataType:268435488 shape:&unk_1EC9F0B30];
  if (v25)
  {
    int v26 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v66 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v25 setValue:v26];

    [v24 addObject:v25];
  }
  mlir::mps::RandomTruncatedNormalOp::getStdDev((mlir::mps::RandomTruncatedNormalOp *)&v55, (uint64_t)&v62);
  uint64_t v27 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"std_dev" dataType:268435488 shape:&unk_1EC9F0B48];
  if (v27)
  {
    uint64_t v28 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v62 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v27 setValue:v28];

    [v24 addObject:v27];
  }
  mlir::mps::PruningOp::getSparsity((mlir::mps::PruningOp *)&v55, (uint64_t)&v59);
  uint64_t v29 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"minimum" dataType:268435488 shape:&unk_1EC9F0B60];
  if (v29)
  {
    uint64_t v30 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v59 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v29 setValue:v30];

    [v24 addObject:v29];
  }
  mlir::mps::InstanceNormOp::getEpsilon((mlir::mps::InstanceNormOp *)&v55, (uint64_t)v56);
  uint64_t v31 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"maximum" dataType:268435488 shape:&unk_1EC9F0B78];
  if (v31)
  {
    uint64_t v32 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v56 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v31 setValue:v32];

    [v24 addObject:v31];
  }
  mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v55);

  uint64_t v33 = v57;
  uint64_t v35 = llvm::APFloatBase::PPCDoubleDouble(v34);
  if (v35 == v33) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)&v58);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v57);
  }

  if (v35 == v60) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v61);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v60);
  }

  if (v35 == v63) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v64);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v63);
  }

  if (v35 == v67) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v68);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v67);
  }
  uint64_t v36 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v37 = [MPSGraphViewerNodeSPI alloc];
  __int16 v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v52];
  uint64_t v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v36];
  uint64_t v42 = [(MPSGraphViewerNodeSPI *)v37 initWithType:v51 inputs:v38 outputs:v39 properties:v40 regions:v41];
  uint64_t v43 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v42;
  uint64_t v44 = ;
  [*((id *)this + 3) setLocalizedDescription:v44];

  if (SHIBYTE(v54) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E42E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10, void *a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  if (a17 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRandomUniformOpHandler *EmitterViewerSPI::MPSRandomUniformOpHandler::MPSRandomUniformOpHandler(EmitterViewerSPI::MPSRandomUniformOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987C28;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 18)
    {
      BOOL v41 = *(void *)AttrData == 0x646E61722E73706DLL && *(void *)(AttrData + 8) == 0x6F66696E755F6D6FLL;
      if (v41 && *(_WORD *)(AttrData + 16) == 28018)
      {
        __int16 v48 = 1283;
        v47[0] = (uint64_t)"classof on '";
        v47[2] = (uint64_t)"mps.random_uniform";
        v47[3] = 18;
        BOOL v45 = "' failed due to the operation not being registered";
        __int16 v46 = 259;
        llvm::operator+(v47, (uint64_t *)&v45, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RandomUniformOp,void>::id) {
    goto LABEL_40;
  }
  uint64_t v44 = a3;
  v47[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v50 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v43 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"state", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"shape", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v44);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"minimum", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v44);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"maximum", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v24)];

    if (v24) {
      [v23 addObject:v24];
    }
  }
  else
  {
  }
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v44);
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  int v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v35 = [(MPSGraphViewerNodeSPI *)v30 initWithType:v43 inputs:v31 outputs:v32 properties:v33 regions:v34];
  uint64_t v36 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v35;
  uint64_t v37 = ;
  [*((id *)this + 3) setLocalizedDescription:v37];

  if (SHIBYTE(v50) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E43558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRankOpHandler *EmitterViewerSPI::MPSRankOpHandler::MPSRankOpHandler(EmitterViewerSPI::MPSRankOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9869F8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6B6E61722E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.rank";
      v40[3] = 8;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RankOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  unint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"This op computes the rank of the input tensor and returns it as a scalar tensor."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E43B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReadDataFromFileOpHandler *EmitterViewerSPI::MPSReadDataFromFileOpHandler::MPSReadDataFromFileOpHandler(EmitterViewerSPI::MPSReadDataFromFileOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9D1DA8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 23)
    {
      BOOL v40 = *AttrData == 0x646165722E73706DLL && AttrData[1] == 0x72665F617461645FLL;
      if (v40 && *(void *)((char *)AttrData + 15) == 0x656C69665F6D6F72)
      {
        __int16 v49 = 1283;
        v46[0] = "classof on '";
        uint64_t v47 = "mps.read_data_from_file";
        uint64_t v48 = 23;
        v44[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+((uint64_t *)v46, v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReadDataFromFileOp,void>::id) {
    goto LABEL_40;
  }
  int64_t v43 = a3;
  v46[0] = *(const void **)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v15 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v16 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unint64_t v17 = @"result";
  if (v16)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v19 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v19 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v16)];

    if (v20) {
      [v15 addObject:v20];
    }
  }
  else
  {

    uint64_t v20 = 0;
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  Name = (const void *)mlir::pdl_interp::ApplyRewriteOp::getName((mlir::pdl_interp::ApplyRewriteOp *)&v43);
  uint64_t v24 = EmitViewerSPI::emitStringProperty(@"file_path", Name, v23);
  if (v24) {
    [v21 addObject:v24];
  }
  v44[0] = 0;
  v44[0] = (uint64_t)mlir::mps::ReadDataFromFileOp::getOffset((mlir::mps::ReadDataFromFileOp *)&v43);
  uint64_t v25 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"offset" dataType:64 shape:&unk_1EC9F0B90];
  if (v25)
  {
    int v26 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v44 length:8];
    [(MPSGraphViewerNodePropertyDataSPI *)v25 setValue:v26];

    [v21 addObject:v25];
  }
  mlir::pdl::OperationOp::getOpName((uint64_t)&v43, (uint64_t)v46);
  if ((_BYTE)v47)
  {
    uint64_t v27 = EmitViewerSPI::emitStringProperty(@"file_symbol", v46[0], (size_t)v46[1]);
    if (v27) {
      [v21 addObject:v27];
    }
  }
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v15];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  uint64_t v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4415C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReadVariableOpHandler *EmitterViewerSPI::MPSReadVariableOpHandler::MPSReadVariableOpHandler(EmitterViewerSPI::MPSReadVariableOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9879E8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 17)
    {
      BOOL v36 = *(void *)AttrData == 0x646165722E73706DLL && *(void *)(AttrData + 8) == 0x6C6261697261765FLL;
      if (v36 && *(unsigned char *)(AttrData + 16) == 101)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.read_variable";
        v42[3] = 17;
        BOOL v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReadVariableOp,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"resource", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Inserts a variableHandle for a tensor resource."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E44710(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRealPartOpHandler *EmitterViewerSPI::MPSRealPartOpHandler::MPSRealPartOpHandler(EmitterViewerSPI::MPSRealPartOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987418;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x6C6165722E73706DLL && *(void *)((char *)AttrData + 5) == 0x747261705F6C6165)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.real_part";
      v41[3] = 13;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RealPartOp,void>::id) {
    goto LABEL_31;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"output";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"output" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Extracts the real part of the input tensor."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E44C94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler *EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler::MPSRealToHermiteanFFTOpHandler(EmitterViewerSPI::MPSRealToHermiteanFFTOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988270;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 25)
    {
      BOOL v46 = *(void *)AttrData == 0x6C6165722E73706DLL && *(void *)(AttrData + 8) == 0x6D7265685F6F745FLL;
      BOOL v47 = v46 && *(void *)(AttrData + 16) == 0x66665F6E61657469;
      if (v47 && *(unsigned char *)(AttrData + 24) == 116)
      {
        __int16 v54 = 1283;
        v53[0] = (uint64_t)"classof on '";
        v53[2] = (uint64_t)"mps.real_to_hermitean_fft";
        v53[3] = 25;
        int64_t v51 = "' failed due to the operation not being registered";
        __int16 v52 = 259;
        llvm::operator+(v53, (uint64_t *)&v51, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_43:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RealToHermiteanFFTOp,void>::id) {
    goto LABEL_43;
  }
  int64_t v50 = a3;
  v53[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v53);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v56 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v56) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v56 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v49 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v50);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v50);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v50);
  unsigned int v21 = @"output";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"output" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v50);
  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v27 addObject:v28];

  uint64_t v29 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"size" value:1];
  [v27 addObject:v29];

  uint64_t v30 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"unitary" value:2];
  [v27 addObject:v30];

  uint64_t v31 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"scaling_mode" type:@"MPSFFTScalingMode" cases:v27 value:Layout];
  if (v31) {
    [v25 addObject:v31];
  }

  LOBYTE(v53[0]) = 0;
  LOBYTE(v53[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v50);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"inverse" dataType:2147483656 shape:&unk_1EC9F0BA8];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v53 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v25 addObject:v32];
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v35 = [MPSGraphViewerNodeSPI alloc];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  __int16 v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v49 inputs:v36 outputs:v37 properties:v38 regions:v39];
  __int16 v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;
  __int16 v42 = ;
  [*((id *)this + 3) setLocalizedDescription:v42];

  if (SHIBYTE(v56) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E453D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReciprocalOpHandler *EmitterViewerSPI::MPSReciprocalOpHandler::MPSReciprocalOpHandler(EmitterViewerSPI::MPSReciprocalOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9877A8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 14 && *AttrData == 0x696365722E73706DLL && *(void *)((char *)AttrData + 6) == 0x6C61636F72706963)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.reciprocal";
      v41[3] = 14;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalOp,void>::id) {
    goto LABEL_31;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E459B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReciprocalSquareRootOpHandler *EmitterViewerSPI::MPSReciprocalSquareRootOpHandler::MPSReciprocalSquareRootOpHandler(EmitterViewerSPI::MPSReciprocalSquareRootOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC97E1E8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 26)
    {
      BOOL v36 = *(void *)AttrData == 0x696365722E73706DLL && *(void *)(AttrData + 8) == 0x735F6C61636F7270;
      BOOL v37 = v36 && *(void *)(AttrData + 16) == 0x6F725F6572617571;
      if (v37 && *(_WORD *)(AttrData + 24) == 29807)
      {
        __int16 v44 = 1283;
        v43[0] = (uint64_t)"classof on '";
        v43[2] = (uint64_t)"mps.reciprocal_square_root";
        v43[3] = 26;
        __int16 v41 = "' failed due to the operation not being registered";
        __int16 v42 = 259;
        llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReciprocalSquareRootOp,void>::id) {
    goto LABEL_37;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v39 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E45F54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionAndOpHandler *EmitterViewerSPI::MPSReductionAndOpHandler::MPSReductionAndOpHandler(EmitterViewerSPI::MPSReductionAndOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987A00;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 17)
    {
      BOOL v40 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x6E615F6E6F697463;
      if (v40 && *(unsigned char *)(AttrData + 16) == 100)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_and";
        v46[3] = 17;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionAndOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0BC0];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E46594(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionArgMaxOpHandler *EmitterViewerSPI::MPSReductionArgMaxOpHandler::MPSReductionArgMaxOpHandler(EmitterViewerSPI::MPSReductionArgMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987F88;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 20)
    {
      BOOL v40 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x72615F6E6F697463;
      if (v40 && *(_DWORD *)(AttrData + 16) == 2019650919)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_argmax";
        v46[3] = 20;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMaxOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0BD8];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E46C08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionArgMinOpHandler *EmitterViewerSPI::MPSReductionArgMinOpHandler::MPSReductionArgMinOpHandler(EmitterViewerSPI::MPSReductionArgMinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987FA0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 20)
    {
      BOOL v40 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x72615F6E6F697463;
      if (v40 && *(_DWORD *)(AttrData + 16) == 1852403047)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_argmin";
        v46[3] = 20;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionArgMinOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0BF0];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4727C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionLogSumExpOpHandler *EmitterViewerSPI::MPSReductionLogSumExpOpHandler::MPSReductionLogSumExpOpHandler(EmitterViewerSPI::MPSReductionLogSumExpOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988288;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 23)
    {
      BOOL v40 = *AttrData == 0x756465722E73706DLL && AttrData[1] == 0x6F6C5F6E6F697463;
      if (v40 && *(void *)((char *)AttrData + 15) == 0x7078656D7573676FLL)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_logsumexp";
        v46[3] = 23;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionLogSumExpOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0C08];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E478F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionMaxOpHandler *EmitterViewerSPI::MPSReductionMaxOpHandler::MPSReductionMaxOpHandler(EmitterViewerSPI::MPSReductionMaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987A18;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 17)
    {
      BOOL v42 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x616D5F6E6F697463;
      if (v42 && *(unsigned char *)(AttrData + 16) == 120)
      {
        __int16 v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.reduction_max";
        v48[3] = 17;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMaxOp,void>::id) {
    goto LABEL_40;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v44 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v45);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0C20];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"propagate_nans" dataType:2147483656 shape:&unk_1EC9F0C38];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v44 inputs:v32 outputs:v33 properties:v34 regions:v35];
  BOOL v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  __int16 v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E47FDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionMeanOpHandler *EmitterViewerSPI::MPSReductionMeanOpHandler::MPSReductionMeanOpHandler(EmitterViewerSPI::MPSReductionMeanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987C40;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 18)
    {
      BOOL v40 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x656D5F6E6F697463;
      if (v40 && *(_WORD *)(AttrData + 16) == 28257)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_mean";
        v46[3] = 18;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMeanOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0C50];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  uint64_t v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E48670(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionMinOpHandler *EmitterViewerSPI::MPSReductionMinOpHandler::MPSReductionMinOpHandler(EmitterViewerSPI::MPSReductionMinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987A30;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v41 == 17)
    {
      BOOL v42 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x696D5F6E6F697463;
      if (v42 && *(unsigned char *)(AttrData + 16) == 110)
      {
        __int16 v49 = 1283;
        v48[0] = (uint64_t)"classof on '";
        v48[2] = (uint64_t)"mps.reduction_min";
        v48[3] = 17;
        v46[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v47 = 259;
        llvm::operator+(v48, v46, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionMinOp,void>::id) {
    goto LABEL_40;
  }
  __int16 v45 = a3;
  v48[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v48);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v51 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v51) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v51 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v44 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v45);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v45);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v45);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v48[0]) = 0;
  LOBYTE(v48[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v45);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0C68];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v48 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v45);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"propagate_nans" dataType:2147483656 shape:&unk_1EC9F0C80];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }

  uint64_t v30 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v31 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v30];
  uint64_t v36 = [(MPSGraphViewerNodeSPI *)v31 initWithType:v44 inputs:v32 outputs:v33 properties:v34 regions:v35];
  BOOL v37 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v36;
  __int16 v38 = ;
  [*((id *)this + 3) setLocalizedDescription:v38];

  if (SHIBYTE(v51) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E48D54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionOrOpHandler *EmitterViewerSPI::MPSReductionOrOpHandler::MPSReductionOrOpHandler(EmitterViewerSPI::MPSReductionOrOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9878E0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 16 && *AttrData == 0x756465722E73706DLL && AttrData[1] == 0x726F5F6E6F697463)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.reduction_or";
      v45[3] = 16;
      __int16 v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionOrOp,void>::id) {
    goto LABEL_35;
  }
  BOOL v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v41 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v45[0]) = 0;
  LOBYTE(v45[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v42);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0C98];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v45 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v41 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  uint64_t v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E493DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionProdOpHandler *EmitterViewerSPI::MPSReductionProdOpHandler::MPSReductionProdOpHandler(EmitterViewerSPI::MPSReductionProdOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987C58;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 18)
    {
      BOOL v40 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x72705F6E6F697463;
      if (v40 && *(_WORD *)(AttrData + 16) == 25711)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_prod";
        v46[3] = 18;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionProdOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0CB0];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  uint64_t v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E49A4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionSumOpHandler *EmitterViewerSPI::MPSReductionSumOpHandler::MPSReductionSumOpHandler(EmitterViewerSPI::MPSReductionSumOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987A48;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 17)
    {
      BOOL v40 = *(void *)AttrData == 0x756465722E73706DLL && *(void *)(AttrData + 8) == 0x75735F6E6F697463;
      if (v40 && *(unsigned char *)(AttrData + 16) == 109)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_sum";
        v46[3] = 17;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionSumOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0CC8];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  uint64_t v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4A0BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReductionVarianceOpHandler *EmitterViewerSPI::MPSReductionVarianceOpHandler::MPSReductionVarianceOpHandler(EmitterViewerSPI::MPSReductionVarianceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9881B0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 22)
    {
      BOOL v40 = *AttrData == 0x756465722E73706DLL && AttrData[1] == 0x61765F6E6F697463;
      if (v40 && *(void *)((char *)AttrData + 14) == 0x65636E6169726176)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.reduction_variance";
        v46[3] = 22;
        __int16 v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReductionVarianceOp,void>::id) {
    goto LABEL_38;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v46[0]) = 0;
  LOBYTE(v46[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v43);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"keep_dims" dataType:2147483656 shape:&unk_1EC9F0CE0];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v46 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  uint64_t v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4A738(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReinterpretCastOpHandler *EmitterViewerSPI::MPSReinterpretCastOpHandler::MPSReinterpretCastOpHandler(EmitterViewerSPI::MPSReinterpretCastOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987FB8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 20)
    {
      BOOL v36 = *(void *)AttrData == 0x6E6965722E73706DLL && *(void *)(AttrData + 8) == 0x5F74657270726574;
      if (v36 && *(_DWORD *)(AttrData + 16) == 1953718627)
      {
        __int16 v43 = 1283;
        v42[0] = (uint64_t)"classof on '";
        v42[2] = (uint64_t)"mps.reinterpret_cast";
        v42[3] = 20;
        BOOL v40 = "' failed due to the operation not being registered";
        __int16 v41 = 259;
        llvm::operator+(v42, (uint64_t *)&v40, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_34:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReinterpretCastOp,void>::id) {
    goto LABEL_34;
  }
  uint64_t v39 = a3;
  v42[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v42);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v45 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v45) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v45 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v38 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v39);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v39);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  mlir::pdl_interp::CheckTypeOp::getType((mlir::pdl_interp::CheckTypeOp *)&v39);
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v38 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"Returns the input tensor reinterpreted to result_element_type type with the innermost dimension scaled by sizeof(type(input)) / sizeof(result_element_type)."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v45) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4AD00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRelu6OpHandler *EmitterViewerSPI::MPSRelu6OpHandler::MPSRelu6OpHandler(EmitterViewerSPI::MPSRelu6OpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986D28;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x756C65722E73706DLL && *(unsigned char *)(AttrData + 8) == 54)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.relu6";
      v41[3] = 9;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::Relu6Op,void>::id) {
    goto LABEL_31;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4B280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReluGradOpHandler *EmitterViewerSPI::MPSReluGradOpHandler::MPSReluGradOpHandler(EmitterViewerSPI::MPSReluGradOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987430;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 13 && *AttrData == 0x756C65722E73706DLL && *(void *)((char *)AttrData + 5) == 0x646172675F756C65)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.relu_grad";
      v41[3] = 13;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReluGradOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradients", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v38);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"features", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  unsigned int v21 = @"backprops";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v20->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v20 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"backprops" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v20)];

    if (v20) {
      [v19 addObject:v20];
    }
  }
  else
  {
  }
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  int v26 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [(MPSGraphViewerNodeSPI *)v26 initWithType:v37 inputs:v27 outputs:v28 properties:v29 regions:v30];
  uint64_t v32 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v31;

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4B80C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void sub_180E4B924(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReluOpHandler *EmitterViewerSPI::MPSReluOpHandler::MPSReluOpHandler(EmitterViewerSPI::MPSReluOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986A10;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x756C65722E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.relu";
      v40[3] = 8;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReluOp,void>::id) {
    goto LABEL_27;
  }
  BOOL v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4BD84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReshapeOpHandler *EmitterViewerSPI::MPSReshapeOpHandler::MPSReshapeOpHandler(EmitterViewerSPI::MPSReshapeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987178;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 11 && *AttrData == 0x687365722E73706DLL && *(void *)((char *)AttrData + 3) == 0x657061687365722ELL)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.reshape";
      v45[3] = 11;
      int64_t v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReshapeOp,void>::id) {
    goto LABEL_35;
  }
  __int16 v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"shape", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v45[0]) = 0;
  LOBYTE(v45[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v42);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"zero_is_copy" dataType:2147483656 shape:&unk_1EC9F0CF8];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v45 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }

  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v41 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4C3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSResizeGradientOpHandler *EmitterViewerSPI::MPSResizeGradientOpHandler::MPSResizeGradientOpHandler(EmitterViewerSPI::MPSResizeGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987D78;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 19)
    {
      BOOL v51 = *AttrData == 0x697365722E73706DLL && AttrData[1] == 0x69646172675F657ALL;
      if (v51 && *(void *)((char *)AttrData + 11) == 0x746E656964617267)
      {
        __int16 v58 = 1283;
        v57[0] = (uint64_t)"classof on '";
        v57[2] = (uint64_t)"mps.resize_gradient";
        v57[3] = 19;
        v55[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v56 = 259;
        llvm::operator+(v57, v55, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_46:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeGradientOp,void>::id) {
    goto LABEL_46;
  }
  __int16 v54 = a3;
  v57[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v57);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v60 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v60) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v60 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v53 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_gradient", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Shape = mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v54);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_shape", Shape);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Scale = mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v54);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"scale", Scale);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t Offset = mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v54);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"offset", Offset);
  if (v22) {
    [v14 addObject:v22];
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  Gateunsigned int Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v54);
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"nearest" value:0];
  [v31 addObject:v32];

  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"bilinear" value:1];
  [v31 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"mode" type:@"MPSSamplingMode" cases:v31 value:GateLayout];
  if (v34) {
    [v29 addObject:v34];
  }

  LOBYTE(v57[0]) = 0;
  LOBYTE(v57[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v54);
  uint64_t v35 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"center_result" dataType:2147483656 shape:&unk_1EC9F0D10];
  if (v35)
  {
    BOOL v36 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v57 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v35 setValue:v36];

    [v29 addObject:v35];
  }
  LOBYTE(v55[0]) = 0;
  LOBYTE(v55[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v54);
  BOOL v37 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"align_corners" dataType:2147483656 shape:&unk_1EC9F0D28];
  if (v37)
  {
    __int16 v38 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v55 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v37 setValue:v38];

    [v29 addObject:v37];
  }
  mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)&v54);

  uint64_t v39 = [MEMORY[0x1E4F1CA48] array];
  __int16 v40 = [MPSGraphViewerNodeSPI alloc];
  __int16 v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  __int16 v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v39];
  uint64_t v45 = [(MPSGraphViewerNodeSPI *)v40 initWithType:v53 inputs:v41 outputs:v42 properties:v43 regions:v44];
  __int16 v46 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v45;
  __int16 v47 = ;
  [*((id *)this + 3) setLocalizedDescription:v47];

  if (SHIBYTE(v60) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4CBE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSResizeOpHandler *EmitterViewerSPI::MPSResizeOpHandler::MPSResizeOpHandler(EmitterViewerSPI::MPSResizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986F68;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 10 && *(void *)AttrData == 0x697365722E73706DLL && *(_WORD *)(AttrData + 8) == 25978)
    {
      __int16 v57 = 1283;
      v56[0] = (uint64_t)"classof on '";
      v56[2] = (uint64_t)"mps.resize";
      v56[3] = 10;
      v54[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v55 = 259;
      llvm::operator+(v56, v54, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_43:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ResizeOp,void>::id) {
    goto LABEL_43;
  }
  __int16 v53 = a3;
  v56[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v56);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v59 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v59) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v59 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v52 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Shape = mlir::mps::ResizeOp::getShape((mlir::mps::ResizeOp *)&v53);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"shape", Shape);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Scale = mlir::mps::ResizeOp::getScale((mlir::mps::ResizeOp *)&v53);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"scale", Scale);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t Offset = mlir::mps::ResizeOp::getOffset((mlir::mps::ResizeOp *)&v53);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"offset", Offset);
  if (v22) {
    [v14 addObject:v22];
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v53);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  Gateunsigned int Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v53);
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"nearest" value:0];
  [v31 addObject:v32];

  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"bilinear" value:1];
  [v31 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"mode" type:@"MPSSamplingMode" cases:v31 value:GateLayout];
  if (v34) {
    [v29 addObject:v34];
  }

  LOBYTE(v56[0]) = 0;
  LOBYTE(v56[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v53);
  uint64_t v35 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"center_result" dataType:2147483656 shape:&unk_1EC9F0D40];
  if (v35)
  {
    BOOL v36 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v56 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v35 setValue:v36];

    [v29 addObject:v35];
  }
  LOBYTE(v54[0]) = 0;
  LOBYTE(v54[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v53);
  BOOL v37 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"align_corners" dataType:2147483656 shape:&unk_1EC9F0D58];
  if (v37)
  {
    __int16 v38 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v54 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v37 setValue:v38];

    [v29 addObject:v37];
  }
  mlir::mps::ResizeGradientOp::getNearestRoundingMode((mlir::mps::ResizeGradientOp *)&v53);

  uint64_t v39 = [MEMORY[0x1E4F1CA48] array];
  __int16 v40 = [MPSGraphViewerNodeSPI alloc];
  __int16 v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  __int16 v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v39];
  uint64_t v45 = [(MPSGraphViewerNodeSPI *)v40 initWithType:v52 inputs:v41 outputs:v42 properties:v43 regions:v44];
  __int16 v46 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v45;
  __int16 v47 = ;
  [*((id *)this + 3) setLocalizedDescription:v47];

  if (SHIBYTE(v59) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4D454(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSReverseOpHandler *EmitterViewerSPI::MPSReverseOpHandler::MPSReverseOpHandler(EmitterViewerSPI::MPSReverseOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987190;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x657665722E73706DLL && *(void *)((char *)AttrData + 3) == 0x657372657665722ELL)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.reverse";
      v43[3] = 11;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ReverseOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  int v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;

  uint64_t v34 = [NSString stringWithUTF8String:"Reverse values within tensor along provided axes. If no axes are provided then all axes are reversed."];
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4DAB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRintOpHandler *EmitterViewerSPI::MPSRintOpHandler::MPSRintOpHandler(EmitterViewerSPI::MPSRintOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986A28;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x746E69722E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.rint";
      v40[3] = 8;
      __int16 v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RintOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4E034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSRoundOpHandler *EmitterViewerSPI::MPSRoundOpHandler::MPSRoundOpHandler(EmitterViewerSPI::MPSRoundOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986D40;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x6E756F722E73706DLL && *(unsigned char *)(AttrData + 8) == 100)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.round";
      v41[3] = 9;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RoundOp,void>::id) {
    goto LABEL_31;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4E5AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSampleGridDataGradientOpHandler *EmitterViewerSPI::MPSSampleGridDataGradientOpHandler::MPSSampleGridDataGradientOpHandler(EmitterViewerSPI::MPSSampleGridDataGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9884C8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v53 == 29)
    {
      BOOL v54 = *AttrData == 0x706D61732E73706DLL && AttrData[1] == 0x5F646972675F656CLL;
      BOOL v55 = v54 && AttrData[2] == 0x6172675F61746164;
      if (v55 && *(void *)((char *)AttrData + 21) == 0x746E656964617267)
      {
        __int16 v64 = 1283;
        v63[0] = (uint64_t)"classof on '";
        v63[2] = (uint64_t)"mps.sample_grid_data_gradient";
        v63[3] = 29;
        v61[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v62 = 259;
        llvm::operator+(v63, v61, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_49:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SampleGridDataGradientOp,void>::id) {
    goto LABEL_49;
  }
  int64_t v60 = a3;
  v63[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v66 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v66) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v66 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v57 = [NSString stringWithCString:v13 encoding:4];
  int64_t v59 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v60);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v15) {
    [v59 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v60);
  unint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"coordinates", Filter);
  if (v17) {
    [v59 addObject:v17];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v60);
  uint64_t v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"outputShape", Bias);
  if (v19) {
    [v59 addObject:v19];
  }

  __int16 v58 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v60);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v58 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v63[0]) = 0;
  LOBYTE(v63[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v60);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"normalize_coordinates" dataType:2147483656 shape:&unk_1EC9F0D70];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v63 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v61[0]) = 0;
  LOBYTE(v61[0]) = mlir::mps::CostVolumeOp::getNormalizeCoordinates((mlir::mps::CostVolumeOp *)&v60);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"relative_coordinates" dataType:2147483656 shape:&unk_1EC9F0D88];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v61 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }
  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v60);
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"constant" value:0];
  [v31 addObject:v32];

  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"reflect" value:1];
  [v31 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"symmetric" value:2];
  [v31 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"clampToEdge" value:3];
  [v31 addObject:v35];

  BOOL v36 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_mode" type:@"MPSPaddingMode" cases:v31 value:Layout];
  if (v36) {
    [v25 addObject:v36];
  }

  unsigned int PaddingStyle = mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v60);
  __int16 v38 = [MEMORY[0x1E4F1CA48] array];
  __int16 v39 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"nearest" value:0];
  [v38 addObject:v39];

  __int16 v40 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"bilinear" value:1];
  [v38 addObject:v40];

  __int16 v41 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"sampling_mode" type:@"MPSSamplingMode" cases:v38 value:PaddingStyle];
  if (v41) {
    [v25 addObject:v41];
  }

  __int16 v42 = [MEMORY[0x1E4F1CA48] array];
  int64_t v43 = [MPSGraphViewerNodeSPI alloc];
  int64_t v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v59];
  uint64_t v45 = [MEMORY[0x1E4F1C978] arrayWithArray:v58];
  int64_t v46 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v47 = [MEMORY[0x1E4F1C978] arrayWithArray:v42];
  uint64_t v48 = [(MPSGraphViewerNodeSPI *)v43 initWithType:v57 inputs:v44 outputs:v45 properties:v46 regions:v47];
  int64_t v49 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v48;

  uint64_t v50 = [NSString stringWithUTF8String:"Gradient of sample_grid operation relative to the input data."];
  [*((id *)this + 3) setLocalizedDescription:v50];

  if (SHIBYTE(v66) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4EE8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *__p,uint64_t a24,int a25,__int16 a26,char a27,char a28)
{
  if (a28 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSampleGridOpHandler *EmitterViewerSPI::MPSSampleGridOpHandler::MPSSampleGridOpHandler(EmitterViewerSPI::MPSSampleGridOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9877C0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v69 == 15 && *AttrData == 0x706D61732E73706DLL && *(void *)((char *)AttrData + 7) == 0x646972675F656C70)
    {
      __int16 v79 = 1283;
      v78[0] = (uint64_t)"classof on '";
      v78[2] = (uint64_t)"mps.sample_grid";
      v78[3] = 15;
      v76[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v77 = 259;
      llvm::operator+(v78, v76, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_47:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SampleGridOp,void>::id) {
    goto LABEL_47;
  }
  uint64_t v75 = a3;
  v78[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v78);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v81 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v81) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v81 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  unsigned int v71 = [NSString stringWithCString:v13 encoding:4];
  uint64_t v73 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v75);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v73 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v75);
  unint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"coordinates", Filter);
  if (v17) {
    [v73 addObject:v17];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v75);
  uint64_t v19 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"constant_values", Bias);
  if (v19) {
    [v73 addObject:v19];
  }

  BOOL v72 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v75);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v72 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v78[0]) = 0;
  LOBYTE(v78[0]) = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v75);
  int v26 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"normalize_coordinates" dataType:2147483656 shape:&unk_1EC9F0DA0];
  if (v26)
  {
    uint64_t v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v78 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v26 setValue:v27];

    [v25 addObject:v26];
  }
  LOBYTE(v76[0]) = 0;
  LOBYTE(v76[0]) = mlir::mps::GRUOp::getTraining((mlir::mps::GRUOp *)&v75);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"relative_coordinates" dataType:2147483656 shape:&unk_1EC9F0DB8];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v76 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v25 addObject:v28];
  }
  BOOL InferredResultTypes = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v75);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"align_corners" dataType:2147483656 shape:&unk_1EC9F0DD0];
  if (v30)
  {
    uint64_t v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&InferredResultTypes length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v25 addObject:v30];
  }
  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v75);
  uint64_t v33 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"constant" value:0];
  [v33 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"reflect" value:1];
  [v33 addObject:v35];

  BOOL v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"symmetric" value:2];
  [v33 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"clampToEdge" value:3];
  [v33 addObject:v37];

  __int16 v38 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_mode" type:@"MPSPaddingMode" cases:v33 value:PaddingStyle];
  if (v38) {
    [v25 addObject:v38];
  }

  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v75);
  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  __int16 v41 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"nearest" value:0];
  [v40 addObject:v41];

  __int16 v42 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"bilinear" value:1];
  [v40 addObject:v42];

  int64_t v43 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"sampling_mode" type:@"MPSSamplingMode" cases:v40 value:WeightsLayout];
  if (v43) {
    [v25 addObject:v43];
  }

  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v75);
  uint64_t v45 = [MEMORY[0x1E4F1CA48] array];
  int64_t v46 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCHW" value:0];
  [v45 addObject:v46];

  __int16 v47 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NHWC" value:1];
  [v45 addObject:v47];

  uint64_t v48 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIHW" value:2];
  [v45 addObject:v48];

  int64_t v49 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWIO" value:3];
  [v45 addObject:v49];

  uint64_t v50 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"CHW" value:4];
  [v45 addObject:v50];

  BOOL v51 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HWC" value:5];
  [v45 addObject:v51];

  __int16 v52 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"HW" value:6];
  [v45 addObject:v52];

  uint64_t v53 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NCDHW" value:7];
  [v45 addObject:v53];

  BOOL v54 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"NDHWC" value:8];
  [v45 addObject:v54];

  BOOL v55 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"OIDHW" value:9];
  [v45 addObject:v55];

  __int16 v56 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"DHWIO" value:10];
  [v45 addObject:v56];

  __int16 v57 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"layout" type:@"MPSTensorDataLayout" cases:v45 value:Layout];
  if (v57) {
    [v25 addObject:v57];
  }

  mlir::mps::SampleGridOp::getNearestRoundingMode((mlir::mps::SampleGridOp *)&v75);
  __int16 v58 = [MEMORY[0x1E4F1CA48] array];
  int64_t v59 = [MPSGraphViewerNodeSPI alloc];
  int64_t v60 = [MEMORY[0x1E4F1C978] arrayWithArray:v73];
  uint64_t v61 = [MEMORY[0x1E4F1C978] arrayWithArray:v72];
  __int16 v62 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  __int16 v63 = [MEMORY[0x1E4F1C978] arrayWithArray:v58];
  uint64_t v64 = [(MPSGraphViewerNodeSPI *)v59 initWithType:v71 inputs:v60 outputs:v61 properties:v62 regions:v63];
  __int16 v65 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v64;
  int64_t v66 = ;
  [*((id *)this + 3) setLocalizedDescription:v66];

  if (SHIBYTE(v81) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E4FAEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSScatterAlongAxisOpHandler *EmitterViewerSPI::MPSScatterAlongAxisOpHandler::MPSScatterAlongAxisOpHandler(EmitterViewerSPI::MPSScatterAlongAxisOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9880A8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 22)
    {
      BOOL v51 = *AttrData == 0x746163732E73706DLL && AttrData[1] == 0x6E6F6C615F726574;
      if (v51 && *(void *)((char *)AttrData + 14) == 0x736978615F676E6FLL)
      {
        __int16 v58 = 1283;
        v57[0] = (uint64_t)"classof on '";
        v57[2] = (uint64_t)"mps.scatter_along_axis";
        v57[3] = 22;
        BOOL v55 = "' failed due to the operation not being registered";
        __int16 v56 = 259;
        llvm::operator+(v57, (uint64_t *)&v55, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterAlongAxisOp,void>::id) {
    goto LABEL_42;
  }
  BOOL v54 = a3;
  v57[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v57);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v60 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v60) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v60 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v53 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v54);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"data", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v54);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"updates", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v54);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"indices", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v54);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v54);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v54);
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"add" value:0];
  [v31 addObject:v32];

  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"subtract" value:1];
  [v31 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"multiply" value:2];
  [v31 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"divide" value:3];
  [v31 addObject:v35];

  BOOL v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"min" value:4];
  [v31 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"max" value:5];
  [v31 addObject:v37];

  __int16 v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"set" value:6];
  [v31 addObject:v38];

  __int16 v39 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"mode" type:@"MPSScatterMode" cases:v31 value:StorageType];
  if (v39) {
    [v29 addObject:v39];
  }

  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  __int16 v41 = [MPSGraphViewerNodeSPI alloc];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int64_t v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v45 = [MEMORY[0x1E4F1C978] arrayWithArray:v40];
  uint64_t v46 = [(MPSGraphViewerNodeSPI *)v41 initWithType:v53 inputs:v42 outputs:v43 properties:v44 regions:v45];
  __int16 v47 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v46;

  if (SHIBYTE(v60) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E503C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSScatterNDOpHandler *EmitterViewerSPI::MPSScatterNDOpHandler::MPSScatterNDOpHandler(EmitterViewerSPI::MPSScatterNDOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987550;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 14 && *AttrData == 0x746163732E73706DLL && *(void *)((char *)AttrData + 6) == 0x646E5F7265747461)
    {
      __int16 v57 = 1283;
      v56[0] = (uint64_t)"classof on '";
      v56[2] = (uint64_t)"mps.scatter_nd";
      v56[3] = 14;
      BOOL v54 = "' failed due to the operation not being registered";
      __int16 v55 = 259;
      llvm::operator+(v56, (uint64_t *)&v54, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterNDOp,void>::id) {
    goto LABEL_39;
  }
  uint64_t v53 = a3;
  v56[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v56);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v59 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v59) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v59 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v52 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"data", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"updates", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"indices", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v53);
  size_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    int v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v56[0]) = 0;
  LODWORD(v56[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v53);
  uint64_t v28 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"batch_dims" dataType:32 shape:&unk_1EC9F0DE8];
  if (v28)
  {
    uint64_t v29 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v56 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v28 setValue:v29];

    [v27 addObject:v28];
  }
  unsigned int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v53);
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"add" value:0];
  [v31 addObject:v32];

  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"subtract" value:1];
  [v31 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"multiply" value:2];
  [v31 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"divide" value:3];
  [v31 addObject:v35];

  BOOL v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"min" value:4];
  [v31 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"max" value:5];
  [v31 addObject:v37];

  __int16 v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"set" value:6];
  [v31 addObject:v38];

  __int16 v39 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"mode" type:@"MPSScatterMode" cases:v31 value:Layout];
  if (v39) {
    [v27 addObject:v39];
  }

  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  __int16 v41 = [MPSGraphViewerNodeSPI alloc];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  int64_t v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  uint64_t v45 = [MEMORY[0x1E4F1C978] arrayWithArray:v40];
  uint64_t v46 = [(MPSGraphViewerNodeSPI *)v41 initWithType:v52 inputs:v42 outputs:v43 properties:v44 regions:v45];
  __int16 v47 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v46;

  if (SHIBYTE(v59) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E50C24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSScatterOpHandler *EmitterViewerSPI::MPSScatterOpHandler::MPSScatterOpHandler(EmitterViewerSPI::MPSScatterOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9871A8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v50 == 11 && *AttrData == 0x746163732E73706DLL && *(void *)((char *)AttrData + 3) == 0x726574746163732ELL)
    {
      __int16 v57 = 1283;
      v56[0] = (uint64_t)"classof on '";
      v56[2] = (uint64_t)"mps.scatter";
      v56[3] = 11;
      BOOL v54 = "' failed due to the operation not being registered";
      __int16 v55 = 259;
      llvm::operator+(v56, (uint64_t *)&v54, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_39:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ScatterOp,void>::id) {
    goto LABEL_39;
  }
  uint64_t v53 = a3;
  v56[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v56);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v59 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v59) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v59 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v52 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v53);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"data", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v53);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"updates", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v53);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"indices", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v53);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v53);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v53);
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v32 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"add" value:0];
  [v31 addObject:v32];

  uint64_t v33 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"subtract" value:1];
  [v31 addObject:v33];

  uint64_t v34 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"multiply" value:2];
  [v31 addObject:v34];

  uint64_t v35 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"divide" value:3];
  [v31 addObject:v35];

  BOOL v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"min" value:4];
  [v31 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"max" value:5];
  [v31 addObject:v37];

  __int16 v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"set" value:6];
  [v31 addObject:v38];

  __int16 v39 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"mode" type:@"MPSScatterMode" cases:v31 value:StorageType];
  if (v39) {
    [v29 addObject:v39];
  }

  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  __int16 v41 = [MPSGraphViewerNodeSPI alloc];
  __int16 v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int64_t v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v45 = [MEMORY[0x1E4F1C978] arrayWithArray:v40];
  uint64_t v46 = [(MPSGraphViewerNodeSPI *)v41 initWithType:v52 inputs:v42 outputs:v43 properties:v44 regions:v45];
  __int16 v47 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v46;

  if (SHIBYTE(v59) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E51440(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSelectOpHandler *EmitterViewerSPI::MPSSelectOpHandler::MPSSelectOpHandler(EmitterViewerSPI::MPSSelectOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986F98;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 10 && *(void *)AttrData == 0x656C65732E73706DLL && *(_WORD *)(AttrData + 8) == 29795)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.select";
      v45[3] = 10;
      int64_t v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SelectOp,void>::id) {
    goto LABEL_35;
  }
  __int16 v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"condition", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"true_value", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"false_value", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  size_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    int v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v41 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E51AAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSShapeOpHandler *EmitterViewerSPI::MPSShapeOpHandler::MPSShapeOpHandler(EmitterViewerSPI::MPSShapeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986D58;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x706168732E73706DLL && *(unsigned char *)(AttrData + 8) == 101)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.shape";
      v41[3] = 9;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::ShapeOp,void>::id) {
    goto LABEL_31;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  uint64_t v32 = [NSString stringWithUTF8String:"This op computes the shape if the input tensor and returns it as a 1-dimensional tensor."];
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E52054(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSigmoidGradientOpHandler *EmitterViewerSPI::MPSSigmoidGradientOpHandler::MPSSigmoidGradientOpHandler(EmitterViewerSPI::MPSSigmoidGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987FD0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 20)
    {
      BOOL v38 = *(void *)AttrData == 0x6D6769732E73706DLL && *(void *)(AttrData + 8) == 0x646172675F64696FLL;
      if (v38 && *(_DWORD *)(AttrData + 16) == 1953391977)
      {
        __int16 v45 = 1283;
        v44[0] = (uint64_t)"classof on '";
        uint64_t v44[2] = (uint64_t)"mps.sigmoid_gradient";
        v44[3] = 20;
        __int16 v42 = "' failed due to the operation not being registered";
        __int16 v43 = 259;
        llvm::operator+(v44, (uint64_t *)&v42, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientOp,void>::id) {
    goto LABEL_36;
  }
  __int16 v41 = a3;
  v44[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v44);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v47 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v47) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v47 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v40 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v41);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v41);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_gradient", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v41);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  int v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v40 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v47) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5261C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler *EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler::MPSSigmoidGradientWithSigmoidOpHandler(EmitterViewerSPI::MPSSigmoidGradientWithSigmoidOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988588;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 33)
    {
      BOOL v38 = *(void *)AttrData == 0x6D6769732E73706DLL && *(void *)(AttrData + 8) == 0x646172675F64696FLL;
      BOOL v39 = v38 && *(void *)(AttrData + 16) == 0x7469775F746E6569;
      BOOL v40 = v39 && *(void *)(AttrData + 24) == 0x696F6D6769735F68;
      if (v40 && *(unsigned char *)(AttrData + 32) == 100)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.sigmoid_gradient_with_sigmoid";
        v46[3] = 33;
        int64_t v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidGradientWithSigmoidOp,void>::id) {
    goto LABEL_42;
  }
  __int16 v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"dy", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"y", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unsigned int v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    size_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  int v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v42 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E52C24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSigmoidHardOpHandler *EmitterViewerSPI::MPSSigmoidHardOpHandler::MPSSigmoidHardOpHandler(EmitterViewerSPI::MPSSigmoidHardOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9878F8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 16 && *AttrData == 0x6D6769732E73706DLL && AttrData[1] == 0x647261685F64696FLL)
    {
      __int16 v46 = 1283;
      v45[0] = (uint64_t)"classof on '";
      v45[2] = (uint64_t)"mps.sigmoid_hard";
      v45[3] = 16;
      __int16 v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+(v45, (uint64_t *)&v43, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidHardOp,void>::id) {
    goto LABEL_35;
  }
  __int16 v42 = a3;
  v45[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v45);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v48 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v48) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v48 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v41 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v42);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"primary", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v42);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"secondary", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v42);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"tertiary", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unsigned int v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v42);
  size_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    int v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v41 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v48) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5322C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSigmoidOpHandler *EmitterViewerSPI::MPSSigmoidOpHandler::MPSSigmoidOpHandler(EmitterViewerSPI::MPSSigmoidOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9871C0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 11 && *AttrData == 0x6D6769732E73706DLL && *(void *)((char *)AttrData + 3) == 0x64696F6D6769732ELL)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.sigmoid";
      v41[3] = 11;
      uint64_t v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SigmoidOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E537E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSignOpHandler *EmitterViewerSPI::MPSSignOpHandler::MPSSignOpHandler(EmitterViewerSPI::MPSSignOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986A40;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x6E6769732E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.sign";
      v40[3] = 8;
      BOOL v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SignOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E53D4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSignbitOpHandler *EmitterViewerSPI::MPSSignbitOpHandler::MPSSignbitOpHandler(EmitterViewerSPI::MPSSignbitOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9871D8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 11 && *AttrData == 0x6E6769732E73706DLL && *(void *)((char *)AttrData + 3) == 0x7469626E6769732ELL)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.signbit";
      v41[3] = 11;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SignbitOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E542D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSinOpHandler *EmitterViewerSPI::MPSSinOpHandler::MPSSinOpHandler(EmitterViewerSPI::MPSSinOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986770;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1852404526)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.sin";
      v41[3] = 7;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SinOp,void>::id) {
    goto LABEL_31;
  }
  BOOL v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  size_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E54844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler *EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler::MPSSingleGateRNNGradientOpHandler(EmitterViewerSPI::MPSSingleGateRNNGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9884B0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v63 == 27)
    {
      BOOL v64 = *AttrData == 0x676E69732E73706DLL && AttrData[1] == 0x725F65746167656CLL;
      BOOL v65 = v64 && AttrData[2] == 0x69646172675F6E6ELL;
      if (v65 && *(void *)((char *)AttrData + 19) == 0x746E656964617267)
      {
        __int16 v73 = 1283;
        v72[0] = (uint64_t)"classof on '";
        void v72[2] = (uint64_t)"mps.singlegate_rnn_gradient";
        v72[3] = 27;
        BOOL v70 = "' failed due to the operation not being registered";
        __int16 v71 = 259;
        llvm::operator+(v72, (uint64_t *)&v70, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_57:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SingleGateRNNGradientOp,void>::id) {
    goto LABEL_57;
  }
  uint64_t v69 = a3;
  v72[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v72);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v75 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v75) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v75 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v67 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v69);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient_input_sequence", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t RecurrentWeight = mlir::mps::SingleGateRNNGradientOp::getRecurrentWeight((mlir::mps::SingleGateRNNGradientOp *)&v69);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"recurrent_weight", RecurrentWeight);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t TrainingState = mlir::mps::SingleGateRNNGradientOp::getTrainingState((mlir::mps::SingleGateRNNGradientOp *)&v69);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"training_state", TrainingState);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t InputState = mlir::mps::SingleGateRNNGradientOp::getInputState((mlir::mps::SingleGateRNNGradientOp *)&v69);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_state", InputState);
  if (v22) {
    [v14 addObject:v22];
  }

  unint64_t Mask = mlir::mps::SingleGateRNNGradientOp::getMask((mlir::mps::SingleGateRNNGradientOp *)&v69);
  uint64_t v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"mask", Mask);
  if (v24) {
    [v14 addObject:v24];
  }

  BOOL v68 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v69);
  int v26 = @"gradient_output_sequence";
  if (v25)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v25 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v25 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v29 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_output_sequence" dataType:MPSDataType shape:v28 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v25)];

    if (v29) {
      [v68 addObject:v29];
    }
  }
  else
  {

    uint64_t v29 = 0;
  }
  uint64_t Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v69);
  uint64_t v31 = @"gradient_recurrent_weight";
  if (Element)
  {
    uint64_t v32 = getMPSDataType((void *)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v33 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v34 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_recurrent_weight" dataType:v32 shape:v33 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, Element)];

    if (v34) {
      [v68 addObject:v34];
    }
  }
  else
  {

    uint64_t v34 = 0;
  }
  uint64_t v35 = mlir::mps::LSTMOp::getTrainingState((mlir::mps::LSTMOp *)&v69);
  BOOL v36 = @"gradient_input_state";
  if (v35)
  {
    uint64_t v37 = getMPSDataType((void *)(*(void *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8));
    BOOL v38 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8));
    __int16 v39 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"gradient_input_state" dataType:v37 shape:v38 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v35)];

    if (v39) {
      [v68 addObject:v39];
    }
  }
  else
  {

    __int16 v39 = 0;
  }

  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v69);
  __int16 v42 = [MEMORY[0x1E4F1CA48] array];
  int64_t v43 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v42 addObject:v43];

  int64_t v44 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v42 addObject:v44];

  __int16 v45 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v42 addObject:v45];

  __int16 v46 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v42 addObject:v46];

  __int16 v47 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v42 addObject:v47];

  int64_t v48 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v42 addObject:v48];

  int64_t v49 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"activation" type:@"MPSRNNActivation" cases:v42 value:StorageType];
  if (v49) {
    [v40 addObject:v49];
  }

  LOBYTE(v72[0]) = 0;
  LOBYTE(v72[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v69);
  uint64_t v50 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"gradient_for_input_state" dataType:2147483656 shape:&unk_1EC9F0E00];
  if (v50)
  {
    BOOL v51 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v72 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v50 setValue:v51];

    [v40 addObject:v50];
  }

  __int16 v52 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v53 = [MPSGraphViewerNodeSPI alloc];
  BOOL v54 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  __int16 v55 = [MEMORY[0x1E4F1C978] arrayWithArray:v68];
  __int16 v56 = [MEMORY[0x1E4F1C978] arrayWithArray:v40];
  __int16 v57 = [MEMORY[0x1E4F1C978] arrayWithArray:v52];
  uint64_t v58 = [(MPSGraphViewerNodeSPI *)v53 initWithType:v67 inputs:v54 outputs:v55 properties:v56 regions:v57];
  int64_t v59 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v58;
  int64_t v60 = ;
  [*((id *)this + 3) setLocalizedDescription:v60];

  if (SHIBYTE(v75) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E55270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSingleGateRNNOpHandler *EmitterViewerSPI::MPSSingleGateRNNOpHandler::MPSSingleGateRNNOpHandler(EmitterViewerSPI::MPSSingleGateRNNOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987C70;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v56 == 18)
    {
      BOOL v57 = *(void *)AttrData == 0x676E69732E73706DLL && *(void *)(AttrData + 8) == 0x725F65746167656CLL;
      if (v57 && *(_WORD *)(AttrData + 16) == 28270)
      {
        __int16 v65 = 1283;
        v64[0] = (uint64_t)"classof on '";
        void v64[2] = (uint64_t)"mps.singlegate_rnn";
        v64[3] = 18;
        __int16 v62 = "' failed due to the operation not being registered";
        __int16 v63 = 259;
        llvm::operator+(v64, (uint64_t *)&v62, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_48:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SingleGateRNNOp,void>::id) {
    goto LABEL_48;
  }
  uint64_t v61 = a3;
  v64[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v64);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v67 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v67) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v67 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v59 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v61);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_sequence", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t RecurrentWeight = mlir::mps::SingleGateRNNGradientOp::getRecurrentWeight((mlir::mps::SingleGateRNNGradientOp *)&v61);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"recurrent_weight", RecurrentWeight);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t InputState = mlir::mps::SingleGateRNNOp::getInputState((mlir::mps::SingleGateRNNOp *)&v61);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input_state", InputState);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t v21 = mlir::mps::SingleGateRNNGradientOp::getInputState((mlir::mps::SingleGateRNNGradientOp *)&v61);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"mask", v21);
  if (v22) {
    [v14 addObject:v22];
  }

  int64_t v60 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v23 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v61);
  uint64_t v24 = @"result";
  if (v23)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v26 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v26 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v23)];

    if (v27) {
      [v60 addObject:v27];
    }
  }
  else
  {

    uint64_t v27 = 0;
  }
  uint64_t TrainingState = mlir::mps::GRUOp::getTrainingState((mlir::mps::GRUOp *)&v61);
  uint64_t v29 = @"training_state";
  if (TrainingState)
  {
    uint64_t v30 = getMPSDataType((void *)(*(void *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v31 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(TrainingState + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v32 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"training_state" dataType:v30 shape:v31 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, TrainingState)];

    if (v32) {
      [v60 addObject:v32];
    }
  }
  else
  {

    uint64_t v32 = 0;
  }

  uint64_t v33 = [MEMORY[0x1E4F1CA48] array];
  unsigned int StorageType = mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v61);
  uint64_t v35 = [MEMORY[0x1E4F1CA48] array];
  BOOL v36 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"none" value:0];
  [v35 addObject:v36];

  uint64_t v37 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"relu" value:1];
  [v35 addObject:v37];

  BOOL v38 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"tanh" value:2];
  [v35 addObject:v38];

  __int16 v39 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sigmoid" value:3];
  [v35 addObject:v39];

  __int16 v40 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"hard_sigmoid" value:4];
  [v35 addObject:v40];

  __int16 v41 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"scaled_tanh" value:5];
  [v35 addObject:v41];

  __int16 v42 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"activation" type:@"MPSRNNActivation" cases:v35 value:StorageType];
  if (v42) {
    [v33 addObject:v42];
  }

  LOBYTE(v64[0]) = 0;
  LOBYTE(v64[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v61);
  int64_t v43 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"training" dataType:2147483656 shape:&unk_1EC9F0E18];
  if (v43)
  {
    int64_t v44 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v64 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v43 setValue:v44];

    [v33 addObject:v43];
  }

  __int16 v45 = [MEMORY[0x1E4F1CA48] array];
  __int16 v46 = [MPSGraphViewerNodeSPI alloc];
  __int16 v47 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int64_t v48 = [MEMORY[0x1E4F1C978] arrayWithArray:v60];
  int64_t v49 = [MEMORY[0x1E4F1C978] arrayWithArray:v33];
  uint64_t v50 = [MEMORY[0x1E4F1C978] arrayWithArray:v45];
  uint64_t v51 = [(MPSGraphViewerNodeSPI *)v46 initWithType:v59 inputs:v47 outputs:v48 properties:v49 regions:v50];
  __int16 v52 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v51;
  uint64_t v53 = ;
  [*((id *)this + 3) setLocalizedDescription:v53];

  if (SHIBYTE(v67) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E55C98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSinhOpHandler *EmitterViewerSPI::MPSSinhOpHandler::MPSSinhOpHandler(EmitterViewerSPI::MPSSinhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986A58;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x686E69732E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.sinh";
      v40[3] = 8;
      BOOL v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SinhOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E562E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSizeOpHandler *EmitterViewerSPI::MPSSizeOpHandler::MPSSizeOpHandler(EmitterViewerSPI::MPSSizeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986A70;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v34 == 8 && *AttrData == 0x657A69732E73706DLL)
    {
      __int16 v40 = 1283;
      v39[0] = (uint64_t)"classof on '";
      v39[2] = (uint64_t)"mps.size";
      v39[3] = 8;
      uint64_t v37 = "' failed due to the operation not being registered";
      __int16 v38 = 259;
      llvm::operator+(v39, (uint64_t *)&v37, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SizeOp,void>::id) {
    goto LABEL_27;
  }
  BOOL v36 = a3;
  v39[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v39);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v42 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v42) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v42 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v35 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v36);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v35 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;

  if (SHIBYTE(v42) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E56820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
  {
    operator delete(__p);

    _Unwind_Resume(a1);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSliceOpHandler *EmitterViewerSPI::MPSSliceOpHandler::MPSSliceOpHandler(EmitterViewerSPI::MPSSliceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986D70;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 9 && *(void *)AttrData == 0x63696C732E73706DLL && *(unsigned char *)(AttrData + 8) == 101)
    {
      __int16 v47 = 1283;
      v46[0] = (uint64_t)"classof on '";
      v46[2] = (uint64_t)"mps.slice";
      v46[3] = 9;
      int64_t v44 = "' failed due to the operation not being registered";
      __int16 v45 = 259;
      llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_37:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SliceOp,void>::id) {
    goto LABEL_37;
  }
  int64_t v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"start", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v43);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"length", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v24)];

    if (v24) {
      [v23 addObject:v24];
    }
  }
  else
  {
  }
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v35 = [(MPSGraphViewerNodeSPI *)v30 initWithType:v42 inputs:v31 outputs:v32 properties:v33 regions:v34];
  BOOL v36 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v35;
  uint64_t v37 = ;
  [*((id *)this + 3) setLocalizedDescription:v37];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E56E2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSoftmaxOpHandler *EmitterViewerSPI::MPSSoftmaxOpHandler::MPSSoftmaxOpHandler(EmitterViewerSPI::MPSSoftmaxOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9871F0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x74666F732E73706DLL && *(void *)((char *)AttrData + 3) == 0x78616D74666F732ELL)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.softmax";
      v43[3] = 11;
      __int16 v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SoftmaxOp,void>::id) {
    goto LABEL_33;
  }
  uint64_t v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  int v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E57420(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSoftplusOpHandler *EmitterViewerSPI::MPSSoftplusOpHandler::MPSSoftplusOpHandler(EmitterViewerSPI::MPSSoftplusOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987448;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(void *)AttrData == 0x74666F732E73706DLL && *(_DWORD *)(AttrData + 8) == 1937075312)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.softplus";
      v41[3] = 12;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SoftplusOp,void>::id) {
    goto LABEL_31;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E579B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSoftplusParametricOpHandler *EmitterViewerSPI::MPSSoftplusParametricOpHandler::MPSSoftplusParametricOpHandler(EmitterViewerSPI::MPSSoftplusParametricOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9882A0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v40 == 23)
    {
      BOOL v41 = *AttrData == 0x74666F732E73706DLL && AttrData[1] == 0x7261705F73756C70;
      if (v41 && *(void *)((char *)AttrData + 15) == 0x63697274656D6172)
      {
        __int16 v48 = 1283;
        v47[0] = (uint64_t)"classof on '";
        v47[2] = (uint64_t)"mps.softplus_parametric";
        v47[3] = 23;
        __int16 v45 = "' failed due to the operation not being registered";
        __int16 v46 = 259;
        llvm::operator+(v47, (uint64_t *)&v45, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_40:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SoftplusParametricOp,void>::id) {
    goto LABEL_40;
  }
  int64_t v44 = a3;
  v47[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v50 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v50) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v50 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v43 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v44);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v44);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"alpha", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v44);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"beta", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v44);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = (MPSGraphViewerNodePortSPI *)mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v44);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)&v24->_dataType & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, MPSGraphViewerNodePortSPI *))(*(void *)a2 + 32))(a2, v24)];

    if (v24) {
      [v23 addObject:v24];
    }
  }
  else
  {
  }
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v30 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v35 = [(MPSGraphViewerNodeSPI *)v30 initWithType:v43 inputs:v31 outputs:v32 properties:v33 regions:v34];
  BOOL v36 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v35;
  uint64_t v37 = ;
  [*((id *)this + 3) setLocalizedDescription:v37];

  if (SHIBYTE(v50) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E57FF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSoftsignOpHandler *EmitterViewerSPI::MPSSoftsignOpHandler::MPSSoftsignOpHandler(EmitterViewerSPI::MPSSoftsignOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987460;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 12 && *(void *)AttrData == 0x74666F732E73706DLL && *(_DWORD *)(AttrData + 8) == 1852270963)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.softsign";
      v41[3] = 12;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SoftsignOp,void>::id) {
    goto LABEL_31;
  }
  __int16 v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  int v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E585A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSortOpHandler *EmitterViewerSPI::MPSSortOpHandler::MPSSortOpHandler(EmitterViewerSPI::MPSSortOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986A88;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 8 && *AttrData == 0x74726F732E73706DLL)
    {
      __int16 v50 = 1283;
      v49[0] = (uint64_t)"classof on '";
      v49[2] = (uint64_t)"mps.sort";
      v49[3] = 8;
      __int16 v47 = "' failed due to the operation not being registered";
      __int16 v48 = 259;
      llvm::operator+(v49, (uint64_t *)&v47, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_35:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SortOp,void>::id) {
    goto LABEL_35;
  }
  __int16 v46 = a3;
  v49[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v52 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v52) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v52 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  int64_t v44 = [NSString stringWithCString:v13 encoding:4];
  __int16 v45 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v46);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v45 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v46);
  unint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v17) {
    [v45 addObject:v17];
  }

  uint64_t v18 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v19 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v46);
  uint64_t v20 = @"result";
  if (v19)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v23 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v22 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v19)];

    if (v23) {
      [v18 addObject:v23];
    }
  }
  else
  {

    uint64_t v23 = 0;
  }
  uint64_t Element = mlir::mpsx::ListPopBackOp::getElement((mlir::mpsx::ListPopBackOp *)&v46);
  uint64_t v25 = @"indices";
  if (Element)
  {
    uint64_t v26 = getMPSDataType((void *)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(Element + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"indices" dataType:v26 shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, Element)];

    if (v28) {
      [v18 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v49[0]) = 0;
  LOBYTE(v49[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v46);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"descending" dataType:2147483656 shape:&unk_1EC9F0E30];
  if (v30)
  {
    uint64_t v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v49 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v29 addObject:v30];
  }

  uint64_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v45];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v18];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v44 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;
  __int16 v40 = ;
  [*((id *)this + 3) setLocalizedDescription:v40];

  if (SHIBYTE(v52) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E58C98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSpaceToBatchOpHandler *EmitterViewerSPI::MPSSpaceToBatchOpHandler::MPSSpaceToBatchOpHandler(EmitterViewerSPI::MPSSpaceToBatchOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987A60;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v43 == 18)
    {
      BOOL v44 = *(void *)AttrData == 0x636170732E73706DLL && *(void *)(AttrData + 8) == 0x7461625F6F745F65;
      if (v44 && *(_WORD *)(AttrData + 16) == 26723)
      {
        __int16 v51 = 1283;
        v50[0] = (uint64_t)"classof on '";
        void v50[2] = (uint64_t)"mps.space_to_batch";
        v50[3] = 18;
        __int16 v48 = "' failed due to the operation not being registered";
        __int16 v49 = 259;
        llvm::operator+(v50, (uint64_t *)&v48, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_42:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SpaceToBatchOp,void>::id) {
    goto LABEL_42;
  }
  __int16 v47 = a3;
  v50[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v50);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v53 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v53) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v53 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v46 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v47);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v47);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"spatial_axes", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v47);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"batch_axis", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v47);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"block_dimensions", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v47);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v47);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"pixel_shuffle" dataType:2147483656 shape:&unk_1EC9F0E48];
  if (v30)
  {
    uint64_t v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v50 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v29 addObject:v30];
  }

  uint64_t v32 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v33 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v34 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v35 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v32];
  uint64_t v38 = [(MPSGraphViewerNodeSPI *)v33 initWithType:v46 inputs:v34 outputs:v35 properties:v36 regions:v37];
  __int16 v39 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v38;
  __int16 v40 = ;
  [*((id *)this + 3) setLocalizedDescription:v40];

  if (SHIBYTE(v53) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E593C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSpaceToDepth2DOpHandler *EmitterViewerSPI::MPSSpaceToDepth2DOpHandler::MPSSpaceToDepth2DOpHandler(EmitterViewerSPI::MPSSpaceToDepth2DOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987D90;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 21)
    {
      BOOL v46 = *AttrData == 0x636170732E73706DLL && AttrData[1] == 0x7065645F6F745F65;
      if (v46 && *(void *)((char *)AttrData + 13) == 0x64325F6874706564)
      {
        __int16 v53 = 1283;
        v52[0] = (uint64_t)"classof on '";
        v52[2] = (uint64_t)"mps.space_to_depth_2d";
        v52[3] = 21;
        v50[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v51 = 259;
        llvm::operator+(v52, v50, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_44:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SpaceToDepth2DOp,void>::id) {
    goto LABEL_44;
  }
  __int16 v49 = a3;
  v52[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v52);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v55 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v55) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v55 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v48 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v49);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v49);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"width_axis", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v49);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"height_axis", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v49);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"depth_axis", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  uint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v49);
  uint64_t v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  uint64_t v29 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v52[0]) = 0;
  LODWORD(v52[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v49);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"block_size" dataType:32 shape:&unk_1EC9F0E60];
  if (v30)
  {
    uint64_t v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v52 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v29 addObject:v30];
  }
  LOBYTE(v50[0]) = 0;
  LOBYTE(v50[0]) = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v49);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"pixel_shuffle" dataType:2147483656 shape:&unk_1EC9F0E78];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v50 length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v29 addObject:v32];
  }

  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v35 = [MPSGraphViewerNodeSPI alloc];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v48 inputs:v36 outputs:v37 properties:v38 regions:v39];
  BOOL v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;
  __int16 v42 = ;
  [*((id *)this + 3) setLocalizedDescription:v42];

  if (SHIBYTE(v55) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E59B58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSplitOpHandler *EmitterViewerSPI::MPSSplitOpHandler::MPSSplitOpHandler(EmitterViewerSPI::MPSSplitOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986D88;
  uint64_t v3 = *((void *)a3 + 6);
  uint64_t v4 = *(void **)(v3 + 16);
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v3 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v45 == 9 && *(void *)AttrData == 0x696C70732E73706DLL && *(unsigned char *)(AttrData + 8) == 116)
    {
      __int16 v55 = 1283;
      v54[0] = (uint64_t)"classof on '";
      void v54[2] = (uint64_t)"mps.split";
      v54[3] = 9;
      int64_t v52 = "' failed due to the operation not being registered";
      __int16 v53 = 259;
      llvm::operator+(v54, (uint64_t *)&v52, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_45:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v4 != &mlir::detail::TypeIDResolver<mlir::mps::SplitOp,void>::id) {
    goto LABEL_45;
  }
  __int16 v51 = a3;
  v54[0] = *(void *)(v3 + 8);
  uint8x8_t v6 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v54);
  size_t v7 = strlen(v6);
  if (v7 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  size_t v8 = (void *)v7;
  if (v7 >= 0x17)
  {
    uint64_t v10 = (v7 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v7 | 7) != 0x17) {
      uint64_t v10 = v7 | 7;
    }
    uint64_t v11 = v10 + 1;
    __int16 v9 = (void **)operator new(v10 + 1);
    __dst[1] = v8;
    int64_t v57 = v11 | 0x8000000000000000;
    __dst[0] = v9;
    goto LABEL_10;
  }
  HIBYTE(v57) = v7;
  __int16 v9 = __dst;
  if (v7) {
LABEL_10:
  }
    memmove(v9, v6, (size_t)v8);
  *((unsigned char *)v8 + (void)v9) = 0;
  if (v57 >= 0) {
    uint64_t v12 = __dst;
  }
  else {
    uint64_t v12 = (void **)__dst[0];
  }
  __int16 v47 = [NSString stringWithCString:v12 encoding:4];
  __int16 v49 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v51);
  unint64_t v14 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"x", Input);
  if (v14) {
    [v49 addObject:v14];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v51);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axis", Filter);
  if (v16) {
    [v49 addObject:v16];
  }
  unint64_t SplitSizes = mlir::mps::SplitOp::getSplitSizes((mlir::mps::SplitOp *)&v51);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"split_sizes", SplitSizes);
  if (v18) {
    [v49 addObject:v18];
  }

  __int16 v50 = [MEMORY[0x1E4F1CA48] array];
  uint64_t Results = mlir::pdl::ApplyNativeRewriteOp::getResults((mlir::pdl::ApplyNativeRewriteOp *)&v51);
  unint64_t v21 = v20;
  if (v20)
  {
    uint64_t v22 = Results;
    unint64_t v23 = 0;
    unsigned int v24 = 1;
    do
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v22, v23);
      objc_msgSend(NSString, "stringWithFormat:", @"results%d", v24 - 1);
      id v27 = (id)objc_claimAutoreleasedReturnValue();
      uint64_t v28 = v27;
      if (NextResultAtOffset)
      {
        uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v30 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v25 = [[MPSGraphViewerNodePortSPI alloc] initWithName:v28 dataType:MPSDataType shape:v30 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, NextResultAtOffset)];

        if (v25) {
          [v50 addObject:v25];
        }
      }
      else
      {
        uint64_t v25 = 0;
      }
      unint64_t v23 = v24++;
    }
    while (v21 > v23);
  }
  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  v54[0] = mlir::pdl::ResultsOp::getIndex((mlir::pdl::ResultsOp *)&v51);
  if ((v54[0] & 0xFF00000000) != 0)
  {
    uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"num_splits" dataType:32 shape:&unk_1EC9F0E90];
    if (v32)
    {
      if (!BYTE4(v54[0])) {
        std::__throw_bad_optional_access[abi:ne180100]();
      }
      uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v54 length:8];
      [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

      [v31 addObject:v32];
    }
  }
  uint64_t v34 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v35 = [MPSGraphViewerNodeSPI alloc];
  BOOL v36 = [MEMORY[0x1E4F1C978] arrayWithArray:v49];
  uint64_t v37 = [MEMORY[0x1E4F1C978] arrayWithArray:v50];
  uint64_t v38 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  __int16 v39 = [MEMORY[0x1E4F1C978] arrayWithArray:v34];
  uint64_t v40 = [(MPSGraphViewerNodeSPI *)v35 initWithType:v47 inputs:v36 outputs:v37 properties:v38 regions:v39];
  BOOL v41 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v40;
  __int16 v42 = ;
  [*((id *)this + 3) setLocalizedDescription:v42];

  if (SHIBYTE(v57) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5A2C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSquareOpHandler *EmitterViewerSPI::MPSSquareOpHandler::MPSSquareOpHandler(EmitterViewerSPI::MPSSquareOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986FB0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 10 && *(void *)AttrData == 0x617571732E73706DLL && *(_WORD *)(AttrData + 8) == 25970)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.square";
      v41[3] = 10;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SquareOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unsigned int v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  id v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5A8BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSquareRootOpHandler *EmitterViewerSPI::MPSSquareRootOpHandler::MPSSquareRootOpHandler(EmitterViewerSPI::MPSSquareRootOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9877D8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 15 && *AttrData == 0x617571732E73706DLL && *(void *)((char *)AttrData + 7) == 0x746F6F725F657261)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.square_root";
      v41[3] = 15;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SquareRootOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  unsigned int v24 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5AE40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSqueezeOpHandler *EmitterViewerSPI::MPSSqueezeOpHandler::MPSSqueezeOpHandler(EmitterViewerSPI::MPSSqueezeOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987208;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 11 && *AttrData == 0x657571732E73706DLL && *(void *)((char *)AttrData + 3) == 0x657A65657571732ELL)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.squeeze";
      v43[3] = 11;
      BOOL v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SqueezeOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Axes = mlir::mps::ReverseOp::getAxes((mlir::mps::ReverseOp *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"axes", Axes);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unsigned int v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    unsigned int v24 = 0;
  }

  uint64_t v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5B3FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSStencilOpHandler *EmitterViewerSPI::MPSStencilOpHandler::MPSStencilOpHandler(EmitterViewerSPI::MPSStencilOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  v114[3] = *MEMORY[0x1E4F143B8];
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987220;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v112 = *(void *)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v112);
    if (v99 == 11 && *AttrData == 0x6E6574732E73706DLL && *(void *)((char *)AttrData + 3) == 0x6C69636E6574732ELL)
    {
      __int16 v111 = 1283;
      __dst[0] = "classof on '";
      uint64_t v109 = "mps.stencil";
      uint64_t v110 = 11;
      __int16 v106 = "' failed due to the operation not being registered";
      __int16 v107 = 259;
      llvm::operator+((uint64_t *)__dst, (uint64_t *)&v106, (uint64_t)&v112);
      llvm::report_fatal_error((llvm::Twine *)&v112, 1);
    }
LABEL_92:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::StencilOp,void>::id) {
    goto LABEL_92;
  }
  __int16 v105 = a3;
  uint64_t v112 = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v112);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    uint64_t v109 = (const char *)(v12 | 0x8000000000000000);
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v109) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (SHIBYTE(v109) >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v102 = [NSString stringWithCString:v13 encoding:4];
  int64_t v104 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v105);
  uint64_t v15 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v15) {
    [v104 addObject:v15];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v105);
  unint64_t v17 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"weights", Filter);
  if (v17) {
    [v104 addObject:v17];
  }

  __int16 v103 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v105);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v103 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  Offsets = (uint64_t **)mlir::mps::StencilOp::getOffsets((mlir::mps::StencilOp *)&v105);
  if (v25)
  {
    uint64_t v26 = Offsets;
    if (Offsets)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Offsets))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26))
        {
          uint64_t InterfaceFor = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v26);
          if (!InterfaceFor)
          {
            uint64_t v28 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v29 = 98;
            uint64_t v30 = "InterfaceSupport.h";
            uint64_t v31 = "Interface";
            goto LABEL_80;
          }
          goto LABEL_29;
        }
        uint64_t v28 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v29 = 566;
        uint64_t v30 = "Casting.h";
        uint64_t v31 = "cast";
      }
      else
      {
        uint64_t v28 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v29 = 692;
        uint64_t v30 = "Casting.h";
        uint64_t v31 = "cast_if_present";
      }
LABEL_80:
      __assert_rtn(v31, v30, v29, v28);
    }
    uint64_t InterfaceFor = 0;
LABEL_29:
    uint64_t v32 = EmitViewerSPI::emitElementsAttrProperty(@"offsets", (uint64_t)v26, InterfaceFor);
    if (v32) {
      [v23 addObject:v32];
    }
  }
  Strides = (uint64_t **)mlir::mps::PoolMaxGradientOp::getStrides((mlir::mps::PoolMaxGradientOp *)&v105);
  uint64_t v34 = Strides;
  if (!Strides)
  {
    uint64_t v35 = 0;
    goto LABEL_38;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(Strides))
  {
    BOOL v36 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v37 = 692;
    uint64_t v38 = "Casting.h";
    __int16 v39 = "cast_if_present";
    goto LABEL_74;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34))
  {
    BOOL v36 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v37 = 566;
    uint64_t v38 = "Casting.h";
    __int16 v39 = "cast";
LABEL_74:
    __assert_rtn(v39, v38, v37, v36);
  }
  uint64_t v35 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v34);
  if (!v35)
  {
    BOOL v36 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v37 = 98;
    uint64_t v38 = "InterfaceSupport.h";
    __int16 v39 = "Interface";
    goto LABEL_74;
  }
LABEL_38:
  __int16 v101 = EmitViewerSPI::emitElementsAttrProperty(@"strides", (uint64_t)v34, v35);
  if (v101) {
    [v23 addObject:v101];
  }
  FastmathAttr = (uint64_t **)mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v105);
  BOOL v41 = FastmathAttr;
  if (!FastmathAttr)
  {
    uint64_t v42 = 0;
    goto LABEL_46;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(FastmathAttr))
  {
    uint64_t v43 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
    int v44 = 692;
    uint64_t v45 = "Casting.h";
    int64_t v46 = "cast_if_present";
    goto LABEL_77;
  }
  if (!mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41))
  {
    uint64_t v43 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
    int v44 = 566;
    uint64_t v45 = "Casting.h";
    int64_t v46 = "cast";
LABEL_77:
    __assert_rtn(v46, v45, v44, v43);
  }
  uint64_t v42 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v41);
  if (!v42)
  {
    uint64_t v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
    int v44 = 98;
    uint64_t v45 = "InterfaceSupport.h";
    int64_t v46 = "Interface";
    goto LABEL_77;
  }
LABEL_46:
  __int16 v47 = EmitViewerSPI::emitElementsAttrProperty(@"dilation_rates", (uint64_t)v41, v42);
  if (v47) {
    [v23 addObject:v47];
  }
  ExplicitPadding = (uint64_t **)mlir::mps::StencilOp::getExplicitPadding((mlir::mps::StencilOp *)&v105);
  if (v49)
  {
    __int16 v50 = ExplicitPadding;
    if (ExplicitPadding)
    {
      if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(ExplicitPadding))
      {
        if (mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v50))
        {
          uint64_t v51 = mlir::AttributeInterface<mlir::ElementsAttr,mlir::detail::ElementsAttrInterfaceTraits>::getInterfaceFor(v50);
          if (!v51)
          {
            int64_t v52 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
            int v53 = 98;
            BOOL v54 = "InterfaceSupport.h";
            __int16 v55 = "Interface";
            goto LABEL_83;
          }
          goto LABEL_55;
        }
        int64_t v52 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
        int v53 = 566;
        BOOL v54 = "Casting.h";
        __int16 v55 = "cast";
      }
      else
      {
        int64_t v52 = "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"";
        int v53 = 692;
        BOOL v54 = "Casting.h";
        __int16 v55 = "cast_if_present";
      }
LABEL_83:
      __assert_rtn(v55, v54, v53, v52);
    }
    uint64_t v51 = 0;
LABEL_55:
    uint64_t v56 = EmitViewerSPI::emitElementsAttrProperty(@"explicit_padding", (uint64_t)v50, v51);
    if (v56) {
      [v23 addObject:v56];
    }
  }
  mlir::mps::RandomNormalOp::getStdDev((mlir::mps::RandomNormalOp *)&v105, (uint64_t)&v112);
  int64_t v57 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"paddingConstant" dataType:268435488 shape:&unk_1EC9F0EA8];
  if (v57)
  {
    uint64_t v58 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&v112 length:32];
    [(MPSGraphViewerNodePropertyDataSPI *)v57 setValue:v58];

    [v23 addObject:v57];
  }
  unsigned int WeightsLayout = mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v105);
  int64_t v60 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v61 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"min" value:0];
  [v60 addObject:v61];

  __int16 v62 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"max" value:1];
  [v60 addObject:v62];

  __int16 v63 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"sum" value:2];
  [v60 addObject:v63];

  BOOL v64 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"product" value:3];
  [v60 addObject:v64];

  __int16 v65 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"argMin " value:4];
  [v60 addObject:v65];

  int64_t v66 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"argMax" value:5];
  [v60 addObject:v66];

  int64_t v67 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"reductionMode" type:@"MPSReductionMode" cases:v60 value:WeightsLayout];
  if (v67) {
    [v23 addObject:v67];
  }

  unsigned int PaddingStyle = mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v105);
  uint64_t v69 = [MEMORY[0x1E4F1CA48] array];
  BOOL v70 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"zero" value:4];
  [v69 addObject:v70];

  __int16 v71 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"constant" value:0];
  [v69 addObject:v71];

  BOOL v72 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"clampToEdge" value:3];
  [v69 addObject:v72];

  __int16 v73 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"mirror" value:1];
  [v69 addObject:v73];

  BOOL v74 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"mirrorWithEdge" value:2];
  [v69 addObject:v74];

  int64_t v75 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"periodic" value:5];
  [v69 addObject:v75];

  unsigned int v76 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"antiPeriodic" value:6];
  [v69 addObject:v76];

  __int16 v77 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"paddingMode" type:@"MPSStencilPaddingMode" cases:v69 value:PaddingStyle];
  if (v77) {
    [v23 addObject:v77];
  }

  unsigned int v78 = mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v105);
  __int16 v79 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v80 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT" value:0];
  [v79 addObject:v80];

  int64_t v81 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_VALID" value:1];
  [v79 addObject:v81];

  BOOL v82 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"TF_SAME" value:2];
  [v79 addObject:v82];

  __int16 v83 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"EXPLICIT_OFFSET" value:3];
  [v79 addObject:v83];

  unint64_t v84 = [[MPSGraphViewerNodePropertyEnumCaseSPI alloc] initWithName:@"ONNX_SAME_LOWER" value:4];
  [v79 addObject:v84];

  unsigned int v85 = [[MPSGraphViewerNodePropertyEnumSPI alloc] initWithName:@"padding_style" type:@"MPSPaddingStyle" cases:v79 value:v78];
  if (v85) {
    [v23 addObject:v85];
  }

  __int16 v86 = v113;
  if (llvm::APFloatBase::PPCDoubleDouble(v87) == v86) {
    std::unique_ptr<llvm::APFloat []>::reset[abi:ne180100]((llvm::APFloatBase *)v114);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v113);
  }

  __int16 v88 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v89 = [MPSGraphViewerNodeSPI alloc];
  int64_t v90 = [MEMORY[0x1E4F1C978] arrayWithArray:v104];
  __int16 v91 = [MEMORY[0x1E4F1C978] arrayWithArray:v103];
  uint64_t v92 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int64_t v93 = [MEMORY[0x1E4F1C978] arrayWithArray:v88];
  uint64_t v94 = [(MPSGraphViewerNodeSPI *)v89 initWithType:v102 inputs:v90 outputs:v91 properties:v92 regions:v93];
  BOOL v95 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v94;
  int64_t v96 = ;
  [*((id *)this + 3) setLocalizedDescription:v96];

  if (SHIBYTE(v109) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5C220(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24,uint64_t a25,uint64_t a26,char a27)
{
  if (a24 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSStridedSliceGradientOpHandler *EmitterViewerSPI::MPSStridedSliceGradientOpHandler::MPSStridedSliceGradientOpHandler(EmitterViewerSPI::MPSStridedSliceGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC988390;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v51 == 26)
    {
      BOOL v52 = *(void *)AttrData == 0x697274732E73706DLL && *(void *)(AttrData + 8) == 0x63696C735F646564;
      BOOL v53 = v52 && *(void *)(AttrData + 16) == 0x6569646172675F65;
      if (v53 && *(_WORD *)(AttrData + 24) == 29806)
      {
        __int16 v62 = 1283;
        v61[0] = (uint64_t)"classof on '";
        v61[2] = (uint64_t)"mps.strided_slice_gradient";
        v61[3] = 26;
        v59[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v60 = 259;
        llvm::operator+(v61, v59, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_53:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceGradientOp,void>::id) {
    goto LABEL_53;
  }
  uint64_t v58 = a3;
  v61[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v61);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v64 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v64) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v64 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v55 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v58);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"grad_input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v58);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"fwd_shape", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v58);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"begin", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v58);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"end", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }
  unint64_t Dense = mlir::mpsx::SparseDenseMatMulOp::getDense((mlir::mpsx::SparseDenseMatMulOp *)&v58);
  unsigned int v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"stride", Dense);
  if (v24) {
    [v14 addObject:v24];
  }

  char v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v58);
  uint64_t v27 = @"result";
  if (v26)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v29 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v30 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v29 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v26)];

    if (v30) {
      [v25 addObject:v30];
    }
  }
  else
  {

    uint64_t v30 = 0;
  }

  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v61[0]) = 0;
  LODWORD(v61[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v58);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"begin_mask" dataType:32 shape:&unk_1EC9F0EC0];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v61 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v31 addObject:v32];
  }
  LODWORD(v59[0]) = 0;
  LODWORD(v59[0]) = mlir::mps::ReadDataFromFileOp::getOffset((mlir::mps::ReadDataFromFileOp *)&v58);
  uint64_t v34 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"end_mask" dataType:32 shape:&unk_1EC9F0ED8];
  if (v34)
  {
    uint64_t v35 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v59 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v34 setValue:v35];

    [v31 addObject:v34];
  }
  unsigned int Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v58);
  BOOL v36 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"shrink_axis_mask" dataType:32 shape:&unk_1EC9F0EF0];
  if (v36)
  {
    int v37 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&Groups length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v36 setValue:v37];

    [v31 addObject:v36];
  }
  BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v58);
  uint64_t v38 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"end_is_size" dataType:2147483656 shape:&unk_1EC9F0F08];
  if (v38)
  {
    __int16 v39 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&IsSize length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v38 setValue:v39];

    [v31 addObject:v38];
  }

  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  BOOL v41 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  int v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  uint64_t v45 = [MEMORY[0x1E4F1C978] arrayWithArray:v40];
  uint64_t v46 = [(MPSGraphViewerNodeSPI *)v41 initWithType:v55 inputs:v42 outputs:v43 properties:v44 regions:v45];
  __int16 v47 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v46;
  __int16 v48 = ;
  [*((id *)this + 3) setLocalizedDescription:v48];

  if (SHIBYTE(v64) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5CC64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSStridedSliceOpHandler *EmitterViewerSPI::MPSStridedSliceOpHandler::MPSStridedSliceOpHandler(EmitterViewerSPI::MPSStridedSliceOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987A78;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v49 == 17)
    {
      BOOL v50 = *(void *)AttrData == 0x697274732E73706DLL && *(void *)(AttrData + 8) == 0x63696C735F646564;
      if (v50 && *(unsigned char *)(AttrData + 16) == 101)
      {
        __int16 v59 = 1283;
        v58[0] = (uint64_t)"classof on '";
        uint64_t v58[2] = (uint64_t)"mps.strided_slice";
        v58[3] = 17;
        v56[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v57 = 259;
        llvm::operator+(v58, v56, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_48:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceOp,void>::id) {
    goto LABEL_48;
  }
  __int16 v55 = a3;
  v58[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v58);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v61 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v61) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v61 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v52 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v55);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v55);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"begin", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v55);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"end", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v55);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"stride", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v55);
  char v25 = @"result";
  if (v24)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v27 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v24 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v28 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v27 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v24)];

    if (v28) {
      [v23 addObject:v28];
    }
  }
  else
  {

    uint64_t v28 = 0;
  }

  int v29 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v58[0]) = 0;
  LODWORD(v58[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v55);
  uint64_t v30 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"begin_mask" dataType:32 shape:&unk_1EC9F0F20];
  if (v30)
  {
    uint64_t v31 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v58 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v30 setValue:v31];

    [v29 addObject:v30];
  }
  LODWORD(v56[0]) = 0;
  LODWORD(v56[0]) = mlir::mps::ReadDataFromFileOp::getOffset((mlir::mps::ReadDataFromFileOp *)&v55);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"end_mask" dataType:32 shape:&unk_1EC9F0F38];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v56 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v29 addObject:v32];
  }
  unsigned int Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v55);
  uint64_t v34 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"shrink_axis_mask" dataType:32 shape:&unk_1EC9F0F50];
  if (v34)
  {
    uint64_t v35 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&Groups length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v34 setValue:v35];

    [v29 addObject:v34];
  }
  BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v55);
  BOOL v36 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"end_is_size" dataType:2147483656 shape:&unk_1EC9F0F68];
  if (v36)
  {
    int v37 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&IsSize length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v36 setValue:v37];

    [v29 addObject:v36];
  }

  uint64_t v38 = [MEMORY[0x1E4F1CA48] array];
  __int16 v39 = [MPSGraphViewerNodeSPI alloc];
  __int16 v40 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  BOOL v41 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v29];
  uint64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v38];
  uint64_t v44 = [(MPSGraphViewerNodeSPI *)v39 initWithType:v52 inputs:v40 outputs:v41 properties:v42 regions:v43];
  uint64_t v45 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v44;
  uint64_t v46 = ;
  [*((id *)this + 3) setLocalizedDescription:v46];

  if (SHIBYTE(v61) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5D554(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSStridedSliceUpdateOpHandler *EmitterViewerSPI::MPSStridedSliceUpdateOpHandler::MPSStridedSliceUpdateOpHandler(EmitterViewerSPI::MPSStridedSliceUpdateOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC9882B8;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v51 == 24)
    {
      BOOL v52 = *AttrData == 0x697274732E73706DLL && AttrData[1] == 0x63696C735F646564;
      if (v52 && AttrData[2] == 0x6574616470755F65)
      {
        __int16 v61 = 1283;
        v60[0] = (uint64_t)"classof on '";
        v60[2] = (uint64_t)"mps.strided_slice_update";
        v60[3] = 24;
        v58[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v59 = 259;
        llvm::operator+(v60, v58, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_50:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::StridedSliceUpdateOp,void>::id) {
    goto LABEL_50;
  }
  __int16 v57 = a3;
  v60[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v60);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v63 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v63) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v63 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v54 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v57);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"data", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v57);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"update", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v57);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"begin", Bias);
  if (v20) {
    [v14 addObject:v20];
  }
  unint64_t SparseShape = mlir::mpsx::SparseDenseMatMulOp::getSparseShape((mlir::mpsx::SparseDenseMatMulOp *)&v57);
  uint64_t v22 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"end", SparseShape);
  if (v22) {
    [v14 addObject:v22];
  }
  unint64_t Dense = mlir::mpsx::SparseDenseMatMulOp::getDense((mlir::mpsx::SparseDenseMatMulOp *)&v57);
  uint64_t v24 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"stride", Dense);
  if (v24) {
    [v14 addObject:v24];
  }

  char v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v57);
  uint64_t v27 = @"result";
  if (v26)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    int v29 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v30 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v29 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v26)];

    if (v30) {
      [v25 addObject:v30];
    }
  }
  else
  {

    uint64_t v30 = 0;
  }

  uint64_t v31 = [MEMORY[0x1E4F1CA48] array];
  LODWORD(v60[0]) = 0;
  LODWORD(v60[0]) = mlir::pdl::ResultOp::getIndex((mlir::pdl::ResultOp *)&v57);
  uint64_t v32 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"begin_mask" dataType:32 shape:&unk_1EC9F0F80];
  if (v32)
  {
    uint64_t v33 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v60 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v32 setValue:v33];

    [v31 addObject:v32];
  }
  LODWORD(v58[0]) = 0;
  LODWORD(v58[0]) = mlir::mps::ReadDataFromFileOp::getOffset((mlir::mps::ReadDataFromFileOp *)&v57);
  uint64_t v34 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"end_mask" dataType:32 shape:&unk_1EC9F0F98];
  if (v34)
  {
    uint64_t v35 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v58 length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v34 setValue:v35];

    [v31 addObject:v34];
  }
  unsigned int Groups = mlir::mps::Conv3DOp::getGroups((mlir::mps::Conv3DOp *)&v57);
  BOOL v36 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"shrink_axis_mask" dataType:32 shape:&unk_1EC9F0FB0];
  if (v36)
  {
    int v37 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&Groups length:4];
    [(MPSGraphViewerNodePropertyDataSPI *)v36 setValue:v37];

    [v31 addObject:v36];
  }
  BOOL IsSize = mlir::mps::StridedSliceOp::getEndIsSize((mlir::mps::StridedSliceOp *)&v57);
  uint64_t v38 = [[MPSGraphViewerNodePropertyDataSPI alloc] initWithName:@"end_is_size" dataType:2147483656 shape:&unk_1EC9F0FC8];
  if (v38)
  {
    __int16 v39 = [MEMORY[0x1E4F1C9B8] dataWithBytes:&IsSize length:1];
    [(MPSGraphViewerNodePropertyDataSPI *)v38 setValue:v39];

    [v31 addObject:v38];
  }

  __int16 v40 = [MEMORY[0x1E4F1CA48] array];
  BOOL v41 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v42 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v43 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v44 = [MEMORY[0x1E4F1C978] arrayWithArray:v31];
  uint64_t v45 = [MEMORY[0x1E4F1C978] arrayWithArray:v40];
  uint64_t v46 = [(MPSGraphViewerNodeSPI *)v41 initWithType:v54 inputs:v42 outputs:v43 properties:v44 regions:v45];
  __int16 v47 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v46;
  __int16 v48 = ;
  [*((id *)this + 3) setLocalizedDescription:v48];

  if (SHIBYTE(v63) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5DE74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSubtractOpHandler *EmitterViewerSPI::MPSSubtractOpHandler::MPSSubtractOpHandler(EmitterViewerSPI::MPSSubtractOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987478;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v37 == 12 && *(void *)AttrData == 0x746275732E73706DLL && *(_DWORD *)(AttrData + 8) == 1952670066)
    {
      __int16 v44 = 1283;
      v43[0] = (uint64_t)"classof on '";
      v43[2] = (uint64_t)"mps.subtract";
      v43[3] = 12;
      BOOL v41 = "' failed due to the operation not being registered";
      __int16 v42 = 259;
      llvm::operator+(v43, (uint64_t *)&v41, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_33:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SubtractOp,void>::id) {
    goto LABEL_33;
  }
  __int16 v40 = a3;
  v43[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v43);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v46 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v46) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v46 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v39 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v40);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"lhs", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v40);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"rhs", Filter);
  if (v18) {
    [v14 addObject:v18];
  }

  uint64_t v19 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v20 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v40);
  unint64_t v21 = @"result";
  if (v20)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v23 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v24 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v23 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v20)];

    if (v24) {
      [v19 addObject:v24];
    }
  }
  else
  {

    uint64_t v24 = 0;
  }

  char v25 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v26 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v27 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  int v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v19];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v25];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v26];
  uint64_t v32 = [(MPSGraphViewerNodeSPI *)v27 initWithType:v39 inputs:v28 outputs:v29 properties:v30 regions:v31];
  uint64_t v33 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v32;
  uint64_t v34 = ;
  [*((id *)this + 3) setLocalizedDescription:v34];

  if (SHIBYTE(v46) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5E50C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSSwishOpHandler *EmitterViewerSPI::MPSSwishOpHandler::MPSSwishOpHandler(EmitterViewerSPI::MPSSwishOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986DA0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 9 && *(void *)AttrData == 0x736977732E73706DLL && *(unsigned char *)(AttrData + 8) == 104)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.swish";
      v41[3] = 9;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SwishOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  char v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5EA9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTanOpHandler *EmitterViewerSPI::MPSTanOpHandler::MPSTanOpHandler(EmitterViewerSPI::MPSTanOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986788;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1851880494)
    {
      __int16 v42 = 1283;
      v41[0] = (uint64_t)"classof on '";
      v41[2] = (uint64_t)"mps.tan";
      v41[3] = 7;
      __int16 v39 = "' failed due to the operation not being registered";
      __int16 v40 = 259;
      llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_31:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TanOp,void>::id) {
    goto LABEL_31;
  }
  uint64_t v38 = a3;
  v41[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v41);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v44 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v44) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v44 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  uint64_t v37 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v38);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v38);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  char v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v37 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v44) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5F010(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTanhOpHandler *EmitterViewerSPI::MPSTanhOpHandler::MPSTanhOpHandler(EmitterViewerSPI::MPSTanhOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC986AA0;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v35 == 8 && *AttrData == 0x686E61742E73706DLL)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"mps.tanh";
      v40[3] = 8;
      uint64_t v38 = "' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, (uint64_t *)&v38, (uint64_t)__dst);
      llvm::report_fatal_error((llvm::Twine *)__dst, 1);
    }
LABEL_27:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TanhOp,void>::id) {
    goto LABEL_27;
  }
  uint64_t v37 = a3;
  v40[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v40);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v43 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v43) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v43 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  BOOL v36 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v37);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Input);
  if (v16) {
    [v14 addObject:v16];
  }

  unint64_t v17 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v18 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v37);
  uint64_t v19 = @"result";
  if (v18)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    unint64_t v21 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v22 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v21 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v18)];

    if (v22) {
      [v17 addObject:v22];
    }
  }
  else
  {

    uint64_t v22 = 0;
  }

  unint64_t v23 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v24 = [MEMORY[0x1E4F1CA48] array];
  char v25 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v26 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v27 = [MEMORY[0x1E4F1C978] arrayWithArray:v17];
  uint64_t v28 = [MEMORY[0x1E4F1C978] arrayWithArray:v23];
  int v29 = [MEMORY[0x1E4F1C978] arrayWithArray:v24];
  uint64_t v30 = [(MPSGraphViewerNodeSPI *)v25 initWithType:v36 inputs:v26 outputs:v27 properties:v28 regions:v29];
  uint64_t v31 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v30;
  uint64_t v32 = ;
  [*((id *)this + 3) setLocalizedDescription:v32];

  if (SHIBYTE(v43) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}

void sub_180E5F57C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

EmitterViewerSPI::MPSTileGradientOpHandler *EmitterViewerSPI::MPSTileGradientOpHandler::MPSTileGradientOpHandler(EmitterViewerSPI::MPSTileGradientOpHandler *this, EmitViewerSPI *a2, mlir::Operation *a3)
{
  *((void *)this + 1) = a2;
  *((void *)this + 2) = a3;
  *((void *)this + 3) = 0;
  *(void *)this = &unk_1EC987A90;
  uint64_t v4 = *((void *)a3 + 6);
  unint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    __dst[0] = *(void **)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)__dst);
    if (v39 == 17)
    {
      BOOL v40 = *(void *)AttrData == 0x656C69742E73706DLL && *(void *)(AttrData + 8) == 0x6E6569646172675FLL;
      if (v40 && *(unsigned char *)(AttrData + 16) == 116)
      {
        __int16 v47 = 1283;
        v46[0] = (uint64_t)"classof on '";
        v46[2] = (uint64_t)"mps.tile_gradient";
        v46[3] = 17;
        int64_t v44 = "' failed due to the operation not being registered";
        __int16 v45 = 259;
        llvm::operator+(v46, (uint64_t *)&v44, (uint64_t)__dst);
        llvm::report_fatal_error((llvm::Twine *)__dst, 1);
      }
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TileGradientOp,void>::id) {
    goto LABEL_38;
  }
  int64_t v43 = a3;
  v46[0] = *(void *)(v4 + 8);
  size_t v7 = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v46);
  size_t v8 = strlen(v7);
  if (v8 >= 0x7FFFFFFFFFFFFFF8) {
    std::string::__throw_length_error[abi:ne180100]();
  }
  __int16 v9 = (void *)v8;
  if (v8 >= 0x17)
  {
    uint64_t v11 = (v8 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v8 | 7) != 0x17) {
      uint64_t v11 = v8 | 7;
    }
    uint64_t v12 = v11 + 1;
    uint64_t v10 = (void **)operator new(v11 + 1);
    __dst[1] = v9;
    int64_t v49 = v12 | 0x8000000000000000;
    __dst[0] = v10;
    goto LABEL_10;
  }
  HIBYTE(v49) = v8;
  uint64_t v10 = __dst;
  if (v8) {
LABEL_10:
  }
    memmove(v10, v7, (size_t)v9);
  *((unsigned char *)v9 + (void)v10) = 0;
  if (v49 >= 0) {
    unint64_t v13 = __dst;
  }
  else {
    unint64_t v13 = (void **)__dst[0];
  }
  __int16 v42 = [NSString stringWithCString:v13 encoding:4];
  unint64_t v14 = [MEMORY[0x1E4F1CA48] array];
  unint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v43);
  uint64_t v16 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"gradient", Input);
  if (v16) {
    [v14 addObject:v16];
  }
  unint64_t Filter = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v43);
  uint64_t v18 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"input", Filter);
  if (v18) {
    [v14 addObject:v18];
  }
  unint64_t Bias = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v43);
  uint64_t v20 = EmitViewerSPI::emitNodeInputPort((uint64_t)a2, @"multiplier", Bias);
  if (v20) {
    [v14 addObject:v20];
  }

  unint64_t v21 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v22 = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v43);
  unint64_t v23 = @"result";
  if (v22)
  {
    uint64_t MPSDataType = getMPSDataType((void *)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    char v25 = getMPSShapeFromMLIR((uint64_t **)(*(void *)(v22 + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v26 = [[MPSGraphViewerNodePortSPI alloc] initWithName:@"result" dataType:MPSDataType shape:v25 valueRef:(*(uint64_t (**)(EmitViewerSPI *, uint64_t))(*(void *)a2 + 32))(a2, v22)];

    if (v26) {
      [v21 addObject:v26];
    }
  }
  else
  {

    uint64_t v26 = 0;
  }

  uint64_t v27 = [MEMORY[0x1E4F1CA48] array];
  uint64_t v28 = [MEMORY[0x1E4F1CA48] array];
  int v29 = [MPSGraphViewerNodeSPI alloc];
  uint64_t v30 = [MEMORY[0x1E4F1C978] arrayWithArray:v14];
  uint64_t v31 = [MEMORY[0x1E4F1C978] arrayWithArray:v21];
  uint64_t v32 = [MEMORY[0x1E4F1C978] arrayWithArray:v27];
  uint64_t v33 = [MEMORY[0x1E4F1C978] arrayWithArray:v28];
  uint64_t v34 = [(MPSGraphViewerNodeSPI *)v29 initWithType:v42 inputs:v30 outputs:v31 properties:v32 regions:v33];
  uint64_t v35 = (void *)*((void *)this + 3);
  *((void *)this + 3) = v34;
  BOOL v36 = ;
  [*((id *)this + 3) setLocalizedDescription:v36];

  if (SHIBYTE(v49) < 0) {
    operator delete(__dst[0]);
  }
  return this;
}