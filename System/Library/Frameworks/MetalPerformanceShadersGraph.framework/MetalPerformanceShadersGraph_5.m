uint64_t mlir::complex::ConstantOp::parse(uint64_t a1, uint64_t a2)
{
  mlir::NoneType **v4;
  mlir::MLIRContext *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void v13[3];
  uint64_t v14;
  uint64_t v15;

  v15 = 0;
  v4 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  v6 = mlir::NoneType::get(*v4, v5);
  if (!mlir::AsmParser::parseAttribute<mlir::ArrayAttr>(a1, &v15, v6)) {
    return 0;
  }
  if (v15)
  {
    v7 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>((void *)a2);
    *v7 = v15;
  }
  v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  v8 = *(void *)(a2 + 8);
  v13[0] = a1;
  v13[1] = &v14;
  v13[2] = a2;
  v9 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v8 + 96));
  if (v9)
  {
    if (!mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps1(v9, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v13))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v13[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v13)) {
    return 0;
  }
  v10 = v13[0];
  v11 = *(unsigned int *)(a2 + 72);
  if (v11 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v11) = v10;
  ++*(_DWORD *)(a2 + 72);
  return 1;
}

void mlir::complex::ConstantOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v21[4] = *MEMORY[0x1E4F143B8];
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  v5 = (unsigned char *)*((void *)v4 + 4);
  if ((unint64_t)v5 >= *((void *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((void *)v4 + 4) = v5 + 1;
    unsigned char *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 48))(a2, *((void *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8));
  v19 = v21;
  v21[0] = "value";
  v21[1] = 5;
  uint64_t v20 = 0x200000001;
  v6 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v6);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v6 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, void))(*(void *)a2 + 192))(a2, Value, v9, v19, v20);
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  v11 = (unsigned char *)*((void *)v10 + 4);
  if ((unint64_t)v11 >= *((void *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((void *)v10 + 4) = v11 + 1;
    unsigned char *v11 = 32;
  }
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  v13 = (unsigned char *)*((void *)v12 + 4);
  if (*((unsigned char **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ":", 1uLL);
  }
  else
  {
    unsigned char *v13 = 58;
    ++*((void *)v12 + 4);
  }
  v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  v15 = (unsigned char *)*((void *)v14 + 4);
  if ((unint64_t)v15 >= *((void *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((void *)v14 + 4) = v15 + 1;
    unsigned char *v15 = 32;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v16 = (uint64_t)*this - 16;
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(void *)a2 + 32))(a2, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v19 != v21) {
    free(v19);
  }
}

BOOL mlir::complex::CosOp::readProperties(uint64_t a1, void *a2)
{
  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::CosOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::CosOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::CosOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::CosOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[473];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::CosOp::parse(uint64_t a1, uint64_t a2)
{
  v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::CosOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::CreateOpGenericAdaptorBase::CreateOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "complex.create", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::complex::CreateOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps1(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::complex::__mlir_ods_local_type_constraint_ComplexOps1(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  uint64_t v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0; {
  uint64_t v4 = *this;
  }
  if ((*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(void *)(*(void *)((*this)[9] + 56)
                                                                                              + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    int v14 = *((_DWORD *)v4 + 9);
    v15 = v4 - 2;
    if (v14) {
      uint64_t v16 = (uint64_t)v15;
    }
    else {
      uint64_t v16 = 0;
    }
    v37[0] = *(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v37);
    v18 = *this;
    if (Value == (*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      int v25 = *((_DWORD *)v18 + 9);
      v26 = v18 - 2;
      if (v25) {
        uint64_t v27 = (uint64_t)v26;
      }
      else {
        uint64_t v27 = 0;
      }
      v37[0] = *(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
      if (mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v37) == (*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8)) {
        return 1;
      }
      v35[0] = (const void **)"failed to verify that complex element type matches imaginary operand type";
      __int16 v36 = 259;
      mlir::OpState::emitOpError(this, v35, (uint64_t)v37);
      uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v37);
      if (v37[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v37);
      }
      if (v44)
      {
        v28 = (void **)__p;
        if (__p)
        {
          v29 = v43;
          v30 = __p;
          if (v43 != __p)
          {
            do
              v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
            while (v29 != v28);
            v30 = __p;
          }
          v43 = v28;
          operator delete(v30);
        }
        uint64_t v9 = v40;
        if (!v40) {
          goto LABEL_61;
        }
        v31 = v41;
        uint64_t v11 = v40;
        if (v41 == v40) {
          goto LABEL_60;
        }
        do
        {
          v33 = (void *)*--v31;
          v32 = v33;
          void *v31 = 0;
          if (v33) {
            operator delete[](v32);
          }
        }
        while (v31 != v9);
        goto LABEL_59;
      }
    }
    else
    {
      v35[0] = (const void **)"failed to verify that complex element type matches real operand type";
      __int16 v36 = 259;
      mlir::OpState::emitOpError(this, v35, (uint64_t)v37);
      uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v37);
      if (v37[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v37);
      }
      if (v44)
      {
        v19 = (void **)__p;
        if (__p)
        {
          uint64_t v20 = v43;
          v21 = __p;
          if (v43 != __p)
          {
            do
              uint64_t v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
            while (v20 != v19);
            v21 = __p;
          }
          v43 = v19;
          operator delete(v21);
        }
        uint64_t v9 = v40;
        if (!v40) {
          goto LABEL_61;
        }
        v22 = v41;
        uint64_t v11 = v40;
        if (v41 == v40) {
          goto LABEL_60;
        }
        do
        {
          v24 = (void *)*--v22;
          v23 = v24;
          void *v22 = 0;
          if (v24) {
            operator delete[](v23);
          }
        }
        while (v22 != v9);
        goto LABEL_59;
      }
    }
  }
  else
  {
    v35[0] = (const void **)"failed to verify that all of {real, imaginary} have same type";
    __int16 v36 = 259;
    mlir::OpState::emitOpError(this, v35, (uint64_t)v37);
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v37);
    if (v37[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v37);
    }
    if (v44)
    {
      unint64_t v6 = (void **)__p;
      if (__p)
      {
        uint64_t v7 = v43;
        uint64_t v8 = __p;
        if (v43 != __p)
        {
          do
            uint64_t v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          uint64_t v8 = __p;
        }
        v43 = v6;
        operator delete(v8);
      }
      uint64_t v9 = v40;
      if (!v40) {
        goto LABEL_61;
      }
      uint64_t v10 = v41;
      uint64_t v11 = v40;
      if (v41 == v40)
      {
LABEL_60:
        v41 = v9;
        operator delete(v11);
LABEL_61:
        if (v38 != &v39) {
          free(v38);
        }
        return v5;
      }
      do
      {
        v13 = (void *)*--v10;
        uint64_t v12 = v13;
        void *v10 = 0;
        if (v13) {
          operator delete[](v12);
        }
      }
      while (v10 != v9);
LABEL_59:
      uint64_t v11 = v40;
      goto LABEL_60;
    }
  }
  return v5;
}

BOOL mlir::complex::CreateOp::parse(uint64_t a1, uint64_t a2)
{
  v18[4] = *MEMORY[0x1E4F143B8];
  memset(v18, 0, 24);
  memset(v17, 0, 24);
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v18, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v15[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v15)) {
    return 0;
  }
  uint64_t __src = v15[0];
  uint64_t v14 = v15[0];
  if (*(_UNKNOWN **)(*(void *)v15[0] + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    uint64_t v8 = *(void **)(*(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v15) + 136);
    if (v8 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
      || v8 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
    {
      mlir::OperationState::addTypes(a2, &__src, 1);
      v15[0] = __src;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v15);
      uint64_t v10 = a2 + 16;
      if ((*(unsigned __int8 (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)a1 + 696))(a1, v18, Value, v10))
      {
        v15[0] = __src;
        uint64_t v11 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v15);
        return (*(unsigned __int8 (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)a1 + 696))(a1, v17, v11, v10) != 0;
      }
      return 0;
    }
  }
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  v13[16] = 257;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t, _WORD *))(*(void *)a1 + 24))(v15, a1, v4, v13);
  uint64_t v5 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v15, "'complex' must be complex type with floating-point elements, but got ");
  uint64_t v6 = mlir::InFlightDiagnostic::append<mlir::Type &>(v5, &v14);
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v6);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v15);
  return v7;
}

BOOL mlir::complex::DivOp::readProperties(uint64_t a1, void *a2)
{
  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::DivOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::DivOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::DivOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::DivOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[475];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::DivOp::parse(uint64_t a1, void *a2)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  uint64_t v10 = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v13, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v12, 1)) {
    return 0;
  }
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0; {
    if (v10)
    }
    {
      uint64_t v4 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(a2);
      void *v4 = v10;
    }
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, void *))(*(void *)a1 + 456))(a1, a2 + 14))
  {
    uint64_t v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    uint64_t v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(void **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::DivOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1))
      {
        uint64_t v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          unint64_t v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, void *, void, void *))(*(void *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, void *, void, void *))(*(void *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::complex::EqualOp::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v12 = *(_DWORD *)(a11 + 8);
  if (v12 != 1)
  {
    if (!v12)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        unsigned int v13 = 0;
LABEL_6:
        bzero((void *)(*(void *)a11 + 8 * v13), 8 - 8 * v13);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      unsigned int v13 = *(_DWORD *)(a11 + 8);
      if (v13 != 1) {
        goto LABEL_6;
      }
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  uint64_t v15 = a1;
  **(void **)a11 = mlir::Builder::getIntegerType((mlir::Builder *)&v15, 1u);
  return 1;
}

uint64_t mlir::complex::EqualOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::complex::__mlir_ods_local_type_constraint_ComplexOps0(*this, *(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  uint64_t v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3(*this, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0; {
  if ((*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(void *)(*(void *)((*this)[9] + 56)
  }
                                                                                              + 8) & 0xFFFFFFFFFFFFFFF8))
    return 1;
  unint64_t v14 = (const void **)"failed to verify that all of {lhs, rhs} have same type";
  __int16 v15 = 259;
  mlir::OpState::emitOpError(this, &v14, (uint64_t)v16);
  uint64_t v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v16);
  if (v16[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v16);
  }
  if (v23)
  {
    uint64_t v5 = (void **)__p;
    if (__p)
    {
      uint64_t v6 = v22;
      unint64_t v7 = __p;
      if (v22 != __p)
      {
        do
          uint64_t v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        unint64_t v7 = __p;
      }
      v22 = v5;
      operator delete(v7);
    }
    uint64_t v8 = v19;
    if (v19)
    {
      uint64_t v9 = v20;
      uint64_t v10 = v19;
      if (v20 != v19)
      {
        do
        {
          int v12 = (void *)*--v9;
          unint64_t v11 = v12;
          *uint64_t v9 = 0;
          if (v12) {
            operator delete[](v11);
          }
        }
        while (v9 != v8);
        uint64_t v10 = v19;
      }
      uint64_t v20 = v8;
      operator delete(v10);
    }
    if (v17 != &v18) {
      free(v17);
    }
  }
  return v4;
}

uint64_t mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  uint64_t v49 = a2;
  uint64_t v9 = 1;
  if (!mlir::Type::isSignlessInteger((mlir::Type *)&v49, 1))
  {
    __int16 v48 = 261;
    v47[0] = a3;
    v47[1] = a4;
    mlir::Operation::emitOpError(a1, v47, (uint64_t)v53);
    if (v53[0])
    {
      int v50 = 3;
      v51 = " #";
      uint64_t v52 = 2;
      uint64_t v10 = &v50;
      unint64_t v11 = (char *)v54;
      if (v55 >= v56)
      {
        unint64_t v37 = v55 + 1;
        if (v54 <= &v50 && (char *)v54 + 24 * v55 > (char *)&v50)
        {
          int64_t v43 = (char *)&v50 - (unsigned char *)v54;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v37, 24);
          unint64_t v11 = (char *)v54;
          uint64_t v10 = (int *)((char *)v54 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v37, 24);
          uint64_t v10 = &v50;
          unint64_t v11 = (char *)v54;
        }
      }
      int v12 = &v11[24 * v55];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)int v12 = v13;
      uint64_t v14 = ++v55;
      if (v53[0])
      {
        int v50 = 5;
        v51 = (const char *)a5;
        __int16 v15 = &v50;
        uint64_t v16 = (char *)v54;
        if (v14 >= v56)
        {
          unint64_t v38 = v14 + 1;
          BOOL v39 = (char *)v54 + 24 * v14 > (char *)&v50;
          if (v54 <= &v50 && v39)
          {
            int64_t v44 = (char *)&v50 - (unsigned char *)v54;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v38, 24);
            uint64_t v16 = (char *)v54;
            __int16 v15 = (int *)((char *)v54 + v44);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v38, 24);
            __int16 v15 = &v50;
            uint64_t v16 = (char *)v54;
          }
        }
        v17 = &v16[24 * v55];
        long long v18 = *(_OWORD *)v15;
        *((void *)v17 + 2) = *((void *)v15 + 2);
        *(_OWORD *)v17 = v18;
        uint64_t v19 = ++v55;
        if (v53[0])
        {
          int v50 = 3;
          v51 = " must be 1-bit signless integer, but got ";
          uint64_t v52 = 41;
          uint64_t v20 = &v50;
          v21 = (char *)v54;
          if (v19 >= v56)
          {
            unint64_t v40 = v19 + 1;
            BOOL v41 = (char *)v54 + 24 * v19 > (char *)&v50;
            if (v54 <= &v50 && v41)
            {
              int64_t v45 = (char *)&v50 - (unsigned char *)v54;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v40, 24);
              v21 = (char *)v54;
              uint64_t v20 = (int *)((char *)v54 + v45);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v40, 24);
              uint64_t v20 = &v50;
              v21 = (char *)v54;
            }
          }
          v22 = &v21[24 * v55];
          long long v23 = *(_OWORD *)v20;
          *((void *)v22 + 2) = *((void *)v20 + 2);
          *(_OWORD *)v22 = v23;
          ++v55;
          if (v53[0])
          {
            uint64_t v24 = &v50;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v50, v49);
            int v25 = (char *)v54;
            if (v55 >= v56)
            {
              unint64_t v42 = v55 + 1;
              if (v54 <= &v50 && (char *)v54 + 24 * v55 > (char *)&v50)
              {
                int64_t v46 = (char *)&v50 - (unsigned char *)v54;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v42, 24);
                int v25 = (char *)v54;
                uint64_t v24 = (int *)((char *)v54 + v46);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v57, v42, 24);
                uint64_t v24 = &v50;
                int v25 = (char *)v54;
              }
            }
            v26 = &v25[24 * v55];
            long long v27 = *(_OWORD *)v24;
            *((void *)v26 + 2) = *((void *)v24 + 2);
            *(_OWORD *)v26 = v27;
            ++v55;
          }
        }
      }
    }
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v53);
    if (v53[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v53);
    }
    if (v62)
    {
      v28 = (void **)__p;
      if (__p)
      {
        v29 = v61;
        v30 = __p;
        if (v61 != __p)
        {
          do
            v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          v30 = __p;
        }
        v61 = v28;
        operator delete(v30);
      }
      v31 = v58;
      if (v58)
      {
        v32 = v59;
        v33 = v58;
        if (v59 != v58)
        {
          do
          {
            v35 = (void *)*--v32;
            v34 = v35;
            void *v32 = 0;
            if (v35) {
              operator delete[](v34);
            }
          }
          while (v32 != v31);
          v33 = v58;
        }
        v59 = v31;
        operator delete(v33);
      }
      if (v54 != v57) {
        free(v54);
      }
    }
  }
  return v9;
}

BOOL mlir::complex::EqualOp::parse(uint64_t a1, uint64_t a2)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  memset(v13, 0, 24);
  v10[0] = (uint64_t)v13;
  v10[1] = 1;
  memset(v12, 0, 24);
  uint64_t v11 = 0;
  v9[0] = &v11;
  v9[1] = 1;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v13, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v12, 1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)
    && (*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)
    && (uint64_t __src = 0, mlir::AsmParser::parseType<mlir::ComplexType>(a1, &__src))
    && (uint64_t v11 = __src,
        uint64_t v5 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1),
        uint64_t __src = mlir::Builder::getIntegerType(v5, 1u),
        mlir::OperationState::addTypes(a2, &__src, 1),
        uint64_t v6 = a2 + 16,
        mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v10, v9, v4, v6)))
  {
    return (*(unsigned __int8 (**)(uint64_t, void *, void, uint64_t))(*(void *)a1 + 696))(a1, v12, *(void *)v9[0], v6) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::complex::detail::ExpOpGenericAdaptorBase::ExpOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  uint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "complex.exp", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::ExpOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::ExpOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[477];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::ExpOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ExpOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::Expm1Op::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties]";
        unint64_t v14 = 110;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[479];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::Expm1Op::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Expm1Op::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::ImOpGenericAdaptorBase::ImOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "complex.im", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::ImOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::ImOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 107;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::ImOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[481];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::ImOp::parse(uint64_t a1, void *a2)
{
  v22[4] = *MEMORY[0x1E4F143B8];
  memset(v22, 0, 24);
  v19[0] = (uint64_t)v22;
  v19[1] = 1;
  v17[1] = 1;
  uint64_t v18 = 0;
  uint64_t v21 = 0;
  v17[0] = &v21;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v22, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v18, 0))return 0; {
  if (v18)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(a2);
    void *v5 = v18;
  }
LABEL_6:
  v14[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *))(*(void *)a1 + 456))(a1, a2 + 14)) {
    return 0;
  }
  uint64_t v6 = a2[1];
  __src[0] = a1;
  __src[1] = v14;
  __src[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ImOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, __src)) {
    return 0;
  }
  uint64_t v21 = __src[0];
  uint64_t v16 = __src[0];
  if (*(_UNKNOWN **)(*(void *)__src[0] + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
    && ((long long v13 = *(void **)(*(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)__src) + 136),
         v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id))
  {
    v14[0] = v21;
    __src[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v14);
    mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
    return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v17, v4, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    __int16 v15 = 257;
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t, void *))(*(void *)a1 + 24))(__src, a1, v8, v14);
    uint64_t v9 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)__src, "'complex' must be complex type with floating-point elements, but got ");
    uint64_t v10 = mlir::InFlightDiagnostic::append<mlir::Type &>(v9, &v16);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v10);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)__src);
  }
  return v11;
}

BOOL mlir::complex::Log1pOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 110;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[483];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::Log1pOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Log1pOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::LogOpGenericAdaptorBase::LogOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "complex.log", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::LogOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::LogOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::LogOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::LogOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::LogOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[485];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::LogOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::LogOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::MulOpGenericAdaptorBase::MulOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "complex.mul", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::MulOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::MulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::MulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::MulOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::MulOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[487];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::MulOp::parse(uint64_t a1, void *a2)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  uint64_t v10 = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v13, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v12, 1)) {
    return 0;
  }
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0; {
    if (v10)
    }
    {
      unint64_t v4 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(a2);
      void *v4 = v10;
    }
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, void *))(*(void *)a1 + 456))(a1, a2 + 14))
  {
    uint64_t v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    uint64_t v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(void **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::MulOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1))
      {
        uint64_t v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          unint64_t v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, void *, void, void *))(*(void *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, void *, void, void *))(*(void *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::complex::detail::NegOpGenericAdaptorBase::NegOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  uint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "complex.neg", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::NegOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::NegOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::NegOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[489];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::NegOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::NegOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::NotEqualOp::parse(uint64_t a1, uint64_t a2)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  memset(v13, 0, 24);
  v10[0] = (uint64_t)v13;
  v10[1] = 1;
  memset(v12, 0, 24);
  uint64_t v11 = 0;
  v9[0] = &v11;
  v9[1] = 1;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v13, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v12, 1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)
    && (*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)
    && (uint64_t __src = 0, mlir::AsmParser::parseType<mlir::ComplexType>(a1, &__src))
    && (uint64_t v11 = __src,
        int v5 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1),
        uint64_t __src = mlir::Builder::getIntegerType(v5, 1u),
        mlir::OperationState::addTypes(a2, &__src, 1),
        uint64_t v6 = a2 + 16,
        mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v10, v9, v4, v6)))
  {
    return (*(unsigned __int8 (**)(uint64_t, void *, void, uint64_t))(*(void *)a1 + 696))(a1, v12, *(void *)v9[0], v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::complex::PowOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::PowOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::PowOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[491];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::PowOp::parse(uint64_t a1, void *a2)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  uint64_t v10 = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v13, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v12, 1)) {
    return 0;
  }
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0; {
    if (v10)
    }
    {
      uint64_t v4 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(a2);
      void *v4 = v10;
    }
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, void *))(*(void *)a1 + 456))(a1, a2 + 14))
  {
    uint64_t v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    uint64_t v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(void **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::PowOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1))
      {
        uint64_t v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          unint64_t v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, void *, void, void *))(*(void *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, void *, void, void *))(*(void *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::complex::detail::ReOpGenericAdaptorBase::ReOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  uint64_t v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "complex.re", 10, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::ReOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::ReOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 107;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::ReOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[493];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::ReOp::parse(uint64_t a1, void *a2)
{
  v22[4] = *MEMORY[0x1E4F143B8];
  memset(v22, 0, 24);
  v19[0] = (uint64_t)v22;
  v19[1] = 1;
  v17[1] = 1;
  uint64_t v18 = 0;
  uint64_t v21 = 0;
  v17[0] = &v21;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v22, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v18, 0))return 0; {
  if (v18)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(a2);
    void *v5 = v18;
  }
LABEL_6:
  v14[0] = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *))(*(void *)a1 + 456))(a1, a2 + 14)) {
    return 0;
  }
  uint64_t v6 = a2[1];
  __src[0] = a1;
  __src[1] = v14;
  __src[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ReOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  __src[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, __src)) {
    return 0;
  }
  uint64_t v21 = __src[0];
  uint64_t v16 = __src[0];
  if (*(_UNKNOWN **)(*(void *)__src[0] + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
    && ((long long v13 = *(void **)(*(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)__src) + 136),
         v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id)
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id
     || v13 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id))
  {
    v14[0] = v21;
    __src[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v14);
    mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
    return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v17, v4, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
    uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    __int16 v15 = 257;
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t, void *))(*(void *)a1 + 24))(__src, a1, v8, v14);
    uint64_t v9 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)__src, "'complex' must be complex type with floating-point elements, but got ");
    uint64_t v10 = mlir::InFlightDiagnostic::append<mlir::Type &>(v9, &v16);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v10);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)__src);
  }
  return v11;
}

BOOL mlir::complex::RsqrtOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 110;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[495];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::RsqrtOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::RsqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::SignOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::SignOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 109;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::SignOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[497];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::SignOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SignOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::SinOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::SinOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::SinOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[499];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::SinOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SinOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::SqrtOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 109;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[501];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::SqrtOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

uint64_t mlir::complex::detail::SubOpGenericAdaptorBase::SubOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a2 + 56);
  unint64_t v4 = *(unsigned int *)(a2 + 44);
  int v5 = (void *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  unint64_t v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(unsigned char *)(a1 + 8) = 0;
  *(void *)a1 = v3;
  *(unsigned char *)(a1 + 16) = 0;
  *(void *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "complex.sub", 11, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::complex::SubOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::SubOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::SubOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[503];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::SubOp::parse(uint64_t a1, void *a2)
{
  v13[4] = *MEMORY[0x1E4F143B8];
  memset(v13, 0, 24);
  memset(v12, 0, 24);
  uint64_t v10 = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v13, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    return 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v12, 1)) {
    return 0;
  }
  if ((*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8))
  {
    if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v10, 0))return 0; {
    if (v10)
    }
    {
      unint64_t v4 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(a2);
      void *v4 = v10;
    }
  }
  uint64_t v9 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(uint64_t, void *))(*(void *)a1 + 456))(a1, a2 + 14))
  {
    uint64_t v5 = a2[1];
    __src[0] = a1;
    __src[1] = &v9;
    __src[2] = a2;
    uint64_t v6 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(void **)(v5 + 96));
    if (!v6
      || mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v6, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SubOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)__src))
    {
      if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1))
      {
        uint64_t v9 = 0;
        if (mlir::AsmParser::parseType<mlir::ComplexType>(a1, &v9))
        {
          __src[0] = v9;
          mlir::OperationState::addTypes((uint64_t)a2, __src, 1);
          unint64_t v7 = a2 + 2;
          if ((*(unsigned __int8 (**)(uint64_t, void *, void, void *))(*(void *)a1 + 696))(a1, v13, __src[0], v7))
          {
            return (*(unsigned __int8 (**)(uint64_t, void *, void, void *))(*(void *)a1 + 696))(a1, v12, __src[0], v7) != 0;
          }
        }
      }
    }
  }
  return 0;
}

BOOL mlir::complex::TanOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::TanOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 108;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::TanOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[505];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::TanOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

BOOL mlir::complex::TanhOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::arith::FastMathFlagsAttr>(a1, v3) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    {
      uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::complex::detail::TanhOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 109;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      }
    }
    a1[33] = v4[507];
    return a1[32];
  }
  return result;
}

BOOL mlir::complex::TanhOp::parse(uint64_t a1, uint64_t a2)
{
  void v17[4] = *MEMORY[0x1E4F143B8];
  memset(v17, 0, 24);
  v15[0] = (uint64_t)v17;
  v15[1] = 1;
  v13[1] = 1;
  uint64_t v14 = 0;
  uint64_t v16 = 0;
  v13[0] = &v16;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v17, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t, const char *, uint64_t))(*(void *)a1 + 376))(a1, "fastmath", 8)) {
    goto LABEL_6;
  }
  if (!mlir::AsmParser::parseCustomAttributeWithFallback<mlir::arith::FastMathFlagsAttr>(a1, &v14, 0))return 0; {
  if (v14)
  }
  {
    int v5 = (void *)mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>((void *)a2);
    void *v5 = v14;
  }
LABEL_6:
  uint64_t v12 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a2 + 8);
  v11[0] = a1;
  v11[1] = &v12;
  v11[2] = a2;
  uint64_t v7 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v6 + 96));
  if (v7)
  {
    if (!mlir::arith::__mlir_ods_local_attr_constraint_ArithOps0(v7, (const void **)"fastmath", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanhOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v11))return 0; {
  }
    }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  v11[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::ComplexType>(a1, v11)) {
    return 0;
  }
  uint64_t v8 = v11[0];
  uint64_t v16 = v11[0];
  uint64_t v9 = *(unsigned int *)(a2 + 72);
  if (v9 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
    uint64_t v8 = v16;
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v9) = v8;
  ++*(_DWORD *)(a2 + 72);
  return mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v15, v13, v4, a2 + 16) != 0;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::__mlir_ods_local_attr_constraint_ComplexOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void mlir::RewritePatternSet::addImpl<ArithBitcast,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = operator new(0x60uLL);
  uint64_t v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v26, 1);
  mlir::Pattern::Pattern((uint64_t)(v8 + 1), (uint64_t)"complex.bitcast", 15, (__int16)v26, v9, 0, 0);
  void *v8 = &unk_1EC995490;
  __p = v8;
  if (v8[9])
  {
    size_t v10 = 16 * a3;
    uint64_t v11 = *((unsigned int *)v8 + 22);
    unint64_t v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *((unsigned int *)v8 + 23)) {
      goto LABEL_3;
    }
  }
  else
  {
    v26 = "StringRef llvm::getTypeName() [DesiredTypeName = ArithBitcast]";
    unint64_t v27 = 62;
    unint64_t v18 = llvm::StringRef::find((uint64_t *)&v26, "DesiredTypeName = ", 0x12uLL, 0);
    if (v27 >= v18) {
      unint64_t v19 = v18;
    }
    else {
      unint64_t v19 = v27;
    }
    uint64_t v20 = &v26[v19];
    unint64_t v21 = v27 - v19;
    if (v27 - v19 >= 0x12) {
      uint64_t v22 = 18;
    }
    else {
      uint64_t v22 = v27 - v19;
    }
    long long v23 = &v20[v22];
    unint64_t v24 = v21 - v22;
    if (v24 >= v24 - 1) {
      --v24;
    }
    v8[8] = v23;
    v8[9] = v24;
    size_t v10 = 16 * a3;
    uint64_t v11 = *((unsigned int *)v8 + 22);
    unint64_t v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *((unsigned int *)v8 + 23))
    {
LABEL_3:
      if (!a3) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v8 + 10), v8 + 12, v12, 16);
  LODWORD(v11) = *((_DWORD *)v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *((_DWORD *)v8 + 22);
  }
LABEL_5:
  *((_DWORD *)v8 + 22) = v11 + (v10 >> 4);
  long long v13 = (void *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    uint64_t v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&__p);
    __int16 v15 = __p;
    a1[2] = v14;
    __p = 0;
    if (v15)
    {
      uint64_t v16 = (void *)v15[10];
      if (v16 != v15 + 12) {
        free(v16);
      }
      v17 = (void *)v15[4];
      if (v17 != v15 + 6) {
        free(v17);
      }
      operator delete(v15);
    }
  }
  else
  {
    void *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void mlir::RewritePatternSet::addImpl<MergeComplexBitcast,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = operator new(0x60uLL);
  uint64_t v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v26, 1);
  mlir::Pattern::Pattern((uint64_t)(v8 + 1), (uint64_t)"complex.bitcast", 15, (__int16)v26, v9, 0, 0);
  void *v8 = &unk_1EC995A88;
  __p = v8;
  if (v8[9])
  {
    size_t v10 = 16 * a3;
    uint64_t v11 = *((unsigned int *)v8 + 22);
    unint64_t v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *((unsigned int *)v8 + 23)) {
      goto LABEL_3;
    }
  }
  else
  {
    v26 = "StringRef llvm::getTypeName() [DesiredTypeName = MergeComplexBitcast]";
    unint64_t v27 = 69;
    unint64_t v18 = llvm::StringRef::find((uint64_t *)&v26, "DesiredTypeName = ", 0x12uLL, 0);
    if (v27 >= v18) {
      unint64_t v19 = v18;
    }
    else {
      unint64_t v19 = v27;
    }
    uint64_t v20 = &v26[v19];
    unint64_t v21 = v27 - v19;
    if (v27 - v19 >= 0x12) {
      uint64_t v22 = 18;
    }
    else {
      uint64_t v22 = v27 - v19;
    }
    long long v23 = &v20[v22];
    unint64_t v24 = v21 - v22;
    if (v24 >= v24 - 1) {
      --v24;
    }
    v8[8] = v23;
    v8[9] = v24;
    size_t v10 = 16 * a3;
    uint64_t v11 = *((unsigned int *)v8 + 22);
    unint64_t v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *((unsigned int *)v8 + 23))
    {
LABEL_3:
      if (!a3) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v8 + 10), v8 + 12, v12, 16);
  LODWORD(v11) = *((_DWORD *)v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *((_DWORD *)v8 + 22);
  }
LABEL_5:
  *((_DWORD *)v8 + 22) = v11 + (v10 >> 4);
  long long v13 = (void *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    uint64_t v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&__p);
    __int16 v15 = __p;
    a1[2] = v14;
    __p = 0;
    if (v15)
    {
      uint64_t v16 = (void *)v15[10];
      if (v16 != v15 + 12) {
        free(v16);
      }
      v17 = (void *)v15[4];
      if (v17 != v15 + 6) {
        free(v17);
      }
      operator delete(v15);
    }
  }
  else
  {
    void *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void mlir::RewritePatternSet::addImpl<MergeArithBitcast,mlir::MLIRContext *&>(void *a1, const void *a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v8 = operator new(0x60uLL);
  uint64_t v9 = *a4;
  mlir::PatternBenefit::PatternBenefit(&v26, 1);
  mlir::Pattern::Pattern((uint64_t)(v8 + 1), (uint64_t)"arith.bitcast", 13, (__int16)v26, v9, 0, 0);
  void *v8 = &unk_1EC9957E8;
  __p = v8;
  if (v8[9])
  {
    size_t v10 = 16 * a3;
    uint64_t v11 = *((unsigned int *)v8 + 22);
    unint64_t v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *((unsigned int *)v8 + 23)) {
      goto LABEL_3;
    }
  }
  else
  {
    v26 = "StringRef llvm::getTypeName() [DesiredTypeName = MergeArithBitcast]";
    unint64_t v27 = 67;
    unint64_t v18 = llvm::StringRef::find((uint64_t *)&v26, "DesiredTypeName = ", 0x12uLL, 0);
    if (v27 >= v18) {
      unint64_t v19 = v18;
    }
    else {
      unint64_t v19 = v27;
    }
    uint64_t v20 = &v26[v19];
    unint64_t v21 = v27 - v19;
    if (v27 - v19 >= 0x12) {
      uint64_t v22 = 18;
    }
    else {
      uint64_t v22 = v27 - v19;
    }
    long long v23 = &v20[v22];
    unint64_t v24 = v21 - v22;
    if (v24 >= v24 - 1) {
      --v24;
    }
    v8[8] = v23;
    v8[9] = v24;
    size_t v10 = 16 * a3;
    uint64_t v11 = *((unsigned int *)v8 + 22);
    unint64_t v12 = v11 + ((16 * a3) >> 4);
    if (v12 <= *((unsigned int *)v8 + 23))
    {
LABEL_3:
      if (!a3) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v8 + 10), v8 + 12, v12, 16);
  LODWORD(v11) = *((_DWORD *)v8 + 22);
  if (a3)
  {
LABEL_4:
    memcpy((void *)(v8[10] + 16 * v11), a2, v10);
    LODWORD(v11) = *((_DWORD *)v8 + 22);
  }
LABEL_5:
  *((_DWORD *)v8 + 22) = v11 + (v10 >> 4);
  long long v13 = (void *)a1[2];
  if ((unint64_t)v13 >= a1[3])
  {
    uint64_t v14 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&__p);
    __int16 v15 = __p;
    a1[2] = v14;
    __p = 0;
    if (v15)
    {
      uint64_t v16 = (void *)v15[10];
      if (v16 != v15 + 12) {
        free(v16);
      }
      v17 = (void *)v15[4];
      if (v17 != v15 + 6) {
        free(v17);
      }
      operator delete(v15);
    }
  }
  else
  {
    void *v13 = v8;
    a1[2] = v13 + 1;
  }
}

void ArithBitcast::~ArithBitcast(ArithBitcast *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::BitcastOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::BitcastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::BitcastOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t ArithBitcast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = *(void *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(void *)v3 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
    || *(_UNKNOWN **)(*(void *)(*(void *)(*(void *)(*(void *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
                    + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
  {
    return 0;
  }
  uint64_t v8 = *(void *)(*(void *)(a2 + 72) + 24);
  unint64_t v9 = v3;
  uint64_t v6 = mlir::OpBuilder::create<mlir::arith::BitcastOp,mlir::Type,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), (uint64_t *)&v9, &v8);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v6);
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::arith::BitcastOp,mlir::Type,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.bitcast", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"arith.bitcast";
    v17[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Broadcast::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::BitcastOp,void>::id) {
    unint64_t v12 = v11;
  }
  else {
    unint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void MergeComplexBitcast::~MergeComplexBitcast(MergeComplexBitcast *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t MergeComplexBitcast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v9 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  if (result
    && *(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id)
  {
    goto LABEL_7;
  }
  unint64_t v9 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  if (!result) {
    return result;
  }
  if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::BitcastOp,void>::id)
  {
LABEL_7:
    unint64_t v6 = *(void *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
    uint64_t v8 = *(void *)(*(void *)(result + 72) + 24);
    unint64_t v9 = v6;
    uint64_t v7 = mlir::OpBuilder::create<mlir::complex::BitcastOp,mlir::Type,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), (uint64_t *)&v9, &v8);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v7);
    return 1;
  }
  return 0;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::complex::BitcastOp,mlir::Type,mlir::Value>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v25[28] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"complex.bitcast", (const unsigned __int8 *)0xF, Context);
  if (!v10)
  {
    __int16 v20 = 1283;
    uint64_t v19[2] = (uint64_t)"complex.bitcast";
    v19[3] = 15;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  uint64_t v11 = *a3;
  v19[0] = *a4;
  mlir::OperationState::addOperands((uint64_t)v21, (uint64_t)v19, 1);
  unsigned int v12 = v23;
  if (v23 >= v24)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v25, v23 + 1, 8);
    unsigned int v12 = v23;
  }
  *(void *)(v22 + 8 * v12) = v11;
  ++v23;
  long long v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id) {
    uint64_t v14 = v13;
  }
  else {
    uint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

void MergeArithBitcast::~MergeArithBitcast(MergeArithBitcast *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::arith::BitcastOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::arith::BitcastOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::arith::BitcastOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t MergeArithBitcast::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v9 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v9);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id)
    {
      unint64_t v6 = *(void *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8;
      uint64_t v8 = *(void *)(*(void *)(result + 72) + 24);
      unint64_t v9 = v6;
      uint64_t v7 = mlir::OpBuilder::create<mlir::complex::BitcastOp,mlir::Type,mlir::Value>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), (uint64_t *)&v9, &v8);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v7);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *anonymous namespace'::FoldComponentNeg<mlir::complex::ImOp,1>::~FoldComponentNeg(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void anonymous namespace'::FoldComponentNeg<mlir::complex::ImOp,1>::~FoldComponentNeg(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ImOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ImOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ImOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t anonymous namespace'::FoldComponentNeg<mlir::complex::ImOp,1>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t v10 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::NegOp,void>::id)
    {
      uint64_t v10 = *(void *)(*(void *)(result + 72) + 24);
      uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (result)
      {
        uint64_t v6 = result;
        if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id)
        {
          unint64_t v9 = *(void *)(result - 8) & 0xFFFFFFFFFFFFFFF8;
          uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v9);
          unint64_t v9 = *(void *)(*(void *)(v6 + 72) + 56);
          uint64_t v10 = Value;
          uint64_t v8 = mlir::OpBuilder::create<mlir::arith::NegFOp,mlir::Type &,mlir::Value>(a3 + 1, *(void *)(a2 + 24), &v10, (uint64_t *)&v9);
          (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v8);
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::arith::NegFOp,mlir::Type &,mlir::Value>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.negf", (const unsigned __int8 *)0xA, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"arith.negf";
    v17[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::arith::NegFOp::build(a1, (uint64_t)v19, *a3, *a4, 0);
  uint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::NegFOp,void>::id) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void *anonymous namespace'::FoldComponentNeg<mlir::complex::ReOp,0>::~FoldComponentNeg(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void anonymous namespace'::FoldComponentNeg<mlir::complex::ReOp,0>::~FoldComponentNeg(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ReOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ReOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::complex::ReOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t anonymous namespace'::FoldComponentNeg<mlir::complex::ReOp,0>::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  uint64_t v10 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::NegOp,void>::id)
    {
      uint64_t v10 = *(void *)(*(void *)(result + 72) + 24);
      uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
      if (result)
      {
        uint64_t v6 = result;
        if (*(_UNKNOWN **)(*(void *)(result + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id)
        {
          unint64_t v9 = *(void *)(result - 8) & 0xFFFFFFFFFFFFFFF8;
          uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v9);
          unint64_t v9 = *(void *)(*(void *)(v6 + 72) + 24);
          uint64_t v10 = Value;
          uint64_t v8 = mlir::OpBuilder::create<mlir::arith::NegFOp,mlir::Type &,mlir::Value>(a3 + 1, *(void *)(a2 + 24), &v10, (uint64_t *)&v9);
          (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*a3 + 4))(a3, a2, v8);
          return 1;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AbsOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AbsOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    __int16 v4 = &v33;
    int v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        int v5 = (char *)v40;
        __int16 v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        __int16 v4 = &v33;
        int v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    unint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      unsigned int v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        unsigned int v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          v28 = (void *)*--v25;
          unint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

uint64_t mlir::AsmParser::parseType<mlir::ComplexType>(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v18 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 504))(a1, &v18)) {
    return 0;
  }
  uint64_t v5 = v18;
  if (*(_UNKNOWN **)(*(void *)v18 + 136) != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id) {
    uint64_t v5 = 0;
  }
  *a2 = v5;
  if (v5) {
    return 1;
  }
  __int16 v16 = "invalid kind of type specified";
  __int16 v17 = 259;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t, const char **))(*(void *)a1 + 24))(v19, a1, v4, &v16);
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  }
  if (v26)
  {
    uint64_t v8 = (void **)__p;
    if (__p)
    {
      unint64_t v9 = v25;
      uint64_t v10 = __p;
      if (v25 != __p)
      {
        do
          unint64_t v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        uint64_t v10 = __p;
      }
      int v25 = v8;
      operator delete(v10);
    }
    uint64_t v11 = v22;
    if (v22)
    {
      unsigned int v12 = v23;
      long long v13 = v22;
      if (v23 != v22)
      {
        do
        {
          unint64_t v15 = (void *)*--v12;
          long long v14 = v15;
          void *v12 = 0;
          if (v15) {
            operator delete[](v14);
          }
        }
        while (v12 != v11);
        long long v13 = v22;
      }
      unsigned int v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21) {
      free(v20);
    }
  }
  return v6;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AddOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      unsigned int v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        unsigned int v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::AngleOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::AngleOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      unsigned int v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        unsigned int v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Atan2OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Atan2Op::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      unsigned int v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        unsigned int v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConjOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ConjOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      unsigned int v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        unsigned int v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

uint64_t mlir::AsmParser::parseAttribute<mlir::ArrayAttr>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v20 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, uint64_t))(*(void *)a1 + 408))(a1, &v20, a3)) {
    return 0;
  }
  uint64_t v7 = v20;
  if (*(_UNKNOWN **)(*(void *)v20 + 136) != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id) {
    uint64_t v7 = 0;
  }
  *a2 = v7;
  if (v7) {
    return 1;
  }
  unsigned int v18 = "invalid kind of attribute specified";
  __int16 v19 = 259;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t, const char **))(*(void *)a1 + 24))(v21, a1, v6, &v18);
  uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
  if (v21[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
  }
  if (v28)
  {
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = v27;
      unsigned int v12 = __p;
      if (v27 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unsigned int v12 = __p;
      }
      uint64_t v27 = v10;
      operator delete(v12);
    }
    long long v13 = v24;
    if (v24)
    {
      long long v14 = v25;
      unint64_t v15 = v24;
      if (v25 != v24)
      {
        do
        {
          __int16 v17 = (void *)*--v14;
          __int16 v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        unint64_t v15 = v24;
      }
      int v25 = v13;
      operator delete(v15);
    }
    if (v22 != &v23) {
      free(v22);
    }
  }
  return v8;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::CosOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::CosOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::CosOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::CosOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::DivOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::DivOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::DivOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::DivOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ExpOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ExpOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Expm1OpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Expm1Op::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ImOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::Log1pOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::Log1pOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::LogOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::LogOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::LogOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::LogOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::MulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::MulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::MulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::MulOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::NegOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::NegOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::NegOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::PowOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::PowOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::PowOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::ReOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::ReOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::ReOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::RsqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::RsqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SignOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SignOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SignOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SinOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SinOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SinOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SqrtOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SqrtOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::SubOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::SubOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::SubOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::complex::detail::TanhOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::complex::TanhOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    v33 = AttrData;
    v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      unsigned int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          unsigned int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          unsigned int v12 = (char *)v40;
        }
      }
      long long v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)long long v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    __int16 v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unint64_t v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      __int16 v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    unsigned int v24 = v44[0];
    if (v44[0])
    {
      int v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *int v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

mlir::complex::ComplexDialect *mlir::complex::ComplexDialect::ComplexDialect(mlir::complex::ComplexDialect *this, mlir::MLIRContext *a2)
{
  unint64_t v3 = (void *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"complex", 7, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ComplexDialect,void>::id);
  void *v3 = &unk_1EC9CD9C0;
  uint64_t v4 = (uint64_t *)v3[4];
  if (!mlir::MLIRContext::isDialectLoading(v4, (uint64_t)"arith", 5))
  {
    uint64_t v6 = v4;
    mlir::MLIRContext::getOrLoadDialect(v4, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v6);
  }
  mlir::Dialect::addOperations<mlir::complex::AbsOp,mlir::complex::AddOp,mlir::complex::AngleOp,mlir::complex::Atan2Op,mlir::complex::BitcastOp,mlir::complex::ConjOp,mlir::complex::ConstantOp,mlir::complex::CosOp,mlir::complex::CreateOp,mlir::complex::DivOp,mlir::complex::EqualOp,mlir::complex::ExpOp,mlir::complex::Expm1Op,mlir::complex::ImOp,mlir::complex::Log1pOp,mlir::complex::LogOp,mlir::complex::MulOp,mlir::complex::NegOp,mlir::complex::NotEqualOp,mlir::complex::PowOp,mlir::complex::ReOp,mlir::complex::RsqrtOp,mlir::complex::SignOp,mlir::complex::SinOp,mlir::complex::SqrtOp,mlir::complex::SubOp,mlir::complex::TanOp,mlir::complex::TanhOp>((uint64_t)this);
  mlir::Dialect::addAttribute<mlir::complex::NumberAttr>((uint64_t)this);
  return this;
}

void mlir::complex::ComplexDialect::~ComplexDialect(llvm **this)
{
}

void sub_1803A5F1C(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::Dialect::addOperations<mlir::complex::AbsOp,mlir::complex::AddOp,mlir::complex::AngleOp,mlir::complex::Atan2Op,mlir::complex::BitcastOp,mlir::complex::ConjOp,mlir::complex::ConstantOp,mlir::complex::CosOp,mlir::complex::CreateOp,mlir::complex::DivOp,mlir::complex::EqualOp,mlir::complex::ExpOp,mlir::complex::Expm1Op,mlir::complex::ImOp,mlir::complex::Log1pOp,mlir::complex::LogOp,mlir::complex::MulOp,mlir::complex::NegOp,mlir::complex::NotEqualOp,mlir::complex::PowOp,mlir::complex::ReOp,mlir::complex::RsqrtOp,mlir::complex::SignOp,mlir::complex::SinOp,mlir::complex::SqrtOp,mlir::complex::SubOp,mlir::complex::TanOp,mlir::complex::TanhOp>(uint64_t a1)
{
  uint64_t v2 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AbsOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v3 = (uint64_t)v54;
  v54 = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AddOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v5 = (uint64_t)v54;
  v54 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  uint64_t v6 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::AngleOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v7 = (uint64_t)v54;
  v54 = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::Model(v8, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Atan2Op::getAttributeNames(void)::attrNames, 1);
  uint64_t v9 = (uint64_t)v54;
  v54 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  mlir::RegisteredOperationName::insert<mlir::complex::BitcastOp>(a1);
  uint64_t v10 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::Model(v10, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ConjOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v11 = (uint64_t)v54;
  v54 = 0;
  if (v11) {
    (*(void (**)(uint64_t))(*(void *)v11 + 8))(v11);
  }
  unsigned int v12 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::Model(v12, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ConstantOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v13 = (uint64_t)v54;
  v54 = 0;
  if (v13) {
    (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
  }
  long long v14 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::Model(v14, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::CosOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v15 = (uint64_t)v54;
  v54 = 0;
  if (v15) {
    (*(void (**)(uint64_t))(*(void *)v15 + 8))(v15);
  }
  mlir::RegisteredOperationName::insert<mlir::complex::CreateOp>(a1);
  __int16 v16 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::Model(v16, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::DivOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v17 = (uint64_t)v54;
  v54 = 0;
  if (v17) {
    (*(void (**)(uint64_t))(*(void *)v17 + 8))(v17);
  }
  unsigned int v18 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::Model(v18, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, 0, 0);
  uint64_t v19 = (uint64_t)v54;
  v54 = 0;
  if (v19) {
    (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
  }
  unint64_t v20 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::Model(v20, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ExpOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v21 = (uint64_t)v54;
  v54 = 0;
  if (v21) {
    (*(void (**)(uint64_t))(*(void *)v21 + 8))(v21);
  }
  uint64_t v22 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::Model(v22, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Expm1Op::getAttributeNames(void)::attrNames, 1);
  uint64_t v23 = (uint64_t)v54;
  v54 = 0;
  if (v23) {
    (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
  }
  unsigned int v24 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::Model(v24, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ImOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v25 = (uint64_t)v54;
  v54 = 0;
  if (v25) {
    (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
  }
  char v26 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::Model(v26, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::Log1pOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v27 = (uint64_t)v54;
  v54 = 0;
  if (v27) {
    (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
  }
  char v28 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::Model(v28, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::LogOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v29 = (uint64_t)v54;
  v54 = 0;
  if (v29) {
    (*(void (**)(uint64_t))(*(void *)v29 + 8))(v29);
  }
  unint64_t v30 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::Model(v30, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::MulOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v31 = (uint64_t)v54;
  v54 = 0;
  if (v31) {
    (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
  }
  int64_t v32 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::Model(v32, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::NegOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v33 = (uint64_t)v54;
  v54 = 0;
  if (v33) {
    (*(void (**)(uint64_t))(*(void *)v33 + 8))(v33);
  }
  v34 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::Model(v34, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, 0, 0);
  uint64_t v35 = (uint64_t)v54;
  v54 = 0;
  if (v35) {
    (*(void (**)(uint64_t))(*(void *)v35 + 8))(v35);
  }
  __int16 v36 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::Model(v36, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::PowOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v37 = (uint64_t)v54;
  v54 = 0;
  if (v37) {
    (*(void (**)(uint64_t))(*(void *)v37 + 8))(v37);
  }
  uint64_t v38 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::Model(v38, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::ReOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v39 = (uint64_t)v54;
  v54 = 0;
  if (v39) {
    (*(void (**)(uint64_t))(*(void *)v39 + 8))(v39);
  }
  unint64_t v40 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::Model(v40, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::RsqrtOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v41 = (uint64_t)v54;
  v54 = 0;
  if (v41) {
    (*(void (**)(uint64_t))(*(void *)v41 + 8))(v41);
  }
  unsigned int v42 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::Model(v42, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SignOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v43 = (uint64_t)v54;
  v54 = 0;
  if (v43) {
    (*(void (**)(uint64_t))(*(void *)v43 + 8))(v43);
  }
  int64_t v44 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::Model(v44, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SinOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v45 = (uint64_t)v54;
  v54 = 0;
  if (v45) {
    (*(void (**)(uint64_t))(*(void *)v45 + 8))(v45);
  }
  int64_t v46 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::Model(v46, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SqrtOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v47 = (uint64_t)v54;
  v54 = 0;
  if (v47) {
    (*(void (**)(uint64_t))(*(void *)v47 + 8))(v47);
  }
  unsigned __int8 v48 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::Model(v48, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::SubOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v49 = (uint64_t)v54;
  v54 = 0;
  if (v49) {
    (*(void (**)(uint64_t))(*(void *)v49 + 8))(v49);
  }
  int v50 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::Model(v50, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::TanOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v51 = (uint64_t)v54;
  v54 = 0;
  if (v51) {
    (*(void (**)(uint64_t))(*(void *)v51 + 8))(v51);
  }
  uint64_t v52 = operator new(0x70uLL);
  v54 = mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::Model(v52, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v54, (uint64_t)&mlir::complex::TanhOp::getAttributeNames(void)::attrNames, 1);
  uint64_t result = (uint64_t)v54;
  v54 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

mlir::GenericProgramPoint *mlir::complex::ComplexDialect::materializeConstant(uint64_t a1, mlir::OpBuilder *a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v11 = a4;
  if (!mlir::complex::ConstantOp::isBuildableWith((uint64_t)a3, a4)) {
    return mlir::arith::ConstantOp::materialize(a2, a3, a4, a5);
  }
  uint64_t v10 = a3;
  return mlir::OpBuilder::create<mlir::complex::ConstantOp,mlir::Type &,mlir::ArrayAttr>(a2, a5, &v11, (uint64_t *)&v10);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::complex::ConstantOp,mlir::Type &,mlir::ArrayAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"complex.constant", (const unsigned __int8 *)0x10, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    void v17[2] = (uint64_t)"complex.constant";
    v17[3] = 16;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::complex::ConstantOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id) {
    unsigned int v12 = v11;
  }
  else {
    unsigned int v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

llvm::APFloatBase *mlir::complex::NumberAttr::get(uint64_t a1, double a2, double a3)
{
  v22[3] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a1;
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v17);
  uint64_t v5 = llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v19, a2);
  uint64_t v6 = llvm::APFloatBase::IEEEdouble(v5);
  llvm::APFloat::Storage::Storage(v22, v19, v6);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
  char v15 = 0;
  FloatSemantics = mlir::FloatType::getFloatSemantics((llvm::APFloatBase *)&Value);
  llvm::APFloat::convert((uint64_t)v21, FloatSemantics, 1, &v15);
  llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v18, a3);
  llvm::APFloat::Storage::Storage(v20, v18, v6);
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
  uint64_t v8 = mlir::FloatType::getFloatSemantics((llvm::APFloatBase *)&Value);
  llvm::APFloat::convert((uint64_t)v19, v8, 1, &v15);
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  AttributeUniquer = (llvm::APFloatBase *)mlir::MLIRContext::getAttributeUniquer(Context);
  v18[0] = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  v18[1] = Context;
  uint64_t v11 = (llvm::APFloatBase *)mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRNS_7APFloatESE_RNS1_11ComplexTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESJ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSL_E_EEvlS5_, (uint64_t)v18, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v21, (uint64_t)v19, &v17);
  unsigned int v12 = (void *)v20[0];
  uint64_t v13 = llvm::APFloatBase::PPCDoubleDouble(v11);
  if (v13 == v12)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v13 != (void *)v22[0]) {
      goto LABEL_3;
    }
LABEL_6:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return v11;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v13 == (void *)v22[0]) {
    goto LABEL_6;
  }
LABEL_3:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return v11;
}

llvm::APFloatBase *mlir::complex::ComplexDialect::parseAttribute(uint64_t a1, uint64_t a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
  uint64_t v45 = a2;
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 40))(a2);
  BYTE2(v49) = 0;
  uint64_t v47 = 0;
  unsigned __int8 v48 = 0;
  uint64_t v46 = v5;
  LOBYTE(v49) = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a2 + 608))(a2, &v47))
  {
    LOWORD(v49) = 256;
    if (!BYTE2(v49)) {
      BYTE2(v49) = 1;
    }
    goto LABEL_15;
  }
  uint64_t v41 = (const void **)"number";
  unsigned int v42 = (const char *)6;
  if (BYTE2(v49)) {
    goto LABEL_15;
  }
  uint64_t v6 = (const char *)v48;
  if (!v48)
  {
    (*(void (**)(uint64_t, const void ***, uint64_t))(*(void *)v45 + 616))(v45, &v41, 1);
    if (!BYTE2(v49))
    {
      uint64_t v6 = (const char *)v48;
      goto LABEL_45;
    }
LABEL_15:
    uint64_t v6 = 0;
    uint64_t v9 = 0;
    uint64_t v8 = 0;
    if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult((uint64_t)&v45) > 0xFFu) {
      return v8;
    }
    goto LABEL_16;
  }
  if (v48 == (void *)6 && *(_DWORD *)v47 == 1651340654 && *(_WORD *)(v47 + 4) == 29285)
  {
    uint64_t v8 = mlir::complex::NumberAttr::parse(a2);
    uint64_t v6 = 0;
    uint64_t v9 = 0;
    LOBYTE(v49) = v8 != 0;
    *(_WORD *)((char *)&v49 + 1) = 257;
    if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult((uint64_t)&v45) > 0xFFu) {
      return v8;
    }
    goto LABEL_16;
  }
LABEL_45:
  uint64_t v8 = 0;
  uint64_t v9 = (const void **)v47;
  LOWORD(v49) = 0;
  BYTE2(v49) = 1;
  if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult((uint64_t)&v45) > 0xFFu) {
    return v8;
  }
LABEL_16:
  __int16 v40 = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, char *))(*(void *)a2 + 24))(&v45, a2, v4, v39);
  if (v45)
  {
    LODWORD(v41) = 3;
    uint64_t v43 = 19;
    char v10 = &v41;
    uint64_t v11 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v33 = v49 + 1;
      if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v33, 24);
        uint64_t v11 = (char *)v48;
        char v10 = (const void ***)((char *)v48 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v33, 24);
        char v10 = &v41;
        uint64_t v11 = (char *)v48;
      }
    }
    unsigned int v12 = &v11[24 * v49];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)unsigned int v12 = v13;
    ++v49;
    if (v45)
    {
      __int16 v44 = 261;
      uint64_t v41 = v9;
      unsigned int v42 = v6;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        uint64_t v43 = 14;
        uint64_t v14 = &v41;
        char v15 = (char *)v48;
        if (v49 >= v50)
        {
          unint64_t v34 = v49 + 1;
          if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
          {
            int64_t v37 = (char *)&v41 - (unsigned char *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
            char v15 = (char *)v48;
            uint64_t v14 = (const void ***)((char *)v48 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
            uint64_t v14 = &v41;
            char v15 = (char *)v48;
          }
        }
        __int16 v16 = &v15[24 * v49];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)__int16 v16 = v17;
        ++v49;
        if (v45)
        {
          __int16 v18 = *(const void ***)(a1 + 8);
          uint64_t v19 = *(const char **)(a1 + 16);
          __int16 v44 = 261;
          uint64_t v41 = v18;
          unsigned int v42 = v19;
          mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
          if (v45)
          {
            LODWORD(v41) = 3;
            uint64_t v43 = 1;
            unint64_t v20 = &v41;
            uint64_t v21 = (char *)v48;
            if (v49 >= v50)
            {
              unint64_t v35 = v49 + 1;
              if (v48 <= &v41 && (char *)v48 + 24 * v49 > (char *)&v41)
              {
                int64_t v38 = (char *)&v41 - (unsigned char *)v48;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
                uint64_t v21 = (char *)v48;
                unint64_t v20 = (const void ***)((char *)v48 + v38);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
                unint64_t v20 = &v41;
                uint64_t v21 = (char *)v48;
              }
            }
            uint64_t v22 = &v21[24 * v49];
            long long v23 = *(_OWORD *)v20;
            *((void *)v22 + 2) = v20[2];
            *(_OWORD *)uint64_t v22 = v23;
            ++v49;
            if (v45) {
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
            }
          }
        }
      }
    }
  }
  if (v56)
  {
    unsigned int v24 = (void **)__p;
    if (__p)
    {
      uint64_t v25 = v55;
      char v26 = __p;
      if (v55 != __p)
      {
        do
          uint64_t v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        char v26 = __p;
      }
      unsigned int v55 = v24;
      operator delete(v26);
    }
    uint64_t v27 = v52;
    if (v52)
    {
      char v28 = v53;
      uint64_t v29 = v52;
      if (v53 != v52)
      {
        do
        {
          uint64_t v31 = (void *)*--v28;
          unint64_t v30 = v31;
          void *v28 = 0;
          if (v31) {
            operator delete[](v30);
          }
        }
        while (v28 != v27);
        uint64_t v29 = v52;
      }
      v53 = v27;
      operator delete(v29);
    }
    if (v48 != v51) {
      free(v48);
    }
  }
  return 0;
}

void mlir::complex::ComplexDialect::printAttribute(uint64_t a1, uint64_t a2, mlir::AsmPrinter *a3)
{
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id)
  {
    uint64_t v6 = a2;
    uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a3 + 16))(a3);
    uint64_t v5 = *((void *)v4 + 4);
    if ((unint64_t)(*((void *)v4 + 3) - v5) > 5)
    {
      *(_WORD *)(v5 + 4) = 29285;
      *(_DWORD *)uint64_t v5 = 1651340654;
      *((void *)v4 + 4) += 6;
    }
    else
    {
      llvm::raw_ostream::write(v4, "number", 6uLL);
    }
    mlir::complex::NumberAttr::print((mlir::complex::NumberAttr *)&v6, a3);
  }
}

void mlir::complex::NumberAttr::print(mlir::complex::NumberAttr *this, mlir::AsmPrinter *a2)
{
  void v21[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = (_WORD *)*((void *)v4 + 4);
  if (*((void *)v4 + 3) - (void)v5 > 1uLL)
  {
    _WORD *v5 = 14908;
    *((void *)v4 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v4, "<:", 2uLL);
  }
  uint64_t v17 = *(void *)(*(void *)this + 72);
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v17);
  (*(void (**)(mlir::AsmPrinter *, uint64_t))(*(void *)a2 + 32))(a2, Value);
  uint64_t v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v8 = (unsigned char *)*((void *)v7 + 4);
  if (*((unsigned char **)v7 + 3) == v8)
  {
    uint64_t v7 = llvm::raw_ostream::write(v7, " ", 1uLL);
  }
  else
  {
    unsigned char *v8 = 32;
    ++*((void *)v7 + 4);
  }
  uint64_t v9 = (const llvm::detail::DoubleAPFloat *)(*(void *)this + 16);
  char v10 = *(void **)v9;
  uint64_t v11 = llvm::APFloatBase::PPCDoubleDouble(v7);
  if (v11 == v10) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21, v9);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v21, v9);
  }
  (*(void (**)(mlir::AsmPrinter *, unsigned char *))(*(void *)a2 + 24))(a2, v20);
  unsigned int v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v13 = (_WORD *)*((void *)v12 + 4);
  if (*((void *)v12 + 3) - (void)v13 > 1uLL)
  {
    _WORD *v13 = 8236;
    *((void *)v12 + 4) += 2;
  }
  else
  {
    llvm::raw_ostream::write(v12, ", ", 2uLL);
  }
  uint64_t v14 = (const llvm::detail::DoubleAPFloat *)(*(void *)this + 48);
  if (v11 == *(void **)v14) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19, v14);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v19, v14);
  }
  (*(void (**)(mlir::AsmPrinter *, unsigned char *))(*(void *)a2 + 24))(a2, v18);
  char v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(void *)a2 + 16))(a2);
  __int16 v16 = (unsigned char *)*((void *)v15 + 4);
  if (*((unsigned char **)v15 + 3) != v16)
  {
    *__int16 v16 = 62;
    ++*((void *)v15 + 4);
    if (v11 != (void *)v19[0]) {
      goto LABEL_18;
    }
LABEL_22:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
    if (v11 != (void *)v21[0]) {
      goto LABEL_19;
    }
LABEL_23:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21);
    return;
  }
  llvm::raw_ostream::write(v15, ">", 1uLL);
  if (v11 == (void *)v19[0]) {
    goto LABEL_22;
  }
LABEL_18:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
  if (v11 == (void *)v21[0]) {
    goto LABEL_23;
  }
LABEL_19:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v21);
}

llvm::APFloatBase *mlir::complex::NumberAttr::parse(uint64_t a1)
{
  uint64_t v6 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 152))(a1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    return 0;
  }
  double v4 = 0.0;
  double v5 = 0.0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 504))(a1, &v6)
    || !(*(unsigned __int8 (**)(uint64_t, double *))(*(void *)a1 + 344))(a1, &v5)
    || !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)
    || !(*(unsigned __int8 (**)(uint64_t, double *))(*(void *)a1 + 344))(a1, &v4)
    || !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 168))(a1))
  {
    return 0;
  }
  uint64_t v2 = mlir::ComplexType::get(v6);
  return mlir::complex::NumberAttr::get(v2, v5, v4);
}

mlir::arith::ArithDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::arith::ArithDialect **a2@<X8>)
{
  uint64_t v3 = *a1;
  double v4 = (mlir::arith::ArithDialect *)operator new(0x60uLL);
  uint64_t result = mlir::arith::ArithDialect::ArithDialect(v4, v3);
  *a2 = result;
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::complex::BitcastOp>(uint64_t a1)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = operator new(0x70uLL);
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"complex.bitcast", 15, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::BitcastOp,void>::id, (uint64_t)&v9);
  uint64_t v3 = v9;
  if (v10)
  {
    uint64_t v4 = 16 * v10;
    double v5 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v3 = v9;
  }
  if (v3 != v11) {
    free(v3);
  }
  *uint64_t v2 = &unk_1EC9C6298;
  uint64_t v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  uint64_t result = (uint64_t)v8;
  uint64_t v8 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::insert<mlir::complex::CreateOp>(uint64_t a1)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = operator new(0x70uLL);
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"complex.create", 14, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::CreateOp,void>::id, (uint64_t)&v9);
  uint64_t v3 = v9;
  if (v10)
  {
    uint64_t v4 = 16 * v10;
    double v5 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v3 = v9;
  }
  if (v3 != v11) {
    free(v3);
  }
  *uint64_t v2 = &unk_1EC9C61D0;
  uint64_t v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  uint64_t result = (uint64_t)v8;
  uint64_t v8 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.abs", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AbsOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C50A0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::AbsOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AbsOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AbsOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AbsOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AbsOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AbsOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  unint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.abs";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v234 = a1;
    uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v40 = v39;
    a1 = v234;
    if (v40)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v248 = 83;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v248;
      }
      uint64_t v43 = &v247[v42];
      unint64_t v44 = v248 - v42;
      if (v248 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v248 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v234;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v222 = v2;
    uint64_t v235 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v49 = v48;
    uint64_t v2 = v222;
    a1 = v235;
    if (v49)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v248 = 81;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v248;
      }
      uint64_t v52 = &v247[v51];
      unint64_t v53 = v248 - v51;
      if (v248 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v248 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v222;
      a1 = v235;
    }
  }
  uint64_t v4 = v3[27];
  unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v223 = v2;
    uint64_t v236 = a1;
    uint64_t v211 = v4;
    unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v4 = v211;
    uint64_t v2 = v223;
    int v58 = v57;
    a1 = v236;
    if (v58)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<Empty>]";
      unint64_t v248 = 109;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v248;
      }
      v61 = &v247[v60];
      unint64_t v62 = v248 - v60;
      if (v248 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v248 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v4 = v211;
      uint64_t v2 = v223;
      a1 = v236;
    }
  }
  uint64_t v6 = v5[509];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v224 = v2;
    uint64_t v237 = a1;
    uint64_t v201 = v6;
    uint64_t v212 = v4;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v201;
    uint64_t v4 = v212;
    int v67 = v66;
    uint64_t v2 = v224;
    a1 = v237;
    if (v67)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v248 = 86;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v248;
      }
      v70 = &v247[v69];
      unint64_t v71 = v248 - v69;
      if (v248 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v248 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v201;
      uint64_t v4 = v212;
      uint64_t v2 = v224;
      a1 = v237;
    }
  }
  uint64_t v8 = v7[12];
  unint64_t v9 = 0x1E8EB8000uLL;
  {
    uint64_t v225 = v2;
    uint64_t v238 = a1;
    uint64_t v202 = v6;
    uint64_t v213 = v4;
    uint64_t v192 = v8;
    unint64_t v9 = 0x1E8EB8000;
    uint64_t v8 = v192;
    uint64_t v6 = v202;
    uint64_t v4 = v213;
    int v76 = v75;
    uint64_t v2 = v225;
    a1 = v238;
    if (v76)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v248 = 82;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v248;
      }
      v79 = &v247[v78];
      unint64_t v80 = v248 - v78;
      if (v248 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v248 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      unint64_t v9 = 0x1E8EB8000;
      uint64_t v8 = v192;
      uint64_t v6 = v202;
      uint64_t v4 = v213;
      uint64_t v2 = v225;
      a1 = v238;
    }
  }
  uint64_t v10 = *(void *)(v9 + 4080);
  char v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v226 = v2;
    uint64_t v239 = a1;
    uint64_t v203 = v6;
    uint64_t v214 = v4;
    uint64_t v184 = v10;
    uint64_t v193 = v8;
    char v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v184;
    uint64_t v8 = v193;
    uint64_t v6 = v203;
    uint64_t v4 = v214;
    int v85 = v84;
    uint64_t v2 = v226;
    a1 = v239;
    if (v85)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v248 = 84;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v248;
      }
      v88 = &v247[v87];
      unint64_t v89 = v248 - v87;
      if (v248 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v248 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      char v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v184;
      uint64_t v8 = v193;
      uint64_t v6 = v203;
      uint64_t v4 = v214;
      uint64_t v2 = v226;
      a1 = v239;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v227 = v2;
    uint64_t v240 = a1;
    uint64_t v204 = v6;
    uint64_t v215 = v4;
    uint64_t v185 = v10;
    uint64_t v194 = v8;
    uint64_t v177 = v12;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v177;
    uint64_t v10 = v185;
    uint64_t v8 = v194;
    uint64_t v6 = v204;
    uint64_t v4 = v215;
    int v94 = v93;
    uint64_t v2 = v227;
    a1 = v240;
    if (v94)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v248 = 89;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v248;
      }
      v97 = &v247[v96];
      unint64_t v98 = v248 - v96;
      if (v248 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v248 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v177;
      uint64_t v10 = v185;
      uint64_t v8 = v194;
      uint64_t v6 = v204;
      uint64_t v4 = v215;
      uint64_t v2 = v227;
      a1 = v240;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2744);
  unint64_t v15 = 0x1E8EB8000uLL;
  {
    uint64_t v228 = v2;
    uint64_t v241 = a1;
    uint64_t v205 = v6;
    uint64_t v216 = v4;
    uint64_t v186 = v10;
    uint64_t v195 = v8;
    uint64_t v171 = v14;
    uint64_t v178 = v12;
    unint64_t v15 = 0x1E8EB8000;
    uint64_t v14 = v171;
    uint64_t v12 = v178;
    uint64_t v10 = v186;
    uint64_t v8 = v195;
    uint64_t v6 = v205;
    uint64_t v4 = v216;
    int v103 = v102;
    uint64_t v2 = v228;
    a1 = v241;
    if (v103)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v248 = 95;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v248;
      }
      v106 = &v247[v105];
      unint64_t v107 = v248 - v105;
      if (v248 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v248 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      unint64_t v15 = 0x1E8EB8000;
      uint64_t v14 = v171;
      uint64_t v12 = v178;
      uint64_t v10 = v186;
      uint64_t v8 = v195;
      uint64_t v6 = v205;
      uint64_t v4 = v216;
      uint64_t v2 = v228;
      a1 = v241;
    }
  }
  uint64_t v16 = *(void *)(v15 + 2776);
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v229 = v2;
    uint64_t v242 = a1;
    uint64_t v206 = v6;
    uint64_t v217 = v4;
    uint64_t v187 = v10;
    uint64_t v196 = v8;
    uint64_t v172 = v14;
    uint64_t v179 = v12;
    uint64_t v166 = v16;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v166;
    uint64_t v14 = v172;
    uint64_t v12 = v179;
    uint64_t v10 = v187;
    uint64_t v8 = v196;
    uint64_t v6 = v206;
    uint64_t v4 = v217;
    int v112 = v111;
    uint64_t v2 = v229;
    a1 = v242;
    if (v112)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v248 = 99;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v248;
      }
      v115 = &v247[v114];
      unint64_t v116 = v248 - v114;
      if (v248 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v248 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v166;
      uint64_t v14 = v172;
      uint64_t v12 = v179;
      uint64_t v10 = v187;
      uint64_t v8 = v196;
      uint64_t v6 = v206;
      uint64_t v4 = v217;
      uint64_t v2 = v229;
      a1 = v242;
    }
  }
  uint64_t v18 = *(void *)(v17 + 2912);
  unint64_t v19 = 0x1E8EB8000uLL;
  {
    uint64_t v230 = v2;
    uint64_t v243 = a1;
    uint64_t v207 = v6;
    uint64_t v218 = v4;
    uint64_t v188 = v10;
    uint64_t v197 = v8;
    uint64_t v173 = v14;
    uint64_t v180 = v12;
    uint64_t v162 = v18;
    uint64_t v167 = v16;
    unint64_t v19 = 0x1E8EB8000;
    uint64_t v18 = v162;
    uint64_t v16 = v167;
    uint64_t v14 = v173;
    uint64_t v12 = v180;
    uint64_t v10 = v188;
    uint64_t v8 = v197;
    uint64_t v6 = v207;
    uint64_t v4 = v218;
    int v121 = v120;
    uint64_t v2 = v230;
    a1 = v243;
    if (v121)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v248 = 93;
      unint64_t v122 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v122) {
        unint64_t v123 = v122;
      }
      else {
        unint64_t v123 = v248;
      }
      v124 = &v247[v123];
      unint64_t v125 = v248 - v123;
      if (v248 - v123 >= 0x12) {
        uint64_t v126 = 18;
      }
      else {
        uint64_t v126 = v248 - v123;
      }
      unint64_t v127 = v125 - v126;
      if (v127 >= v127 - 1) {
        uint64_t v128 = v127 - 1;
      }
      else {
        uint64_t v128 = v127;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      unint64_t v19 = 0x1E8EB8000;
      uint64_t v18 = v162;
      uint64_t v16 = v167;
      uint64_t v14 = v173;
      uint64_t v12 = v180;
      uint64_t v10 = v188;
      uint64_t v8 = v197;
      uint64_t v6 = v207;
      uint64_t v4 = v218;
      uint64_t v2 = v230;
      a1 = v243;
    }
  }
  uint64_t v20 = *(void *)(v19 + 3904);
  uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v231 = v2;
    uint64_t v244 = a1;
    uint64_t v208 = v6;
    uint64_t v219 = v4;
    uint64_t v189 = v10;
    uint64_t v198 = v8;
    uint64_t v174 = v14;
    uint64_t v181 = v12;
    uint64_t v163 = v18;
    uint64_t v168 = v16;
    uint64_t v159 = v20;
    uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v20 = v159;
    uint64_t v18 = v163;
    uint64_t v16 = v168;
    uint64_t v14 = v174;
    uint64_t v12 = v181;
    uint64_t v10 = v189;
    uint64_t v8 = v198;
    uint64_t v6 = v208;
    uint64_t v4 = v219;
    int v130 = v129;
    uint64_t v2 = v231;
    a1 = v244;
    if (v130)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      unint64_t v248 = 83;
      unint64_t v131 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v131) {
        unint64_t v132 = v131;
      }
      else {
        unint64_t v132 = v248;
      }
      v133 = &v247[v132];
      unint64_t v134 = v248 - v132;
      if (v248 - v132 >= 0x12) {
        uint64_t v135 = 18;
      }
      else {
        uint64_t v135 = v248 - v132;
      }
      unint64_t v136 = v134 - v135;
      if (v136 >= v136 - 1) {
        uint64_t v137 = v136 - 1;
      }
      else {
        uint64_t v137 = v136;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v20 = v159;
      uint64_t v18 = v163;
      uint64_t v16 = v168;
      uint64_t v14 = v174;
      uint64_t v12 = v181;
      uint64_t v10 = v189;
      uint64_t v8 = v198;
      uint64_t v6 = v208;
      uint64_t v4 = v219;
      uint64_t v2 = v231;
      a1 = v244;
    }
  }
  uint64_t v22 = v21[372];
  long long v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v232 = v2;
    uint64_t v245 = a1;
    uint64_t v209 = v6;
    uint64_t v220 = v4;
    uint64_t v190 = v10;
    uint64_t v199 = v8;
    uint64_t v175 = v14;
    uint64_t v182 = v12;
    uint64_t v164 = v18;
    uint64_t v169 = v16;
    uint64_t v157 = v22;
    uint64_t v160 = v20;
    long long v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v22 = v157;
    uint64_t v20 = v160;
    uint64_t v18 = v164;
    uint64_t v16 = v169;
    uint64_t v14 = v175;
    uint64_t v12 = v182;
    uint64_t v10 = v190;
    uint64_t v8 = v199;
    uint64_t v6 = v209;
    uint64_t v4 = v220;
    int v139 = v138;
    uint64_t v2 = v232;
    a1 = v245;
    if (v139)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      unint64_t v248 = 99;
      unint64_t v140 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v140) {
        unint64_t v141 = v140;
      }
      else {
        unint64_t v141 = v248;
      }
      v142 = &v247[v141];
      unint64_t v143 = v248 - v141;
      if (v248 - v141 >= 0x12) {
        uint64_t v144 = 18;
      }
      else {
        uint64_t v144 = v248 - v141;
      }
      unint64_t v145 = v143 - v144;
      if (v145 >= v145 - 1) {
        uint64_t v146 = v145 - 1;
      }
      else {
        uint64_t v146 = v145;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      long long v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v22 = v157;
      uint64_t v20 = v160;
      uint64_t v18 = v164;
      uint64_t v16 = v169;
      uint64_t v14 = v175;
      uint64_t v12 = v182;
      uint64_t v10 = v190;
      uint64_t v8 = v199;
      uint64_t v6 = v209;
      uint64_t v4 = v220;
      uint64_t v2 = v232;
      a1 = v245;
    }
  }
  uint64_t v24 = v23[368];
  unint64_t v25 = 0x1E8EB8000uLL;
  {
    uint64_t v233 = v2;
    uint64_t v246 = a1;
    uint64_t v210 = v6;
    uint64_t v221 = v4;
    uint64_t v191 = v10;
    uint64_t v200 = v8;
    uint64_t v176 = v14;
    uint64_t v183 = v12;
    uint64_t v165 = v18;
    uint64_t v170 = v16;
    uint64_t v158 = v22;
    uint64_t v161 = v20;
    uint64_t v156 = v24;
    unint64_t v25 = 0x1E8EB8000;
    uint64_t v24 = v156;
    uint64_t v22 = v158;
    uint64_t v20 = v161;
    uint64_t v18 = v165;
    uint64_t v16 = v170;
    uint64_t v14 = v176;
    uint64_t v12 = v183;
    uint64_t v10 = v191;
    uint64_t v8 = v200;
    uint64_t v6 = v210;
    uint64_t v4 = v221;
    int v148 = v147;
    uint64_t v2 = v233;
    a1 = v246;
    if (v148)
    {
      v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v248 = 90;
      unint64_t v149 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v149) {
        unint64_t v150 = v149;
      }
      else {
        unint64_t v150 = v248;
      }
      v151 = &v247[v150];
      unint64_t v152 = v248 - v150;
      if (v248 - v150 >= 0x12) {
        uint64_t v153 = 18;
      }
      else {
        uint64_t v153 = v248 - v150;
      }
      unint64_t v154 = v152 - v153;
      if (v154 >= v154 - 1) {
        uint64_t v155 = v154 - 1;
      }
      else {
        uint64_t v155 = v154;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      unint64_t v25 = 0x1E8EB8000;
      uint64_t v24 = v156;
      uint64_t v22 = v158;
      uint64_t v20 = v161;
      uint64_t v18 = v165;
      uint64_t v16 = v170;
      uint64_t v14 = v176;
      uint64_t v12 = v183;
      uint64_t v10 = v191;
      uint64_t v8 = v200;
      uint64_t v6 = v210;
      uint64_t v4 = v221;
      uint64_t v2 = v233;
      a1 = v246;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v24 == a1
      || *(void *)(v25 + 3856) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (uint64_t v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AbsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.add", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AddOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5168;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  BOOL v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        BOOL v5 = v7;
      }
      else {
        BOOL v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::AddOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    BOOL v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    BOOL v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AddOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AddOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AddOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AddOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AddOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.add";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::AddOp::fold(&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v259 = a1;
    uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v43 = v42;
    a1 = v259;
    if (v43)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v274 = 83;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v274;
      }
      unint64_t v46 = &v273[v45];
      unint64_t v47 = v274 - v45;
      if (v274 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v274 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v259;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v246 = v2;
    uint64_t v260 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v52 = v51;
    uint64_t v2 = v246;
    a1 = v260;
    if (v52)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v274 = 81;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v274;
      }
      unint64_t v55 = &v273[v54];
      unint64_t v56 = v274 - v54;
      if (v274 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v274 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v246;
      a1 = v260;
    }
  }
  uint64_t v4 = v3[27];
  unint64_t v5 = &unk_1E8EBA000;
  {
    uint64_t v247 = v2;
    uint64_t v261 = a1;
    uint64_t v234 = v4;
    unint64_t v5 = (void *)&unk_1E8EBA000;
    uint64_t v4 = v234;
    uint64_t v2 = v247;
    int v61 = v60;
    a1 = v261;
    if (v61)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      unint64_t v274 = 111;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v274;
      }
      unint64_t v64 = &v273[v63];
      unint64_t v65 = v274 - v63;
      if (v274 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v274 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      unint64_t v5 = (void *)&unk_1E8EBA000;
      uint64_t v4 = v234;
      uint64_t v2 = v247;
      a1 = v261;
    }
  }
  uint64_t v6 = v5[1];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v248 = v2;
    uint64_t v262 = a1;
    uint64_t v223 = v6;
    uint64_t v235 = v4;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v223;
    uint64_t v4 = v235;
    int v70 = v69;
    uint64_t v2 = v248;
    a1 = v262;
    if (v70)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v274 = 86;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v274;
      }
      unint64_t v73 = &v273[v72];
      unint64_t v74 = v274 - v72;
      if (v274 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v274 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v223;
      uint64_t v4 = v235;
      uint64_t v2 = v248;
      a1 = v262;
    }
  }
  uint64_t v8 = v7[12];
  unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v249 = v2;
    uint64_t v263 = a1;
    uint64_t v224 = v6;
    uint64_t v236 = v4;
    uint64_t v213 = v8;
    unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v213;
    uint64_t v6 = v224;
    uint64_t v4 = v236;
    int v79 = v78;
    uint64_t v2 = v249;
    a1 = v263;
    if (v79)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      unint64_t v274 = 90;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v274;
      }
      unint64_t v82 = &v273[v81];
      unint64_t v83 = v274 - v81;
      if (v274 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v274 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v213;
      uint64_t v6 = v224;
      uint64_t v4 = v236;
      uint64_t v2 = v249;
      a1 = v263;
    }
  }
  uint64_t v10 = v9[24];
  uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v250 = v2;
    uint64_t v264 = a1;
    uint64_t v225 = v6;
    uint64_t v237 = v4;
    uint64_t v204 = v10;
    uint64_t v214 = v8;
    uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v204;
    uint64_t v8 = v214;
    uint64_t v6 = v225;
    uint64_t v4 = v237;
    int v88 = v87;
    uint64_t v2 = v250;
    a1 = v264;
    if (v88)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v274 = 84;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v274;
      }
      unint64_t v91 = &v273[v90];
      unint64_t v92 = v274 - v90;
      if (v274 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v274 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v204;
      uint64_t v8 = v214;
      uint64_t v6 = v225;
      uint64_t v4 = v237;
      uint64_t v2 = v250;
      a1 = v264;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v251 = v2;
    uint64_t v265 = a1;
    uint64_t v226 = v6;
    uint64_t v238 = v4;
    uint64_t v205 = v10;
    uint64_t v215 = v8;
    uint64_t v196 = v12;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v196;
    uint64_t v10 = v205;
    uint64_t v8 = v215;
    uint64_t v6 = v226;
    uint64_t v4 = v238;
    int v97 = v96;
    uint64_t v2 = v251;
    a1 = v265;
    if (v97)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v274 = 89;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v274;
      }
      unint64_t v100 = &v273[v99];
      unint64_t v101 = v274 - v99;
      if (v274 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v274 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v196;
      uint64_t v10 = v205;
      uint64_t v8 = v215;
      uint64_t v6 = v226;
      uint64_t v4 = v238;
      uint64_t v2 = v251;
      a1 = v265;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2744);
  unint64_t v15 = 0x1E8EB8000uLL;
  {
    uint64_t v252 = v2;
    uint64_t v266 = a1;
    uint64_t v227 = v6;
    uint64_t v239 = v4;
    uint64_t v206 = v10;
    uint64_t v216 = v8;
    uint64_t v189 = v14;
    uint64_t v197 = v12;
    unint64_t v15 = 0x1E8EB8000;
    uint64_t v14 = v189;
    uint64_t v12 = v197;
    uint64_t v10 = v206;
    uint64_t v8 = v216;
    uint64_t v6 = v227;
    uint64_t v4 = v239;
    int v106 = v105;
    uint64_t v2 = v252;
    a1 = v266;
    if (v106)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v274 = 95;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v274;
      }
      unint64_t v109 = &v273[v108];
      unint64_t v110 = v274 - v108;
      if (v274 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v274 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      unint64_t v15 = 0x1E8EB8000;
      uint64_t v14 = v189;
      uint64_t v12 = v197;
      uint64_t v10 = v206;
      uint64_t v8 = v216;
      uint64_t v6 = v227;
      uint64_t v4 = v239;
      uint64_t v2 = v252;
      a1 = v266;
    }
  }
  uint64_t v16 = *(void *)(v15 + 2776);
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v253 = v2;
    uint64_t v267 = a1;
    uint64_t v228 = v6;
    uint64_t v240 = v4;
    uint64_t v207 = v10;
    uint64_t v217 = v8;
    uint64_t v190 = v14;
    uint64_t v198 = v12;
    uint64_t v183 = v16;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v183;
    uint64_t v14 = v190;
    uint64_t v12 = v198;
    uint64_t v10 = v207;
    uint64_t v8 = v217;
    uint64_t v6 = v228;
    uint64_t v4 = v240;
    int v115 = v114;
    uint64_t v2 = v253;
    a1 = v267;
    if (v115)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v274 = 99;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v274;
      }
      unint64_t v118 = &v273[v117];
      unint64_t v119 = v274 - v117;
      if (v274 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v274 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v183;
      uint64_t v14 = v190;
      uint64_t v12 = v198;
      uint64_t v10 = v207;
      uint64_t v8 = v217;
      uint64_t v6 = v228;
      uint64_t v4 = v240;
      uint64_t v2 = v253;
      a1 = v267;
    }
  }
  uint64_t v18 = *(void *)(v17 + 2912);
  unint64_t v19 = 0x1E8EB8000uLL;
  {
    uint64_t v254 = v2;
    uint64_t v268 = a1;
    uint64_t v229 = v6;
    uint64_t v241 = v4;
    uint64_t v208 = v10;
    uint64_t v218 = v8;
    uint64_t v191 = v14;
    uint64_t v199 = v12;
    uint64_t v178 = v18;
    uint64_t v184 = v16;
    unint64_t v19 = 0x1E8EB8000;
    uint64_t v18 = v178;
    uint64_t v16 = v184;
    uint64_t v14 = v191;
    uint64_t v12 = v199;
    uint64_t v10 = v208;
    uint64_t v8 = v218;
    uint64_t v6 = v229;
    uint64_t v4 = v241;
    int v124 = v123;
    uint64_t v2 = v254;
    a1 = v268;
    if (v124)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v274 = 93;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v274;
      }
      unint64_t v127 = &v273[v126];
      unint64_t v128 = v274 - v126;
      if (v274 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v274 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      unint64_t v19 = 0x1E8EB8000;
      uint64_t v18 = v178;
      uint64_t v16 = v184;
      uint64_t v14 = v191;
      uint64_t v12 = v199;
      uint64_t v10 = v208;
      uint64_t v8 = v218;
      uint64_t v6 = v229;
      uint64_t v4 = v241;
      uint64_t v2 = v254;
      a1 = v268;
    }
  }
  uint64_t v20 = *(void *)(v19 + 3904);
  uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v255 = v2;
    uint64_t v269 = a1;
    uint64_t v230 = v6;
    uint64_t v242 = v4;
    uint64_t v209 = v10;
    uint64_t v219 = v8;
    uint64_t v192 = v14;
    uint64_t v200 = v12;
    uint64_t v179 = v18;
    uint64_t v185 = v16;
    uint64_t v174 = v20;
    uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v20 = v174;
    uint64_t v18 = v179;
    uint64_t v16 = v185;
    uint64_t v14 = v192;
    uint64_t v12 = v200;
    uint64_t v10 = v209;
    uint64_t v8 = v219;
    uint64_t v6 = v230;
    uint64_t v4 = v242;
    int v133 = v132;
    uint64_t v2 = v255;
    a1 = v269;
    if (v133)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v274 = 97;
      unint64_t v134 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v134) {
        unint64_t v135 = v134;
      }
      else {
        unint64_t v135 = v274;
      }
      unint64_t v136 = &v273[v135];
      unint64_t v137 = v274 - v135;
      if (v274 - v135 >= 0x12) {
        uint64_t v138 = 18;
      }
      else {
        uint64_t v138 = v274 - v135;
      }
      unint64_t v139 = v137 - v138;
      if (v139 >= v139 - 1) {
        uint64_t v140 = v139 - 1;
      }
      else {
        uint64_t v140 = v139;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v136[v138], v140);
      uint64_t v21 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v20 = v174;
      uint64_t v18 = v179;
      uint64_t v16 = v185;
      uint64_t v14 = v192;
      uint64_t v12 = v200;
      uint64_t v10 = v209;
      uint64_t v8 = v219;
      uint64_t v6 = v230;
      uint64_t v4 = v242;
      uint64_t v2 = v255;
      a1 = v269;
    }
  }
  uint64_t v22 = v21[21];
  long long v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v256 = v2;
    uint64_t v270 = a1;
    uint64_t v231 = v6;
    uint64_t v243 = v4;
    uint64_t v210 = v10;
    uint64_t v220 = v8;
    uint64_t v193 = v14;
    uint64_t v201 = v12;
    uint64_t v180 = v18;
    uint64_t v186 = v16;
    uint64_t v171 = v22;
    uint64_t v175 = v20;
    long long v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v22 = v171;
    uint64_t v20 = v175;
    uint64_t v18 = v180;
    uint64_t v16 = v186;
    uint64_t v14 = v193;
    uint64_t v12 = v201;
    uint64_t v10 = v210;
    uint64_t v8 = v220;
    uint64_t v6 = v231;
    uint64_t v4 = v243;
    int v142 = v141;
    uint64_t v2 = v256;
    a1 = v270;
    if (v142)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      unint64_t v274 = 83;
      unint64_t v143 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v143) {
        unint64_t v144 = v143;
      }
      else {
        unint64_t v144 = v274;
      }
      unint64_t v145 = &v273[v144];
      unint64_t v146 = v274 - v144;
      if (v274 - v144 >= 0x12) {
        uint64_t v147 = 18;
      }
      else {
        uint64_t v147 = v274 - v144;
      }
      unint64_t v148 = v146 - v147;
      if (v148 >= v148 - 1) {
        uint64_t v149 = v148 - 1;
      }
      else {
        uint64_t v149 = v148;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v145[v147], v149);
      long long v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v22 = v171;
      uint64_t v20 = v175;
      uint64_t v18 = v180;
      uint64_t v16 = v186;
      uint64_t v14 = v193;
      uint64_t v12 = v201;
      uint64_t v10 = v210;
      uint64_t v8 = v220;
      uint64_t v6 = v231;
      uint64_t v4 = v243;
      uint64_t v2 = v256;
      a1 = v270;
    }
  }
  uint64_t v24 = v23[372];
  unint64_t v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v257 = v2;
    uint64_t v271 = a1;
    uint64_t v232 = v6;
    uint64_t v244 = v4;
    uint64_t v211 = v10;
    uint64_t v221 = v8;
    uint64_t v194 = v14;
    uint64_t v202 = v12;
    uint64_t v181 = v18;
    uint64_t v187 = v16;
    uint64_t v172 = v22;
    uint64_t v176 = v20;
    uint64_t v169 = v24;
    unint64_t v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v24 = v169;
    uint64_t v22 = v172;
    uint64_t v20 = v176;
    uint64_t v18 = v181;
    uint64_t v16 = v187;
    uint64_t v14 = v194;
    uint64_t v12 = v202;
    uint64_t v10 = v211;
    uint64_t v8 = v221;
    uint64_t v6 = v232;
    uint64_t v4 = v244;
    int v151 = v150;
    uint64_t v2 = v257;
    a1 = v271;
    if (v151)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      unint64_t v274 = 99;
      unint64_t v152 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v152) {
        unint64_t v153 = v152;
      }
      else {
        unint64_t v153 = v274;
      }
      unint64_t v154 = &v273[v153];
      unint64_t v155 = v274 - v153;
      if (v274 - v153 >= 0x12) {
        uint64_t v156 = 18;
      }
      else {
        uint64_t v156 = v274 - v153;
      }
      unint64_t v157 = v155 - v156;
      if (v157 >= v157 - 1) {
        uint64_t v158 = v157 - 1;
      }
      else {
        uint64_t v158 = v157;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v154[v156], v158);
      unint64_t v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v24 = v169;
      uint64_t v22 = v172;
      uint64_t v20 = v176;
      uint64_t v18 = v181;
      uint64_t v16 = v187;
      uint64_t v14 = v194;
      uint64_t v12 = v202;
      uint64_t v10 = v211;
      uint64_t v8 = v221;
      uint64_t v6 = v232;
      uint64_t v4 = v244;
      uint64_t v2 = v257;
      a1 = v271;
    }
  }
  uint64_t v26 = v25[368];
  unint64_t v27 = 0x1E8EB8000uLL;
  {
    uint64_t v258 = v2;
    uint64_t v272 = a1;
    uint64_t v233 = v6;
    uint64_t v245 = v4;
    uint64_t v212 = v10;
    uint64_t v222 = v8;
    uint64_t v195 = v14;
    uint64_t v203 = v12;
    uint64_t v182 = v18;
    uint64_t v188 = v16;
    uint64_t v173 = v22;
    uint64_t v177 = v20;
    uint64_t v168 = v26;
    uint64_t v170 = v24;
    unint64_t v27 = 0x1E8EB8000;
    uint64_t v26 = v168;
    uint64_t v24 = v170;
    uint64_t v22 = v173;
    uint64_t v20 = v177;
    uint64_t v18 = v182;
    uint64_t v16 = v188;
    uint64_t v14 = v195;
    uint64_t v12 = v203;
    uint64_t v10 = v212;
    uint64_t v8 = v222;
    uint64_t v6 = v233;
    uint64_t v4 = v245;
    int v160 = v159;
    uint64_t v2 = v258;
    a1 = v272;
    if (v160)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v274 = 90;
      unint64_t v161 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v161) {
        unint64_t v162 = v161;
      }
      else {
        unint64_t v162 = v274;
      }
      uint64_t v163 = &v273[v162];
      unint64_t v164 = v274 - v162;
      if (v274 - v162 >= 0x12) {
        uint64_t v165 = 18;
      }
      else {
        uint64_t v165 = v274 - v162;
      }
      unint64_t v166 = v164 - v165;
      if (v166 >= v166 - 1) {
        uint64_t v167 = v166 - 1;
      }
      else {
        uint64_t v167 = v166;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v163[v165], v167);
      unint64_t v27 = 0x1E8EB8000;
      uint64_t v26 = v168;
      uint64_t v24 = v170;
      uint64_t v22 = v173;
      uint64_t v20 = v177;
      uint64_t v18 = v182;
      uint64_t v16 = v188;
      uint64_t v14 = v195;
      uint64_t v12 = v203;
      uint64_t v10 = v212;
      uint64_t v8 = v222;
      uint64_t v6 = v233;
      uint64_t v4 = v245;
      uint64_t v2 = v258;
      a1 = v272;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v24 == a1
      || v26 == a1
      || *(void *)(v27 + 3856) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (uint64_t v8 = a1, mlir::complex::AddOp::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v5))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AddOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.angle", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::AngleOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5D20;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::AngleOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::AngleOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::AngleOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AngleOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::AngleOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::AngleOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.angle";
  v16[1] = 13;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (unint64_t v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::AngleOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.atan2", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Atan2Op,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5DE8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::Atan2Op::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Atan2Op>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Atan2Op>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Atan2Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Atan2Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Atan2Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.atan2";
  v16[1] = 13;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Atan2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    unint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    unint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  BOOL v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getCanonicalizationPatterns(uint64_t a1, void *a2, uint64_t a3)
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        BOOL v5 = v7;
      }
      else {
        BOOL v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::BitcastOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x1E4F143B8];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          char v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      int64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      unint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          unint64_t v17 = (void *)*--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        unint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::BitcastOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::BitcastOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::BitcastOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::BitcastOpGenericAdaptorBase::BitcastOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::BitcastOp::fold((uint64_t)&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::BitcastOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5)) {
    return 0;
  }
  uint64_t v7 = a1;
  if (!mlir::complex::BitcastOp::verifyInvariantsImpl((mlir::complex::BitcastOp *)&v7)) {
    return 0;
  }
  uint64_t v7 = a1;
  return mlir::complex::BitcastOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::complex::BitcastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.conj", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ConjOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5A00;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  BOOL v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        BOOL v5 = v7;
      }
      else {
        BOOL v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ConjOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    BOOL v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    BOOL v5 = 0;
  }
  AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConjOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConjOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ConjOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ConjOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ConjOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.conj";
  v16[1] = 12;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::ConjOpGenericAdaptorBase::ConjOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::ConjOp::fold((uint64_t)&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v259 = a1;
    uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v43 = v42;
    a1 = v259;
    if (v43)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v274 = 83;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v274;
      }
      unint64_t v46 = &v273[v45];
      unint64_t v47 = v274 - v45;
      if (v274 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v274 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v259;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v246 = v2;
    uint64_t v260 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v52 = v51;
    uint64_t v2 = v246;
    a1 = v260;
    if (v52)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v274 = 81;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v274;
      }
      unint64_t v55 = &v273[v54];
      unint64_t v56 = v274 - v54;
      if (v274 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v274 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v246;
      a1 = v260;
    }
  }
  uint64_t v4 = v3[27];
  unint64_t v5 = &unk_1E8EBA000;
  {
    uint64_t v247 = v2;
    uint64_t v261 = a1;
    uint64_t v234 = v4;
    unint64_t v5 = (void *)&unk_1E8EBA000;
    uint64_t v4 = v234;
    uint64_t v2 = v247;
    int v61 = v60;
    a1 = v261;
    if (v61)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      unint64_t v274 = 111;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v274;
      }
      unint64_t v64 = &v273[v63];
      unint64_t v65 = v274 - v63;
      if (v274 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v274 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      unint64_t v5 = (void *)&unk_1E8EBA000;
      uint64_t v4 = v234;
      uint64_t v2 = v247;
      a1 = v261;
    }
  }
  uint64_t v6 = v5[1];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v248 = v2;
    uint64_t v262 = a1;
    uint64_t v223 = v6;
    uint64_t v235 = v4;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v223;
    uint64_t v4 = v235;
    int v70 = v69;
    uint64_t v2 = v248;
    a1 = v262;
    if (v70)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v274 = 86;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v274;
      }
      unint64_t v73 = &v273[v72];
      unint64_t v74 = v274 - v72;
      if (v274 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v274 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v223;
      uint64_t v4 = v235;
      uint64_t v2 = v248;
      a1 = v262;
    }
  }
  uint64_t v8 = v7[12];
  unint64_t v9 = 0x1E8EB8000uLL;
  {
    uint64_t v249 = v2;
    uint64_t v263 = a1;
    uint64_t v224 = v6;
    uint64_t v236 = v4;
    uint64_t v213 = v8;
    unint64_t v9 = 0x1E8EB8000;
    uint64_t v8 = v213;
    uint64_t v6 = v224;
    uint64_t v4 = v236;
    int v79 = v78;
    uint64_t v2 = v249;
    a1 = v263;
    if (v79)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v274 = 82;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v274;
      }
      unint64_t v82 = &v273[v81];
      unint64_t v83 = v274 - v81;
      if (v274 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v274 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      unint64_t v9 = 0x1E8EB8000;
      uint64_t v8 = v213;
      uint64_t v6 = v224;
      uint64_t v4 = v236;
      uint64_t v2 = v249;
      a1 = v263;
    }
  }
  uint64_t v10 = *(void *)(v9 + 4080);
  uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v250 = v2;
    uint64_t v264 = a1;
    uint64_t v225 = v6;
    uint64_t v237 = v4;
    uint64_t v204 = v10;
    uint64_t v214 = v8;
    uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v204;
    uint64_t v8 = v214;
    uint64_t v6 = v225;
    uint64_t v4 = v237;
    int v88 = v87;
    uint64_t v2 = v250;
    a1 = v264;
    if (v88)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v274 = 84;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v274;
      }
      unint64_t v91 = &v273[v90];
      unint64_t v92 = v274 - v90;
      if (v274 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v274 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v204;
      uint64_t v8 = v214;
      uint64_t v6 = v225;
      uint64_t v4 = v237;
      uint64_t v2 = v250;
      a1 = v264;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v251 = v2;
    uint64_t v265 = a1;
    uint64_t v226 = v6;
    uint64_t v238 = v4;
    uint64_t v205 = v10;
    uint64_t v215 = v8;
    uint64_t v196 = v12;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v196;
    uint64_t v10 = v205;
    uint64_t v8 = v215;
    uint64_t v6 = v226;
    uint64_t v4 = v238;
    int v97 = v96;
    uint64_t v2 = v251;
    a1 = v265;
    if (v97)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v274 = 89;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v274;
      }
      unint64_t v100 = &v273[v99];
      unint64_t v101 = v274 - v99;
      if (v274 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v274 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v196;
      uint64_t v10 = v205;
      uint64_t v8 = v215;
      uint64_t v6 = v226;
      uint64_t v4 = v238;
      uint64_t v2 = v251;
      a1 = v265;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2744);
  uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v252 = v2;
    uint64_t v266 = a1;
    uint64_t v227 = v6;
    uint64_t v239 = v4;
    uint64_t v206 = v10;
    uint64_t v216 = v8;
    uint64_t v189 = v14;
    uint64_t v197 = v12;
    uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v14 = v189;
    uint64_t v12 = v197;
    uint64_t v10 = v206;
    uint64_t v8 = v216;
    uint64_t v6 = v227;
    uint64_t v4 = v239;
    int v106 = v105;
    uint64_t v2 = v252;
    a1 = v266;
    if (v106)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      unint64_t v274 = 97;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v274;
      }
      unint64_t v109 = &v273[v108];
      unint64_t v110 = v274 - v108;
      if (v274 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v274 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v14 = v189;
      uint64_t v12 = v197;
      uint64_t v10 = v206;
      uint64_t v8 = v216;
      uint64_t v6 = v227;
      uint64_t v4 = v239;
      uint64_t v2 = v252;
      a1 = v266;
    }
  }
  uint64_t v16 = v15[21];
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v253 = v2;
    uint64_t v267 = a1;
    uint64_t v228 = v6;
    uint64_t v240 = v4;
    uint64_t v207 = v10;
    uint64_t v217 = v8;
    uint64_t v190 = v14;
    uint64_t v198 = v12;
    uint64_t v183 = v16;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v183;
    uint64_t v14 = v190;
    uint64_t v12 = v198;
    uint64_t v10 = v207;
    uint64_t v8 = v217;
    uint64_t v6 = v228;
    uint64_t v4 = v240;
    int v115 = v114;
    uint64_t v2 = v253;
    a1 = v267;
    if (v115)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v274 = 95;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v274;
      }
      unint64_t v118 = &v273[v117];
      unint64_t v119 = v274 - v117;
      if (v274 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v274 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v183;
      uint64_t v14 = v190;
      uint64_t v12 = v198;
      uint64_t v10 = v207;
      uint64_t v8 = v217;
      uint64_t v6 = v228;
      uint64_t v4 = v240;
      uint64_t v2 = v253;
      a1 = v267;
    }
  }
  uint64_t v18 = *(void *)(v17 + 2776);
  unint64_t v19 = 0x1E8EB8000uLL;
  {
    uint64_t v254 = v2;
    uint64_t v268 = a1;
    uint64_t v229 = v6;
    uint64_t v241 = v4;
    uint64_t v208 = v10;
    uint64_t v218 = v8;
    uint64_t v191 = v14;
    uint64_t v199 = v12;
    uint64_t v178 = v18;
    uint64_t v184 = v16;
    unint64_t v19 = 0x1E8EB8000;
    uint64_t v18 = v178;
    uint64_t v16 = v184;
    uint64_t v14 = v191;
    uint64_t v12 = v199;
    uint64_t v10 = v208;
    uint64_t v8 = v218;
    uint64_t v6 = v229;
    uint64_t v4 = v241;
    int v124 = v123;
    uint64_t v2 = v254;
    a1 = v268;
    if (v124)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v274 = 99;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v274;
      }
      unint64_t v127 = &v273[v126];
      unint64_t v128 = v274 - v126;
      if (v274 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v274 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      unint64_t v19 = 0x1E8EB8000;
      uint64_t v18 = v178;
      uint64_t v16 = v184;
      uint64_t v14 = v191;
      uint64_t v12 = v199;
      uint64_t v10 = v208;
      uint64_t v8 = v218;
      uint64_t v6 = v229;
      uint64_t v4 = v241;
      uint64_t v2 = v254;
      a1 = v268;
    }
  }
  uint64_t v20 = *(void *)(v19 + 2912);
  unint64_t v21 = 0x1E8EB8000uLL;
  {
    uint64_t v255 = v2;
    uint64_t v269 = a1;
    uint64_t v230 = v6;
    uint64_t v242 = v4;
    uint64_t v209 = v10;
    uint64_t v219 = v8;
    uint64_t v192 = v14;
    uint64_t v200 = v12;
    uint64_t v179 = v18;
    uint64_t v185 = v16;
    uint64_t v174 = v20;
    unint64_t v21 = 0x1E8EB8000;
    uint64_t v20 = v174;
    uint64_t v18 = v179;
    uint64_t v16 = v185;
    uint64_t v14 = v192;
    uint64_t v12 = v200;
    uint64_t v10 = v209;
    uint64_t v8 = v219;
    uint64_t v6 = v230;
    uint64_t v4 = v242;
    int v133 = v132;
    uint64_t v2 = v255;
    a1 = v269;
    if (v133)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v274 = 93;
      unint64_t v134 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v134) {
        unint64_t v135 = v134;
      }
      else {
        unint64_t v135 = v274;
      }
      unint64_t v136 = &v273[v135];
      unint64_t v137 = v274 - v135;
      if (v274 - v135 >= 0x12) {
        uint64_t v138 = 18;
      }
      else {
        uint64_t v138 = v274 - v135;
      }
      unint64_t v139 = v137 - v138;
      if (v139 >= v139 - 1) {
        uint64_t v140 = v139 - 1;
      }
      else {
        uint64_t v140 = v139;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v136[v138], v140);
      unint64_t v21 = 0x1E8EB8000;
      uint64_t v20 = v174;
      uint64_t v18 = v179;
      uint64_t v16 = v185;
      uint64_t v14 = v192;
      uint64_t v12 = v200;
      uint64_t v10 = v209;
      uint64_t v8 = v219;
      uint64_t v6 = v230;
      uint64_t v4 = v242;
      uint64_t v2 = v255;
      a1 = v269;
    }
  }
  uint64_t v22 = *(void *)(v21 + 3904);
  uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v256 = v2;
    uint64_t v270 = a1;
    uint64_t v231 = v6;
    uint64_t v243 = v4;
    uint64_t v210 = v10;
    uint64_t v220 = v8;
    uint64_t v193 = v14;
    uint64_t v201 = v12;
    uint64_t v180 = v18;
    uint64_t v186 = v16;
    uint64_t v171 = v22;
    uint64_t v175 = v20;
    uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v22 = v171;
    uint64_t v20 = v175;
    uint64_t v18 = v180;
    uint64_t v16 = v186;
    uint64_t v14 = v193;
    uint64_t v12 = v201;
    uint64_t v10 = v210;
    uint64_t v8 = v220;
    uint64_t v6 = v231;
    uint64_t v4 = v243;
    int v142 = v141;
    uint64_t v2 = v256;
    a1 = v270;
    if (v142)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      unint64_t v274 = 83;
      unint64_t v143 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v143) {
        unint64_t v144 = v143;
      }
      else {
        unint64_t v144 = v274;
      }
      unint64_t v145 = &v273[v144];
      unint64_t v146 = v274 - v144;
      if (v274 - v144 >= 0x12) {
        uint64_t v147 = 18;
      }
      else {
        uint64_t v147 = v274 - v144;
      }
      unint64_t v148 = v146 - v147;
      if (v148 >= v148 - 1) {
        uint64_t v149 = v148 - 1;
      }
      else {
        uint64_t v149 = v148;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v145[v147], v149);
      uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v22 = v171;
      uint64_t v20 = v175;
      uint64_t v18 = v180;
      uint64_t v16 = v186;
      uint64_t v14 = v193;
      uint64_t v12 = v201;
      uint64_t v10 = v210;
      uint64_t v8 = v220;
      uint64_t v6 = v231;
      uint64_t v4 = v243;
      uint64_t v2 = v256;
      a1 = v270;
    }
  }
  uint64_t v24 = v23[372];
  unint64_t v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v257 = v2;
    uint64_t v271 = a1;
    uint64_t v232 = v6;
    uint64_t v244 = v4;
    uint64_t v211 = v10;
    uint64_t v221 = v8;
    uint64_t v194 = v14;
    uint64_t v202 = v12;
    uint64_t v181 = v18;
    uint64_t v187 = v16;
    uint64_t v172 = v22;
    uint64_t v176 = v20;
    uint64_t v169 = v24;
    unint64_t v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v24 = v169;
    uint64_t v22 = v172;
    uint64_t v20 = v176;
    uint64_t v18 = v181;
    uint64_t v16 = v187;
    uint64_t v14 = v194;
    uint64_t v12 = v202;
    uint64_t v10 = v211;
    uint64_t v8 = v221;
    uint64_t v6 = v232;
    uint64_t v4 = v244;
    int v151 = v150;
    uint64_t v2 = v257;
    a1 = v271;
    if (v151)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface::Trait<Empty>]";
      unint64_t v274 = 99;
      unint64_t v152 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v152) {
        unint64_t v153 = v152;
      }
      else {
        unint64_t v153 = v274;
      }
      unint64_t v154 = &v273[v153];
      unint64_t v155 = v274 - v153;
      if (v274 - v153 >= 0x12) {
        uint64_t v156 = 18;
      }
      else {
        uint64_t v156 = v274 - v153;
      }
      unint64_t v157 = v155 - v156;
      if (v157 >= v157 - 1) {
        uint64_t v158 = v157 - 1;
      }
      else {
        uint64_t v158 = v157;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::arith::ArithFastMathInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v154[v156], v158);
      unint64_t v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v24 = v169;
      uint64_t v22 = v172;
      uint64_t v20 = v176;
      uint64_t v18 = v181;
      uint64_t v16 = v187;
      uint64_t v14 = v194;
      uint64_t v12 = v202;
      uint64_t v10 = v211;
      uint64_t v8 = v221;
      uint64_t v6 = v232;
      uint64_t v4 = v244;
      uint64_t v2 = v257;
      a1 = v271;
    }
  }
  uint64_t v26 = v25[368];
  unint64_t v27 = 0x1E8EB8000uLL;
  {
    uint64_t v258 = v2;
    uint64_t v272 = a1;
    uint64_t v233 = v6;
    uint64_t v245 = v4;
    uint64_t v212 = v10;
    uint64_t v222 = v8;
    uint64_t v195 = v14;
    uint64_t v203 = v12;
    uint64_t v182 = v18;
    uint64_t v188 = v16;
    uint64_t v173 = v22;
    uint64_t v177 = v20;
    uint64_t v168 = v26;
    uint64_t v170 = v24;
    unint64_t v27 = 0x1E8EB8000;
    uint64_t v26 = v168;
    uint64_t v24 = v170;
    uint64_t v22 = v173;
    uint64_t v20 = v177;
    uint64_t v18 = v182;
    uint64_t v16 = v188;
    uint64_t v14 = v195;
    uint64_t v12 = v203;
    uint64_t v10 = v212;
    uint64_t v8 = v222;
    uint64_t v6 = v233;
    uint64_t v4 = v245;
    int v160 = v159;
    uint64_t v2 = v258;
    a1 = v272;
    if (v160)
    {
      v273 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v274 = 90;
      unint64_t v161 = llvm::StringRef::find((uint64_t *)&v273, "DesiredTypeName = ", 0x12uLL, 0);
      if (v274 >= v161) {
        unint64_t v162 = v161;
      }
      else {
        unint64_t v162 = v274;
      }
      uint64_t v163 = &v273[v162];
      unint64_t v164 = v274 - v162;
      if (v274 - v162 >= 0x12) {
        uint64_t v165 = 18;
      }
      else {
        uint64_t v165 = v274 - v162;
      }
      unint64_t v166 = v164 - v165;
      if (v166 >= v166 - 1) {
        uint64_t v167 = v166 - 1;
      }
      else {
        uint64_t v167 = v166;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v163[v165], v167);
      unint64_t v27 = 0x1E8EB8000;
      uint64_t v26 = v168;
      uint64_t v24 = v170;
      uint64_t v22 = v173;
      uint64_t v20 = v177;
      uint64_t v18 = v182;
      uint64_t v16 = v188;
      uint64_t v14 = v195;
      uint64_t v12 = v203;
      uint64_t v10 = v212;
      uint64_t v8 = v222;
      uint64_t v6 = v233;
      uint64_t v4 = v245;
      uint64_t v2 = v258;
      a1 = v272;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v24 == a1
      || v26 == a1
      || *(void *)(v27 + 3856) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (unint64_t v9 = a1, mlir::complex::ConjOp::verifyInvariantsImpl((uint64_t **)&v9))
    && mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v6))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v7) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ConjOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.constant", 16, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ConstantOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C4D80;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  BOOL v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        uint64_t v11 = v13;
      }
      else {
        uint64_t v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ConstantOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        char v10 = v11;
      }
      else {
        char v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::ConstantOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::complex::ConstantOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::ConstantOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::complex::ConstantOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::complex::ConstantOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::ConstantOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ConstantOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::CmpFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ConstantOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  *uint64_t v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getDefaultDialect;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      unint64_t v14 = 72;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3760), v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5 = a2;
  return mlir::complex::ConstantOp::getAsmResultNames(&v5, a3, a4);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::complex::ConstantOp>::getDefaultDialect()
{
  return "";
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::ConstantOp::fold((uint64_t)&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v210 = a1;
    uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v37 = v36;
    a1 = v210;
    if (v37)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v223 = 83;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v223;
      }
      int v40 = &v222[v39];
      unint64_t v41 = v223 - v39;
      if (v223 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v223 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v210;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v199 = v2;
    uint64_t v211 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v46 = v45;
    uint64_t v2 = v199;
    a1 = v211;
    if (v46)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v223 = 81;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v223;
      }
      unint64_t v49 = &v222[v48];
      unint64_t v50 = v223 - v48;
      if (v223 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v223 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v199;
      a1 = v211;
    }
  }
  uint64_t v4 = v3[27];
  uint64_t v5 = &unk_1E8EBA000;
  {
    uint64_t v200 = v2;
    uint64_t v212 = a1;
    uint64_t v189 = v4;
    uint64_t v5 = (void *)&unk_1E8EBA000;
    uint64_t v4 = v189;
    uint64_t v2 = v200;
    int v55 = v54;
    a1 = v212;
    if (v55)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      unint64_t v223 = 111;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v223;
      }
      unint64_t v58 = &v222[v57];
      unint64_t v59 = v223 - v57;
      if (v223 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v223 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v5 = (void *)&unk_1E8EBA000;
      uint64_t v4 = v189;
      uint64_t v2 = v200;
      a1 = v212;
    }
  }
  uint64_t v6 = v5[1];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v201 = v2;
    uint64_t v213 = a1;
    uint64_t v190 = v4;
    uint64_t v180 = v6;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v180;
    uint64_t v4 = v190;
    uint64_t v2 = v201;
    int v64 = v63;
    a1 = v213;
    if (v64)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v223 = 86;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v223;
      }
      unint64_t v67 = &v222[v66];
      unint64_t v68 = v223 - v66;
      if (v223 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v223 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v180;
      uint64_t v4 = v190;
      uint64_t v2 = v201;
      a1 = v213;
    }
  }
  uint64_t v8 = v7[12];
  unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v202 = v2;
    uint64_t v214 = a1;
    uint64_t v191 = v4;
    uint64_t v172 = v8;
    uint64_t v181 = v6;
    unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v172;
    uint64_t v6 = v181;
    uint64_t v4 = v191;
    uint64_t v2 = v202;
    int v73 = v72;
    a1 = v214;
    if (v73)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      unint64_t v223 = 84;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v223;
      }
      unint64_t v76 = &v222[v75];
      unint64_t v77 = v223 - v75;
      if (v223 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v223 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v172;
      uint64_t v6 = v181;
      uint64_t v4 = v191;
      uint64_t v2 = v202;
      a1 = v214;
    }
  }
  uint64_t v10 = v9[10];
  uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v203 = v2;
    uint64_t v215 = a1;
    uint64_t v192 = v4;
    uint64_t v173 = v8;
    uint64_t v182 = v6;
    uint64_t v165 = v10;
    uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v165;
    uint64_t v8 = v173;
    uint64_t v6 = v182;
    uint64_t v4 = v192;
    uint64_t v2 = v203;
    int v82 = v81;
    a1 = v215;
    if (v82)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v223 = 84;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v223;
      }
      unint64_t v85 = &v222[v84];
      unint64_t v86 = v223 - v84;
      if (v223 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v223 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v165;
      uint64_t v8 = v173;
      uint64_t v6 = v182;
      uint64_t v4 = v192;
      uint64_t v2 = v203;
      a1 = v215;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v204 = v2;
    uint64_t v216 = a1;
    uint64_t v193 = v4;
    uint64_t v174 = v8;
    uint64_t v183 = v6;
    uint64_t v159 = v12;
    uint64_t v166 = v10;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v159;
    uint64_t v10 = v166;
    uint64_t v8 = v174;
    uint64_t v6 = v183;
    uint64_t v4 = v193;
    uint64_t v2 = v204;
    int v91 = v90;
    a1 = v216;
    if (v91)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v223 = 89;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v223;
      }
      unint64_t v94 = &v222[v93];
      unint64_t v95 = v223 - v93;
      if (v223 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v223 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v159;
      uint64_t v10 = v166;
      uint64_t v8 = v174;
      uint64_t v6 = v183;
      uint64_t v4 = v193;
      uint64_t v2 = v204;
      a1 = v216;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2744);
  uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v205 = v2;
    uint64_t v217 = a1;
    uint64_t v194 = v4;
    uint64_t v175 = v8;
    uint64_t v184 = v6;
    uint64_t v160 = v12;
    uint64_t v167 = v10;
    uint64_t v154 = v14;
    uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v14 = v154;
    uint64_t v12 = v160;
    uint64_t v10 = v167;
    uint64_t v8 = v175;
    uint64_t v6 = v184;
    uint64_t v4 = v194;
    uint64_t v2 = v205;
    int v100 = v99;
    a1 = v217;
    if (v100)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
      unint64_t v223 = 84;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v223;
      }
      unint64_t v103 = &v222[v102];
      unint64_t v104 = v223 - v102;
      if (v223 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v223 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v14 = v154;
      uint64_t v12 = v160;
      uint64_t v10 = v167;
      uint64_t v8 = v175;
      uint64_t v6 = v184;
      uint64_t v4 = v194;
      uint64_t v2 = v205;
      a1 = v217;
    }
  }
  uint64_t v16 = v15[6];
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v206 = v2;
    uint64_t v218 = a1;
    uint64_t v195 = v4;
    uint64_t v176 = v8;
    uint64_t v185 = v6;
    uint64_t v161 = v12;
    uint64_t v168 = v10;
    uint64_t v150 = v16;
    uint64_t v155 = v14;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v150;
    uint64_t v14 = v155;
    uint64_t v12 = v161;
    uint64_t v10 = v168;
    uint64_t v8 = v176;
    uint64_t v6 = v185;
    uint64_t v4 = v195;
    uint64_t v2 = v206;
    int v109 = v108;
    a1 = v218;
    if (v109)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v223 = 95;
      unint64_t v110 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v110) {
        unint64_t v111 = v110;
      }
      else {
        unint64_t v111 = v223;
      }
      unint64_t v112 = &v222[v111];
      unint64_t v113 = v223 - v111;
      if (v223 - v111 >= 0x12) {
        uint64_t v114 = 18;
      }
      else {
        uint64_t v114 = v223 - v111;
      }
      unint64_t v115 = v113 - v114;
      if (v115 >= v115 - 1) {
        uint64_t v116 = v115 - 1;
      }
      else {
        uint64_t v116 = v115;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v150;
      uint64_t v14 = v155;
      uint64_t v12 = v161;
      uint64_t v10 = v168;
      uint64_t v8 = v176;
      uint64_t v6 = v185;
      uint64_t v4 = v195;
      uint64_t v2 = v206;
      a1 = v218;
    }
  }
  uint64_t v18 = *(void *)(v17 + 2776);
  unint64_t v19 = 0x1E8EB8000uLL;
  {
    uint64_t v207 = v2;
    uint64_t v219 = a1;
    uint64_t v196 = v4;
    uint64_t v177 = v8;
    uint64_t v186 = v6;
    uint64_t v162 = v12;
    uint64_t v169 = v10;
    uint64_t v151 = v16;
    uint64_t v156 = v14;
    uint64_t v147 = v18;
    unint64_t v19 = 0x1E8EB8000;
    uint64_t v18 = v147;
    uint64_t v16 = v151;
    uint64_t v14 = v156;
    uint64_t v12 = v162;
    uint64_t v10 = v169;
    uint64_t v8 = v177;
    uint64_t v6 = v186;
    uint64_t v4 = v196;
    uint64_t v2 = v207;
    int v118 = v117;
    a1 = v219;
    if (v118)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v223 = 99;
      unint64_t v119 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v119) {
        unint64_t v120 = v119;
      }
      else {
        unint64_t v120 = v223;
      }
      unint64_t v121 = &v222[v120];
      unint64_t v122 = v223 - v120;
      if (v223 - v120 >= 0x12) {
        uint64_t v123 = 18;
      }
      else {
        uint64_t v123 = v223 - v120;
      }
      unint64_t v124 = v122 - v123;
      if (v124 >= v124 - 1) {
        uint64_t v125 = v124 - 1;
      }
      else {
        uint64_t v125 = v124;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v121[v123], v125);
      unint64_t v19 = 0x1E8EB8000;
      uint64_t v18 = v147;
      uint64_t v16 = v151;
      uint64_t v14 = v156;
      uint64_t v12 = v162;
      uint64_t v10 = v169;
      uint64_t v8 = v177;
      uint64_t v6 = v186;
      uint64_t v4 = v196;
      uint64_t v2 = v207;
      a1 = v219;
    }
  }
  uint64_t v20 = *(void *)(v19 + 2912);
  unint64_t v21 = 0x1E8EB8000uLL;
  {
    uint64_t v208 = v2;
    uint64_t v220 = a1;
    uint64_t v197 = v4;
    uint64_t v178 = v8;
    uint64_t v187 = v6;
    uint64_t v163 = v12;
    uint64_t v170 = v10;
    uint64_t v152 = v16;
    uint64_t v157 = v14;
    uint64_t v145 = v20;
    uint64_t v148 = v18;
    unint64_t v21 = 0x1E8EB8000;
    uint64_t v20 = v145;
    uint64_t v18 = v148;
    uint64_t v16 = v152;
    uint64_t v14 = v157;
    uint64_t v12 = v163;
    uint64_t v10 = v170;
    uint64_t v8 = v178;
    uint64_t v6 = v187;
    uint64_t v4 = v197;
    uint64_t v2 = v208;
    int v127 = v126;
    a1 = v220;
    if (v127)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v223 = 93;
      unint64_t v128 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v128) {
        unint64_t v129 = v128;
      }
      else {
        unint64_t v129 = v223;
      }
      unint64_t v130 = &v222[v129];
      unint64_t v131 = v223 - v129;
      if (v223 - v129 >= 0x12) {
        uint64_t v132 = 18;
      }
      else {
        uint64_t v132 = v223 - v129;
      }
      unint64_t v133 = v131 - v132;
      if (v133 >= v133 - 1) {
        uint64_t v134 = v133 - 1;
      }
      else {
        uint64_t v134 = v133;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v130[v132], v134);
      unint64_t v21 = 0x1E8EB8000;
      uint64_t v20 = v145;
      uint64_t v18 = v148;
      uint64_t v16 = v152;
      uint64_t v14 = v157;
      uint64_t v12 = v163;
      uint64_t v10 = v170;
      uint64_t v8 = v178;
      uint64_t v6 = v187;
      uint64_t v4 = v197;
      uint64_t v2 = v208;
      a1 = v220;
    }
  }
  uint64_t v22 = *(void *)(v21 + 3904);
  unint64_t v23 = 0x1E8EB8000uLL;
  {
    uint64_t v209 = v2;
    uint64_t v221 = a1;
    uint64_t v198 = v4;
    uint64_t v179 = v8;
    uint64_t v188 = v6;
    uint64_t v164 = v12;
    uint64_t v171 = v10;
    uint64_t v153 = v16;
    uint64_t v158 = v14;
    uint64_t v146 = v20;
    uint64_t v149 = v18;
    uint64_t v144 = v22;
    unint64_t v23 = 0x1E8EB8000;
    uint64_t v22 = v144;
    uint64_t v20 = v146;
    uint64_t v18 = v149;
    uint64_t v16 = v153;
    uint64_t v14 = v158;
    uint64_t v12 = v164;
    uint64_t v10 = v171;
    uint64_t v8 = v179;
    uint64_t v6 = v188;
    uint64_t v4 = v198;
    uint64_t v2 = v209;
    int v136 = v135;
    a1 = v221;
    if (v136)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      unint64_t v223 = 86;
      unint64_t v137 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v137) {
        unint64_t v138 = v137;
      }
      else {
        unint64_t v138 = v223;
      }
      unint64_t v139 = &v222[v138];
      unint64_t v140 = v223 - v138;
      if (v223 - v138 >= 0x12) {
        uint64_t v141 = 18;
      }
      else {
        uint64_t v141 = v223 - v138;
      }
      unint64_t v142 = v140 - v141;
      if (v142 >= v142 - 1) {
        uint64_t v143 = v142 - 1;
      }
      else {
        uint64_t v143 = v142;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v139[v141], v143);
      unint64_t v23 = 0x1E8EB8000;
      uint64_t v22 = v144;
      uint64_t v20 = v146;
      uint64_t v18 = v149;
      uint64_t v16 = v153;
      uint64_t v14 = v158;
      uint64_t v12 = v164;
      uint64_t v10 = v171;
      uint64_t v8 = v179;
      uint64_t v6 = v188;
      uint64_t v4 = v198;
      uint64_t v2 = v209;
      a1 = v221;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || *(void *)(v23 + 3752) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::ConstantOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroOperands(a1, v5)) {
    return 0;
  }
  uint64_t v7 = a1;
  if (!mlir::complex::ConstantOp::verifyInvariantsImpl((uint64_t **)&v7)) {
    return 0;
  }
  uint64_t v7 = a1;
  return mlir::complex::ConstantOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::complex::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.cos", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::CosOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5230;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::foldHook()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::CosOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::CosOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CosOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::CosOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::CosOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::CosOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.cos";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    unint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    unint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  BOOL v5 = (*(BOOL (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        BOOL v5 = v7;
      }
      else {
        BOOL v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::CreateOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, unsigned int *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                              + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x1E4F143B8];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          char v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      int64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          unint64_t v17 = (void *)*--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::CreateOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::CreateOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::CreateOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::CreateOpGenericAdaptorBase::CreateOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::CreateOp::fold((uint64_t)&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 4 == (unsigned int *)(v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>(uint64_t a1)
{
  uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v144 = a1;
    uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v28 = v27;
    a1 = v144;
    if (v28)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v154 = 83;
      unint64_t v29 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v29) {
        unint64_t v30 = v29;
      }
      else {
        unint64_t v30 = v154;
      }
      uint64_t v31 = &v153[v30];
      unint64_t v32 = v154 - v30;
      if (v154 - v30 >= 0x12) {
        uint64_t v33 = 18;
      }
      else {
        uint64_t v33 = v154 - v30;
      }
      unint64_t v34 = v32 - v33;
      if (v34 >= v34 - 1) {
        uint64_t v35 = v34 - 1;
      }
      else {
        uint64_t v35 = v34;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v31[v33], v35);
      uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v144;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v136 = v2;
    uint64_t v145 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v37 = v36;
    uint64_t v2 = v136;
    a1 = v145;
    if (v37)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v154 = 81;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v154;
      }
      int v40 = &v153[v39];
      unint64_t v41 = v154 - v39;
      if (v154 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v154 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v136;
      a1 = v145;
    }
  }
  uint64_t v4 = v3[27];
  unint64_t v5 = &unk_1E8EBA000;
  {
    uint64_t v137 = v2;
    uint64_t v146 = a1;
    uint64_t v129 = v4;
    unint64_t v5 = (void *)&unk_1E8EBA000;
    uint64_t v4 = v129;
    int v46 = v45;
    uint64_t v2 = v137;
    a1 = v146;
    if (v46)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<Empty>]";
      unint64_t v154 = 111;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v154;
      }
      unint64_t v49 = &v153[v48];
      unint64_t v50 = v154 - v48;
      if (v154 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v154 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v5 = (void *)&unk_1E8EBA000;
      uint64_t v4 = v129;
      uint64_t v2 = v137;
      a1 = v146;
    }
  }
  uint64_t v6 = v5[1];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v138 = v2;
    uint64_t v147 = a1;
    uint64_t v123 = v6;
    uint64_t v130 = v4;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v123;
    uint64_t v4 = v130;
    int v55 = v54;
    uint64_t v2 = v138;
    a1 = v147;
    if (v55)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v154 = 86;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v154;
      }
      unint64_t v58 = &v153[v57];
      unint64_t v59 = v154 - v57;
      if (v154 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v154 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v123;
      uint64_t v4 = v130;
      uint64_t v2 = v138;
      a1 = v147;
    }
  }
  uint64_t v8 = v7[12];
  unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v139 = v2;
    uint64_t v148 = a1;
    uint64_t v124 = v6;
    uint64_t v131 = v4;
    uint64_t v118 = v8;
    unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v118;
    uint64_t v6 = v124;
    uint64_t v4 = v131;
    int v64 = v63;
    uint64_t v2 = v139;
    a1 = v148;
    if (v64)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      unint64_t v154 = 90;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v154;
      }
      unint64_t v67 = &v153[v66];
      unint64_t v68 = v154 - v66;
      if (v154 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v154 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v118;
      uint64_t v6 = v124;
      uint64_t v4 = v131;
      uint64_t v2 = v139;
      a1 = v148;
    }
  }
  uint64_t v10 = v9[24];
  uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v140 = v2;
    uint64_t v149 = a1;
    uint64_t v125 = v6;
    uint64_t v132 = v4;
    uint64_t v114 = v10;
    uint64_t v119 = v8;
    uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v114;
    uint64_t v8 = v119;
    uint64_t v6 = v125;
    uint64_t v4 = v132;
    int v73 = v72;
    uint64_t v2 = v140;
    a1 = v149;
    if (v73)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v154 = 84;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v154;
      }
      unint64_t v76 = &v153[v75];
      unint64_t v77 = v154 - v75;
      if (v154 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v154 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v114;
      uint64_t v8 = v119;
      uint64_t v6 = v125;
      uint64_t v4 = v132;
      uint64_t v2 = v140;
      a1 = v149;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v141 = v2;
    uint64_t v150 = a1;
    uint64_t v126 = v6;
    uint64_t v133 = v4;
    uint64_t v115 = v10;
    uint64_t v120 = v8;
    uint64_t v111 = v12;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v111;
    uint64_t v10 = v115;
    uint64_t v8 = v120;
    uint64_t v6 = v126;
    uint64_t v4 = v133;
    int v82 = v81;
    uint64_t v2 = v141;
    a1 = v150;
    if (v82)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v154 = 95;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v154;
      }
      unint64_t v85 = &v153[v84];
      unint64_t v86 = v154 - v84;
      if (v154 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v154 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v111;
      uint64_t v10 = v115;
      uint64_t v8 = v120;
      uint64_t v6 = v126;
      uint64_t v4 = v133;
      uint64_t v2 = v141;
      a1 = v150;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2776);
  unint64_t v15 = 0x1E8EB8000uLL;
  {
    uint64_t v142 = v2;
    uint64_t v151 = a1;
    uint64_t v127 = v6;
    uint64_t v134 = v4;
    uint64_t v116 = v10;
    uint64_t v121 = v8;
    uint64_t v109 = v14;
    uint64_t v112 = v12;
    unint64_t v15 = 0x1E8EB8000;
    uint64_t v14 = v109;
    uint64_t v12 = v112;
    uint64_t v10 = v116;
    uint64_t v8 = v121;
    uint64_t v6 = v127;
    uint64_t v4 = v134;
    int v91 = v90;
    uint64_t v2 = v142;
    a1 = v151;
    if (v91)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v154 = 99;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v154;
      }
      unint64_t v94 = &v153[v93];
      unint64_t v95 = v154 - v93;
      if (v154 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v154 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unint64_t v15 = 0x1E8EB8000;
      uint64_t v14 = v109;
      uint64_t v12 = v112;
      uint64_t v10 = v116;
      uint64_t v8 = v121;
      uint64_t v6 = v127;
      uint64_t v4 = v134;
      uint64_t v2 = v142;
      a1 = v151;
    }
  }
  uint64_t v16 = *(void *)(v15 + 2912);
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v143 = v2;
    uint64_t v152 = a1;
    uint64_t v128 = v6;
    uint64_t v135 = v4;
    uint64_t v117 = v10;
    uint64_t v122 = v8;
    uint64_t v110 = v14;
    uint64_t v113 = v12;
    uint64_t v108 = v16;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v108;
    uint64_t v14 = v110;
    uint64_t v12 = v113;
    uint64_t v10 = v117;
    uint64_t v8 = v122;
    uint64_t v6 = v128;
    uint64_t v4 = v135;
    int v100 = v99;
    uint64_t v2 = v143;
    a1 = v152;
    if (v100)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v154 = 93;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v154;
      }
      unint64_t v103 = &v153[v102];
      unint64_t v104 = v154 - v102;
      if (v154 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v154 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v108;
      uint64_t v14 = v110;
      uint64_t v12 = v113;
      uint64_t v10 = v117;
      uint64_t v8 = v122;
      uint64_t v6 = v128;
      uint64_t v4 = v135;
      uint64_t v2 = v143;
      a1 = v152;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || *(void *)(v17 + 3904) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::AddIOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  uint64_t v6 = a1;
  return mlir::complex::CreateOp::verifyInvariantsImpl((uint64_t **)&v6) != 0;
}

uint64_t mlir::Op<mlir::complex::CreateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.div", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::DivOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C52F8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::foldHook()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::DivOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::DivOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::DivOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::DivOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::DivOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::DivOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.div";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::DivOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.eq", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::EqualOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5EB0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::EqualOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x1E4F143B8];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      char v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          char v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      unint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          unint64_t v17 = (void *)*--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        unint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::EqualOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::EqualOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::EqualOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::EqualOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::EqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.eq";
  v16[1] = 10;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(uint64_t a1)
{
  uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v187 = a1;
    uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v34 = v33;
    a1 = v187;
    if (v34)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v199 = 83;
      unint64_t v35 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v35) {
        unint64_t v36 = v35;
      }
      else {
        unint64_t v36 = v199;
      }
      int v37 = &v198[v36];
      unint64_t v38 = v199 - v36;
      if (v199 - v36 >= 0x12) {
        uint64_t v39 = 18;
      }
      else {
        uint64_t v39 = v199 - v36;
      }
      unint64_t v40 = v38 - v39;
      if (v40 >= v40 - 1) {
        uint64_t v41 = v40 - 1;
      }
      else {
        uint64_t v41 = v40;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v37[v39], v41);
      uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v187;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v177 = v2;
    uint64_t v188 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v43 = v42;
    uint64_t v2 = v177;
    a1 = v188;
    if (v43)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v199 = 81;
      unint64_t v44 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v44) {
        unint64_t v45 = v44;
      }
      else {
        unint64_t v45 = v199;
      }
      int v46 = &v198[v45];
      unint64_t v47 = v199 - v45;
      if (v199 - v45 >= 0x12) {
        uint64_t v48 = 18;
      }
      else {
        uint64_t v48 = v199 - v45;
      }
      unint64_t v49 = v47 - v48;
      if (v49 >= v49 - 1) {
        uint64_t v50 = v49 - 1;
      }
      else {
        uint64_t v50 = v49;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v46[v48], v50);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v177;
      a1 = v188;
    }
  }
  uint64_t v4 = v3[27];
  unint64_t v5 = &unk_1E8EBA000;
  {
    uint64_t v178 = v2;
    uint64_t v189 = a1;
    uint64_t v168 = v4;
    unint64_t v5 = (void *)&unk_1E8EBA000;
    uint64_t v4 = v168;
    uint64_t v2 = v178;
    int v52 = v51;
    a1 = v189;
    if (v52)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<Empty>]";
      unint64_t v199 = 111;
      unint64_t v53 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v53) {
        unint64_t v54 = v53;
      }
      else {
        unint64_t v54 = v199;
      }
      int v55 = &v198[v54];
      unint64_t v56 = v199 - v54;
      if (v199 - v54 >= 0x12) {
        uint64_t v57 = 18;
      }
      else {
        uint64_t v57 = v199 - v54;
      }
      unint64_t v58 = v56 - v57;
      if (v58 >= v58 - 1) {
        uint64_t v59 = v58 - 1;
      }
      else {
        uint64_t v59 = v58;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v55[v57], v59);
      unint64_t v5 = (void *)&unk_1E8EBA000;
      uint64_t v4 = v168;
      uint64_t v2 = v178;
      a1 = v189;
    }
  }
  uint64_t v6 = v5[17];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v179 = v2;
    uint64_t v190 = a1;
    uint64_t v169 = v4;
    uint64_t v160 = v6;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v160;
    uint64_t v4 = v169;
    uint64_t v2 = v179;
    int v61 = v60;
    a1 = v190;
    if (v61)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v199 = 86;
      unint64_t v62 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v62) {
        unint64_t v63 = v62;
      }
      else {
        unint64_t v63 = v199;
      }
      int v64 = &v198[v63];
      unint64_t v65 = v199 - v63;
      if (v199 - v63 >= 0x12) {
        uint64_t v66 = 18;
      }
      else {
        uint64_t v66 = v199 - v63;
      }
      unint64_t v67 = v65 - v66;
      if (v67 >= v67 - 1) {
        uint64_t v68 = v67 - 1;
      }
      else {
        uint64_t v68 = v67;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v64[v66], v68);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v160;
      uint64_t v4 = v169;
      uint64_t v2 = v179;
      a1 = v190;
    }
  }
  uint64_t v8 = v7[12];
  uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v180 = v2;
    uint64_t v191 = a1;
    uint64_t v170 = v4;
    uint64_t v153 = v8;
    uint64_t v161 = v6;
    uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v153;
    uint64_t v6 = v161;
    uint64_t v4 = v170;
    uint64_t v2 = v180;
    int v70 = v69;
    a1 = v191;
    if (v70)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      unint64_t v199 = 90;
      unint64_t v71 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v71) {
        unint64_t v72 = v71;
      }
      else {
        unint64_t v72 = v199;
      }
      int v73 = &v198[v72];
      unint64_t v74 = v199 - v72;
      if (v199 - v72 >= 0x12) {
        uint64_t v75 = 18;
      }
      else {
        uint64_t v75 = v199 - v72;
      }
      unint64_t v76 = v74 - v75;
      if (v76 >= v76 - 1) {
        uint64_t v77 = v76 - 1;
      }
      else {
        uint64_t v77 = v76;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v73[v75], v77);
      uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v153;
      uint64_t v6 = v161;
      uint64_t v4 = v170;
      uint64_t v2 = v180;
      a1 = v191;
    }
  }
  uint64_t v10 = v9[24];
  char v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v181 = v2;
    uint64_t v192 = a1;
    uint64_t v171 = v4;
    uint64_t v154 = v8;
    uint64_t v162 = v6;
    uint64_t v147 = v10;
    char v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v147;
    uint64_t v8 = v154;
    uint64_t v6 = v162;
    uint64_t v4 = v171;
    uint64_t v2 = v181;
    int v79 = v78;
    a1 = v192;
    if (v79)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v199 = 84;
      unint64_t v80 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v80) {
        unint64_t v81 = v80;
      }
      else {
        unint64_t v81 = v199;
      }
      int v82 = &v198[v81];
      unint64_t v83 = v199 - v81;
      if (v199 - v81 >= 0x12) {
        uint64_t v84 = 18;
      }
      else {
        uint64_t v84 = v199 - v81;
      }
      unint64_t v85 = v83 - v84;
      if (v85 >= v85 - 1) {
        uint64_t v86 = v85 - 1;
      }
      else {
        uint64_t v86 = v85;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v82[v84], v86);
      char v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v147;
      uint64_t v8 = v154;
      uint64_t v6 = v162;
      uint64_t v4 = v171;
      uint64_t v2 = v181;
      a1 = v192;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v182 = v2;
    uint64_t v193 = a1;
    uint64_t v172 = v4;
    uint64_t v155 = v8;
    uint64_t v163 = v6;
    uint64_t v142 = v12;
    uint64_t v148 = v10;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v142;
    uint64_t v10 = v148;
    uint64_t v8 = v155;
    uint64_t v6 = v163;
    uint64_t v4 = v172;
    uint64_t v2 = v182;
    int v88 = v87;
    a1 = v193;
    if (v88)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v199 = 95;
      unint64_t v89 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v89) {
        unint64_t v90 = v89;
      }
      else {
        unint64_t v90 = v199;
      }
      int v91 = &v198[v90];
      unint64_t v92 = v199 - v90;
      if (v199 - v90 >= 0x12) {
        uint64_t v93 = 18;
      }
      else {
        uint64_t v93 = v199 - v90;
      }
      unint64_t v94 = v92 - v93;
      if (v94 >= v94 - 1) {
        uint64_t v95 = v94 - 1;
      }
      else {
        uint64_t v95 = v94;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v91[v93], v95);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v142;
      uint64_t v10 = v148;
      uint64_t v8 = v155;
      uint64_t v6 = v163;
      uint64_t v4 = v172;
      uint64_t v2 = v182;
      a1 = v193;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2776);
  unint64_t v15 = 0x1E8EB8000uLL;
  {
    uint64_t v183 = v2;
    uint64_t v194 = a1;
    uint64_t v173 = v4;
    uint64_t v156 = v8;
    uint64_t v164 = v6;
    uint64_t v143 = v12;
    uint64_t v149 = v10;
    uint64_t v138 = v14;
    unint64_t v15 = 0x1E8EB8000;
    uint64_t v14 = v138;
    uint64_t v12 = v143;
    uint64_t v10 = v149;
    uint64_t v8 = v156;
    uint64_t v6 = v164;
    uint64_t v4 = v173;
    uint64_t v2 = v183;
    int v97 = v96;
    a1 = v194;
    if (v97)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v199 = 99;
      unint64_t v98 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v98) {
        unint64_t v99 = v98;
      }
      else {
        unint64_t v99 = v199;
      }
      int v100 = &v198[v99];
      unint64_t v101 = v199 - v99;
      if (v199 - v99 >= 0x12) {
        uint64_t v102 = 18;
      }
      else {
        uint64_t v102 = v199 - v99;
      }
      unint64_t v103 = v101 - v102;
      if (v103 >= v103 - 1) {
        uint64_t v104 = v103 - 1;
      }
      else {
        uint64_t v104 = v103;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v100[v102], v104);
      unint64_t v15 = 0x1E8EB8000;
      uint64_t v14 = v138;
      uint64_t v12 = v143;
      uint64_t v10 = v149;
      uint64_t v8 = v156;
      uint64_t v6 = v164;
      uint64_t v4 = v173;
      uint64_t v2 = v183;
      a1 = v194;
    }
  }
  uint64_t v16 = *(void *)(v15 + 2912);
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v184 = v2;
    uint64_t v195 = a1;
    uint64_t v174 = v4;
    uint64_t v157 = v8;
    uint64_t v165 = v6;
    uint64_t v144 = v12;
    uint64_t v150 = v10;
    uint64_t v135 = v16;
    uint64_t v139 = v14;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v135;
    uint64_t v14 = v139;
    uint64_t v12 = v144;
    uint64_t v10 = v150;
    uint64_t v8 = v157;
    uint64_t v6 = v165;
    uint64_t v4 = v174;
    uint64_t v2 = v184;
    int v106 = v105;
    a1 = v195;
    if (v106)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v199 = 93;
      unint64_t v107 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v107) {
        unint64_t v108 = v107;
      }
      else {
        unint64_t v108 = v199;
      }
      uint64_t v109 = &v198[v108];
      unint64_t v110 = v199 - v108;
      if (v199 - v108 >= 0x12) {
        uint64_t v111 = 18;
      }
      else {
        uint64_t v111 = v199 - v108;
      }
      unint64_t v112 = v110 - v111;
      if (v112 >= v112 - 1) {
        uint64_t v113 = v112 - 1;
      }
      else {
        uint64_t v113 = v112;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v109[v111], v113);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v135;
      uint64_t v14 = v139;
      uint64_t v12 = v144;
      uint64_t v10 = v150;
      uint64_t v8 = v157;
      uint64_t v6 = v165;
      uint64_t v4 = v174;
      uint64_t v2 = v184;
      a1 = v195;
    }
  }
  uint64_t v18 = *(void *)(v17 + 3904);
  uint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v185 = v2;
    uint64_t v196 = a1;
    uint64_t v175 = v4;
    uint64_t v158 = v8;
    uint64_t v166 = v6;
    uint64_t v145 = v12;
    uint64_t v151 = v10;
    uint64_t v136 = v16;
    uint64_t v140 = v14;
    uint64_t v133 = v18;
    uint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v18 = v133;
    uint64_t v16 = v136;
    uint64_t v14 = v140;
    uint64_t v12 = v145;
    uint64_t v10 = v151;
    uint64_t v8 = v158;
    uint64_t v6 = v166;
    uint64_t v4 = v175;
    uint64_t v2 = v185;
    int v115 = v114;
    a1 = v196;
    if (v115)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Elementwise<Empty>]";
      unint64_t v199 = 83;
      unint64_t v116 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v116) {
        unint64_t v117 = v116;
      }
      else {
        unint64_t v117 = v199;
      }
      uint64_t v118 = &v198[v117];
      unint64_t v119 = v199 - v117;
      if (v199 - v117 >= 0x12) {
        uint64_t v120 = 18;
      }
      else {
        uint64_t v120 = v199 - v117;
      }
      unint64_t v121 = v119 - v120;
      if (v121 >= v121 - 1) {
        uint64_t v122 = v121 - 1;
      }
      else {
        uint64_t v122 = v121;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::Elementwise<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Elementwise>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v118[v120], v122);
      uint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v18 = v133;
      uint64_t v16 = v136;
      uint64_t v14 = v140;
      uint64_t v12 = v145;
      uint64_t v10 = v151;
      uint64_t v8 = v158;
      uint64_t v6 = v166;
      uint64_t v4 = v175;
      uint64_t v2 = v185;
      a1 = v196;
    }
  }
  uint64_t v20 = v19[372];
  unint64_t v21 = 0x1E8EB8000uLL;
  {
    uint64_t v186 = v2;
    uint64_t v197 = a1;
    uint64_t v176 = v4;
    uint64_t v159 = v8;
    uint64_t v167 = v6;
    uint64_t v146 = v12;
    uint64_t v152 = v10;
    uint64_t v137 = v16;
    uint64_t v141 = v14;
    uint64_t v132 = v20;
    uint64_t v134 = v18;
    unint64_t v21 = 0x1E8EB8000;
    uint64_t v20 = v132;
    uint64_t v18 = v134;
    uint64_t v16 = v137;
    uint64_t v14 = v141;
    uint64_t v12 = v146;
    uint64_t v10 = v152;
    uint64_t v8 = v159;
    uint64_t v6 = v167;
    uint64_t v4 = v176;
    uint64_t v2 = v186;
    int v124 = v123;
    a1 = v197;
    if (v124)
    {
      uint64_t v198 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      unint64_t v199 = 90;
      unint64_t v125 = llvm::StringRef::find((uint64_t *)&v198, "DesiredTypeName = ", 0x12uLL, 0);
      if (v199 >= v125) {
        unint64_t v126 = v125;
      }
      else {
        unint64_t v126 = v199;
      }
      uint64_t v127 = &v198[v126];
      unint64_t v128 = v199 - v126;
      if (v199 - v126 >= 0x12) {
        uint64_t v129 = 18;
      }
      else {
        uint64_t v129 = v199 - v126;
      }
      unint64_t v130 = v128 - v129;
      if (v130 >= v130 - 1) {
        uint64_t v131 = v130 - 1;
      }
      else {
        uint64_t v131 = v130;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v127[v129], v131);
      unint64_t v21 = 0x1E8EB8000;
      uint64_t v20 = v132;
      uint64_t v18 = v134;
      uint64_t v16 = v137;
      uint64_t v14 = v141;
      uint64_t v12 = v146;
      uint64_t v10 = v152;
      uint64_t v8 = v159;
      uint64_t v6 = v167;
      uint64_t v4 = v176;
      uint64_t v2 = v186;
      a1 = v197;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || *(void *)(v21 + 3856) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::MulSIExtendedOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (uint64_t v7 = a1, mlir::complex::EqualOp::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::EqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.exp", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ExpOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C53C0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  BOOL v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        char v11 = v13;
      }
      else {
        char v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::ExpOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        char v10 = v11;
      }
      else {
        char v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ExpOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ExpOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ExpOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ExpOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ExpOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.exp";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::ExpOpGenericAdaptorBase::ExpOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::ExpOp::fold((uint64_t)&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::ExpOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.expm1", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Expm1Op,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5F78;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::Expm1Op::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Expm1Op>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Expm1Op>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Expm1Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Expm1Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Expm1Op>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.expm1";
  v16[1] = 13;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Expm1Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.im", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ImOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C4F10;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  BOOL v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getCanonicalizationPatterns(uint64_t a1, void *a2, uint64_t a3)
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        BOOL v5 = v7;
      }
      else {
        BOOL v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::ImOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    BOOL v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    BOOL v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ImOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ImOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ImOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ImOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ImOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.im";
  v16[1] = 10;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::ImOpGenericAdaptorBase::ImOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::ImOp::fold((uint64_t)&v13, (uint64_t)v14);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (unint64_t v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.log1p", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::Log1pOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C6040;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::foldHook()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::Log1pOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::Log1pOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::Log1pOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Log1pOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::Log1pOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::Log1pOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.log1p";
  v16[1] = 13;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::Log1pOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.log", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::LogOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5488;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  BOOL v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        char v11 = v13;
      }
      else {
        char v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::LogOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        char v10 = v11;
      }
      else {
        char v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::LogOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::LogOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::LogOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::LogOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::LogOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.log";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::LogOpGenericAdaptorBase::LogOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::LogOp::fold((uint64_t)&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::LogOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.mul", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::MulOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5550;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  BOOL v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        BOOL v5 = v7;
      }
      else {
        BOOL v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::MulOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    BOOL v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    BOOL v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::MulOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::MulOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::MulOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::MulOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::MulOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.mul";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::MulOpGenericAdaptorBase::MulOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::MulOp::fold((uint64_t)&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::MulOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.neg", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NegOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5618;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  BOOL v5 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        BOOL v5 = v7;
      }
      else {
        BOOL v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::NegOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    BOOL v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    BOOL v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::NegOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NegOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NegOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NegOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NegOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.neg";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::NegOpGenericAdaptorBase::NegOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::NegOp::fold((uint64_t)&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::NegOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.neq", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NotEqualOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C4E48;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::foldHook()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::NotEqualOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x1E4F143B8];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    uint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = (void *)*--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::NotEqualOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::NotEqualOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NotEqualOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::NotEqualOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::NotEqualOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::complex::EqualOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.neq";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::MulSIExtendedOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::EqualOp>,mlir::OpTrait::OneResult<mlir::complex::EqualOp>,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::EqualOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::EqualOp>,mlir::OpTrait::OpInvariants<mlir::complex::EqualOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::EqualOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::EqualOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::EqualOp>,mlir::OpTrait::Elementwise<mlir::complex::EqualOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::EqualOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::NotEqualOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::IntegerType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.pow", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::PowOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C56E0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::foldHook()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::PowOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::PowOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::PowOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::PowOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::PowOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::PowOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.pow";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::PowOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.re", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::ReOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C4FD8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  BOOL v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        char v11 = v13;
      }
      else {
        char v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getCanonicalizationPatterns(uint64_t a1, void *a2, uint64_t a3)
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::ReOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        char v10 = v11;
      }
      else {
        char v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::ReOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::ReOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ReOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::ReOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::ReOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::complex::AbsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.re";
  v16[1] = 10;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::ReOpGenericAdaptorBase::ReOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::ReOp::fold((uint64_t)&v13, (uint64_t)v14);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand(a1, v5)
    && (unint64_t v8 = a1, mlir::complex::AbsOp::verifyInvariantsImpl((uint64_t **)&v8)))
  {
    return mlir::OpTrait::impl::verifyElementwise(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::complex::ReOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::FloatType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.rsqrt", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::RsqrtOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C6108;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::foldHook()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::RsqrtOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::RsqrtOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::RsqrtOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::RsqrtOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::RsqrtOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::RsqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.rsqrt";
  v16[1] = 13;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::RsqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sign", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SignOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5AC8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SignOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SignOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SignOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SignOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SignOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SignOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.sign";
  v16[1] = 12;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SignOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sin", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SinOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C57A8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SinOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SinOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SinOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SinOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SinOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SinOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.sin";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SinOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sqrt", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SqrtOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5B90;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::SqrtOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SqrtOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SqrtOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SqrtOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SqrtOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SqrtOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.sqrt";
  v16[1] = 12;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SqrtOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.sub", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::SubOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5870;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  unint64_t v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  BOOL v9 = (*(BOOL (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                            + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  char v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0) {
        char v11 = v13;
      }
      else {
        char v11 = (llvm **)v13[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0) {
      llvm::deallocate_buffer(v13[0], v13[1]);
    }
  }
  return v9;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::complex::SubOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        char v10 = v11;
      }
      else {
        char v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::SubOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::SubOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SubOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::SubOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::SubOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.sub";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

BOOL llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = a2;
  mlir::complex::detail::SubOpGenericAdaptorBase::SubOpGenericAdaptorBase((uint64_t)v14, a2);
  uint64_t v15 = a3;
  uint64_t v16 = a4;
  unint64_t v9 = mlir::complex::SubOp::fold(&v13);
  unint64_t v10 = v9;
  if (v9 < 8 || a2 - 16 == (v9 & ((uint64_t)(v9 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8)) {
    return v9 > 7;
  }
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::arith::AddFOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::AddOp>,mlir::OpTrait::OneResult<mlir::complex::AddOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::AddOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::AddOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::complex::AddOp>,mlir::OpTrait::OpInvariants<mlir::complex::AddOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::AddOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::AddOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::AddOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::AddOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::AddOp>,mlir::OpTrait::Elementwise<mlir::complex::AddOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::AddOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::AddOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::SubOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.tan", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::TanOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5938;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::TanOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.tan";
  v16[1] = 11;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::TanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"complex.tanh", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::TanhOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9C5C58;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::complex::TanhOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::arith::AddFOp::getInherentAttr(Context, v8, a3, a4);
}

void *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::arith::AddFOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::arith::AddFOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::arith::AddFOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::initProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, mlir::MLIRContext **a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::arith::AddFOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::arith::AddFOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::AddFOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::complex::TanhOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::arith::AddFOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::complex::TanhOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  mlir::GenericProgramPoint::~GenericProgramPoint((mlir::GenericProgramPoint *)&v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathFlagsAttr;
  v2[1] = mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathAttrName;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::arith::ArithFastMathInterface]";
      unint64_t v14 = 85;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::arith::ArithFastMathInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2848), v2);
}

uint64_t mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathFlagsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = a2;
  return mlir::arith::AddFOp::getFastmathAttr((mlir::arith::AddFOp *)&v3);
}

const char *mlir::arith::detail::ArithFastMathInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::getFastMathAttrName()
{
  return "fastmath";
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x18uLL);
  *uint64_t v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::isCompatibleReturnTypes;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      unint64_t v14 = 76;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3864), v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanhOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

BOOL mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::complex::TanhOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a2 == a4
      && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(a1, 0, a1, a2, a3, 0, a3, a2);
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::complex::TanhOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11 = a3;
  void v22[4] = *MEMORY[0x1E4F143B8];
  int64_t v20 = v22;
  uint64_t v21 = 0x400000000;
  if (!mlir::arith::AddFOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v20))
  {
    uint64_t v13 = 0;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v18, (uint64_t)v20, v21);
  mlir::ValueRange::ValueRange(v17, *(void *)a11, *(unsigned int *)(a11 + 8));
  if (v19 == v17[1]
    && std::__equal_impl[abi:nn180100]<llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,llvm::detail::indexed_accessor_range_base<mlir::TypeRange,llvm::PointerUnion<mlir::Value const*,mlir::Type const*,mlir::OpOperand *,mlir::detail::OpResultImpl *>,mlir::Type,mlir::Type,mlir::Type>::iterator,std::__equal_to,std::__identity,std::__identity>(v18, 0, v18, v19, v17[0], 0, v17[0], v19))
  {
    uint64_t v13 = 1;
    unint64_t v14 = v20;
    if (v20 == v22) {
      return v13;
    }
    goto LABEL_7;
  }
  v16[0] = "complex.tanh";
  v16[1] = 12;
  uint64_t v13 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v16, "' op inferred type(s) ", (uint64_t)&v20, " are incompatible with return type(s) of operation ", a11);
  unint64_t v14 = v20;
  if (v20 != v22) {
LABEL_7:
  }
    free(v14);
  return v13;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::complex::AbsOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::complex::ConjOp>,mlir::OpTrait::OneResult<mlir::complex::ConjOp>,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl<mlir::complex::ConjOp>,mlir::OpTrait::ZeroSuccessors<mlir::complex::ConjOp>,mlir::OpTrait::OneOperand<mlir::complex::ConjOp>,mlir::OpTrait::OpInvariants<mlir::complex::ConjOp>,mlir::BytecodeOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::complex::ConjOp>,mlir::ConditionallySpeculatable::Trait<mlir::complex::ConjOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::complex::ConjOp>,mlir::MemoryEffectOpInterface::Trait<mlir::complex::ConjOp>,mlir::OpTrait::Elementwise<mlir::complex::ConjOp>,mlir::arith::ArithFastMathInterface::Trait<mlir::complex::ConjOp>,mlir::InferTypeOpInterface::Trait<mlir::complex::ConjOp>>(a1, a2);
}

BOOL mlir::Op<mlir::complex::TanhOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::ComplexType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Elementwise,mlir::arith::ArithFastMathInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t *mlir::Dialect::addAttribute<mlir::complex::NumberAttr>(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  mlir::AbstractAttribute::get<mlir::complex::NumberAttr>(a1, (uint64_t)v10);
  mlir::Dialect::addAttribute(a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v10);
  char v2 = v15;
  if (v15 >= 8)
  {
    if ((v15 & 4) != 0)
    {
      if ((v15 & 2) != 0) {
        unint64_t v3 = v14;
      }
      else {
        unint64_t v3 = (llvm **)v14[0];
      }
      (*(void (**)(llvm **))((v15 & 0xFFFFFFFFFFFFFFF8) + 16))(v3);
    }
    if ((v2 & 2) == 0) {
      llvm::deallocate_buffer(v14[0], v14[1]);
    }
  }
  int v4 = (uint64_t *)v11;
  if (v12)
  {
    uint64_t v5 = 16 * v12;
    unint64_t v6 = (void **)((char *)v11 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = (uint64_t *)v11;
  }
  if (v4 != &v13) {
    free(v4);
  }
  AttributeUniquer = (uint64_t *)mlir::MLIRContext::getAttributeUniquer(*(mlir::MLIRContext **)(a1 + 32));
  return mlir::StorageUniquer::registerParametricStorageTypeImpl(AttributeUniquer, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)llvm::function_ref<void ()(mlir::StorageUniquer::BaseStorage *)>::callback_fn<void mlir::StorageUniquer::registerParametricStorageType<mlir::complex::detail::NumberAttrStorage>(mlir::TypeID)::{lambda(mlir::StorageUniquer::BaseStorage *)#1}>, (uint64_t)v10);
}

void mlir::AbstractAttribute::get<mlir::complex::NumberAttr>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  v13[6] = *MEMORY[0x1E4F143B8];
  char v11 = v13;
  uint64_t v12 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>>((uint64_t)&v11);
  *(void *)a2 = a1;
  *(void *)(a2 + 8) = a2 + 24;
  *(void *)(a2 + 16) = 0x300000000;
  if (v12) {
    llvm::SmallVectorImpl<std::pair<mlir::TypeID,void *>>::operator=(a2 + 8, (uint64_t)&v11);
  }
  *(void *)(a2 + 96) = (char *)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks
                       + 2;
  if ((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<BOOL (*)(mlir::TypeID),BOOL (* const)(mlir::TypeID),void>::Callbacks
     + 2 >= 8)
  {
    *(void *)(a2 + 72) = mlir::detail::StorageUserBase<mlir::complex::NumberAttr,mlir::Attribute,mlir::complex::detail::NumberAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke;
    *(_OWORD *)(a2 + 80) = v10;
  }
  *(void *)(a2 + 104) = _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSD_6detail17NumberAttrStorageENSB_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_;
  *(void *)(a2 + 112) = &v9;
  *(void *)(a2 + 120) = _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSC_6detail17NumberAttrStorageENSA_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_;
  *(void *)(a2 + 128) = &v8;
  *(void *)(a2 + 136) = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  int v4 = v11;
  if (v12)
  {
    uint64_t v5 = 16 * v12;
    unint64_t v6 = (void **)((char *)v11 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v11;
  }
  if (v4 != v13) {
    free(v4);
  }
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>>(uint64_t a1)
{
  char v2 = malloc(8uLL);
  *char v2 = mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>::getType;
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v12 = v2;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    char v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypedAttr]";
      unint64_t v14 = 65;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::TypedAttr,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      char v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v3[28], v2);
}

uint64_t mlir::detail::TypedAttrInterfaceTraits::Model<mlir::complex::NumberAttr>::getType(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 72);
}

BOOL mlir::detail::StorageUserBase<mlir::complex::NumberAttr,mlir::Attribute,mlir::complex::detail::NumberAttrStorage,mlir::detail::AttributeUniquer,mlir::TypedAttr::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1}::__invoke(uint64_t a1)
{
  uint64_t v1 = &unk_1E8EBA000;
  {
    uint64_t v12 = a1;
    uint64_t v1 = (void *)&unk_1E8EBA000;
    int v4 = v3;
    a1 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypedAttr::Trait<Empty>]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::TypedAttr::Trait<mlir::TypeID mlir::TypeID::get<mlir::TypedAttr::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      uint64_t v1 = (void *)&unk_1E8EBA000;
      a1 = v12;
    }
  }
  return v1[51] == a1;
}

void _ZN4llvm12function_refIFvN4mlir9AttributeENS0_IFvS2_EEENS0_IFvNS1_4TypeEEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSD_6detail17NumberAttrStorageENSB_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE29getWalkImmediateSubElementsFnEvEUlT_S4_S7_E_EEvlS2_S4_S7_(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
}

void mlir::detail::walkImmediateSubElementsImpl<mlir::complex::NumberAttr>(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  unint64_t v10 = (const llvm::detail::DoubleAPFloat *)(a1 + 2);
  uint64_t v11 = (void *)a1[2];
  uint64_t v12 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v12 == v11) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v15, v10);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v15, v10);
  }
  uint64_t v13 = (const llvm::detail::DoubleAPFloat *)(a1 + 6);
  if (v12 == (void *)a1[6]) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v16, v13);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v16, v13);
  }
  uint64_t v17 = a1[9];
  v14[0] = a2;
  v14[1] = a3;
  v14[2] = a4;
  v14[3] = a5;
  mlir::AttrTypeImmediateSubElementWalker::walk((uint64_t)v14, v17);
  if (v12 == (void *)v16[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v16);
    if (v12 != (void *)v15[0]) {
      goto LABEL_9;
    }
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v15);
    return;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v16);
  if (v12 == (void *)v15[0]) {
    goto LABEL_12;
  }
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v15);
}

uint64_t _ZN4llvm12function_refIFN4mlir9AttributeES2_NS_8ArrayRefIS2_EENS3_INS1_4TypeEEEEE11callback_fnIZNS1_6detail15StorageUserBaseINS1_7complex10NumberAttrES2_NSC_6detail17NumberAttrStorageENSA_16AttributeUniquerEJNS1_9TypedAttr5TraitEEE32getReplaceImmediateSubElementsFnEvEUlT_S4_S6_E_EES2_lS2_S4_S6_(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t *a6)
{
  v8[0] = a3;
  v8[1] = a4;
  v7[0] = a5;
  v7[1] = a6;
  return mlir::detail::replaceImmediateSubElementsImpl<mlir::complex::NumberAttr>(a2, (uint64_t)v8, v7);
}

uint64_t mlir::detail::replaceImmediateSubElementsImpl<mlir::complex::NumberAttr>(void *a1, uint64_t a2, uint64_t **a3)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unint64_t v15 = a1;
  unint64_t v5 = (const llvm::detail::DoubleAPFloat *)(a1 + 2);
  unint64_t v6 = (void *)a1[2];
  uint64_t v7 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v7 == v6) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18, v5);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v18, v5);
  }
  unint64_t v8 = (const llvm::detail::DoubleAPFloat *)(a1 + 6);
  if (v7 == (void *)a1[6])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20, v8);
    uint64_t v21 = a1[9];
    if (v21) {
      goto LABEL_6;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v20, v8);
    uint64_t v21 = a1[9];
    if (v21)
    {
LABEL_6:
      uint64_t v9 = **a3;
      goto LABEL_9;
    }
  }
  uint64_t v9 = 0;
LABEL_9:
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  uint64_t v14 = v9;
  AttributeUniquer = (llvm::APFloatBase *)mlir::MLIRContext::getAttributeUniquer(Context);
  v16[0] = &mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id;
  v16[1] = Context;
  uint64_t v12 = mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRKNS_7APFloatESF_RNS1_4TypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_, (uint64_t)v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::complex::NumberAttr,void>::id, (uint64_t)v17, (uint64_t)&v19, &v14);
  if (v7 == (void *)v20[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v7 != (void *)v18[0]) {
      goto LABEL_11;
    }
LABEL_14:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
    return v12;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v7 == (void *)v18[0]) {
    goto LABEL_14;
  }
LABEL_11:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
  return v12;
}

uint64_t mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  v25[1] = *MEMORY[0x1E4F143B8];
  v20[0] = a2;
  v20[1] = a3;
  uint64_t v11 = (const llvm::detail::DoubleAPFloat *)(a5 + 8);
  uint64_t v12 = *(void **)(a5 + 8);
  uint64_t v13 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v13 == v12) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22, v11);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v22, v11);
  }
  uint64_t v14 = (const llvm::detail::DoubleAPFloat *)(a6 + 8);
  if (v13 == *(void **)(a6 + 8)) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24, v14);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v24, v14);
  }
  v25[0] = *a7;
  unsigned int v15 = llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>((llvm *)v21, (const llvm::APFloat *)&v23, v25);
  v18[0] = v21;
  v18[1] = v20;
  uint64_t v19 = v21;
  uint64_t ParametricStorageTypeImpl = mlir::StorageUniquer::getParametricStorageTypeImpl((unsigned __int8 **)a1, a4, v15, (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v19, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v18);
  if (v13 == (void *)v24[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if (v13 != (void *)v22[0]) {
      goto LABEL_9;
    }
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return ParametricStorageTypeImpl;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
  if (v13 == (void *)v22[0]) {
    goto LABEL_12;
  }
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return ParametricStorageTypeImpl;
}

unint64_t llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>(llvm *a1, const llvm::APFloat *a2, _DWORD *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v17 = 0;
  memset(v16, 0, sizeof(v16));
  memset(v15, 0, sizeof(v15));
  {
    unint64_t v10 = a1;
    a1 = v10;
    if (v11)
    {
      unint64_t v12 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v12 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v12;
      a1 = v10;
    }
  }
  uint64_t v18 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(void *)&v15[0] = llvm::hash_value(a1, a2);
  unint64_t v13 = 0;
  unint64_t v6 = llvm::hash_value(a2, v5);
  uint64_t v7 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v15, (uint64_t *)&v13, (void *)v15 + 1, (unint64_t)v16, v6);
  unint64_t v14 = v13;
  unint64_t v8 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v15, (uint64_t *)&v14, v7, (unint64_t)v16, (*a3 >> 4) ^ (*a3 >> 9));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine((llvm::hashing::detail::hash_combine_recursive_helper *)v15, v14, v8, (char *)v16);
}

uint64_t llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(llvm::APFloatBase *a1, void *a2)
{
  uint64_t v2 = *(void *)a1;
  int v3 = (llvm::detail::DoubleAPFloat *)(a2 + 2);
  int v4 = (void *)a2[2];
  unint64_t v5 = (const llvm::detail::DoubleAPFloat *)(*(void *)a1 + 8);
  if (v4 != *(void **)v5) {
    return 0;
  }
  unint64_t v8 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v8 == v4)
  {
    uint64_t result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v3, v5);
    if (!result) {
      return result;
    }
  }
  else if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v3, v5))
  {
    return 0;
  }
  uint64_t v9 = (llvm::detail::IEEEFloat *)(a2 + 6);
  unint64_t v10 = (void *)a2[6];
  int v11 = (const llvm::detail::IEEEFloat *)(v2 + 40);
  if (v10 != *(void **)(v2 + 40)) {
    return 0;
  }
  if (v8 != v10)
  {
    if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v9, v11)) {
      return 0;
    }
    return a2[9] == *(void *)(v2 + 64);
  }
  uint64_t result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v9, v11);
  if (result) {
    return a2[9] == *(void *)(v2 + 64);
  }
  return result;
}

void *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat const&,llvm::APFloat const&,mlir::Type &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t *a2)
{
  int v3 = mlir::complex::detail::NumberAttrStorage::construct(a2, *(void **)a1);
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(void *)v4) {
    (*(void (**)(void, void *))v4)(*(void *)(v4 + 8), v3);
  }
  return v3;
}

void *mlir::complex::detail::NumberAttrStorage::construct(uint64_t *a1, void *a2)
{
  void v21[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a2 + 1;
  unint64_t v5 = (void *)a2[1];
  unint64_t v6 = llvm::APFloatBase::PPCDoubleDouble((llvm::APFloatBase *)a1);
  if (v6 == v5) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v21, v4);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v21, (uint64_t)v4);
  }
  uint64_t v7 = a2 + 5;
  if (v6 == (void *)a2[5])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v20, v7);
    uint64_t v8 = a2[8];
    a1[10] += 80;
    uint64_t v9 = *a1;
    if (!*a1) {
      goto LABEL_10;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v20, (uint64_t)v7);
    uint64_t v8 = a2[8];
    a1[10] += 80;
    uint64_t v9 = *a1;
    if (!*a1) {
      goto LABEL_10;
    }
  }
  if (((v9 + 7) & 0xFFFFFFFFFFFFFFF8) - v9 + 80 <= a1[1] - v9)
  {
    unint64_t v10 = (void *)((v9 + 7) & 0xFFFFFFFFFFFFFFF8);
    goto LABEL_15;
  }
LABEL_10:
  unsigned int v11 = *((_DWORD *)a1 + 6) >> 7;
  if (v11 >= 0x1E) {
    LOBYTE(v11) = 30;
  }
  uint64_t v12 = 4096 << v11;
  buffer = (char *)llvm::allocate_buffer(4096 << v11, (std::align_val_t)8uLL);
  uint64_t v14 = *((unsigned int *)a1 + 6);
  if (v14 >= *((_DWORD *)a1 + 7))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a1 + 2), a1 + 4, v14 + 1, 8);
    LODWORD(v14) = *((_DWORD *)a1 + 6);
  }
  *(void *)(a1[2] + 8 * v14) = buffer;
  ++*((_DWORD *)a1 + 6);
  a1[1] = (uint64_t)&buffer[v12];
  unint64_t v10 = (void *)((unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8);
LABEL_15:
  *a1 = (uint64_t)(v10 + 10);
  if (v6 == (void *)v21[0]) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v19, v21);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v19, (uint64_t)v21);
  }
  if (v6 == (void *)v20[0])
  {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v18, v20);
    void *v10 = 0;
    unsigned int v15 = v10 + 2;
    if (v6 != (void *)v19[0])
    {
LABEL_20:
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v15, (uint64_t)v19);
      uint64_t v16 = v10 + 6;
      if (v6 != (void *)v18[0]) {
        goto LABEL_21;
      }
      goto LABEL_29;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v18, (uint64_t)v20);
    void *v10 = 0;
    unsigned int v15 = v10 + 2;
    if (v6 != (void *)v19[0]) {
      goto LABEL_20;
    }
  }
  llvm::detail::DoubleAPFloat::DoubleAPFloat(v15, v19);
  uint64_t v16 = v10 + 6;
  if (v6 != (void *)v18[0])
  {
LABEL_21:
    llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v16, (uint64_t)v18);
    v10[9] = v8;
    if (v6 != (void *)v18[0]) {
      goto LABEL_22;
    }
    goto LABEL_30;
  }
LABEL_29:
  llvm::detail::DoubleAPFloat::DoubleAPFloat(v16, v18);
  v10[9] = v8;
  if (v6 != (void *)v18[0])
  {
LABEL_22:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
    if (v6 != (void *)v19[0]) {
      goto LABEL_23;
    }
    goto LABEL_31;
  }
LABEL_30:
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
  if (v6 != (void *)v19[0])
  {
LABEL_23:
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
    if (v6 != (void *)v20[0]) {
      goto LABEL_24;
    }
LABEL_32:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    if (v6 != (void *)v21[0]) {
      goto LABEL_25;
    }
LABEL_33:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v21);
    return v10;
  }
LABEL_31:
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
  if (v6 == (void *)v20[0]) {
    goto LABEL_32;
  }
LABEL_24:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
  if (v6 == (void *)v21[0]) {
    goto LABEL_33;
  }
LABEL_25:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v21);
  return v10;
}

void *_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRKNS_7APFloatESF_RNS1_4TypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_(uint64_t *a1, void *a2)
{
  return mlir::detail::AttributeUniquer::initializeAttributeStorage(a2, a1[1], *a1);
}

void llvm::function_ref<void ()(mlir::StorageUniquer::BaseStorage *)>::callback_fn<void mlir::StorageUniquer::registerParametricStorageType<mlir::complex::detail::NumberAttrStorage>(mlir::TypeID)::{lambda(mlir::StorageUniquer::BaseStorage *)#1}>(llvm::APFloatBase *a1, uint64_t a2)
{
  int v3 = (llvm::detail::DoubleAPFloat *)(a2 + 48);
  uint64_t v4 = *(void **)(a2 + 48);
  unint64_t v5 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v5 == v4)
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat(v3);
    unint64_t v6 = (llvm::detail::IEEEFloat *)(a2 + 16);
    if (v5 != *(void **)(a2 + 16)) {
      goto LABEL_3;
    }
  }
  else
  {
    llvm::detail::IEEEFloat::~IEEEFloat(v3);
    unint64_t v6 = (llvm::detail::IEEEFloat *)(a2 + 16);
    if (v5 != *(void **)(a2 + 16))
    {
LABEL_3:
      llvm::detail::IEEEFloat::~IEEEFloat(v6);
      return;
    }
  }

  llvm::detail::DoubleAPFloat::~DoubleAPFloat(v6);
}

uint64_t mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::APFloatBase *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  v25[1] = *MEMORY[0x1E4F143B8];
  v20[0] = a2;
  v20[1] = a3;
  unsigned int v11 = (const llvm::detail::DoubleAPFloat *)(a5 + 8);
  uint64_t v12 = *(void **)(a5 + 8);
  unint64_t v13 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v13 == v12) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22, v11);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v22, v11);
  }
  uint64_t v14 = (const llvm::detail::DoubleAPFloat *)(a6 + 8);
  if (v13 == *(void **)(a6 + 8)) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24, v14);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat((llvm::detail::IEEEFloat *)v24, v14);
  }
  v25[0] = *a7;
  unsigned int v15 = llvm::hash_combine<llvm::APFloat,llvm::APFloat,mlir::Type>((llvm *)v21, (const llvm::APFloat *)&v23, v25);
  v18[0] = v21;
  v18[1] = v20;
  uint64_t v19 = v21;
  uint64_t ParametricStorageTypeImpl = mlir::StorageUniquer::getParametricStorageTypeImpl((unsigned __int8 **)a1, a4, v15, (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v19, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v18);
  if (v13 == (void *)v24[0])
  {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v24);
    if (v13 != (void *)v22[0]) {
      goto LABEL_9;
    }
LABEL_12:
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v22);
    return ParametricStorageTypeImpl;
  }
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v24);
  if (v13 == (void *)v22[0]) {
    goto LABEL_12;
  }
LABEL_9:
  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v22);
  return ParametricStorageTypeImpl;
}

uint64_t llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(llvm::APFloatBase *a1, void *a2)
{
  uint64_t v2 = *(void *)a1;
  int v3 = (llvm::detail::DoubleAPFloat *)(a2 + 2);
  uint64_t v4 = (void *)a2[2];
  unint64_t v5 = (const llvm::detail::DoubleAPFloat *)(*(void *)a1 + 8);
  if (v4 != *(void **)v5) {
    return 0;
  }
  uint64_t v8 = llvm::APFloatBase::PPCDoubleDouble(a1);
  if (v8 == v4)
  {
    uint64_t result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v3, v5);
    if (!result) {
      return result;
    }
  }
  else if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v3, v5))
  {
    return 0;
  }
  uint64_t v9 = (llvm::detail::IEEEFloat *)(a2 + 6);
  unint64_t v10 = (void *)a2[6];
  unsigned int v11 = (const llvm::detail::IEEEFloat *)(v2 + 40);
  if (v10 != *(void **)(v2 + 40)) {
    return 0;
  }
  if (v8 != v10)
  {
    if (!llvm::detail::IEEEFloat::bitwiseIsEqual(v9, v11)) {
      return 0;
    }
    return a2[9] == *(void *)(v2 + 64);
  }
  uint64_t result = llvm::detail::DoubleAPFloat::bitwiseIsEqual(v9, v11);
  if (result) {
    return a2[9] == *(void *)(v2 + 64);
  }
  return result;
}

void *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::complex::detail::NumberAttrStorage * mlir::StorageUniquer::get<mlir::complex::detail::NumberAttrStorage,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &>(llvm::function_ref<void ()(mlir::complex::detail::NumberAttrStorage *)>,mlir::TypeID,llvm::APFloat &,llvm::APFloat &,mlir::ComplexType &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t *a2)
{
  int v3 = mlir::complex::detail::NumberAttrStorage::construct(a2, *(void **)a1);
  uint64_t v4 = *(void *)(a1 + 8);
  if (*(void *)v4) {
    (*(void (**)(void, void *))v4)(*(void *)(v4 + 8), v3);
  }
  return v3;
}

void *_ZN4llvm12function_refIFvPN4mlir7complex6detail17NumberAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_10NumberAttrEJRNS_7APFloatESE_RNS1_11ComplexTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESJ_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSL_E_EEvlS5_(uint64_t *a1, void *a2)
{
  return mlir::detail::AttributeUniquer::initializeAttributeStorage(a2, a1[1], *a1);
}

const char *mlir::cf::ControlFlowDialect::initialize(mlir::cf::ControlFlowDialect *this)
{
  mlir::Dialect::addOperations<mlir::cf::AssertOp,mlir::cf::BranchOp,mlir::cf::CondBranchOp,mlir::cf::SwitchOp>((uint64_t)this);
  uint64_t v2 = (char *)operator new(0x18uLL);
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unsigned int v15 = v2;
    unint64_t v3 = 0x1E8EB8000;
    int v7 = v6;
    uint64_t v2 = v15;
    if (v7)
    {
      uint64_t v16 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      unint64_t v17 = 79;
      unint64_t v8 = llvm::StringRef::find((uint64_t *)&v16, "DesiredTypeName = ", 0x12uLL, 0);
      if (v17 >= v8) {
        unint64_t v9 = v8;
      }
      else {
        unint64_t v9 = v17;
      }
      unint64_t v10 = &v16[v9];
      unint64_t v11 = v17 - v9;
      if (v17 - v9 >= 0x12) {
        uint64_t v12 = 18;
      }
      else {
        uint64_t v12 = v17 - v9;
      }
      unint64_t v13 = v11 - v12;
      if (v13 >= v13 - 1) {
        uint64_t v14 = v13 - 1;
      }
      else {
        uint64_t v14 = v13;
      }
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v10[v12], v14);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v15;
    }
  }
  uint64_t v4 = *(void *)(v3 + 3896);
  *((void *)v2 + 1) = this;
  *((void *)v2 + 2) = v4;
  *(void *)uint64_t v2 = &unk_1EC99BB08;
  uint64_t v16 = v2;
  mlir::Dialect::addInterface((uint64_t)this, (uint64_t *)&v16);
  uint64_t result = v16;
  uint64_t v16 = 0;
  if (result) {
    return (const char *)(*(uint64_t (**)(const char *))(*(void *)result + 8))(result);
  }
  return result;
}

mlir::cf::ControlFlowDialect *mlir::cf::ControlFlowDialect::ControlFlowDialect(mlir::cf::ControlFlowDialect *this, mlir::MLIRContext *a2)
{
  unint64_t v3 = (void *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"cf", 2, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::ControlFlowDialect,void>::id);
  void *v3 = &unk_1EC9C6DA8;
  uint64_t v4 = (uint64_t *)v3[4];
  if (!mlir::MLIRContext::isDialectLoading(v4, (uint64_t)"arith", 5))
  {
    int v6 = v4;
    mlir::MLIRContext::getOrLoadDialect(v4, (uint64_t)"arith", 5, (uint64_t)&mlir::detail::TypeIDResolver<mlir::arith::ArithDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::arith::ArithDialect * mlir::MLIRContext::getOrLoadDialect<mlir::arith::ArithDialect>(void)::{lambda(void)#1}>, (uint64_t)&v6);
  }
  mlir::cf::ControlFlowDialect::initialize(this);
  return this;
}

void mlir::cf::ControlFlowDialect::~ControlFlowDialect(llvm **this)
{
}

void sub_1803C9D0C(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::Dialect::addOperations<mlir::cf::AssertOp,mlir::cf::BranchOp,mlir::cf::CondBranchOp,mlir::cf::SwitchOp>(uint64_t a1)
{
  mlir::RegisteredOperationName::insert<mlir::cf::AssertOp>(a1);
  uint64_t v2 = operator new(0x70uLL);
  unint64_t v8 = mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  uint64_t v3 = (uint64_t)v8;
  unint64_t v8 = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  uint64_t v4 = operator new(0x70uLL);
  unint64_t v8 = mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, (uint64_t)&mlir::cf::CondBranchOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v5 = (uint64_t)v8;
  unint64_t v8 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  int v6 = operator new(0x70uLL);
  unint64_t v8 = mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, (uint64_t)&mlir::cf::SwitchOp::getAttributeNames(void)::attrNames, 3);
  uint64_t result = (uint64_t)v8;
  unint64_t v8 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t mlir::cf::AssertOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 24);
  int v6 = mlir::m_One(void)::{lambda(llvm::APInt const&)#1}::__invoke;
  uint64_t v7 = v4;
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v7);
  if (result)
  {
    uint64_t result = mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(void **))&v6, (mlir::Operation *)result);
    if (result)
    {
      (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, a1);
      return 1;
    }
  }
  return result;
}

uint64_t mlir::cf::BranchOp::canonicalize(uint64_t a1, uint64_t a2)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(unsigned int *)(a1 + 44);
  uint64_t v5 = *(void **)(((a1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 24);
  uint64_t v6 = *(void *)(a1 + 16);
  if (v5 != (void *)v6 && *v5 && !*(void *)*v5)
  {
    if ((v4 & 0x800000) != 0)
    {
      uint64_t v13 = *(void *)(a1 + 72);
      unint64_t v14 = *(unsigned int *)(a1 + 68);
      unint64_t v29 = v31;
      uint64_t v30 = 0x600000000;
      if (v14 >= 7)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v29, v31, v14, 8);
        unsigned int v15 = (char *)v29 + 8 * v30;
        if (v14 >= 0xD
          && ((unint64_t)v15 >= v13 + 32 * v14
           || v13 + 24 >= (unint64_t)v29 + 8 * v30 + 8 * v14))
        {
          uint64_t v17 = v14 & 3;
          if ((v14 & 3) == 0) {
            uint64_t v17 = 4;
          }
          unint64_t v16 = v14 - v17;
          v15 += 8 * v16;
          uint64_t v18 = (const double *)(v13 + 88);
          uint64_t v19 = (unsigned long long *)((char *)v29 + 8 * v30 + 16);
          unint64_t v20 = v16;
          do
          {
            uint64_t v21 = v18 - 8;
            unsigned long long v22 = (unsigned __int128)vld4q_f64(v21);
            unsigned long long v23 = (unsigned __int128)vld4q_f64(v18);
            *(v19 - 1) = v22;
            unsigned long long *v19 = v23;
            v18 += 16;
            v19 += 2;
            v20 -= 4;
          }
          while (v20);
          goto LABEL_26;
        }
LABEL_21:
        unint64_t v16 = 0;
LABEL_26:
        unint64_t v24 = v14 - v16;
        unint64_t v25 = (uint64_t *)(v13 + 32 * v16 + 24);
        do
        {
          uint64_t v26 = *v25;
          v25 += 4;
          *(void *)unsigned int v15 = v26;
          v15 += 8;
          --v24;
        }
        while (v24);
        int v27 = v30;
        goto LABEL_29;
      }
      if (v14)
      {
        unsigned int v15 = v31;
        goto LABEL_21;
      }
      int v27 = 0;
    }
    else
    {
      LODWORD(v14) = 0;
      int v27 = 0;
      unint64_t v29 = v31;
      HIDWORD(v30) = 6;
    }
LABEL_29:
    LODWORD(v30) = v27 + v14;
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 40))(a2, a1);
    mlir::ValueRange::ValueRange((unint64_t *)v32, (uint64_t)v29, v30);
    mlir::RewriterBase::mergeBlocks(a2, (uint64_t)v5, v6, v32[0], v32[1]);
    if (v29 != v31) {
      free(v29);
    }
    return 1;
  }
  uint64_t v28 = *(void *)(((a1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 24);
  if ((v4 & 0x800000) != 0)
  {
    uint64_t v7 = *(void *)(a1 + 72);
    unint64_t v8 = *(unsigned int *)(a1 + 68);
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v8 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)v32, v7, v8);
  unint64_t v29 = v31;
  uint64_t v30 = 0x400000000;
  if (v5 != *(void **)(a1 + 16) && collapseBranch(&v28, v32, (uint64_t)&v29))
  {
    unint64_t v9 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::ValueRange &>((mlir::OpBuilder *)(a2 + 8), *(void *)(a1 + 24), &v28, v32);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v9);
    uint64_t v10 = 1;
    unint64_t v11 = v29;
    if (v29 == v31) {
      return v10;
    }
    goto LABEL_11;
  }
  uint64_t v10 = 0;
  unint64_t v11 = v29;
  if (v29 != v31) {
LABEL_11:
  }
    free(v11);
  return v10;
}

void mlir::cf::CondBranchOp::getCanonicalizationPatterns(void *a1, uint64_t a2)
{
  unint64_t v4 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v4 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(void *)unint64_t v4 = &unk_1EC99BE18;
  if (*((void *)v4 + 9))
  {
    unint64_t v5 = v4[22];
    if (v5 <= v4[23]) {
      goto LABEL_3;
    }
LABEL_14:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v4 + 20), v4 + 24, v5, 16);
    v4[22] = v4[22];
    uint64_t v7 = (char *)a1[2];
    unint64_t v6 = a1[3];
    if ((unint64_t)v7 < v6) {
      goto LABEL_4;
    }
    goto LABEL_15;
  }
  uint64_t v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyConstCondBranchPred]";
  unint64_t v175 = 100;
  unint64_t v9 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v9) {
    unint64_t v10 = v9;
  }
  else {
    unint64_t v10 = v175;
  }
  unint64_t v11 = &v174[v10];
  unint64_t v12 = v175 - v10;
  if (v175 - v10 >= 0x12) {
    uint64_t v13 = 18;
  }
  else {
    uint64_t v13 = v175 - v10;
  }
  unint64_t v14 = &v11[v13];
  unint64_t v15 = v12 - v13;
  if (v15 >= v15 - 1) {
    --v15;
  }
  *((void *)v4 + 8) = v14;
  *((void *)v4 + 9) = v15;
  unint64_t v5 = v4[22];
  if (v5 > v4[23]) {
    goto LABEL_14;
  }
LABEL_3:
  v4[22] = v5;
  uint64_t v7 = (char *)a1[2];
  unint64_t v6 = a1[3];
  if ((unint64_t)v7 < v6)
  {
LABEL_4:
    *(void *)uint64_t v7 = v4;
    uint64_t v8 = (uint64_t)(v7 + 8);
    goto LABEL_39;
  }
LABEL_15:
  unint64_t v16 = (char *)a1[1];
  uint64_t v17 = (v7 - v16) >> 3;
  unint64_t v18 = v17 + 1;
  if ((unint64_t)(v17 + 1) >> 61) {
    goto LABEL_192;
  }
  uint64_t v19 = v6 - (void)v16;
  if (v19 >> 2 > v18) {
    unint64_t v18 = v19 >> 2;
  }
  if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v20 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v20 = v18;
  }
  if (v20)
  {
    if (v20 >> 61) {
      goto LABEL_193;
    }
    uint64_t v21 = (char *)operator new(8 * v20);
    unsigned long long v22 = &v21[8 * v17];
    unsigned long long v23 = &v21[8 * v20];
    *(void *)unsigned long long v22 = v4;
    uint64_t v8 = (uint64_t)(v22 + 8);
    unint64_t v24 = (char *)(v7 - v16);
    if (v7 != v16) {
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v21 = 0;
    unsigned long long v22 = (char *)(8 * v17);
    unsigned long long v23 = 0;
    *(void *)(8 * v17) = v4;
    uint64_t v8 = 8 * v17 + 8;
    unint64_t v24 = (char *)(v7 - v16);
    if (v7 != v16)
    {
LABEL_24:
      unint64_t v25 = (unint64_t)(v24 - 8);
      if (v25 < 0x78
        || &v7[-(v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v22 && &v21[v7 - v16 - (v25 & 0xFFFFFFFFFFFFFFF8) - 8] < v7)
      {
        goto LABEL_196;
      }
      uint64_t v26 = (v25 >> 3) + 1;
      uint64_t v27 = 8 * (v26 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v28 = &v7[-v27];
      v22 -= v27;
      unint64_t v29 = &v21[8 * v17 - 16];
      uint64_t v30 = v7 - 16;
      uint64_t v31 = v26 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v33 = *((_OWORD *)v30 - 1);
        long long v32 = *(_OWORD *)v30;
        *((_OWORD *)v30 - 1) = 0uLL;
        *(_OWORD *)uint64_t v30 = 0uLL;
        *((_OWORD *)v29 - 1) = v33;
        *(_OWORD *)unint64_t v29 = v32;
        v29 -= 32;
        v30 -= 32;
        v31 -= 4;
      }
      while (v31);
      uint64_t v7 = v28;
      if (v26 != (v26 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_196:
        do
        {
          uint64_t v34 = *((void *)v7 - 1);
          v7 -= 8;
          *(void *)uint64_t v7 = 0;
          *((void *)v22 - 1) = v34;
          v22 -= 8;
        }
        while (v7 != v16);
      }
      uint64_t v7 = (char *)a1[1];
      unint64_t v35 = (char *)a1[2];
      a1[1] = v22;
      a1[2] = v8;
      a1[3] = v23;
      while (v35 != v7)
      {
        uint64_t v37 = *((void *)v35 - 1);
        v35 -= 8;
        uint64_t v36 = v37;
        *(void *)unint64_t v35 = 0;
        if (v37) {
          (*(void (**)(uint64_t))(*(void *)v36 + 8))(v36);
        }
      }
      goto LABEL_37;
    }
  }
  a1[1] = v22;
  a1[2] = v8;
  a1[3] = v23;
LABEL_37:
  if (v7) {
    operator delete(v7);
  }
LABEL_39:
  a1[2] = v8;
  unint64_t v38 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v38 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(void *)unint64_t v38 = &unk_1EC99BFA8;
  if (*((void *)v38 + 9))
  {
    unint64_t v39 = v38[22];
    if (v39 <= v38[23]) {
      goto LABEL_41;
    }
LABEL_52:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v38 + 20), v38 + 24, v39, 16);
    v38[22] = v38[22];
    uint64_t v41 = (char *)a1[2];
    unint64_t v40 = a1[3];
    if ((unint64_t)v41 < v40) {
      goto LABEL_42;
    }
    goto LABEL_53;
  }
  uint64_t v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyPassThroughCondBranch]";
  unint64_t v175 = 102;
  unint64_t v43 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v43) {
    unint64_t v44 = v43;
  }
  else {
    unint64_t v44 = v175;
  }
  unint64_t v45 = &v174[v44];
  unint64_t v46 = v175 - v44;
  if (v175 - v44 >= 0x12) {
    uint64_t v47 = 18;
  }
  else {
    uint64_t v47 = v175 - v44;
  }
  uint64_t v48 = &v45[v47];
  unint64_t v49 = v46 - v47;
  if (v49 >= v49 - 1) {
    --v49;
  }
  *((void *)v38 + 8) = v48;
  *((void *)v38 + 9) = v49;
  unint64_t v39 = v38[22];
  if (v39 > v38[23]) {
    goto LABEL_52;
  }
LABEL_41:
  v38[22] = v39;
  uint64_t v41 = (char *)a1[2];
  unint64_t v40 = a1[3];
  if ((unint64_t)v41 < v40)
  {
LABEL_42:
    *(void *)uint64_t v41 = v38;
    uint64_t v42 = (uint64_t)(v41 + 8);
    goto LABEL_77;
  }
LABEL_53:
  uint64_t v50 = (char *)a1[1];
  uint64_t v51 = (v41 - v50) >> 3;
  unint64_t v52 = v51 + 1;
  if ((unint64_t)(v51 + 1) >> 61) {
    goto LABEL_192;
  }
  uint64_t v53 = v40 - (void)v50;
  if (v53 >> 2 > v52) {
    unint64_t v52 = v53 >> 2;
  }
  if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v54 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v54 = v52;
  }
  if (v54)
  {
    if (v54 >> 61) {
      goto LABEL_193;
    }
    int v55 = (char *)operator new(8 * v54);
    unint64_t v56 = &v55[8 * v51];
    uint64_t v57 = &v55[8 * v54];
    *(void *)unint64_t v56 = v38;
    uint64_t v42 = (uint64_t)(v56 + 8);
    unint64_t v58 = (char *)(v41 - v50);
    if (v41 != v50) {
      goto LABEL_62;
    }
  }
  else
  {
    int v55 = 0;
    unint64_t v56 = (char *)(8 * v51);
    uint64_t v57 = 0;
    *(void *)(8 * v51) = v38;
    uint64_t v42 = 8 * v51 + 8;
    unint64_t v58 = (char *)(v41 - v50);
    if (v41 != v50)
    {
LABEL_62:
      unint64_t v59 = (unint64_t)(v58 - 8);
      if (v59 < 0x78
        || &v41[-(v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v56 && &v55[v41 - v50 - (v59 & 0xFFFFFFFFFFFFFFF8) - 8] < v41)
      {
        goto LABEL_197;
      }
      uint64_t v60 = (v59 >> 3) + 1;
      uint64_t v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v62 = &v41[-v61];
      v56 -= v61;
      unint64_t v63 = &v55[8 * v51 - 16];
      int v64 = v41 - 16;
      uint64_t v65 = v60 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v67 = *((_OWORD *)v64 - 1);
        long long v66 = *(_OWORD *)v64;
        *((_OWORD *)v64 - 1) = 0uLL;
        *(_OWORD *)int v64 = 0uLL;
        *((_OWORD *)v63 - 1) = v67;
        *(_OWORD *)unint64_t v63 = v66;
        v63 -= 32;
        v64 -= 32;
        v65 -= 4;
      }
      while (v65);
      uint64_t v41 = v62;
      if (v60 != (v60 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_197:
        do
        {
          uint64_t v68 = *((void *)v41 - 1);
          v41 -= 8;
          *(void *)uint64_t v41 = 0;
          *((void *)v56 - 1) = v68;
          v56 -= 8;
        }
        while (v41 != v50);
      }
      uint64_t v41 = (char *)a1[1];
      int v69 = (char *)a1[2];
      a1[1] = v56;
      a1[2] = v42;
      a1[3] = v57;
      while (v69 != v41)
      {
        uint64_t v71 = *((void *)v69 - 1);
        v69 -= 8;
        uint64_t v70 = v71;
        *(void *)int v69 = 0;
        if (v71) {
          (*(void (**)(uint64_t))(*(void *)v70 + 8))(v70);
        }
      }
      goto LABEL_75;
    }
  }
  a1[1] = v56;
  a1[2] = v42;
  a1[3] = v57;
LABEL_75:
  if (v41) {
    operator delete(v41);
  }
LABEL_77:
  a1[2] = v42;
  unint64_t v72 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v72 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(void *)unint64_t v72 = &unk_1EC99C3F0;
  if (*((void *)v72 + 9))
  {
    unint64_t v73 = v72[22];
    if (v73 <= v72[23]) {
      goto LABEL_79;
    }
LABEL_90:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v72 + 20), v72 + 24, v73, 16);
    v72[22] = v72[22];
    uint64_t v75 = (char *)a1[2];
    unint64_t v74 = a1[3];
    if ((unint64_t)v75 < v74) {
      goto LABEL_80;
    }
    goto LABEL_91;
  }
  uint64_t v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyCondBranchIdenticalSuccessors]";
  unint64_t v175 = 110;
  unint64_t v77 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v77) {
    unint64_t v78 = v77;
  }
  else {
    unint64_t v78 = v175;
  }
  int v79 = &v174[v78];
  unint64_t v80 = v175 - v78;
  if (v175 - v78 >= 0x12) {
    uint64_t v81 = 18;
  }
  else {
    uint64_t v81 = v175 - v78;
  }
  int v82 = &v79[v81];
  unint64_t v83 = v80 - v81;
  if (v83 >= v83 - 1) {
    --v83;
  }
  *((void *)v72 + 8) = v82;
  *((void *)v72 + 9) = v83;
  unint64_t v73 = v72[22];
  if (v73 > v72[23]) {
    goto LABEL_90;
  }
LABEL_79:
  v72[22] = v73;
  uint64_t v75 = (char *)a1[2];
  unint64_t v74 = a1[3];
  if ((unint64_t)v75 < v74)
  {
LABEL_80:
    *(void *)uint64_t v75 = v72;
    uint64_t v76 = (uint64_t)(v75 + 8);
    goto LABEL_115;
  }
LABEL_91:
  uint64_t v84 = (char *)a1[1];
  uint64_t v85 = (v75 - v84) >> 3;
  unint64_t v86 = v85 + 1;
  if ((unint64_t)(v85 + 1) >> 61) {
    goto LABEL_192;
  }
  uint64_t v87 = v74 - (void)v84;
  if (v87 >> 2 > v86) {
    unint64_t v86 = v87 >> 2;
  }
  if ((unint64_t)v87 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v88 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v88 = v86;
  }
  if (v88)
  {
    if (v88 >> 61) {
      goto LABEL_193;
    }
    unint64_t v89 = (char *)operator new(8 * v88);
    unint64_t v90 = &v89[8 * v85];
    int v91 = &v89[8 * v88];
    *(void *)unint64_t v90 = v72;
    uint64_t v76 = (uint64_t)(v90 + 8);
    unint64_t v92 = (char *)(v75 - v84);
    if (v75 != v84) {
      goto LABEL_100;
    }
  }
  else
  {
    unint64_t v89 = 0;
    unint64_t v90 = (char *)(8 * v85);
    int v91 = 0;
    *(void *)(8 * v85) = v72;
    uint64_t v76 = 8 * v85 + 8;
    unint64_t v92 = (char *)(v75 - v84);
    if (v75 != v84)
    {
LABEL_100:
      unint64_t v93 = (unint64_t)(v92 - 8);
      if (v93 < 0x78
        || &v75[-(v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v90 && &v89[v75 - v84 - (v93 & 0xFFFFFFFFFFFFFFF8) - 8] < v75)
      {
        goto LABEL_198;
      }
      uint64_t v94 = (v93 >> 3) + 1;
      uint64_t v95 = 8 * (v94 & 0x3FFFFFFFFFFFFFFCLL);
      int v96 = &v75[-v95];
      v90 -= v95;
      int v97 = &v89[8 * v85 - 16];
      unint64_t v98 = v75 - 16;
      uint64_t v99 = v94 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v101 = *((_OWORD *)v98 - 1);
        long long v100 = *(_OWORD *)v98;
        *((_OWORD *)v98 - 1) = 0uLL;
        *(_OWORD *)unint64_t v98 = 0uLL;
        *((_OWORD *)v97 - 1) = v101;
        *(_OWORD *)int v97 = v100;
        v97 -= 32;
        v98 -= 32;
        v99 -= 4;
      }
      while (v99);
      uint64_t v75 = v96;
      if (v94 != (v94 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_198:
        do
        {
          uint64_t v102 = *((void *)v75 - 1);
          v75 -= 8;
          *(void *)uint64_t v75 = 0;
          *((void *)v90 - 1) = v102;
          v90 -= 8;
        }
        while (v75 != v84);
      }
      uint64_t v75 = (char *)a1[1];
      unint64_t v103 = (char *)a1[2];
      a1[1] = v90;
      a1[2] = v76;
      a1[3] = v91;
      while (v103 != v75)
      {
        uint64_t v105 = *((void *)v103 - 1);
        v103 -= 8;
        uint64_t v104 = v105;
        *(void *)unint64_t v103 = 0;
        if (v105) {
          (*(void (**)(uint64_t))(*(void *)v104 + 8))(v104);
        }
      }
      goto LABEL_113;
    }
  }
  a1[1] = v90;
  a1[2] = v76;
  a1[3] = v91;
LABEL_113:
  if (v75) {
    operator delete(v75);
  }
LABEL_115:
  a1[2] = v76;
  int v106 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v106 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(void *)int v106 = &unk_1EC99C668;
  if (*((void *)v106 + 9))
  {
    unint64_t v107 = v106[22];
    if (v107 <= v106[23]) {
      goto LABEL_117;
    }
LABEL_128:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v106 + 20), v106 + 24, v107, 16);
    v106[22] = v106[22];
    uint64_t v109 = (char *)a1[2];
    unint64_t v108 = a1[3];
    if ((unint64_t)v109 < v108) {
      goto LABEL_118;
    }
    goto LABEL_129;
  }
  uint64_t v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::SimplifyCondBranchFromCondBranchOnSameCondition]";
  unint64_t v175 = 120;
  unint64_t v111 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v111) {
    unint64_t v112 = v111;
  }
  else {
    unint64_t v112 = v175;
  }
  uint64_t v113 = &v174[v112];
  unint64_t v114 = v175 - v112;
  if (v175 - v112 >= 0x12) {
    uint64_t v115 = 18;
  }
  else {
    uint64_t v115 = v175 - v112;
  }
  unint64_t v116 = &v113[v115];
  unint64_t v117 = v114 - v115;
  if (v117 >= v117 - 1) {
    --v117;
  }
  *((void *)v106 + 8) = v116;
  *((void *)v106 + 9) = v117;
  unint64_t v107 = v106[22];
  if (v107 > v106[23]) {
    goto LABEL_128;
  }
LABEL_117:
  v106[22] = v107;
  uint64_t v109 = (char *)a1[2];
  unint64_t v108 = a1[3];
  if ((unint64_t)v109 < v108)
  {
LABEL_118:
    *(void *)uint64_t v109 = v106;
    uint64_t v110 = (uint64_t)(v109 + 8);
    goto LABEL_153;
  }
LABEL_129:
  uint64_t v118 = (char *)a1[1];
  uint64_t v119 = (v109 - v118) >> 3;
  unint64_t v120 = v119 + 1;
  if ((unint64_t)(v119 + 1) >> 61) {
    goto LABEL_192;
  }
  uint64_t v121 = v108 - (void)v118;
  if (v121 >> 2 > v120) {
    unint64_t v120 = v121 >> 2;
  }
  if ((unint64_t)v121 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v122 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v122 = v120;
  }
  if (v122)
  {
    if (v122 >> 61) {
      goto LABEL_193;
    }
    int v123 = (char *)operator new(8 * v122);
    int v124 = &v123[8 * v119];
    unint64_t v125 = &v123[8 * v122];
    *(void *)int v124 = v106;
    uint64_t v110 = (uint64_t)(v124 + 8);
    unint64_t v126 = (char *)(v109 - v118);
    if (v109 != v118) {
      goto LABEL_138;
    }
  }
  else
  {
    int v123 = 0;
    int v124 = (char *)(8 * v119);
    unint64_t v125 = 0;
    *(void *)(8 * v119) = v106;
    uint64_t v110 = 8 * v119 + 8;
    unint64_t v126 = (char *)(v109 - v118);
    if (v109 != v118)
    {
LABEL_138:
      unint64_t v127 = (unint64_t)(v126 - 8);
      if (v127 < 0x78
        || &v109[-(v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v124
        && &v123[v109 - v118 - (v127 & 0xFFFFFFFFFFFFFFF8) - 8] < v109)
      {
        goto LABEL_199;
      }
      uint64_t v128 = (v127 >> 3) + 1;
      uint64_t v129 = 8 * (v128 & 0x3FFFFFFFFFFFFFFCLL);
      unint64_t v130 = &v109[-v129];
      v124 -= v129;
      uint64_t v131 = &v123[8 * v119 - 16];
      uint64_t v132 = v109 - 16;
      uint64_t v133 = v128 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v135 = *((_OWORD *)v132 - 1);
        long long v134 = *(_OWORD *)v132;
        *((_OWORD *)v132 - 1) = 0uLL;
        *(_OWORD *)uint64_t v132 = 0uLL;
        *((_OWORD *)v131 - 1) = v135;
        *(_OWORD *)uint64_t v131 = v134;
        v131 -= 32;
        v132 -= 32;
        v133 -= 4;
      }
      while (v133);
      uint64_t v109 = v130;
      if (v128 != (v128 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_199:
        do
        {
          uint64_t v136 = *((void *)v109 - 1);
          v109 -= 8;
          *(void *)uint64_t v109 = 0;
          *((void *)v124 - 1) = v136;
          v124 -= 8;
        }
        while (v109 != v118);
      }
      uint64_t v109 = (char *)a1[1];
      uint64_t v137 = (char *)a1[2];
      a1[1] = v124;
      a1[2] = v110;
      a1[3] = v125;
      while (v137 != v109)
      {
        uint64_t v139 = *((void *)v137 - 1);
        v137 -= 8;
        uint64_t v138 = v139;
        *(void *)uint64_t v137 = 0;
        if (v139) {
          (*(void (**)(uint64_t))(*(void *)v138 + 8))(v138);
        }
      }
      goto LABEL_151;
    }
  }
  a1[1] = v124;
  a1[2] = v110;
  a1[3] = v125;
LABEL_151:
  if (v109) {
    operator delete(v109);
  }
LABEL_153:
  a1[2] = v110;
  uint64_t v140 = (unsigned int *)operator new(0x60uLL);
  mlir::PatternBenefit::PatternBenefit(&v174, 1);
  mlir::Pattern::Pattern((uint64_t)(v140 + 2), (uint64_t)"cf.cond_br", 10, (__int16)v174, a2, 0, 0);
  *(void *)uint64_t v140 = &unk_1EC99B780;
  if (*((void *)v140 + 9))
  {
    unint64_t v141 = v140[22];
    if (v141 <= v140[23]) {
      goto LABEL_155;
    }
LABEL_166:
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v140 + 20), v140 + 24, v141, 16);
    v140[22] = v140[22];
    uint64_t v143 = (char *)a1[2];
    unint64_t v142 = a1[3];
    if ((unint64_t)v143 < v142) {
      goto LABEL_156;
    }
    goto LABEL_167;
  }
  uint64_t v174 = "StringRef llvm::getTypeName() [DesiredTypeName = (anonymous namespace)::CondBranchTruthPropagation]";
  unint64_t v175 = 99;
  unint64_t v145 = llvm::StringRef::find((uint64_t *)&v174, "DesiredTypeName = ", 0x12uLL, 0);
  if (v175 >= v145) {
    unint64_t v146 = v145;
  }
  else {
    unint64_t v146 = v175;
  }
  uint64_t v147 = &v174[v146];
  unint64_t v148 = v175 - v146;
  if (v175 - v146 >= 0x12) {
    uint64_t v149 = 18;
  }
  else {
    uint64_t v149 = v175 - v146;
  }
  uint64_t v150 = &v147[v149];
  unint64_t v151 = v148 - v149;
  if (v151 >= v151 - 1) {
    --v151;
  }
  *((void *)v140 + 8) = v150;
  *((void *)v140 + 9) = v151;
  unint64_t v141 = v140[22];
  if (v141 > v140[23]) {
    goto LABEL_166;
  }
LABEL_155:
  v140[22] = v141;
  uint64_t v143 = (char *)a1[2];
  unint64_t v142 = a1[3];
  if ((unint64_t)v143 < v142)
  {
LABEL_156:
    *(void *)uint64_t v143 = v140;
    uint64_t v144 = (uint64_t)(v143 + 8);
    goto LABEL_191;
  }
LABEL_167:
  uint64_t v152 = (char *)a1[1];
  uint64_t v153 = (v143 - v152) >> 3;
  unint64_t v154 = v153 + 1;
  if ((unint64_t)(v153 + 1) >> 61) {
LABEL_192:
  }
    abort();
  uint64_t v155 = v142 - (void)v152;
  if (v155 >> 2 > v154) {
    unint64_t v154 = v155 >> 2;
  }
  if ((unint64_t)v155 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v156 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v156 = v154;
  }
  if (!v156)
  {
    uint64_t v157 = 0;
    uint64_t v158 = (char *)(8 * v153);
    uint64_t v159 = 0;
    *(void *)(8 * v153) = v140;
    uint64_t v144 = 8 * v153 + 8;
    uint64_t v160 = (char *)(v143 - v152);
    if (v143 != v152) {
      goto LABEL_176;
    }
    goto LABEL_188;
  }
  if (v156 >> 61) {
LABEL_193:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  uint64_t v157 = (char *)operator new(8 * v156);
  uint64_t v158 = &v157[8 * v153];
  uint64_t v159 = &v157[8 * v156];
  *(void *)uint64_t v158 = v140;
  uint64_t v144 = (uint64_t)(v158 + 8);
  uint64_t v160 = (char *)(v143 - v152);
  if (v143 != v152)
  {
LABEL_176:
    unint64_t v161 = (unint64_t)(v160 - 8);
    if (v161 < 0x78
      || &v143[-(v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v158
      && &v157[v143 - v152 - (v161 & 0xFFFFFFFFFFFFFFF8) - 8] < v143)
    {
      goto LABEL_200;
    }
    uint64_t v162 = (v161 >> 3) + 1;
    uint64_t v163 = 8 * (v162 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v164 = &v143[-v163];
    v158 -= v163;
    uint64_t v165 = &v157[8 * v153 - 16];
    uint64_t v166 = v143 - 16;
    uint64_t v167 = v162 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v169 = *((_OWORD *)v166 - 1);
      long long v168 = *(_OWORD *)v166;
      *((_OWORD *)v166 - 1) = 0uLL;
      *(_OWORD *)uint64_t v166 = 0uLL;
      *((_OWORD *)v165 - 1) = v169;
      *(_OWORD *)uint64_t v165 = v168;
      v165 -= 32;
      v166 -= 32;
      v167 -= 4;
    }
    while (v167);
    uint64_t v143 = v164;
    if (v162 != (v162 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_200:
      do
      {
        uint64_t v170 = *((void *)v143 - 1);
        v143 -= 8;
        *(void *)uint64_t v143 = 0;
        *((void *)v158 - 1) = v170;
        v158 -= 8;
      }
      while (v143 != v152);
    }
    uint64_t v143 = (char *)a1[1];
    uint64_t v171 = (char *)a1[2];
    a1[1] = v158;
    a1[2] = v144;
    a1[3] = v159;
    while (v171 != v143)
    {
      uint64_t v173 = *((void *)v171 - 1);
      v171 -= 8;
      uint64_t v172 = v173;
      *(void *)uint64_t v171 = 0;
      if (v173) {
        (*(void (**)(uint64_t))(*(void *)v172 + 8))(v172);
      }
    }
    goto LABEL_189;
  }
LABEL_188:
  a1[1] = v158;
  a1[2] = v144;
  a1[3] = v159;
LABEL_189:
  if (v143) {
    operator delete(v143);
  }
LABEL_191:
  a1[2] = v144;
}

void mlir::cf::CondBranchOp::getSuccessorOperands(mlir::cf::CondBranchOp *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  void v22[3] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)this;
  if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v6 = (int *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }
  int v7 = *v6;
  int v8 = v6[1];
  if (a2)
  {
    v7 += v8;
    int v8 = v6[2];
    uint64_t v9 = *(void *)(*(void *)(*(void *)(v5 + 48) + 96) + 8 * *(void *)(*(void *)(v5 + 48) + 104) - 8);
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v5 + 24));
    if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
      uint64_t v11 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v11, 3);
    mlir::NamedAttribute::NamedAttribute(&v17, v9, v12);
    int v18 = 2;
  }
  else
  {
    uint64_t v13 = *(void *)(*(void *)(*(void *)(v5 + 48) + 96) + 8 * *(void *)(*(void *)(v5 + 48) + 104) - 8);
    unint64_t v14 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v5 + 24));
    if (HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
      uint64_t v15 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
    }
    else {
      uint64_t v15 = 0;
    }
    uint64_t v16 = mlir::detail::DenseArrayAttrImpl<int>::get(v14, v15, 3);
    mlir::NamedAttribute::NamedAttribute(&v17, v13, v16);
    int v18 = 1;
  }
  long long v19 = v17;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v20, v5, v7, v8, &v18, 1);
  mlir::SuccessorOperands::SuccessorOperands(a3, v20);
  if (v21 != v22) {
    free(v21);
  }
}

void mlir::cf::SwitchOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v52[6] = *MEMORY[0x1E4F143B8];
  uint64_t v49 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v49, 1);
  mlir::OperationState::addOperands(a2, a4, a5);
  int v18 = (uint64_t *)(a6 + 16 * a7);
  if (a7)
  {
    int v48 = a5;
    a5 = a8;
    long long v19 = (uint64_t *)a6;
    do
    {
      uint64_t v20 = *v19;
      uint64_t v21 = v19[1];
      v19 += 2;
      mlir::OperationState::addOperands(a2, v20, v21);
    }
    while (v19 != v18);
    LODWORD(v22) = 0;
    uint64_t v50 = v52;
    uint64_t v51 = 0xC00000000;
    uint64_t v23 = 16 * a7;
    unint64_t v24 = (int *)(a6 + 8);
    do
    {
      int v26 = *v24;
      v24 += 4;
      int v25 = v26;
      if (v22 >= HIDWORD(v51))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v22 + 1, 4);
        LODWORD(v22) = v51;
      }
      *((_DWORD *)v50 + v22) = v25;
      uint64_t v22 = (v51 + 1);
      LODWORD(v51) = v51 + 1;
      v23 -= 16;
    }
    while (v23);
    uint64_t v27 = v50;
    a8 = a5;
    LODWORD(a5) = v48;
  }
  else
  {
    uint64_t v22 = 0;
    uint64_t v50 = v52;
    uint64_t v51 = 0xC00000000;
    uint64_t v27 = v52;
  }
  uint64_t DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr(a1, (uint64_t)v27, v22);
  *(void *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>((void *)a2) = DenseI32ArrayAttr;
  if (v50 != v52) {
    free(v50);
  }
  if (a7)
  {
    unint64_t v29 = (a7 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v29 >= 8)
    {
      unint64_t v32 = v29 + 1;
      uint64_t v33 = v32 & 7;
      if ((v32 & 7) == 0) {
        uint64_t v33 = 8;
      }
      unint64_t v34 = v32 - v33;
      uint64_t v31 = a6 + 16 * v34;
      unint64_t v35 = (const double *)(a6 + 72);
      int32x4_t v36 = 0uLL;
      int32x4_t v37 = 0uLL;
      do
      {
        unint64_t v38 = v35 - 8;
        unsigned long long v39 = (unsigned __int128)vld2q_f64(v38);
        unint64_t v40 = v35 - 4;
        unsigned long long v41 = (unsigned __int128)vld2q_f64(v40);
        uint64_t v42 = v35 + 16;
        unsigned long long v44 = (unsigned __int128)vld2q_f64(v35);
        unint64_t v43 = v35 + 4;
        unsigned long long v45 = (unsigned __int128)vld2q_f64(v43);
        int32x4_t v36 = vaddq_s32(v36, vuzp1q_s32((int32x4_t)v39, (int32x4_t)v41));
        int32x4_t v37 = vaddq_s32(v37, vuzp1q_s32((int32x4_t)v44, (int32x4_t)v45));
        unint64_t v35 = v42;
        v34 -= 8;
      }
      while (v34);
      int v30 = vaddvq_s32(vaddq_s32(v37, v36));
    }
    else
    {
      int v30 = 0;
      uint64_t v31 = a6;
    }
    do
    {
      v30 += *(_DWORD *)(v31 + 8);
      v31 += 16;
    }
    while ((uint64_t *)v31 != v18);
  }
  else
  {
    int v30 = 0;
  }
  unint64_t v46 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>((void *)a2);
  v46[4] = 1;
  v46[5] = a5;
  v46[6] = v30;
  if (a8) {
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>((void *)a2)
  }
              + 8) = a8;
  uint64_t v47 = *(unsigned int *)(a2 + 208);
  if (v47 >= *(_DWORD *)(a2 + 212))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v47 + 1, 8);
    LODWORD(v47) = *(_DWORD *)(a2 + 208);
  }
  *(void *)(*(void *)(a2 + 200) + 8 * v47) = a9;
  ++*(_DWORD *)(a2 + 208);
  mlir::OperationState::addSuccessors((unsigned int *)a2, a10, a11);
}

uint64_t mlir::cf::SwitchOp::verify(Operation **this)
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  }
  else {
    unint64_t v3 = 0;
  }
  uint64_t v99 = *(void *)(v3 + 8);
  BOOL v100 = v99 != 0;
  mlir::SuccessorRange::SuccessorRange((unint64_t *)&Value, v2);
  mlir::SuccessorRange::SuccessorRange((unint64_t *)&Value, *this);
  unint64_t v4 = (const char *)(v105 - 1);
  if (v99) {
    BOOL v5 = 0;
  }
  else {
    BOOL v5 = v105 == 1;
  }
  if (v5) {
    return 1;
  }
  unint64_t v6 = *(void *)(*(void *)(*((void *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v99);
  uint64_t v105 = v7;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
  if (OperandRange != v6)
  {
    uint64_t v9 = OperandRange;
    __int16 v98 = 257;
    mlir::OpState::emitOpError((uint64_t **)this, v97, (uint64_t)&Value);
    if (Value)
    {
      int v101 = 3;
      uint64_t v102 = "'flag' type (";
      uint64_t v103 = 13;
      unint64_t v10 = &v101;
      uint64_t v11 = (char *)v106;
      if (v107 >= v108)
      {
        unint64_t v72 = v107 + 1;
        if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
        {
          int64_t v87 = (char *)&v101 - (unsigned char *)v106;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v72, 24);
          uint64_t v11 = (char *)v106;
          unint64_t v10 = (int *)((char *)v106 + v87);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v72, 24);
          unint64_t v10 = &v101;
          uint64_t v11 = (char *)v106;
        }
      }
      uint64_t v12 = &v11[24 * v107];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)uint64_t v12 = v13;
      ++v107;
      if (Value)
      {
        unint64_t v14 = &v101;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v101, v6);
        uint64_t v15 = (char *)v106;
        if (v107 >= v108)
        {
          unint64_t v73 = v107 + 1;
          if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
          {
            int64_t v88 = (char *)&v101 - (unsigned char *)v106;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v73, 24);
            uint64_t v15 = (char *)v106;
            unint64_t v14 = (int *)((char *)v106 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v73, 24);
            unint64_t v14 = &v101;
            uint64_t v15 = (char *)v106;
          }
        }
        uint64_t v16 = &v15[24 * v107];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = *((void *)v14 + 2);
        *(_OWORD *)uint64_t v16 = v17;
        uint64_t v18 = ++v107;
        if (Value)
        {
          int v101 = 3;
          uint64_t v102 = ") should match case value type (";
          uint64_t v103 = 32;
          long long v19 = &v101;
          uint64_t v20 = (char *)v106;
          if (v18 >= v108)
          {
            unint64_t v74 = v18 + 1;
            BOOL v75 = (char *)v106 + 24 * v18 > (char *)&v101;
            if (v106 <= &v101 && v75)
            {
              int64_t v89 = (char *)&v101 - (unsigned char *)v106;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v74, 24);
              uint64_t v20 = (char *)v106;
              long long v19 = (int *)((char *)v106 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v74, 24);
              long long v19 = &v101;
              uint64_t v20 = (char *)v106;
            }
          }
          uint64_t v21 = &v20[24 * v107];
          long long v22 = *(_OWORD *)v19;
          *((void *)v21 + 2) = *((void *)v19 + 2);
          *(_OWORD *)uint64_t v21 = v22;
          ++v107;
          if (Value)
          {
            uint64_t v23 = &v101;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v101, v9);
            unint64_t v24 = (char *)v106;
            if (v107 >= v108)
            {
              unint64_t v76 = v107 + 1;
              if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
              {
                int64_t v90 = (char *)&v101 - (unsigned char *)v106;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v76, 24);
                unint64_t v24 = (char *)v106;
                uint64_t v23 = (int *)((char *)v106 + v90);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v76, 24);
                uint64_t v23 = &v101;
                unint64_t v24 = (char *)v106;
              }
            }
            int v25 = &v24[24 * v107];
            long long v26 = *(_OWORD *)v23;
            *((void *)v25 + 2) = *((void *)v23 + 2);
            *(_OWORD *)int v25 = v26;
            uint64_t v27 = ++v107;
            if (Value)
            {
              int v101 = 3;
              uint64_t v102 = ")";
              uint64_t v103 = 1;
              uint64_t v28 = &v101;
              unint64_t v29 = (char *)v106;
              if (v27 >= v108)
              {
                unint64_t v79 = v27 + 1;
                BOOL v80 = (char *)v106 + 24 * v27 > (char *)&v101;
                if (v106 <= &v101 && v80)
                {
                  int64_t v93 = (char *)&v101 - (unsigned char *)v106;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v79, 24);
                  unint64_t v29 = (char *)v106;
                  uint64_t v28 = (int *)((char *)v106 + v93);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v79, 24);
                  uint64_t v28 = &v101;
                  unint64_t v29 = (char *)v106;
                }
              }
              int v30 = &v29[24 * v107];
              long long v31 = *(_OWORD *)v28;
              *((void *)v30 + 2) = *((void *)v28 + 2);
              *(_OWORD *)int v30 = v31;
              ++v107;
            }
          }
        }
      }
    }
    uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    }
    if (v114)
    {
      uint64_t v33 = (void **)__p;
      if (__p)
      {
        unint64_t v34 = v113;
        unint64_t v35 = __p;
        if (v113 != __p)
        {
          do
            unint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
          while (v34 != v33);
          unint64_t v35 = __p;
        }
        uint64_t v113 = v33;
        operator delete(v35);
      }
      int32x4_t v36 = v110;
      if (!v110) {
        goto LABEL_66;
      }
      int32x4_t v37 = v111;
      unint64_t v38 = v110;
      if (v111 == v110)
      {
LABEL_65:
        unint64_t v111 = v36;
        operator delete(v38);
LABEL_66:
        if (v106 != v109) {
          free(v106);
        }
        return v32;
      }
      do
      {
        unint64_t v40 = (void *)*--v37;
        unsigned long long v39 = v40;
        *int32x4_t v37 = 0;
        if (v40) {
          operator delete[](v39);
        }
      }
      while (v37 != v36);
LABEL_64:
      unint64_t v38 = v110;
      goto LABEL_65;
    }
    return v32;
  }
  if (!v100 || (const char *)mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v99) == v4) {
    return 1;
  }
  __int16 v98 = 257;
  mlir::OpState::emitOpError((uint64_t **)this, v97, (uint64_t)&Value);
  if (Value)
  {
    int v101 = 3;
    uint64_t v102 = "number of case values (";
    uint64_t v103 = 23;
    uint64_t v42 = &v101;
    unint64_t v43 = (char *)v106;
    if (v107 >= v108)
    {
      unint64_t v77 = v107 + 1;
      if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
      {
        int64_t v91 = (char *)&v101 - (unsigned char *)v106;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v77, 24);
        unint64_t v43 = (char *)v106;
        uint64_t v42 = (int *)((char *)v106 + v91);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v77, 24);
        uint64_t v42 = &v101;
        unint64_t v43 = (char *)v106;
      }
    }
    unsigned long long v44 = &v43[24 * v107];
    long long v45 = *(_OWORD *)v42;
    *((void *)v44 + 2) = *((void *)v42 + 2);
    *(_OWORD *)unsigned long long v44 = v45;
    ++v107;
  }
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v99);
  if (Value)
  {
    int v101 = 2;
    uint64_t v102 = (const char *)NumElements;
    uint64_t v47 = &v101;
    int v48 = (char *)v106;
    if (v107 >= v108)
    {
      unint64_t v78 = v107 + 1;
      if (v106 <= &v101 && (char *)v106 + 24 * v107 > (char *)&v101)
      {
        int64_t v92 = (char *)&v101 - (unsigned char *)v106;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v78, 24);
        int v48 = (char *)v106;
        uint64_t v47 = (int *)((char *)v106 + v92);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v78, 24);
        uint64_t v47 = &v101;
        int v48 = (char *)v106;
      }
    }
    uint64_t v49 = &v48[24 * v107];
    long long v50 = *(_OWORD *)v47;
    *((void *)v49 + 2) = *((void *)v47 + 2);
    *(_OWORD *)uint64_t v49 = v50;
    uint64_t v51 = ++v107;
    if (Value)
    {
      int v101 = 3;
      uint64_t v102 = ") should match number of case destinations (";
      uint64_t v103 = 44;
      unint64_t v52 = &v101;
      uint64_t v53 = (char *)v106;
      if (v51 >= v108)
      {
        unint64_t v81 = v51 + 1;
        BOOL v82 = (char *)v106 + 24 * v51 > (char *)&v101;
        if (v106 <= &v101 && v82)
        {
          int64_t v94 = (char *)&v101 - (unsigned char *)v106;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v81, 24);
          uint64_t v53 = (char *)v106;
          unint64_t v52 = (int *)((char *)v106 + v94);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v81, 24);
          unint64_t v52 = &v101;
          uint64_t v53 = (char *)v106;
        }
      }
      unint64_t v54 = &v53[24 * v107];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = *((void *)v52 + 2);
      *(_OWORD *)unint64_t v54 = v55;
      uint64_t v56 = ++v107;
      if (Value)
      {
        int v101 = 5;
        uint64_t v102 = v4;
        uint64_t v57 = &v101;
        unint64_t v58 = (char *)v106;
        if (v56 >= v108)
        {
          unint64_t v83 = v56 + 1;
          BOOL v84 = (char *)v106 + 24 * v56 > (char *)&v101;
          if (v106 <= &v101 && v84)
          {
            int64_t v95 = (char *)&v101 - (unsigned char *)v106;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v83, 24);
            unint64_t v58 = (char *)v106;
            uint64_t v57 = (int *)((char *)v106 + v95);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v83, 24);
            uint64_t v57 = &v101;
            unint64_t v58 = (char *)v106;
          }
        }
        unint64_t v59 = &v58[24 * v107];
        long long v60 = *(_OWORD *)v57;
        *((void *)v59 + 2) = *((void *)v57 + 2);
        *(_OWORD *)unint64_t v59 = v60;
        uint64_t v61 = ++v107;
        if (Value)
        {
          int v101 = 3;
          uint64_t v102 = ")";
          uint64_t v103 = 1;
          unint64_t v62 = &v101;
          unint64_t v63 = (char *)v106;
          if (v61 >= v108)
          {
            unint64_t v85 = v61 + 1;
            BOOL v86 = (char *)v106 + 24 * v61 > (char *)&v101;
            if (v106 <= &v101 && v86)
            {
              int64_t v96 = (char *)&v101 - (unsigned char *)v106;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v85, 24);
              unint64_t v63 = (char *)v106;
              unint64_t v62 = (int *)((char *)v106 + v96);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v106, v109, v85, 24);
              unint64_t v62 = &v101;
              unint64_t v63 = (char *)v106;
            }
          }
          int v64 = &v63[24 * v107];
          long long v65 = *(_OWORD *)v62;
          *((void *)v64 + 2) = *((void *)v62 + 2);
          *(_OWORD *)int v64 = v65;
          ++v107;
        }
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v114)
  {
    long long v66 = (void **)__p;
    if (__p)
    {
      long long v67 = v113;
      uint64_t v68 = __p;
      if (v113 != __p)
      {
        do
          long long v67 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v67 - 1);
        while (v67 != v66);
        uint64_t v68 = __p;
      }
      uint64_t v113 = v66;
      operator delete(v68);
    }
    int32x4_t v36 = v110;
    if (!v110) {
      goto LABEL_66;
    }
    int v69 = v111;
    unint64_t v38 = v110;
    if (v111 == v110) {
      goto LABEL_65;
    }
    do
    {
      uint64_t v71 = (void *)*--v69;
      uint64_t v70 = v71;
      *int v69 = 0;
      if (v71) {
        operator delete[](v70);
      }
    }
    while (v69 != v36);
    goto LABEL_64;
  }
  return v32;
}

void mlir::cf::SwitchOp::getSuccessorOperands(mlir::Operation **this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  v21[7] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    uint64_t v5 = (a2 - 1);
    mlir::cf::SwitchOp::getCaseOperandsMutable(this, (uint64_t)&v19);
    mlir::MutableOperandRangeRange::dereference((uint64_t)&v19, v21[5] + v5, (uint64_t)v16);
    if (*((void **)&v20 + 1) != v21) {
      free(*((void **)&v20 + 1));
    }
    mlir::SuccessorOperands::SuccessorOperands(a3, v16);
    unint64_t v6 = v17;
    if (v17 != v18) {
LABEL_5:
    }
      free(v6);
  }
  else
  {
    uint64_t v7 = *this;
    if (HIBYTE(*((_DWORD *)*this + 11))) {
      unint64_t v8 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
    }
    else {
      unint64_t v8 = 0;
    }
    int v9 = *(_DWORD *)(v8 + 16);
    int v10 = *(_DWORD *)(v8 + 20);
    uint64_t v11 = *(void *)(*(void *)(*((void *)v7 + 6) + 96) + 8 * *(void *)(*((void *)v7 + 6) + 104) - 8);
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Operation *)((char *)v7 + 24));
    unint64_t v13 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
    if (!HIBYTE(*((_DWORD *)*this + 11))) {
      unint64_t v13 = 0;
    }
    uint64_t v14 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v13 + 16, 3);
    mlir::NamedAttribute::NamedAttribute(&v15, v11, v14);
    int v19 = 1;
    long long v20 = v15;
    mlir::MutableOperandRange::MutableOperandRange((uint64_t)v16, (uint64_t)v7, v9, v10, &v19, 1);
    mlir::SuccessorOperands::SuccessorOperands(a3, v16);
    unint64_t v6 = v17;
    if (v17 != v18) {
      goto LABEL_5;
    }
  }
}

void **mlir::cf::SwitchOp::getSuccessorForOperands(Operation **a1, uint64_t *a2)
{
  unint64_t v3 = *a1;
  unint64_t v4 = *((unsigned int *)*a1 + 11);
  uint64_t v5 = (uint64_t)*a1 + 16 * ((v4 >> 23) & 1) + 64;
  if (HIBYTE(*((_DWORD *)*a1 + 11))) {
    uint64_t v6 = (uint64_t)*a1 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v6 = 0;
  }
  v29[0] = *(void *)(v6 + 8);
  v29[1] = v29[0] != 0;
  if (!v29[0])
  {
    uint64_t v12 = v5 + ((v4 >> 21) & 0x7F8) + 7;
    return *(void ***)((v12 & 0xFFFFFFFFFFFFFFF8) + 24);
  }
  mlir::SuccessorRange::SuccessorRange((unint64_t *)__p, v3);
  unint64_t v8 = __p[0];
  mlir::SuccessorRange::SuccessorRange((unint64_t *)__p, *a1);
  uint64_t v9 = *a2;
  if (*a2)
  {
    int v10 = *(void **)(*(void *)v9 + 136);
    if (v10 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
      uint64_t v9 = 0;
    }
    uint64_t v28 = v9;
    if (v10 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      uint64_t v11 = __p;
      mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v29, (uint64_t)__p);
      long long v21 = *(_OWORD *)__p;
      long long v22 = v24;
      unint64_t v13 = v25;
      int v14 = v26;
      uint64_t v15 = v27;
      uint64_t v20 = 0;
      if (__p[0] != v25 || BYTE8(v21) != v26 || (void)v22 != v27)
      {
        uint64_t v16 = 0;
        do
        {
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v21, (llvm::APInt *)&v30);
          LODWORD(v24) = v31;
          __p[0] = v16;
          __p[1] = v30;
          mlir::IntegerAttr::getValue(&v28, (llvm::APInt *)&v30);
          if (v24 > 0x40)
          {
            BOOL v17 = llvm::APInt::equalSlowCase((const void **)&__p[1], (const void **)&v30);
            if (v31 < 0x41) {
              goto LABEL_21;
            }
          }
          else
          {
            BOOL v17 = __p[1] == v30;
            if (v31 < 0x41) {
              goto LABEL_21;
            }
          }
          if (v30) {
            operator delete[](v30);
          }
LABEL_21:
          if (v17) {
            uint64_t v11 = (void **)v8[4 * (uint64_t)__p[0] + 7];
          }
          if (v24 >= 0x41 && __p[1]) {
            operator delete[](__p[1]);
          }
          if (v17) {
            return v11;
          }
          uint64_t v16 = (void *)(v20 + 1);
          uint64_t v18 = v22 + 1;
          ++v20;
          *(void *)&long long v22 = v22 + 1;
        }
        while ((void *)v21 != v13 || BYTE8(v21) != v14 || v18 != v15);
      }
      uint64_t v12 = (uint64_t)*a1
          + 16 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1)
          + (((unint64_t)*((unsigned int *)*a1 + 11) >> 21) & 0x7F8)
          + 71;
      return *(void ***)((v12 & 0xFFFFFFFFFFFFFFF8) + 24);
    }
  }
  return 0;
}

uint64_t mlir::cf::SwitchOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v43, 1);
  __int16 v2 = v43;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"cf.switch", 9, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D06B0;
  v4[12] = simplifySwitchWithOnlyDefault;
  unsigned long long v44 = v4;
  uint64_t v5 = (void *)a1[2];
  if ((unint64_t)v5 >= a1[3])
  {
    uint64_t v6 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    uint64_t v7 = (uint64_t)v44;
    a1[2] = (uint64_t)v6;
    unsigned long long v44 = 0;
    if (v7) {
      (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    }
  }
  else
  {
    void *v5 = v4;
    a1[2] = (uint64_t)(v5 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v42, 1);
  __int16 v8 = v42;
  uint64_t v9 = *a1;
  int v10 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v10 + 1), (uint64_t)"cf.switch", 9, v8, v9, 0, 0);
  void *v10 = &unk_1EC9D06B0;
  v10[12] = dropSwitchCasesThatMatchDefault;
  unsigned long long v44 = v10;
  uint64_t v11 = (void *)a1[2];
  if ((unint64_t)v11 >= a1[3])
  {
    uint64_t v12 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    uint64_t v13 = (uint64_t)v44;
    a1[2] = (uint64_t)v12;
    unsigned long long v44 = 0;
    if (v13) {
      (*(void (**)(uint64_t))(*(void *)v13 + 8))(v13);
    }
  }
  else
  {
    void *v11 = v10;
    a1[2] = (uint64_t)(v11 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v41, 1);
  __int16 v14 = v41;
  uint64_t v15 = *a1;
  uint64_t v16 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v16 + 1), (uint64_t)"cf.switch", 9, v14, v15, 0, 0);
  *uint64_t v16 = &unk_1EC9D06B0;
  v16[12] = simplifyConstSwitchValue;
  unsigned long long v44 = v16;
  BOOL v17 = (void *)a1[2];
  if ((unint64_t)v17 >= a1[3])
  {
    uint64_t v18 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    uint64_t v19 = (uint64_t)v44;
    a1[2] = (uint64_t)v18;
    unsigned long long v44 = 0;
    if (v19) {
      (*(void (**)(uint64_t))(*(void *)v19 + 8))(v19);
    }
  }
  else
  {
    void *v17 = v16;
    a1[2] = (uint64_t)(v17 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v40, 1);
  __int16 v20 = v40;
  uint64_t v21 = *a1;
  long long v22 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v22 + 1), (uint64_t)"cf.switch", 9, v20, v21, 0, 0);
  void *v22 = &unk_1EC9D06B0;
  v22[12] = simplifyPassThroughSwitch;
  unsigned long long v44 = v22;
  uint64_t v23 = (void *)a1[2];
  if ((unint64_t)v23 >= a1[3])
  {
    long long v24 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    uint64_t v25 = (uint64_t)v44;
    a1[2] = (uint64_t)v24;
    unsigned long long v44 = 0;
    if (v25) {
      (*(void (**)(uint64_t))(*(void *)v25 + 8))(v25);
    }
  }
  else
  {
    void *v23 = v22;
    a1[2] = (uint64_t)(v23 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v39, 1);
  __int16 v26 = v39;
  uint64_t v27 = *a1;
  uint64_t v28 = operator new(0x68uLL);
  mlir::Pattern::Pattern((uint64_t)(v28 + 1), (uint64_t)"cf.switch", 9, v26, v27, 0, 0);
  void *v28 = &unk_1EC9D06B0;
  v28[12] = simplifySwitchFromSwitchOnSameCondition;
  unsigned long long v44 = v28;
  unint64_t v29 = (void *)a1[2];
  if ((unint64_t)v29 >= a1[3])
  {
    int v30 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    uint64_t v31 = (uint64_t)v44;
    a1[2] = (uint64_t)v30;
    unsigned long long v44 = 0;
    if (v31) {
      (*(void (**)(uint64_t))(*(void *)v31 + 8))(v31);
    }
  }
  else
  {
    *unint64_t v29 = v28;
    a1[2] = (uint64_t)(v29 + 1);
  }
  mlir::PatternBenefit::PatternBenefit(&v38, 1);
  __int16 v32 = v38;
  uint64_t v33 = *a1;
  unint64_t v34 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v34 + 1), (uint64_t)"cf.switch", 9, v32, v33, 0, 0);
  void *v34 = &unk_1EC9D06B0;
  v34[12] = simplifySwitchFromDefaultSwitchOnSameCondition;
  unsigned long long v44 = v34;
  int32x4_t v36 = (void *)a1[2];
  if ((unint64_t)v36 >= a1[3])
  {
    int32x4_t v37 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v44);
    uint64_t result = (uint64_t)v44;
    a1[2] = (uint64_t)v37;
    unsigned long long v44 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    *int32x4_t v36 = v34;
    a1[2] = (uint64_t)(v36 + 1);
  }
  return result;
}

uint64_t simplifySwitchWithOnlyDefault(uint64_t a1, uint64_t a2)
{
  mlir::SuccessorRange::SuccessorRange(&v12, (Operation *)a1);
  mlir::SuccessorRange::SuccessorRange(&v12, (Operation *)a1);
  if (v13 != 1) {
    return 0;
  }
  unint64_t v4 = *(unsigned int *)(a1 + 44);
  uint64_t v11 = *(void *)(((a1 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
  if (BYTE3(v4)) {
    uint64_t v5 = a1 + 16 * ((v4 >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v6 = *(unsigned int *)(v5 + 16);
  int v7 = *(_DWORD *)(v5 + 20);
  if ((v4 & 0x800000) != 0) {
    uint64_t v8 = *(void *)(a1 + 72);
  }
  else {
    uint64_t v8 = 0;
  }
  unint64_t v12 = v8 + 32 * v6;
  uint64_t v13 = (v7 + v6) - v6;
  uint64_t v9 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(void *)(a1 + 24), &v11, (uint64_t)&v12);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v9);
  return 1;
}

uint64_t dropSwitchCasesThatMatchDefault(uint64_t a1, mlir::MLIRContext **a2)
{
  v84[6] = *MEMORY[0x1E4F143B8];
  BOOL v82 = v84;
  uint64_t v83 = 0x600000000;
  unint64_t v79 = v81;
  uint64_t v80 = 0x300000000;
  unint64_t v76 = v78;
  uint64_t v77 = 0x300000000;
  uint64_t v4 = a1 + 64;
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v5 = a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
  }
  else {
    unint64_t v5 = 0;
  }
  v72[0] = *(void *)(v5 + 8);
  v72[1] = v72[0] != 0;
  mlir::SuccessorRange::SuccessorRange((unint64_t *)&v67, (Operation *)a1);
  uint64_t v6 = v67;
  mlir::SuccessorRange::SuccessorRange((unint64_t *)&v67, (Operation *)a1);
  mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v72, (uint64_t)&v67);
  long long v65 = v67;
  long long v66 = v68;
  uint64_t v7 = v69;
  int v8 = v70;
  uint64_t v9 = v71;
  uint64_t v64 = 0;
  if ((void)v67 == v69 && BYTE8(v65) == v70 && (void)v66 == v71)
  {
    uint64_t v10 = 0;
    uint64_t v11 = (char *)v76;
    uint64_t v12 = v77;
    if (!v77) {
      goto LABEL_65;
    }
    goto LABEL_59;
  }
  long long v60 = a2;
  uint64_t v13 = 0;
  char v14 = 0;
  uint64_t v15 = v6 + 32;
  do
  {
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v65, (llvm::APInt *)&v67);
    unsigned int v63 = DWORD2(v67);
    uint64_t v61 = v13;
    __p = (void *)v67;
    unint64_t v19 = *(unsigned int *)(a1 + 44);
    __int16 v20 = (uint64_t *)(v4 + 16 * ((v19 >> 23) & 1));
    if (*(void *)(v15 + 32 * v13 + 24) != *(void *)((((unint64_t)v20 + ((v19 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                                       + 24))
      goto LABEL_36;
    if (BYTE3(v19)) {
      uint64_t v21 = (_DWORD *)(v4 + 16 * ((v19 >> 23) & 1));
    }
    else {
      uint64_t v21 = 0;
    }
    if ((v19 & 0x800000) != 0) {
      uint64_t v22 = *(void *)(a1 + 72);
    }
    else {
      uint64_t v22 = 0;
    }
    uint64_t v23 = (v21[5] + v21[4]);
    uint64_t v24 = (v21[6] + v23) - v23;
    uint64_t v73 = v22 + 32 * v23;
    uint64_t v74 = v24;
    mlir::OperandRange::split(&v73, *v20, &v67);
    uint64_t v25 = mlir::OperandRangeRange::dereference(&v67, v68 + v13);
    unint64_t v27 = *(unsigned int *)(a1 + 44);
    if (HIBYTE(*(_DWORD *)(a1 + 44))) {
      uint64_t v28 = v4 + 16 * ((v27 >> 23) & 1);
    }
    else {
      uint64_t v28 = 0;
    }
    if ((v27 & 0x800000) != 0)
    {
      uint64_t v29 = *(void *)(a1 + 72);
      uint64_t v30 = *(unsigned int *)(v28 + 16);
      if (v26 != (*(_DWORD *)(v28 + 20) + v30) - v30) {
        goto LABEL_36;
      }
    }
    else
    {
      uint64_t v29 = 0;
      uint64_t v30 = *(unsigned int *)(v28 + 16);
      if (v26 != (*(_DWORD *)(v28 + 20) + v30) - v30) {
        goto LABEL_36;
      }
    }
    if (!v26)
    {
LABEL_32:
      char v14 = 1;
      if (v63 < 0x41) {
        goto LABEL_10;
      }
      goto LABEL_49;
    }
    uint64_t v31 = (void *)(v29 + 32 * v30 + 24);
    __int16 v32 = (void *)(v25 + 24);
    while (*v32 == *v31)
    {
      v31 += 4;
      v32 += 4;
      if (!--v26) {
        goto LABEL_32;
      }
    }
LABEL_36:
    uint64_t v33 = *(void *)(v15 + 32 * v61 + 24);
    uint64_t v34 = v83;
    if (v83 >= (unint64_t)HIDWORD(v83))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v84, v83 + 1, 8);
      uint64_t v34 = v83;
    }
    v82[v34] = v33;
    LODWORD(v83) = v83 + 1;
    unint64_t v35 = *(unsigned int *)(a1 + 44);
    int32x4_t v36 = (uint64_t *)(v4 + 16 * ((v35 >> 23) & 1));
    if (HIBYTE(*(_DWORD *)(a1 + 44))) {
      int32x4_t v37 = (_DWORD *)(v4 + 16 * ((v35 >> 23) & 1));
    }
    else {
      int32x4_t v37 = 0;
    }
    int v38 = v37[4];
    int v39 = v37[5];
    int v40 = v37[6];
    if ((v35 & 0x800000) != 0) {
      uint64_t v41 = *(void *)(a1 + 72);
    }
    else {
      uint64_t v41 = 0;
    }
    uint64_t v42 = (v39 + v38);
    uint64_t v73 = v41 + 32 * v42;
    uint64_t v74 = (v40 + v42) - v42;
    mlir::OperandRange::split(&v73, *v36, &v67);
    uint64_t v43 = mlir::OperandRangeRange::dereference(&v67, v68 + v61);
    mlir::ValueRange::ValueRange((unint64_t *)&v75, v43, v44);
    long long v45 = v75;
    uint64_t v46 = v80;
    if (v80 >= (unint64_t)HIDWORD(v80))
    {
      long long v59 = v75;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v81, v80 + 1, 16);
      long long v45 = v59;
      uint64_t v46 = v80;
    }
    v79[v46] = v45;
    LODWORD(v80) = v80 + 1;
    Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v76, (unint64_t)&__p, 1);
    int v48 = (llvm::APInt *)((char *)v76 + 16 * v77);
    unsigned int v49 = *((_DWORD *)Address + 2);
    *((_DWORD *)v48 + 2) = v49;
    if (v49 > 0x40)
    {
      llvm::APInt::initSlowCase(v48, (const void **)Address);
      LODWORD(v77) = v77 + 1;
      if (v63 < 0x41) {
        goto LABEL_10;
      }
    }
    else
    {
      *(void *)int v48 = *(void *)Address;
      LODWORD(v77) = v77 + 1;
      if (v63 < 0x41) {
        goto LABEL_10;
      }
    }
LABEL_49:
    if (__p) {
      operator delete[](__p);
    }
LABEL_10:
    uint64_t v13 = v64 + 1;
    uint64_t v16 = v66 + 1;
    ++v64;
    *(void *)&long long v66 = v66 + 1;
  }
  while ((void)v65 != v7 || BYTE8(v65) != v8 || v16 != v9);
  if (v14)
  {
    unint64_t v50 = *(unsigned int *)(a1 + 44);
    uint64_t v51 = *(void *)(a1 + 72);
    uint64_t v64 = *(void *)(v51 + 24);
    uint64_t v61 = *(void *)(((a1 + 80 + ((v50 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
    if (BYTE3(v50)) {
      uint64_t v52 = a1 + 80;
    }
    else {
      uint64_t v52 = 0;
    }
    uint64_t v53 = *(unsigned int *)(v52 + 16);
    uint64_t v54 = (*(_DWORD *)(v52 + 20) + v53) - v53;
    *(void *)&long long v67 = v51 + 32 * v53;
    *((void *)&v67 + 1) = v54;
    long long v55 = mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *,mlir::OperandRange,llvm::SmallVector<llvm::APInt,3u> &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(v60 + 1, *(void *)(a1 + 24), &v64, &v61, (uint64_t)&v67, (uint64_t)&v76, (uint64_t)&v82, (uint64_t)&v79);
    (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*v60 + 4))(v60, a1, v55);
    uint64_t v10 = 1;
    uint64_t v11 = (char *)v76;
    uint64_t v12 = v77;
    if (!v77) {
      goto LABEL_65;
    }
  }
  else
  {
    uint64_t v10 = 0;
    uint64_t v11 = (char *)v76;
    uint64_t v12 = v77;
    if (!v77) {
      goto LABEL_65;
    }
  }
LABEL_59:
  uint64_t v56 = 16 * v12;
  do
  {
    if (*(_DWORD *)&v11[v56 - 8] >= 0x41u)
    {
      uint64_t v57 = *(void **)&v11[v56 - 16];
      if (v57) {
        operator delete[](v57);
      }
    }
    v56 -= 16;
  }
  while (v56);
  uint64_t v11 = (char *)v76;
LABEL_65:
  if (v11 != v78) {
    free(v11);
  }
  if (v79 != (_OWORD *)v81) {
    free(v79);
  }
  if (v82 != v84) {
    free(v82);
  }
  return v10;
}

uint64_t simplifyConstSwitchValue(uint64_t a1, uint64_t a2)
{
  v19[1] = *MEMORY[0x1E4F143B8];
  unsigned int v16 = 1;
  uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 24);
  p_p = &__p;
  __p = 0;
  uint64_t v17 = v4;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
  if (!DefiningOp) {
    goto LABEL_20;
  }
  uint64_t v6 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((void *)(DefiningOp + 48))) {
    goto LABEL_20;
  }
  v18[0] = v19;
  v18[1] = (void *)0x100000000;
  mlir::Operation::fold(v6, 0, 0, (uint64_t)v18);
  unint64_t v7 = *(void *)v18[0] & 0xFFFFFFFFFFFFFFF8;
  if (v18[0] != v19) {
    free(v18[0]);
  }
  if (v7
    && ((int v8 = *(void **)(*(void *)(*(void *)(v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 136),
         v8 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      ? (BOOL v9 = v8 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      : (BOOL v9 = 1),
        !v9 ? (BOOL v10 = v8 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (BOOL v10 = 1),
        !v10 ? (BOOL v11 = v8 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (BOOL v11 = 1),
        v11 && mlir::detail::constant_int_value_binder::match((uint64_t *)&p_p, v7)))
  {
    foldSwitch(a1, a2, (const void **)&__p);
    uint64_t v12 = 1;
    if (v16 < 0x41) {
      return v12;
    }
  }
  else
  {
LABEL_20:
    uint64_t v12 = 0;
    if (v16 < 0x41) {
      return v12;
    }
  }
  if (__p) {
    operator delete[](__p);
  }
  return v12;
}

uint64_t simplifyPassThroughSwitch(uint64_t a1, mlir::MLIRContext **a2)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  unint64_t v44 = v56;
  uint64_t v54 = v56;
  uint64_t v55 = 0x600000000;
  uint64_t v51 = v53;
  uint64_t v52 = 0x300000000;
  int v48 = v50;
  uint64_t v49 = 0x100000000;
  uint64_t v4 = a1 + 64;
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v5 = a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
  }
  else {
    unint64_t v5 = 0;
  }
  v46[0] = *(void *)(v5 + 8);
  v46[1] = v46[0] != 0;
  unint64_t v6 = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v46) + 1;
  if (v6 > HIDWORD(v49)) {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::grow((uint64_t)&v48, v6);
  }
  unint64_t v7 = mlir::SuccessorRange::SuccessorRange((unint64_t *)&v57, (Operation *)a1);
  uint64_t v8 = v57;
  mlir::SuccessorRange::SuccessorRange(v7, (Operation *)a1);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v46);
  if (NumElements < 1)
  {
    char v11 = 0;
  }
  else
  {
    uint64_t v10 = NumElements;
    char v11 = 0;
    uint64_t v12 = 0;
    uint64_t v13 = (uint64_t *)(v8 + 56);
    do
    {
      uint64_t v45 = *v13;
      unint64_t v14 = *(unsigned int *)(a1 + 44);
      uint64_t v15 = (uint64_t *)(v4 + 16 * ((v14 >> 23) & 1));
      if (HIBYTE(*(_DWORD *)(a1 + 44))) {
        unsigned int v16 = (_DWORD *)(v4 + 16 * ((v14 >> 23) & 1));
      }
      else {
        unsigned int v16 = 0;
      }
      if ((v14 & 0x800000) != 0) {
        uint64_t v17 = *(void *)(a1 + 72);
      }
      else {
        uint64_t v17 = 0;
      }
      uint64_t v18 = (v16[5] + v16[4]);
      uint64_t v19 = (v16[6] + v18) - v18;
      v47[0] = v17 + 32 * v18;
      v47[1] = v19;
      mlir::OperandRange::split(v47, *v15, &v57);
      uint64_t v20 = mlir::OperandRangeRange::dereference(&v57, v58 + v12);
      mlir::ValueRange::ValueRange((unint64_t *)&v57, v20, v21);
      if (v49 >= HIDWORD(v49))
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::growAndEmplaceBack<>((uint64_t)&v48);
        unsigned int v23 = v49;
      }
      else
      {
        uint64_t v22 = (char *)v48 + 64 * (unint64_t)v49;
        void *v22 = v22 + 2;
        v22[1] = 0x600000000;
        unsigned int v23 = v49 + 1;
        LODWORD(v49) = v49 + 1;
      }
      BOOL v24 = collapseBranch(&v45, &v57, (uint64_t)((uint64_t)v48 + 64 * (unint64_t)v23) - 64) != 0;
      uint64_t v25 = v45;
      uint64_t v26 = v55;
      if (v55 >= (unint64_t)HIDWORD(v55))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v54, v44, v55 + 1, 8);
        uint64_t v26 = v55;
      }
      *(void *)&v54[8 * v26] = v25;
      LODWORD(v55) = v55 + 1;
      long long v27 = v57;
      uint64_t v28 = v52;
      if (v52 >= (unint64_t)HIDWORD(v52))
      {
        long long v43 = v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
        long long v27 = v43;
        uint64_t v28 = v52;
      }
      v11 |= v24;
      *((_OWORD *)v51 + v28) = v27;
      LODWORD(v52) = v52 + 1;
      ++v12;
      v13 += 4;
    }
    while (v10 != v12);
  }
  unint64_t v29 = *(unsigned int *)(a1 + 44);
  v47[0] = *(void *)(((v4 + 16 * ((v29 >> 23) & 1) + ((v29 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
  if (BYTE3(v29)) {
    uint64_t v30 = v4 + 16 * ((v29 >> 23) & 1);
  }
  else {
    uint64_t v30 = 0;
  }
  uint64_t v31 = *(unsigned int *)(v30 + 16);
  int v32 = *(_DWORD *)(v30 + 20);
  if ((v29 & 0x800000) != 0) {
    uint64_t v33 = *(void *)(a1 + 72);
  }
  else {
    uint64_t v33 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v57, v33 + 32 * v31, (v32 + v31) - v31);
  if (v49 >= HIDWORD(v49))
  {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::growAndEmplaceBack<>((uint64_t)&v48);
    unsigned int v35 = v49;
  }
  else
  {
    uint64_t v34 = (char *)v48 + 64 * (unint64_t)v49;
    void *v34 = v34 + 2;
    v34[1] = 0x600000000;
    unsigned int v35 = v49 + 1;
    LODWORD(v49) = v49 + 1;
  }
  if ((collapseBranch(v47, &v57, (uint64_t)((uint64_t)v48 + 64 * (unint64_t)v35) - 64) != 0) | v11 & 1)
  {
    uint64_t v45 = *(void *)(*(void *)(a1 + 72) + 24);
    int32x4_t v36 = mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::DenseIntElementsAttr &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(a2 + 1, *(void *)(a1 + 24), &v45, v47, (uint64_t *)&v57, v46, (uint64_t)&v54, (uint64_t)&v51);
    (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*a2 + 4))(a2, a1, v36);
    uint64_t v37 = 1;
    int v38 = (char *)v48;
    uint64_t v39 = v49;
    if (!v49) {
      goto LABEL_40;
    }
  }
  else
  {
    uint64_t v37 = 0;
    int v38 = (char *)v48;
    uint64_t v39 = v49;
    if (!v49) {
      goto LABEL_40;
    }
  }
  uint64_t v40 = v39 << 6;
  do
  {
    uint64_t v41 = *(char **)&v38[v40 - 64];
    if (&v38[v40 - 48] != v41) {
      free(v41);
    }
    v40 -= 64;
  }
  while (v40);
  int v38 = (char *)v48;
LABEL_40:
  if (v38 != v50) {
    free(v38);
  }
  if (v51 != v53) {
    free(v51);
  }
  if (v54 != v44) {
    free(v54);
  }
  return v37;
}

uint64_t simplifySwitchFromSwitchOnSameCondition(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(mlir::Block **)(a1 + 16);
  uint64_t result = mlir::Block::getSinglePredecessor(v4);
  if (result)
  {
    mlir::Block::getTerminator((mlir::GenericProgramPoint **)result);
    if (v6) {
      BOOL v7 = *(void *)(*(void *)(v6 + 48) + 16) == (void)&mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id;
    }
    else {
      BOOL v7 = 0;
    }
    if (v7
      && (uint64_t v8 = (unsigned int *)v6, *(void *)(*(void *)(a1 + 72) + 24) == *(void *)(*(void *)(v6 + 72) + 24))
      && *(mlir::Block **)(((v6 + 64 + (((unint64_t)*(unsigned int *)(v6 + 44) >> 21) & 0x7F8) + 23) & 0xFFFFFFFFFFFFFFF8)
                         + 24) != v4)
    {
      mlir::SuccessorRange::SuccessorRange((unint64_t *)&v20, (Operation *)v6);
      uint64_t v9 = v20;
      mlir::SuccessorRange::SuccessorRange((unint64_t *)&v20, (Operation *)v8);
      uint64_t v10 = 0;
      uint64_t v11 = *((void *)&v20 + 1) - 1;
      if (*((void *)&v20 + 1) != 1)
      {
        uint64_t v12 = (mlir::Block **)(v9 + 56);
        while (*v12 != v4)
        {
          ++v10;
          v12 += 4;
          if (v11 == v10) {
            goto LABEL_17;
          }
        }
      }
      if (v10 == v11)
      {
LABEL_17:
        unint64_t v13 = *(unsigned int *)(a1 + 44);
        *(void *)&long long v26 = *(void *)(((a1 + 16 * ((v13 >> 23) & 1) + 64 + ((v13 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                    + 24);
        if (BYTE3(v13)) {
          uint64_t v14 = a1 + 16 * ((v13 >> 23) & 1) + 64;
        }
        else {
          uint64_t v14 = 0;
        }
        uint64_t v15 = *(unsigned int *)(v14 + 16);
        int v16 = *(_DWORD *)(v14 + 20);
        if ((v13 & 0x800000) != 0) {
          uint64_t v17 = *(void *)(a1 + 72);
        }
        else {
          uint64_t v17 = 0;
        }
        *(void *)&long long v20 = v17 + 32 * v15;
        *((void *)&v20 + 1) = (v16 + v15) - v15;
        uint64_t v18 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(void *)(a1 + 24), (uint64_t *)&v26, (uint64_t)&v20);
        (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v18);
      }
      else
      {
        if (HIBYTE(v8[11])) {
          unint64_t v19 = (unint64_t)&v8[4 * (((unint64_t)v8[11] >> 23) & 1) + 16];
        }
        else {
          unint64_t v19 = 0;
        }
        v25[0] = *(void *)(v19 + 8);
        v25[1] = v25[0] != 0;
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v25, (uint64_t)&v20);
        long long v26 = v20;
        uint64_t v27 = v21 + v10;
        uint64_t v28 = v22;
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v26, (llvm::APInt *)&__p);
        foldSwitch(a1, a2, (const void **)&__p);
        if (v24 >= 0x41 && __p) {
          operator delete[](__p);
        }
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t simplifySwitchFromDefaultSwitchOnSameCondition(uint64_t a1, mlir::MLIRContext **a2)
{
  v83[7] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(mlir::Block **)(a1 + 16);
  SinglePredecessor = (mlir::GenericProgramPoint **)mlir::Block::getSinglePredecessor(v4);
  if (SinglePredecessor)
  {
    mlir::Block::getTerminator(SinglePredecessor);
    if (v6
      && *(void *)(*(void *)(v6 + 48) + 16) == (void)&mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id)
    {
      uint64_t v8 = (unsigned int *)v6;
      if (*(void *)(*(void *)(a1 + 72) + 24) == *(void *)(*(void *)(v6 + 72) + 24)
        && *(mlir::Block **)(((v6 + (((unint64_t)*(unsigned int *)(v6 + 44) >> 21) & 0x7F8) + 87) & 0xFFFFFFFFFFFFFFF8)
                           + 24) == v4)
      {
        v72[0] = 0;
        v72[1] = 0;
        unsigned int v73 = 0;
        mlir::SuccessorRange::SuccessorRange((unint64_t *)&v66, (Operation *)v6);
        uint64_t v10 = v66;
        mlir::SuccessorRange::SuccessorRange((unint64_t *)&v66, (Operation *)v8);
        if (HIBYTE(v8[11])) {
          unint64_t v11 = (unint64_t)&v8[4 * (((unint64_t)v8[11] >> 23) & 1) + 16];
        }
        else {
          unint64_t v11 = 0;
        }
        v71[0] = *(void *)(v11 + 8);
        v71[1] = v71[0] != 0;
        uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)v71);
        if (NumElements >= 1)
        {
          uint64_t v13 = NumElements;
          uint64_t v14 = 0;
          uint64_t v15 = (mlir::Block **)(v10 + 56);
          do
          {
            if (v4 != *v15)
            {
              mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v71, (uint64_t)&v66);
              long long v82 = v66;
              v83[0] = v14 + v67;
              v83[1] = *((void *)&v67 + 1);
              mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v82, (llvm::APInt *)&v79);
              *(void *)&long long v82 = 0;
              if (llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>((uint64_t *)v72, (llvm *)&v79, (uint64_t *)&v82))
              {
                if (v80 >= 0x41 && v79) {
                  operator delete[](v79);
                }
              }
              else
              {
                uint64_t v16 = llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::InsertIntoBucketImpl<llvm::APInt>((uint64_t)v72, (uint64_t)&v79, (llvm *)&v79, v82);
                uint64_t v17 = v16;
                if (*(_DWORD *)(v16 + 8) >= 0x41u)
                {
                  uint64_t v18 = *(void **)v16;
                  if (*(void *)v17) {
                    operator delete[](v18);
                  }
                }
                *(void *)uint64_t v17 = v79;
                *(_DWORD *)(v17 + 8) = v80;
              }
            }
            ++v14;
            v15 += 4;
          }
          while (v13 != v14);
        }
        *(void *)&long long v82 = v83;
        *((void *)&v82 + 1) = 0x600000000;
        unint64_t v79 = v81;
        uint64_t v80 = 0x300000000;
        unint64_t v76 = v78;
        uint64_t v77 = 0x300000000;
        if (HIBYTE(*(_DWORD *)(a1 + 44))) {
          unint64_t v19 = a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
        }
        else {
          unint64_t v19 = 0;
        }
        v65[0] = *(void *)(v19 + 8);
        v65[1] = v65[0] != 0;
        mlir::SuccessorRange::SuccessorRange((unint64_t *)&v66, (Operation *)a1);
        uint64_t v20 = v66;
        mlir::SuccessorRange::SuccessorRange((unint64_t *)&v66, (Operation *)a1);
        mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v65, (uint64_t)&v66);
        long long v63 = v66;
        long long v64 = v67;
        uint64_t v21 = v68;
        int v22 = v69;
        uint64_t v23 = v70;
        uint64_t v62 = 0;
        if ((void)v66 == v68 && BYTE8(v63) == v69 && (void)v64 == v70)
        {
LABEL_61:
          unint64_t v50 = (char *)v76;
          if (v77)
          {
            uint64_t v51 = 16 * v77;
            do
            {
              if (*(_DWORD *)&v50[v51 - 8] >= 0x41u)
              {
                uint64_t v52 = *(void **)&v50[v51 - 16];
                if (v52) {
                  operator delete[](v52);
                }
              }
              v51 -= 16;
            }
            while (v51);
            unint64_t v50 = (char *)v76;
          }
          if (v50 != v78) {
            free(v50);
          }
          if (v79 != v81) {
            free(v79);
          }
          if ((void *)v82 != v83) {
            free((void *)v82);
          }
          uint64_t v53 = v72[0];
          if (v73)
          {
            uint64_t v54 = (_DWORD *)((char *)v72[0] + 8);
            uint64_t v55 = 16 * v73;
            do
            {
              if (*v54 >= 0x41u)
              {
                uint64_t v56 = (void *)*((void *)v54 - 1);
                if (v56) {
                  operator delete[](v56);
                }
              }
              v54 += 4;
              v55 -= 16;
            }
            while (v55);
            uint64_t v53 = v72[0];
            long long v57 = (void *)(16 * v73);
          }
          else
          {
            long long v57 = 0;
          }
          llvm::deallocate_buffer(v53, v57);
        }
        uint64_t v24 = 0;
        char v25 = 0;
        while (1)
        {
          mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v63, (llvm::APInt *)&v66);
          unsigned int v61 = DWORD2(v66);
          uint64_t v59 = v24;
          __p = (void *)v66;
          *(void *)&long long v66 = 0;
          if (!llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>((uint64_t *)v72, (llvm *)&__p, (uint64_t *)&v66)|| (llvm *)v66 == (llvm *)((char *)v72[0] + 16 * v73))
          {
            uint64_t v26 = *(void *)(v20 + 32 + 32 * v59 + 24);
            uint64_t v27 = DWORD2(v82);
            if (DWORD2(v82) >= (unint64_t)HIDWORD(v82))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v82, v83, DWORD2(v82) + 1, 8);
              uint64_t v27 = DWORD2(v82);
            }
            *(void *)(v82 + 8 * v27) = v26;
            ++DWORD2(v82);
            unint64_t v28 = *(unsigned int *)(a1 + 44);
            unint64_t v29 = (uint64_t *)(a1 + 64 + 16 * ((v28 >> 23) & 1));
            if (HIBYTE(*(_DWORD *)(a1 + 44))) {
              uint64_t v30 = (_DWORD *)(a1 + 64 + 16 * ((v28 >> 23) & 1));
            }
            else {
              uint64_t v30 = 0;
            }
            int v31 = v30[4];
            int v32 = v30[5];
            int v33 = v30[6];
            if ((v28 & 0x800000) != 0) {
              uint64_t v34 = *(void *)(a1 + 72);
            }
            else {
              uint64_t v34 = 0;
            }
            uint64_t v35 = (v32 + v31);
            v74[0] = v34 + 32 * v35;
            v74[1] = (v33 + v35) - v35;
            mlir::OperandRange::split(v74, *v29, &v66);
            uint64_t v36 = mlir::OperandRangeRange::dereference(&v66, v67 + v59);
            mlir::ValueRange::ValueRange((unint64_t *)&v75, v36, v37);
            long long v38 = v75;
            uint64_t v39 = v80;
            if (v80 >= (unint64_t)HIDWORD(v80))
            {
              long long v58 = v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v81, v80 + 1, 16);
              long long v38 = v58;
              uint64_t v39 = v80;
            }
            *(_OWORD *)&v79[16 * v39] = v38;
            LODWORD(v80) = v80 + 1;
            Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v76, (unint64_t)&__p, 1);
            uint64_t v41 = (llvm::APInt *)((char *)v76 + 16 * v77);
            unsigned int v42 = *((_DWORD *)Address + 2);
            *((_DWORD *)v41 + 2) = v42;
            if (v42 > 0x40)
            {
              llvm::APInt::initSlowCase(v41, (const void **)Address);
              LODWORD(v77) = v77 + 1;
              if (v61 >= 0x41)
              {
LABEL_49:
                if (__p) {
                  operator delete[](__p);
                }
              }
            }
            else
            {
              *(void *)uint64_t v41 = *(void *)Address;
              LODWORD(v77) = v77 + 1;
              if (v61 >= 0x41) {
                goto LABEL_49;
              }
            }
          }
          else
          {
            char v25 = 1;
            if (v61 >= 0x41) {
              goto LABEL_49;
            }
          }
          uint64_t v24 = v62 + 1;
          uint64_t v43 = v64 + 1;
          ++v62;
          *(void *)&long long v64 = v64 + 1;
          if ((void)v63 == v21 && BYTE8(v63) == v22 && v43 == v23)
          {
            if (v25)
            {
              unint64_t v44 = *(unsigned int *)(a1 + 44);
              uint64_t v45 = *(void *)(a1 + 72);
              uint64_t v62 = *(void *)(v45 + 24);
              uint64_t v59 = *(void *)(((a1 + 80 + ((v44 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
              if (BYTE3(v44)) {
                uint64_t v46 = a1 + 80;
              }
              else {
                uint64_t v46 = 0;
              }
              uint64_t v47 = *(unsigned int *)(v46 + 16);
              uint64_t v48 = (*(_DWORD *)(v46 + 20) + v47) - v47;
              *(void *)&long long v66 = v45 + 32 * v47;
              *((void *)&v66 + 1) = v48;
              uint64_t v49 = mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *,mlir::OperandRange,llvm::SmallVector<llvm::APInt,3u> &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(a2 + 1, *(void *)(a1 + 24), &v62, &v59, (uint64_t)&v66, (uint64_t)&v76, (uint64_t)&v82, (uint64_t)&v79);
              (*((void (**)(mlir::MLIRContext **, uint64_t, mlir::GenericProgramPoint *))*a2 + 4))(a2, a1, v49);
            }
            goto LABEL_61;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t mlir::cf::AssertOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v69 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      long long v57 = "expected DictionaryAttr to set properties";
      uint64_t v58 = 41;
      uint64_t v26 = &v56;
      uint64_t v27 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v51 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          uint64_t v27 = (char *)v60;
          uint64_t v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          uint64_t v26 = &v56;
          uint64_t v27 = (char *)v60;
        }
      }
      unint64_t v28 = &v27[24 * v61];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)unint64_t v28 = v29;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    uint64_t v30 = (void **)__p;
    if (__p)
    {
      int v31 = v67;
      int v32 = __p;
      if (v67 != __p)
      {
        do
          int v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        int v32 = __p;
      }
      long long v67 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    int v33 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v35 = (void *)*--v33;
      uint64_t v34 = v35;
      void *v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "msg", 3uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      int v56 = 3;
      long long v57 = "expected key entry for msg in DictionaryAttr to set Properties.";
      uint64_t v58 = 63;
      uint64_t v36 = &v56;
      unint64_t v37 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v53 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          unint64_t v37 = (char *)v60;
          uint64_t v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          uint64_t v36 = &v56;
          unint64_t v37 = (char *)v60;
        }
      }
      long long v38 = &v37[24 * v61];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)long long v38 = v39;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
    if (!v68) {
      return 0;
    }
    uint64_t v40 = (void **)__p;
    if (__p)
    {
      uint64_t v41 = v67;
      unsigned int v42 = __p;
      if (v67 != __p)
      {
        do
          uint64_t v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        unsigned int v42 = __p;
      }
      long long v67 = v40;
      operator delete(v42);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    uint64_t v43 = v65;
    uint64_t v23 = v64;
    if (v65 == v64) {
      goto LABEL_58;
    }
    do
    {
      uint64_t v45 = (void *)*--v43;
      unint64_t v44 = v45;
      *uint64_t v43 = 0;
      if (v45) {
        operator delete[](v44);
      }
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  uint64_t v9 = v8;
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    int v56 = 3;
    uint64_t v58 = 48;
    uint64_t v10 = &v56;
    unint64_t v11 = (char *)v60;
    if (v61 >= v62)
    {
      unint64_t v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        int64_t v52 = (char *)&v56 - (unsigned char *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        unint64_t v11 = (char *)v60;
        uint64_t v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        uint64_t v10 = &v56;
        unint64_t v11 = (char *)v60;
      }
    }
    uint64_t v12 = &v11[24 * v61];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = *((void *)v10 + 2);
    *(_OWORD *)uint64_t v12 = v13;
    ++v61;
    if (v59[0])
    {
      uint64_t v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      uint64_t v15 = (char *)v60;
      if (v61 >= v62)
      {
        unint64_t v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          int64_t v54 = (char *)&v56 - (unsigned char *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v15 = (char *)v60;
          uint64_t v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          uint64_t v14 = &v56;
          uint64_t v15 = (char *)v60;
        }
      }
      uint64_t v16 = &v15[24 * v61];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)uint64_t v16 = v17;
      ++v61;
      if (v59[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
      }
    }
  }
  if (v68)
  {
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      unint64_t v19 = v67;
      uint64_t v20 = __p;
      if (v67 != __p)
      {
        do
          unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      long long v67 = v18;
      operator delete(v20);
    }
    uint64_t v21 = v64;
    if (!v64) {
      goto LABEL_59;
    }
    int v22 = v65;
    uint64_t v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      long long v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63) {
        free(v60);
      }
      return 0;
    }
    do
    {
      char v25 = (void *)*--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
LABEL_57:
    uint64_t v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::cf::AssertOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  long long v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"msg", 3, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  BOOL v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  BOOL v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1 || *(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    uint64_t v30 = "attribute '";
    uint64_t v31 = 11;
    BOOL v7 = &v29;
    BOOL v8 = (char *)v35;
    if (v36 >= v37)
    {
      unint64_t v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        int64_t v27 = (char *)&v29 - (unsigned char *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        BOOL v8 = (char *)v35;
        BOOL v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        BOOL v7 = &v29;
        BOOL v8 = (char *)v35;
      }
    }
    uint64_t v9 = &v8[24 * v36];
    long long v10 = *(_OWORD *)v7;
    *((void *)v9 + 2) = v7[2];
    *(_OWORD *)uint64_t v9 = v10;
    ++v36;
    if (v33)
    {
      __int16 v32 = 261;
      long long v29 = a2;
      uint64_t v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        uint64_t v30 = "' failed to satisfy constraint: string attribute";
        uint64_t v31 = 48;
        unint64_t v11 = &v29;
        uint64_t v12 = (char *)v35;
        if (v36 >= v37)
        {
          unint64_t v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            int64_t v28 = (char *)&v29 - (unsigned char *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            uint64_t v12 = (char *)v35;
            unint64_t v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            unint64_t v11 = &v29;
            uint64_t v12 = (char *)v35;
          }
        }
        long long v13 = &v12[24 * v36];
        long long v14 = *(_OWORD *)v11;
        *((void *)v13 + 2) = v11[2];
        *(_OWORD *)long long v13 = v14;
        ++v36;
      }
    }
  }
  uint64_t v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  }
  if (v43)
  {
    uint64_t v16 = (void **)__p;
    if (__p)
    {
      long long v17 = v42;
      uint64_t v18 = __p;
      if (v42 != __p)
      {
        do
          long long v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        uint64_t v18 = __p;
      }
      unsigned int v42 = v16;
      operator delete(v18);
    }
    unint64_t v19 = v39;
    if (v39)
    {
      uint64_t v20 = v40;
      uint64_t v21 = v39;
      if (v40 != v39)
      {
        do
        {
          uint64_t v23 = (void *)*--v20;
          int v22 = v23;
          *uint64_t v20 = 0;
          if (v23) {
            operator delete[](v22);
          }
        }
        while (v20 != v19);
        uint64_t v21 = v39;
      }
      uint64_t v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38) {
      free(v35);
    }
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &unk_1E8EBA000;
    {
      uint64_t v4 = (void *)&unk_1E8EBA000;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::cf::detail::AssertOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 106;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = (void *)&unk_1E8EBA000;
      }
    }
    a1[33] = v4[73];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    BOOL v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)BOOL v8 = v9;
    ++v47;
  }
  uint64_t v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::StringAttr]";
  unint64_t v41 = 66;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    uint64_t v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      uint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          uint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          uint64_t v15 = (char *)v46;
        }
      }
      uint64_t v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)uint64_t v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        uint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    uint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      unint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        unint64_t v25 = __p;
      }
      int64_t v53 = v23;
      operator delete(v25);
    }
    unint64_t v26 = v50;
    if (v50)
    {
      int64_t v27 = v51;
      int64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          uint64_t v30 = (void *)*--v27;
          long long v29 = v30;
          *int64_t v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        int64_t v28 = v50;
      }
      int64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

BOOL mlir::cf::AssertOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v16[0] = v2;
    return mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v3, (const void **)"msg", (const char *)3, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v16)&& mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3(*this, *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0) != 0;
  }
  else
  {
    unint64_t v14 = (const void **)"requires attribute 'msg'";
    __int16 v15 = 259;
    mlir::OpState::emitOpError(this, &v14, (uint64_t)v16);
    uint64_t v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v16);
    if (v16[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v16);
    }
    if (v23)
    {
      int v5 = (void **)__p;
      if (__p)
      {
        unint64_t v6 = v22;
        unint64_t v7 = __p;
        if (v22 != __p)
        {
          do
            unint64_t v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          unint64_t v7 = __p;
        }
        uint64_t v22 = v5;
        operator delete(v7);
      }
      BOOL v8 = v19;
      if (v19)
      {
        long long v9 = v20;
        unint64_t v10 = v19;
        if (v20 != v19)
        {
          do
          {
            uint64_t v12 = (void *)*--v9;
            unint64_t v11 = v12;
            *long long v9 = 0;
            if (v12) {
              operator delete[](v11);
            }
          }
          while (v9 != v8);
          unint64_t v10 = v19;
        }
        uint64_t v20 = v8;
        operator delete(v10);
      }
      if (v17 != &v18) {
        free(v17);
      }
    }
  }
  return v4;
}

uint64_t mlir::cf::AssertOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"cf.assert", 9, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D0600;
  v4[12] = mlir::cf::AssertOp::canonicalize;
  long long v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    long long v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

BOOL mlir::cf::AssertOp::parse(uint64_t a1, void *a2)
{
  v16[4] = *MEMORY[0x1E4F143B8];
  memset(v16, 0, 24);
  uint64_t v15 = 0;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v16, 1)) {
    return 0;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)) {
    return 0;
  }
  uint64_t v4 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  uint64_t v6 = mlir::NoneType::get(*v4, v5);
  if (!mlir::AsmParser::parseAttribute<mlir::StringAttr>(a1, &v15, v6)) {
    return 0;
  }
  if (v15)
  {
    unint64_t v7 = (void *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(a2);
    *unint64_t v7 = v15;
  }
  uint64_t v14 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *))(*(void *)a1 + 456))(a1, a2 + 14)) {
    return 0;
  }
  uint64_t v8 = a2[1];
  v13[0] = a1;
  v13[1] = &v14;
  void v13[2] = a2;
  uint64_t v9 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(void **)(v8 + 96));
  if (v9)
  {
    if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v9, (const void **)"msg", (const char *)3, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::AssertOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v13))return 0; {
  }
    }
  unint64_t v10 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  uint64_t IntegerType = mlir::Builder::getIntegerType(v10, 1u);
  return (*(unsigned __int8 (**)(uint64_t, void *, uint64_t, void *))(*(void *)a1 + 696))(a1, v16, IntegerType, a2 + 2) != 0;
}

void mlir::cf::AssertOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  uint64_t v17[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  int v5 = (unsigned char *)*((void *)v4 + 4);
  if ((unint64_t)v5 >= *((void *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((void *)v4 + 4) = v5 + 1;
    unsigned char *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 160))(a2, *(void *)(*((void *)*this + 9) + 24));
  uint64_t v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  unint64_t v7 = (unsigned char *)*((void *)v6 + 4);
  if (*((unsigned char **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, ",", 1uLL);
  }
  else
  {
    *unint64_t v7 = 44;
    ++*((void *)v6 + 4);
  }
  uint64_t v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v9 = (unsigned char *)*((void *)v8 + 4);
  if ((unint64_t)v9 >= *((void *)v8 + 3))
  {
    llvm::raw_ostream::write(v8, 32);
  }
  else
  {
    *((void *)v8 + 4) = v9 + 1;
    *uint64_t v9 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 48))(a2, *((void *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8));
  uint64_t v15 = v17;
  v17[0] = "msg";
  v17[1] = 3;
  uint64_t v16 = 0x200000001;
  unint64_t v10 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v10);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v10 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, void))(*(void *)a2 + 192))(a2, Value, v13, v15, v16);
  if (v15 != v17) {
    free(v15);
  }
}

void mlir::cf::BranchOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = *(unsigned int *)(a2 + 208);
  if (v9 >= *(_DWORD *)(a2 + 212))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v9 + 1, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 208);
  }
  *(void *)(*(void *)(a2 + 200) + 8 * v9) = a3;
  ++*(_DWORD *)(a2 + 208);

  mlir::OperationState::addOperands(a2, a4, a5);
}

void mlir::OperationState::addSuccessors(mlir::OperationState *this, mlir::Block *a2)
{
  uint64_t v4 = *((unsigned int *)this + 52);
  if (v4 >= *((_DWORD *)this + 53))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 200, (char *)this + 216, v4 + 1, 8);
    LODWORD(v4) = *((_DWORD *)this + 52);
  }
  *(void *)(*((void *)this + 25) + 8 * v4) = a2;
  ++*((_DWORD *)this + 52);
}

uint64_t mlir::cf::BranchOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"cf.br", 5, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D0658;
  v4[12] = mlir::cf::BranchOp::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    unint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

BOOL mlir::cf::BranchOp::parse(uint64_t a1, uint64_t a2)
{
  v12[16] = *MEMORY[0x1E4F143B8];
  v11[0] = v12;
  v11[1] = (void *)0x400000000;
  v9[0] = &v10;
  v9[1] = (void *)0x100000000;
  if (!(*(unsigned __int8 (**)(void))(*(void *)a1 + 768))())
  {
LABEL_14:
    BOOL v6 = 0;
    unint64_t v7 = v9[0];
    if (v9[0] == &v10) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 272))(a1))
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if (!(*(unsigned __int8 (**)(uint64_t, void **, void, uint64_t, uint64_t))(*(void *)a1 + 688))(a1, v11, 0, 1, 0xFFFFFFFFLL)|| !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v9)|| !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 280))(a1))
    {
      goto LABEL_14;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    goto LABEL_14;
  }
  uint64_t v5 = *(unsigned int *)(a2 + 208);
  if (v5 >= *(_DWORD *)(a2 + 212))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v5 + 1, 8);
    LODWORD(v5) = *(_DWORD *)(a2 + 208);
  }
  *(void *)(*(void *)(a2 + 200) + 8 * v5) = 0;
  ++*(_DWORD *)(a2 + 208);
  BOOL v6 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)v11, (uint64_t)v9, v4, a2 + 16) != 0;
  unint64_t v7 = v9[0];
  if (v9[0] != &v10) {
LABEL_15:
  }
    free(v7);
LABEL_16:
  if (v11[0] != v12) {
    free(v11[0]);
  }
  return v6;
}

void mlir::cf::BranchOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v31[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = (unsigned char *)*((void *)v4 + 4);
  if ((unint64_t)v5 >= *((void *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((void *)v4 + 4) = v5 + 1;
    unsigned char *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 176))(a2, *(void *)((((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 24));
  if ((*((unsigned char *)*this + 46) & 0x80) == 0 || !*((_DWORD *)*this + 17)) {
    goto LABEL_25;
  }
  BOOL v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  unint64_t v7 = (unsigned char *)*((void *)v6 + 4);
  if (*((unsigned char **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "(", 1uLL);
    __int16 v8 = *this;
    if ((*((unsigned char *)*this + 46) & 0x80) != 0) {
      goto LABEL_8;
    }
LABEL_15:
    uint64_t v10 = 0;
    uint64_t v9 = 0;
    goto LABEL_9;
  }
  *unint64_t v7 = 40;
  ++*((void *)v6 + 4);
  __int16 v8 = *this;
  if ((*((unsigned char *)*this + 46) & 0x80) == 0) {
    goto LABEL_15;
  }
LABEL_8:
  uint64_t v9 = *((unsigned int *)v8 + 17);
  uint64_t v10 = *((void *)v8 + 9);
LABEL_9:
  unint64_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v29 = ", ";
  uint64_t v30 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v10, 0, v10, v9, (uint64_t)a2, v11, (uint64_t)&v29);
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)v12 + 4);
  if ((unint64_t)v13 >= *((void *)v12 + 3))
  {
    llvm::raw_ostream::write(v12, 32);
  }
  else
  {
    *((void *)v12 + 4) = v13 + 1;
    unsigned char *v13 = 32;
  }
  uint64_t v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v15 = (unsigned char *)*((void *)v14 + 4);
  if (*((unsigned char **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, ":", 1uLL);
  }
  else
  {
    unsigned char *v15 = 58;
    ++*((void *)v14 + 4);
  }
  uint64_t v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v17 = (unsigned char *)*((void *)v16 + 4);
  if ((unint64_t)v17 >= *((void *)v16 + 3))
  {
    llvm::raw_ostream::write(v16, 32);
  }
  else
  {
    *((void *)v16 + 4) = v17 + 1;
    unsigned char *v17 = 32;
  }
  uint64_t v18 = *this;
  if ((*((unsigned char *)*this + 46) & 0x80) != 0)
  {
    uint64_t v19 = *((unsigned int *)v18 + 17);
    uint64_t v20 = *((void *)v18 + 9);
  }
  else
  {
    uint64_t v20 = 0;
    uint64_t v19 = 0;
  }
  v27[0] = v20;
  v27[1] = v19;
  mlir::OperandRange::getTypes(v27, (uint64_t *)&v29);
  v28[0] = ", ";
  v28[1] = 2;
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)v29, v30, v31[0], v31[1], (uint64_t)a2, (uint64_t)a2, (uint64_t)v28);
  long long v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v22 = (unsigned char *)*((void *)v21 + 4);
  if (*((unsigned char **)v21 + 3) == v22)
  {
    llvm::raw_ostream::write(v21, ")", 1uLL);
  }
  else
  {
    unsigned char *v22 = 41;
    ++*((void *)v21 + 4);
  }
LABEL_25:
  long long v29 = v31;
  uint64_t v30 = 0x200000000;
  char v23 = *this;
  if (*((unsigned char *)*this + 47))
  {
    v28[0] = mlir::Operation::getAttrDictionary(v23);
    uint64_t v24 = (mlir::ArrayAttr *)v28;
  }
  else
  {
    uint64_t v24 = (mlir::Operation *)((char *)v23 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v24);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, void))(*(void *)a2 + 192))(a2, Value, v26, v29, v30);
  if (v29 != v31) {
    free(v29);
  }
}

BOOL mlir::cf::CondBranchOp::setPropertiesFromAttr(void *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v36 = v6;
  if (!v6)
  {
    a3(v40, a4);
    if (v40[0])
    {
      int v37 = 3;
      long long v38 = "expected DictionaryAttr to set properties";
      uint64_t v39 = 41;
      uint64_t v10 = &v37;
      unint64_t v11 = (char *)v41;
      if (v42 >= v43)
      {
        unint64_t v32 = v42 + 1;
        if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
        {
          int64_t v34 = (char *)&v37 - (unsigned char *)v41;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
          unint64_t v11 = (char *)v41;
          uint64_t v10 = (int *)((char *)v41 + v34);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
          uint64_t v10 = &v37;
          unint64_t v11 = (char *)v41;
        }
      }
      uint64_t v12 = &v11[24 * v42];
      long long v13 = *(_OWORD *)v10;
      *((void *)v12 + 2) = *((void *)v10 + 2);
      *(_OWORD *)uint64_t v12 = v13;
      ++v42;
      if (v40[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v40);
      }
    }
    if (!v49) {
      return 0;
    }
    uint64_t v14 = (void **)__p;
    if (__p)
    {
      uint64_t v15 = v48;
      uint64_t v16 = __p;
      if (v48 != __p)
      {
        do
          uint64_t v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        uint64_t v16 = __p;
      }
      unsigned int v48 = v14;
      operator delete(v16);
    }
    long long v17 = v45;
    if (!v45) {
      goto LABEL_43;
    }
    uint64_t v18 = v46;
    uint64_t v19 = v45;
    if (v46 == v45)
    {
LABEL_42:
      uint64_t v46 = v17;
      operator delete(v19);
LABEL_43:
      if (v41 != v44) {
        free(v41);
      }
      return 0;
    }
    do
    {
      long long v21 = (void *)*--v18;
      uint64_t v20 = v21;
      void *v18 = 0;
      if (v21) {
        operator delete[](v20);
      }
    }
    while (v18 != v17);
LABEL_41:
    uint64_t v19 = v45;
    goto LABEL_42;
  }
  __int16 v8 = (void *)mlir::DictionaryAttr::get((uint64_t)&v36, "operandSegmentSizes", 0x13uLL);
  if (!v8)
  {
    __int16 v8 = (void *)mlir::DictionaryAttr::get((uint64_t)&v36, "operand_segment_sizes", 0x15uLL);
    if (!v8)
    {
      a3(v40, a4);
      if (v40[0])
      {
        int v37 = 3;
        long long v38 = "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.";
        uint64_t v39 = 79;
        uint64_t v22 = &v37;
        char v23 = (char *)v41;
        if (v42 >= v43)
        {
          unint64_t v33 = v42 + 1;
          if (v41 <= &v37 && (char *)v41 + 24 * v42 > (char *)&v37)
          {
            int64_t v35 = (char *)&v37 - (unsigned char *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v33, 24);
            char v23 = (char *)v41;
            uint64_t v22 = (int *)((char *)v41 + v35);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v33, 24);
            uint64_t v22 = &v37;
            char v23 = (char *)v41;
          }
        }
        uint64_t v24 = &v23[24 * v42];
        long long v25 = *(_OWORD *)v22;
        *((void *)v24 + 2) = *((void *)v22 + 2);
        *(_OWORD *)uint64_t v24 = v25;
        ++v42;
        if (v40[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v40);
        }
      }
      if (!v49) {
        return 0;
      }
      uint64_t v26 = (void **)__p;
      if (__p)
      {
        int64_t v27 = v48;
        int64_t v28 = __p;
        if (v48 != __p)
        {
          do
            int64_t v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
          while (v27 != v26);
          int64_t v28 = __p;
        }
        unsigned int v48 = v26;
        operator delete(v28);
      }
      long long v17 = v45;
      if (!v45) {
        goto LABEL_43;
      }
      long long v29 = v46;
      uint64_t v19 = v45;
      if (v46 == v45) {
        goto LABEL_42;
      }
      do
      {
        uint64_t v31 = (void *)*--v29;
        uint64_t v30 = v31;
        *long long v29 = 0;
        if (v31) {
          operator delete[](v30);
        }
      }
      while (v29 != v17);
      goto LABEL_41;
    }
  }
  return mlir::convertFromAttribute(a1, (const char *)3, v8, a3, a4) != 0;
}

uint64_t mlir::cf::CondBranchOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t a2)
{
  v16[6] = *MEMORY[0x1E4F143B8];
  long long v13 = a1;
  uint64_t v14 = v16;
  uint64_t v15 = 0x300000000;
  uint64_t v2 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, a2, 3);
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v13, (uint64_t)"operandSegmentSizes", 19, v2);
  uint64_t v5 = v4;
  unsigned int v6 = v15;
  if (v15 >= HIDWORD(v15))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, v15 + 1, 16);
    unsigned int v6 = v15;
  }
  unint64_t v7 = (uint64_t *)((char *)v14 + 16 * v6);
  *unint64_t v7 = NamedAttr;
  v7[1] = v5;
  BOOL v8 = __CFADD__(v15, 1);
  uint64_t v9 = (v15 + 1);
  LODWORD(v15) = v15 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    unint64_t v11 = v14;
    if (v14 == v16) {
      return DictionaryAttr;
    }
    goto LABEL_8;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v13, (uint64_t *)v14, v9);
  unint64_t v11 = v14;
  if (v14 != v16) {
LABEL_8:
  }
    free(v11);
  return DictionaryAttr;
}

unint64_t mlir::cf::CondBranchOp::computePropertiesHash(void *a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    long long v17 = a1;
    unint64_t v1 = 0x1E8EB8000uLL;
    int v11 = v10;
    a1 = v17;
    if (v11)
    {
      unint64_t v12 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v12 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v12;
      unint64_t v1 = 0x1E8EB8000;
      a1 = v17;
    }
  }
  uint64_t v2 = *(void *)(v1 + 3024);
  uint64_t v3 = *a1;
  uint64_t v4 = *(void *)((char *)a1 + 4);
  {
    uint64_t v15 = v4;
    uint64_t v18 = v2;
    uint64_t v16 = v3;
    uint64_t v4 = v15;
    uint64_t v3 = v16;
    uint64_t v2 = v18;
    unint64_t v1 = 0x1E8EB8000uLL;
    if (v13)
    {
      unint64_t v14 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v14 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v14;
      uint64_t v4 = v15;
      uint64_t v3 = v16;
      uint64_t v2 = v18;
      unint64_t v1 = 0x1E8EB8000;
    }
  }
  uint64_t v5 = __ROR8__(v4 + 12, 12);
  unint64_t v6 = (0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v5 ^ ((0x9DDFEA08EB382D69 * (v3 ^ v2 ^ v5)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ v2 ^ v5)))) ^ ((0x9DDFEA08EB382D69 * (v5 ^ ((0x9DDFEA08EB382D69 * (v3 ^ v2 ^ v5)) >> 47) ^ (0x9DDFEA08EB382D69 * (v3 ^ v2 ^ v5)))) >> 47))) ^ v4;
  uint64_t v7 = 8 * v6 + 8;
  unint64_t v8 = *(void *)(v1 + 3024) ^ HIDWORD(v6);
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v8 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v7)))) ^ ((0x9DDFEA08EB382D69 * (v8 ^ ((0x9DDFEA08EB382D69 * (v8 ^ v7)) >> 47) ^ (0x9DDFEA08EB382D69 * (v8 ^ v7)))) >> 47));
}

uint64_t mlir::cf::CondBranchOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, void *a4)
{
  uint64_t v5 = (void *)result;
  if (a3 == 19)
  {
    uint64_t result = memcmp(__s1, "operandSegmentSizes", 0x13uLL);
    if (result) {
      return result;
    }
  }
  else
  {
    if (a3 != 21) {
      return result;
    }
    BOOL v6 = *(void *)__s1 == 0x5F646E617265706FLL && *((void *)__s1 + 1) == 0x5F746E656D676573;
    if (!v6 || *(void *)(__s1 + 13) != 0x73657A69735F746ELL) {
      return result;
    }
  }
  if (a4)
  {
    uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
    if (result) {
      unint64_t v8 = a4;
    }
    else {
      unint64_t v8 = 0;
    }
    int v10 = v8;
    if (result)
    {
      uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v10);
      if (result == 3)
      {
        uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v10);
        if (v9) {
          return (uint64_t)memmove(v5, (const void *)result, 4 * v9);
        }
      }
    }
  }
  return result;
}

BOOL mlir::cf::CondBranchOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(a2);
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 4)
    {
      uint64_t v15 = "size mismatch for operand/result_segment_size";
      __int16 v16 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, const char **))(*(void *)a1 + 16))(v18, a1, &v15);
      if (v18[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      }
      if (v25)
      {
        uint64_t v4 = (void **)__p;
        if (__p)
        {
          uint64_t v5 = v24;
          BOOL v6 = __p;
          if (v24 != __p)
          {
            do
              uint64_t v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            BOOL v6 = __p;
          }
          uint64_t v24 = v4;
          operator delete(v6);
        }
        uint64_t v7 = v21;
        if (v21)
        {
          unint64_t v8 = v22;
          uint64_t v9 = v21;
          if (v22 != v21)
          {
            do
            {
              int v11 = (void *)*--v8;
              int v10 = v11;
              void *v8 = 0;
              if (v11) {
                operator delete[](v10);
              }
            }
            while (v8 != v7);
            uint64_t v9 = v21;
          }
          uint64_t v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20) {
          free(v19);
        }
      }
      return 0;
    }
    unint64_t v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13) {
      memmove(v3, v12, 4 * v13);
    }
  }
  return (unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) < 6
      || mlir::DialectBytecodeReader::readSparseArray<int>(a1, v3, (const char *)3);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0xCuLL);
    *(void *)uint64_t v3 = 0;
    v3[2] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &unk_1E8EBA000;
    {
      uint64_t v4 = (void *)&unk_1E8EBA000;
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 110;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = (void *)&unk_1E8EBA000;
      }
    }
    a1[33] = v4[75];
    return a1[32];
  }
  return result;
}

void mlir::cf::CondBranchOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, a4, a5);
  mlir::OperationState::addOperands(a2, a6, a7);
  uint64_t v15 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>((void *)a2);
  _DWORD *v15 = 1;
  v15[1] = a5;
  uint64_t v15[2] = a7;
  uint64_t v16 = *(unsigned int *)(a2 + 208);
  if (v16 >= *(_DWORD *)(a2 + 212))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v16 + 1, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 208);
  }
  *(void *)(*(void *)(a2 + 200) + 8 * v16) = a8;
  unsigned int v17 = *(_DWORD *)(a2 + 212);
  uint64_t v18 = (*(_DWORD *)(a2 + 208) + 1);
  *(_DWORD *)(a2 + 208) = v18;
  if (v18 >= v17)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 200, (void *)(a2 + 216), v18 + 1, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 208);
  }
  *(void *)(*(void *)(a2 + 200) + 8 * v18) = a9;
  ++*(_DWORD *)(a2 + 208);
}

BOOL mlir::cf::CondBranchOp::parse(uint64_t a1, mlir::OperationState *a2)
{
  v26[4] = *MEMORY[0x1E4F143B8];
  memset(v26, 0, 24);
  unint64_t v14 = 0;
  uint64_t v15 = 0;
  char v23 = v25;
  uint64_t v24 = 0x400000000;
  v21[0] = &v22;
  v21[1] = (void *)0x100000000;
  uint64_t v18 = v20;
  uint64_t v19 = 0x400000000;
  v16[0] = &v17;
  v16[1] = (void *)0x100000000;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v26, 1)
    || !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)
    || !(*(unsigned __int8 (**)(uint64_t, mlir::Block **))(*(void *)a1 + 768))(a1, &v15))
  {
    goto LABEL_24;
  }
  if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 272))(a1))
  {
    uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if (!(*(unsigned __int8 (**)(uint64_t, void **, void, uint64_t, uint64_t))(*(void *)a1 + 688))(a1, &v23, 0, 1, 0xFFFFFFFFLL)|| !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v21)|| !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 280))(a1))
    {
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 120))(a1)
    && (*(unsigned __int8 (**)(uint64_t, mlir::Block **))(*(void *)a1 + 768))(a1, &v14))
  {
    if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 272))(a1))
    {
      uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
      if (!(*(unsigned __int8 (**)(uint64_t, void **, void, uint64_t, uint64_t))(*(void *)a1 + 688))(a1, &v18, 0, 1, 0xFFFFFFFFLL)|| !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v16)|| !(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 280))(a1))
      {
        goto LABEL_24;
      }
    }
    else
    {
      uint64_t v5 = 0;
    }
    (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
    if ((*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, (uint64_t)a2 + 112))
    {
      mlir::OperationState::addSuccessors(a2, v15);
      mlir::OperationState::addSuccessors(a2, v14);
      int v6 = v24;
      int v7 = v19;
      unint64_t v8 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(a2);
      _DWORD *v8 = 1;
      v8[1] = v6;
      void v8[2] = v7;
      unint64_t v9 = (mlir::Builder *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
      uint64_t IntegerType = mlir::Builder::getIntegerType(v9, 1u);
      uint64_t v11 = (uint64_t)a2 + 16;
      if ((*(unsigned __int8 (**)(uint64_t, void *, uint64_t, uint64_t))(*(void *)a1 + 696))(a1, v26, IntegerType, v11))
      {
        if (mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v23, (uint64_t)v21, v4, v11))
        {
          BOOL v12 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v18, (uint64_t)v16, v5, v11) != 0;
          goto LABEL_25;
        }
      }
    }
  }
LABEL_24:
  BOOL v12 = 0;
LABEL_25:
  if (v16[0] != &v17) {
    free(v16[0]);
  }
  if (v18 != v20) {
    free(v18);
  }
  if (v21[0] != &v22) {
    free(v21[0]);
  }
  if (v23 != v25) {
    free(v23);
  }
  return v12;
}

void mlir::cf::CondBranchOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = (unsigned char *)*((void *)v4 + 4);
  if ((unint64_t)v5 >= *((void *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((void *)v4 + 4) = v5 + 1;
    unsigned char *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 160))(a2, *(void *)(*((void *)*this + 9) + 24));
  int v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  int v7 = (unsigned char *)*((void *)v6 + 4);
  if (*((unsigned char **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, ",", 1uLL);
  }
  else
  {
    *int v7 = 44;
    ++*((void *)v6 + 4);
  }
  unint64_t v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  unint64_t v9 = (unsigned char *)*((void *)v8 + 4);
  if ((unint64_t)v9 >= *((void *)v8 + 3))
  {
    llvm::raw_ostream::write(v8, 32);
  }
  else
  {
    *((void *)v8 + 4) = v9 + 1;
    *unint64_t v9 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 176))(a2, *(void *)((((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 24));
  unint64_t v10 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v10 = 0;
  }
  if (*(_DWORD *)(v10 + 4))
  {
    uint64_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    BOOL v12 = (unsigned char *)*((void *)v11 + 4);
    if (*((unsigned char **)v11 + 3) == v12)
    {
      llvm::raw_ostream::write(v11, "(", 1uLL);
    }
    else
    {
      unsigned char *v12 = 40;
      ++*((void *)v11 + 4);
    }
    unint64_t v13 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11))) {
      unint64_t v14 = (unsigned int *)((char *)*this + 16 * ((v13 >> 23) & 1) + 64);
    }
    else {
      unint64_t v14 = 0;
    }
    uint64_t v15 = *v14;
    unsigned int v16 = v14[1];
    if ((v13 & 0x800000) != 0) {
      uint64_t v17 = *((void *)*this + 9);
    }
    else {
      uint64_t v17 = 0;
    }
    uint64_t v18 = v17 + 32 * v15;
    uint64_t v19 = v16 + v15 - v15;
    uint64_t v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    uint64_t v74 = ", ";
    uint64_t v75 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v18, 0, v18, v19, (uint64_t)a2, v20, (uint64_t)&v74);
    long long v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    uint64_t v22 = (unsigned char *)*((void *)v21 + 4);
    if ((unint64_t)v22 >= *((void *)v21 + 3))
    {
      llvm::raw_ostream::write(v21, 32);
    }
    else
    {
      *((void *)v21 + 4) = v22 + 1;
      unsigned char *v22 = 32;
    }
    char v23 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    uint64_t v24 = (unsigned char *)*((void *)v23 + 4);
    if (*((unsigned char **)v23 + 3) == v24)
    {
      llvm::raw_ostream::write(v23, ":", 1uLL);
    }
    else
    {
      unsigned char *v24 = 58;
      ++*((void *)v23 + 4);
    }
    char v25 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    uint64_t v26 = (unsigned char *)*((void *)v25 + 4);
    if ((unint64_t)v26 >= *((void *)v25 + 3))
    {
      llvm::raw_ostream::write(v25, 32);
    }
    else
    {
      *((void *)v25 + 4) = v26 + 1;
      unsigned char *v26 = 32;
    }
    unint64_t v27 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11))) {
      int64_t v28 = (unsigned int *)((char *)*this + 16 * ((v27 >> 23) & 1) + 64);
    }
    else {
      int64_t v28 = 0;
    }
    uint64_t v29 = *v28;
    unsigned int v30 = v28[1];
    if ((v27 & 0x800000) != 0) {
      uint64_t v31 = *((void *)*this + 9);
    }
    else {
      uint64_t v31 = 0;
    }
    uint64_t v70 = v31 + 32 * v29;
    uint64_t v71 = v30 + v29 - v29;
    mlir::OperandRange::getTypes(&v70, (uint64_t *)&v74);
    unint64_t AttrDictionary = ", ";
    uint64_t v73 = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)v74, v75, (uint64_t)v76, v77, (uint64_t)a2, (uint64_t)a2, (uint64_t)&AttrDictionary);
    unint64_t v32 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    unint64_t v33 = (unsigned char *)*((void *)v32 + 4);
    if (*((unsigned char **)v32 + 3) == v33)
    {
      llvm::raw_ostream::write(v32, ")", 1uLL);
    }
    else
    {
      unsigned char *v33 = 41;
      ++*((void *)v32 + 4);
    }
  }
  int64_t v34 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  int64_t v35 = (unsigned char *)*((void *)v34 + 4);
  if (*((unsigned char **)v34 + 3) == v35)
  {
    llvm::raw_ostream::write(v34, ",", 1uLL);
  }
  else
  {
    unsigned char *v35 = 44;
    ++*((void *)v34 + 4);
  }
  uint64_t v36 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  int v37 = (unsigned char *)*((void *)v36 + 4);
  if ((unint64_t)v37 >= *((void *)v36 + 3))
  {
    llvm::raw_ostream::write(v36, 32);
  }
  else
  {
    *((void *)v36 + 4) = v37 + 1;
    *int v37 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 176))(a2, *(void *)((((unint64_t)*this+ 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 71) & 0xFFFFFFFFFFFFFFF8)+ 56));
  unint64_t v38 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v38 = 0;
  }
  if (*(_DWORD *)(v38 + 8))
  {
    uint64_t v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    uint64_t v40 = (unsigned char *)*((void *)v39 + 4);
    if (*((unsigned char **)v39 + 3) == v40)
    {
      llvm::raw_ostream::write(v39, "(", 1uLL);
    }
    else
    {
      unsigned char *v40 = 40;
      ++*((void *)v39 + 4);
    }
    unint64_t v41 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11))) {
      unsigned int v42 = (int *)((char *)*this + 16 * ((v41 >> 23) & 1) + 64);
    }
    else {
      unsigned int v42 = 0;
    }
    int v43 = *v42;
    int v44 = v42[1];
    int v45 = v42[2];
    if ((v41 & 0x800000) != 0) {
      uint64_t v46 = *((void *)*this + 9);
    }
    else {
      uint64_t v46 = 0;
    }
    uint64_t v47 = (v44 + v43);
    uint64_t v48 = v46 + 32 * v47;
    uint64_t v49 = (v45 + v47) - v47;
    uint64_t v50 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    uint64_t v74 = ", ";
    uint64_t v75 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v48, 0, v48, v49, (uint64_t)a2, v50, (uint64_t)&v74);
    int64_t v51 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    int64_t v52 = (unsigned char *)*((void *)v51 + 4);
    if ((unint64_t)v52 >= *((void *)v51 + 3))
    {
      llvm::raw_ostream::write(v51, 32);
    }
    else
    {
      *((void *)v51 + 4) = v52 + 1;
      *int64_t v52 = 32;
    }
    int64_t v53 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    char v54 = (unsigned char *)*((void *)v53 + 4);
    if (*((unsigned char **)v53 + 3) == v54)
    {
      llvm::raw_ostream::write(v53, ":", 1uLL);
    }
    else
    {
      unsigned char *v54 = 58;
      ++*((void *)v53 + 4);
    }
    uint64_t v55 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    int v56 = (unsigned char *)*((void *)v55 + 4);
    if ((unint64_t)v56 >= *((void *)v55 + 3))
    {
      llvm::raw_ostream::write(v55, 32);
    }
    else
    {
      *((void *)v55 + 4) = v56 + 1;
      *int v56 = 32;
    }
    unint64_t v57 = *((unsigned int *)*this + 11);
    if (HIBYTE(*((_DWORD *)*this + 11))) {
      uint64_t v58 = (int *)((char *)*this + 16 * ((v57 >> 23) & 1) + 64);
    }
    else {
      uint64_t v58 = 0;
    }
    int v59 = *v58;
    int v60 = v58[1];
    int v61 = v58[2];
    if ((v57 & 0x800000) != 0) {
      uint64_t v62 = *((void *)*this + 9);
    }
    else {
      uint64_t v62 = 0;
    }
    uint64_t v63 = (v60 + v59);
    uint64_t v70 = v62 + 32 * v63;
    uint64_t v71 = (v61 + v63) - v63;
    mlir::OperandRange::getTypes(&v70, (uint64_t *)&v74);
    unint64_t AttrDictionary = ", ";
    uint64_t v73 = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)v74, v75, (uint64_t)v76, v77, (uint64_t)a2, (uint64_t)a2, (uint64_t)&AttrDictionary);
    long long v64 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    long long v65 = (unsigned char *)*((void *)v64 + 4);
    if (*((unsigned char **)v64 + 3) == v65)
    {
      llvm::raw_ostream::write(v64, ")", 1uLL);
    }
    else
    {
      *long long v65 = 41;
      ++*((void *)v64 + 4);
    }
  }
  uint64_t v74 = &v76;
  unint64_t v76 = "operandSegmentSizes";
  uint64_t v77 = 19;
  uint64_t v75 = 0x200000001;
  long long v66 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = (const char *)mlir::Operation::getAttrDictionary(v66);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v66 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, void))(*(void *)a2 + 192))(a2, Value, v69, v74, v75);
  if (v74 != &v76) {
    free(v74);
  }
}

void mlir::cf::SwitchOp::getCaseOperandsMutable(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  v17[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (uint64_t)*this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v5 = (_DWORD *)((char *)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  int v6 = v5[5] + v5[4];
  int v7 = v5[6];
  uint64_t v8 = *(void *)(*(void *)(*(void *)(v4 + 48) + 96) + 8 * *(void *)(*(void *)(v4 + 48) + 104) - 8);
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(v4 + 24));
  unint64_t v10 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  if (!HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v10 = 0;
  }
  uint64_t v11 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v10 + 16, 3);
  mlir::NamedAttribute::NamedAttribute(&v12, v8, v11);
  LODWORD(v13) = 2;
  long long v14 = v12;
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v15, v4, v6, v7, &v13, 1);
  *(void *)&long long v12 = mlir::Operation::getAttrDictionary(*this);
  mlir::DictionaryAttr::getNamed((uint64_t)&v12, **(void **)(*((void *)*this + 6) + 96), (uint64_t)&v13);
  mlir::MutableOperandRange::split((uint64_t)v15, v13, v14, a2);
  if (v16 != v17) {
    free(v16);
  }
}

BOOL mlir::cf::SwitchOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v88 = v6;
  if (!v6)
  {
    a3(v92, a4);
    if (v92[0])
    {
      int v89 = 3;
      int64_t v90 = "expected DictionaryAttr to set properties";
      uint64_t v91 = 41;
      long long v14 = &v89;
      uint64_t v15 = (char *)v93;
      if (v94 >= v95)
      {
        unint64_t v74 = v94 + 1;
        if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
        {
          int64_t v81 = (char *)&v89 - (unsigned char *)v93;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v74, 24);
          uint64_t v15 = (char *)v93;
          long long v14 = (int *)((char *)v93 + v81);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v74, 24);
          long long v14 = &v89;
          uint64_t v15 = (char *)v93;
        }
      }
      unsigned int v16 = &v15[24 * v94];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = *((void *)v14 + 2);
      *(_OWORD *)unsigned int v16 = v17;
      ++v94;
      if (v92[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
      }
    }
    if (!v101) {
      return 0;
    }
    uint64_t v18 = (void **)__p;
    if (__p)
    {
      uint64_t v19 = v100;
      uint64_t v20 = __p;
      if (v100 != __p)
      {
        do
          uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        uint64_t v20 = __p;
      }
      BOOL v100 = v18;
      operator delete(v20);
    }
    long long v21 = v97;
    if (!v97) {
      goto LABEL_100;
    }
    uint64_t v22 = v98;
    char v23 = v97;
    if (v98 == v97)
    {
LABEL_99:
      __int16 v98 = v21;
      operator delete(v23);
LABEL_100:
      if (v93 != v96) {
        free(v93);
      }
      return 0;
    }
    do
    {
      char v25 = (void *)*--v22;
      uint64_t v24 = v25;
      void *v22 = 0;
      if (v25) {
        operator delete[](v24);
      }
    }
    while (v22 != v21);
    goto LABEL_98;
  }
  uint64_t v8 = (void *)mlir::DictionaryAttr::get((uint64_t)&v88, "case_operand_segments", 0x15uLL);
  if (!v8)
  {
    a3(v92, a4);
    if (v92[0])
    {
      int v89 = 3;
      int64_t v90 = "expected key entry for case_operand_segments in DictionaryAttr to set Properties.";
      uint64_t v91 = 81;
      uint64_t v26 = &v89;
      unint64_t v27 = (char *)v93;
      if (v94 >= v95)
      {
        unint64_t v75 = v94 + 1;
        if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
        {
          int64_t v82 = (char *)&v89 - (unsigned char *)v93;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v75, 24);
          unint64_t v27 = (char *)v93;
          uint64_t v26 = (int *)((char *)v93 + v82);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v75, 24);
          uint64_t v26 = &v89;
          unint64_t v27 = (char *)v93;
        }
      }
      int64_t v28 = &v27[24 * v94];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = *((void *)v26 + 2);
      *(_OWORD *)int64_t v28 = v29;
      ++v94;
      if (v92[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
      }
    }
    if (!v101) {
      return 0;
    }
    unsigned int v30 = (void **)__p;
    if (__p)
    {
      uint64_t v31 = v100;
      unint64_t v32 = __p;
      if (v100 != __p)
      {
        do
          uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      BOOL v100 = v30;
      operator delete(v32);
    }
    long long v21 = v97;
    if (!v97) {
      goto LABEL_100;
    }
    unint64_t v33 = v98;
    char v23 = v97;
    if (v98 == v97) {
      goto LABEL_99;
    }
    do
    {
      int64_t v35 = (void *)*--v33;
      int64_t v34 = v35;
      void *v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_98;
  }
  uint64_t v9 = (uint64_t)v8;
  if (!mlir::detail::DenseArrayAttrImpl<int>::classof(v8))
  {
    a3(v92, a4);
    if (v92[0])
    {
      int v89 = 3;
      uint64_t v91 = 66;
      uint64_t v36 = &v89;
      int v37 = (char *)v93;
      if (v94 >= v95)
      {
        unint64_t v76 = v94 + 1;
        if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
        {
          int64_t v83 = (char *)&v89 - (unsigned char *)v93;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v76, 24);
          int v37 = (char *)v93;
          uint64_t v36 = (int *)((char *)v93 + v83);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v76, 24);
          uint64_t v36 = &v89;
          int v37 = (char *)v93;
        }
      }
      unint64_t v38 = &v37[24 * v94];
      long long v39 = *(_OWORD *)v36;
      *((void *)v38 + 2) = *((void *)v36 + 2);
      *(_OWORD *)unint64_t v38 = v39;
      ++v94;
      if (v92[0])
      {
        uint64_t v40 = &v89;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v89, v9);
        unint64_t v41 = (char *)v93;
        if (v94 >= v95)
        {
          unint64_t v77 = v94 + 1;
          if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
          {
            int64_t v84 = (char *)&v89 - (unsigned char *)v93;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v77, 24);
            unint64_t v41 = (char *)v93;
            uint64_t v40 = (int *)((char *)v93 + v84);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v77, 24);
            uint64_t v40 = &v89;
            unint64_t v41 = (char *)v93;
          }
        }
        unsigned int v42 = &v41[24 * v94];
        long long v43 = *(_OWORD *)v40;
        *((void *)v42 + 2) = *((void *)v40 + 2);
        *(_OWORD *)unsigned int v42 = v43;
        ++v94;
        if (v92[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
        }
      }
    }
    if (!v101) {
      return 0;
    }
    int v44 = (void **)__p;
    if (__p)
    {
      int v45 = v100;
      uint64_t v46 = __p;
      if (v100 != __p)
      {
        do
          int v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        uint64_t v46 = __p;
      }
      BOOL v100 = v44;
      operator delete(v46);
    }
    long long v21 = v97;
    if (!v97) {
      goto LABEL_100;
    }
    uint64_t v47 = v98;
    char v23 = v97;
    if (v98 == v97) {
      goto LABEL_99;
    }
    do
    {
      uint64_t v49 = (void *)*--v47;
      uint64_t v48 = v49;
      *uint64_t v47 = 0;
      if (v49) {
        operator delete[](v48);
      }
    }
    while (v47 != v21);
    goto LABEL_98;
  }
  *a1 = v9;
  uint64_t v10 = mlir::DictionaryAttr::get((uint64_t)&v88, "case_values", 0xBuLL);
  if (v10)
  {
    uint64_t v11 = v10;
    if (mlir::DenseIntElementsAttr::classof(v10))
    {
      a1[1] = v11;
      goto LABEL_10;
    }
    a3(v92, a4);
    if (v92[0])
    {
      int v89 = 3;
      uint64_t v91 = 56;
      uint64_t v50 = &v89;
      int64_t v51 = (char *)v93;
      if (v94 >= v95)
      {
        unint64_t v78 = v94 + 1;
        if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
        {
          int64_t v85 = (char *)&v89 - (unsigned char *)v93;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v78, 24);
          int64_t v51 = (char *)v93;
          uint64_t v50 = (int *)((char *)v93 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v78, 24);
          uint64_t v50 = &v89;
          int64_t v51 = (char *)v93;
        }
      }
      int64_t v52 = &v51[24 * v94];
      long long v53 = *(_OWORD *)v50;
      *((void *)v52 + 2) = *((void *)v50 + 2);
      *(_OWORD *)int64_t v52 = v53;
      ++v94;
      if (v92[0])
      {
        char v54 = &v89;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v89, v11);
        uint64_t v55 = (char *)v93;
        if (v94 >= v95)
        {
          unint64_t v79 = v94 + 1;
          if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
          {
            int64_t v86 = (char *)&v89 - (unsigned char *)v93;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v79, 24);
            uint64_t v55 = (char *)v93;
            char v54 = (int *)((char *)v93 + v86);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v79, 24);
            char v54 = &v89;
            uint64_t v55 = (char *)v93;
          }
        }
        int v56 = &v55[24 * v94];
        long long v57 = *(_OWORD *)v54;
        *((void *)v56 + 2) = *((void *)v54 + 2);
        *(_OWORD *)int v56 = v57;
        ++v94;
        if (v92[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
        }
      }
    }
    if (!v101) {
      return 0;
    }
    uint64_t v58 = (void **)__p;
    if (__p)
    {
      int v59 = v100;
      int v60 = __p;
      if (v100 != __p)
      {
        do
          int v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
        while (v59 != v58);
        int v60 = __p;
      }
      BOOL v100 = v58;
      operator delete(v60);
    }
    long long v21 = v97;
    if (!v97) {
      goto LABEL_100;
    }
    int v61 = v98;
    char v23 = v97;
    if (v98 == v97) {
      goto LABEL_99;
    }
    do
    {
      uint64_t v63 = (void *)*--v61;
      uint64_t v62 = v63;
      void *v61 = 0;
      if (v63) {
        operator delete[](v62);
      }
    }
    while (v61 != v21);
LABEL_98:
    char v23 = v97;
    goto LABEL_99;
  }
LABEL_10:
  long long v12 = (void *)mlir::DictionaryAttr::get((uint64_t)&v88, "operandSegmentSizes", 0x13uLL);
  if (!v12)
  {
    long long v12 = (void *)mlir::DictionaryAttr::get((uint64_t)&v88, "operand_segment_sizes", 0x15uLL);
    if (!v12)
    {
      a3(v92, a4);
      if (v92[0])
      {
        int v89 = 3;
        int64_t v90 = "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.";
        uint64_t v91 = 79;
        long long v64 = &v89;
        long long v65 = (char *)v93;
        if (v94 >= v95)
        {
          unint64_t v80 = v94 + 1;
          if (v93 <= &v89 && (char *)v93 + 24 * v94 > (char *)&v89)
          {
            int64_t v87 = (char *)&v89 - (unsigned char *)v93;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v80, 24);
            long long v65 = (char *)v93;
            long long v64 = (int *)((char *)v93 + v87);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v93, v96, v80, 24);
            long long v64 = &v89;
            long long v65 = (char *)v93;
          }
        }
        long long v66 = &v65[24 * v94];
        long long v67 = *(_OWORD *)v64;
        *((void *)v66 + 2) = *((void *)v64 + 2);
        *(_OWORD *)long long v66 = v67;
        ++v94;
        if (v92[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
        }
      }
      if (!v101) {
        return 0;
      }
      char v68 = (void **)__p;
      if (__p)
      {
        uint64_t v69 = v100;
        uint64_t v70 = __p;
        if (v100 != __p)
        {
          do
            uint64_t v69 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v69 - 1);
          while (v69 != v68);
          uint64_t v70 = __p;
        }
        BOOL v100 = v68;
        operator delete(v70);
      }
      long long v21 = v97;
      if (!v97) {
        goto LABEL_100;
      }
      uint64_t v71 = v98;
      char v23 = v97;
      if (v98 == v97) {
        goto LABEL_99;
      }
      do
      {
        uint64_t v73 = (void *)*--v71;
        unint64_t v72 = v73;
        *uint64_t v71 = 0;
        if (v73) {
          operator delete[](v72);
        }
      }
      while (v71 != v21);
      goto LABEL_98;
    }
  }
  return mlir::convertFromAttribute(a1 + 2, (const char *)3, v12, a3, a4) != 0;
}

uint64_t mlir::cf::SwitchOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v29[6] = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a1;
  unint64_t v27 = v29;
  uint64_t v28 = 0x300000000;
  if (*a2)
  {
    uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v26, (uint64_t)"case_operand_segments", 21, *a2);
    uint64_t v6 = v5;
    unsigned int v7 = v28;
    if (v28 >= HIDWORD(v28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v28 + 1, 16);
      unsigned int v7 = v28;
    }
    uint64_t v8 = (uint64_t *)((char *)v27 + 16 * v7);
    uint64_t *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v28) = v28 + 1;
  }
  uint64_t v9 = a2[1];
  if (v9)
  {
    uint64_t v10 = mlir::Builder::getNamedAttr(&v26, (uint64_t)"case_values", 11, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v28;
    if (v28 >= HIDWORD(v28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v28 + 1, 16);
      unsigned int v13 = v28;
    }
    long long v14 = (uint64_t *)((char *)v27 + 16 * v13);
    uint64_t *v14 = v10;
    v14[1] = v12;
    LODWORD(v28) = v28 + 1;
  }
  uint64_t v15 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 2), 3);
  uint64_t v16 = mlir::Builder::getNamedAttr(&v26, (uint64_t)"operandSegmentSizes", 19, v15);
  uint64_t v18 = v17;
  unsigned int v19 = v28;
  if (v28 >= HIDWORD(v28))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v28 + 1, 16);
    unsigned int v19 = v28;
  }
  uint64_t v20 = (uint64_t *)((char *)v27 + 16 * v19);
  *uint64_t v20 = v16;
  v20[1] = v18;
  BOOL v21 = __CFADD__(v28, 1);
  uint64_t v22 = (v28 + 1);
  LODWORD(v28) = v28 + 1;
  if (v21)
  {
    uint64_t DictionaryAttr = 0;
    uint64_t v24 = v27;
    if (v27 == v29) {
      return DictionaryAttr;
    }
    goto LABEL_16;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v26, (uint64_t *)v27, v22);
  uint64_t v24 = v27;
  if (v27 != v29) {
LABEL_16:
  }
    free(v24);
  return DictionaryAttr;
}

unint64_t mlir::cf::SwitchOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1 = *a1;
  unint64_t v2 = 0x1E8EB8000uLL;
  {
    unint64_t v21 = v1;
    char v23 = a1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v13 = v12;
    unint64_t v1 = v21;
    a1 = v23;
    if (v13)
    {
      unint64_t v14 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v14 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v14;
      unint64_t v1 = v21;
      a1 = v23;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v3 = HIDWORD(v1);
  unint64_t v4 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v1) ^ HIDWORD(v1));
  unint64_t v28 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  unint64_t v5 = a1[1];
  {
    unint64_t v22 = v5;
    uint64_t v24 = a1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v16 = v15;
    unint64_t v5 = v22;
    a1 = v24;
    if (v16)
    {
      unint64_t v17 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v17 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v17;
      unint64_t v5 = v22;
      a1 = v24;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v6 = HIDWORD(v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v5) ^ HIDWORD(v5));
  unint64_t v27 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  {
    char v25 = a1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v19 = v18;
    a1 = v25;
    if (v19)
    {
      unint64_t v20 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v20 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v20;
      unint64_t v2 = 0x1E8EB8000;
      a1 = v25;
    }
  }
  uint64_t v8 = *(unint64_t *)((char *)a1 + 20);
  uint64_t v9 = __ROR8__(v8 + 12, 12);
  unint64_t v10 = 0x9DDFEA08EB382D69 * (a1[2] ^ *(void *)(v2 + 3024) ^ v9);
  unint64_t v26 = (0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47))) ^ v8;
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v28, (uint64_t *)&v27, (uint64_t *)&v26);
}

uint64_t mlir::cf::SwitchOp::getInherentAttr(mlir::MLIRContext *a1, void *a2, char *__s1, size_t __n)
{
  if (__n == 11)
  {
    if (!memcmp(__s1, "case_values", 0xBuLL)) {
      return a2[1];
    }
    return 0;
  }
  if (__n == 19)
  {
    if (!memcmp(__s1, "operandSegmentSizes", 0x13uLL)) {
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 2), 3);
    }
    return 0;
  }
  if (__n != 21) {
    return 0;
  }
  if (*(void *)__s1 != 0x65706F5F65736163
    || *((void *)__s1 + 1) != 0x6765735F646E6172
    || *(void *)(__s1 + 13) != 0x73746E656D676573)
  {
    if (!memcmp(__s1, "operand_segment_sizes", 0x15uLL)) {
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 2), 3);
    }
    return 0;
  }
  return *a2;
}

uint64_t mlir::cf::SwitchOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, void *a4)
{
  unint64_t v5 = (void *)result;
  if (a3 == 11)
  {
    uint64_t result = memcmp(__s1, "case_values", 0xBuLL);
    if (!result)
    {
      if (a4)
      {
        uint64_t result = mlir::DenseIntElementsAttr::classof((uint64_t)a4);
        if (result) {
          uint64_t v8 = a4;
        }
        else {
          uint64_t v8 = 0;
        }
        v5[1] = v8;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else
  {
    if (a3 == 19)
    {
      uint64_t result = memcmp(__s1, "operandSegmentSizes", 0x13uLL);
      if (result) {
        return result;
      }
    }
    else
    {
      if (a3 != 21) {
        return result;
      }
      if (*(void *)__s1 == 0x65706F5F65736163
        && *((void *)__s1 + 1) == 0x6765735F646E6172
        && *(void *)(__s1 + 13) == 0x73746E656D676573)
      {
        if (a4)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          if (result) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          void *v5 = v11;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
        return result;
      }
      uint64_t result = memcmp(__s1, "operand_segment_sizes", 0x15uLL);
      if (result) {
        return result;
      }
    }
    if (a4)
    {
      uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
      if (result) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      int v12 = v9;
      if (result)
      {
        uint64_t result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v12);
        if (result == 3)
        {
          uint64_t result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v12);
          if (v10) {
            return (uint64_t)memmove(v5 + 2, (const void *)result, 4 * v10);
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::cf::SwitchOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = (void *)mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(v8, (const void **)"case_operand_segments", (const char *)0x15, a3, a4))
  {
    uint64_t v9 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(v9, (const void **)"case_values", (const char *)0xB, a3, a4))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(void *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1 || mlir::detail::DenseArrayAttrImpl<int>::classof(a1)) {
    return 1;
  }
  a4(&v35, a5);
  if (v35)
  {
    LODWORD(v31) = 3;
    unint64_t v32 = "attribute '";
    uint64_t v33 = 11;
    uint64_t v11 = &v31;
    int v12 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        int v12 = (char *)v37;
        uint64_t v11 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = &v31;
        int v12 = (char *)v37;
      }
    }
    int v13 = &v12[24 * v38];
    long long v14 = *(_OWORD *)v11;
    *((void *)v13 + 2) = v11[2];
    *(_OWORD *)int v13 = v14;
    ++v38;
    if (v35)
    {
      __int16 v34 = 261;
      uint64_t v31 = a2;
      unint64_t v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (v35)
      {
        LODWORD(v31) = 3;
        unint64_t v32 = "' failed to satisfy constraint: i32 dense array attribute";
        uint64_t v33 = 57;
        int v15 = &v31;
        int v16 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            int v16 = (char *)v37;
            int v15 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            int v15 = &v31;
            int v16 = (char *)v37;
          }
        }
        unint64_t v17 = &v16[24 * v38];
        long long v18 = *(_OWORD *)v15;
        *((void *)v17 + 2) = v15[2];
        *(_OWORD *)unint64_t v17 = v18;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v35);
  if (v35) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v35);
  }
  if (v45)
  {
    int v19 = (void **)__p;
    if (__p)
    {
      unint64_t v20 = v44;
      unint64_t v21 = __p;
      if (v44 != __p)
      {
        do
          unint64_t v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        unint64_t v21 = __p;
      }
      int v44 = v19;
      operator delete(v21);
    }
    unint64_t v22 = v41;
    if (v41)
    {
      char v23 = v42;
      uint64_t v24 = v41;
      if (v42 != v41)
      {
        do
        {
          unint64_t v26 = (void *)*--v23;
          char v25 = v26;
          void *v23 = 0;
          if (v26) {
            operator delete[](v25);
          }
        }
        while (v23 != v22);
        uint64_t v24 = v41;
      }
      unsigned int v42 = v22;
      operator delete(v24);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

uint64_t mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1 || (mlir::DenseIntElementsAttr::classof(a1) & 1) != 0) {
    return 1;
  }
  a4(&v35, a5);
  if (v35)
  {
    LODWORD(v31) = 3;
    unint64_t v32 = "attribute '";
    uint64_t v33 = 11;
    uint64_t v11 = &v31;
    int v12 = (char *)v37;
    if (v38 >= v39)
    {
      unint64_t v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        int64_t v29 = (char *)&v31 - (unsigned char *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        int v12 = (char *)v37;
        uint64_t v11 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        uint64_t v11 = &v31;
        int v12 = (char *)v37;
      }
    }
    int v13 = &v12[24 * v38];
    long long v14 = *(_OWORD *)v11;
    *((void *)v13 + 2) = v11[2];
    *(_OWORD *)int v13 = v14;
    ++v38;
    if (v35)
    {
      __int16 v34 = 261;
      uint64_t v31 = a2;
      unint64_t v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (v35)
      {
        LODWORD(v31) = 3;
        unint64_t v32 = "' failed to satisfy constraint: integer elements attribute";
        uint64_t v33 = 58;
        int v15 = &v31;
        int v16 = (char *)v37;
        if (v38 >= v39)
        {
          unint64_t v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            int64_t v30 = (char *)&v31 - (unsigned char *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            int v16 = (char *)v37;
            int v15 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            int v15 = &v31;
            int v16 = (char *)v37;
          }
        }
        unint64_t v17 = &v16[24 * v38];
        long long v18 = *(_OWORD *)v15;
        *((void *)v17 + 2) = v15[2];
        *(_OWORD *)unint64_t v17 = v18;
        ++v38;
      }
    }
  }
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v35);
  if (v35) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v35);
  }
  if (v45)
  {
    int v19 = (void **)__p;
    if (__p)
    {
      unint64_t v20 = v44;
      unint64_t v21 = __p;
      if (v44 != __p)
      {
        do
          unint64_t v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        unint64_t v21 = __p;
      }
      int v44 = v19;
      operator delete(v21);
    }
    unint64_t v22 = v41;
    if (v41)
    {
      char v23 = v42;
      uint64_t v24 = v41;
      if (v42 != v41)
      {
        do
        {
          unint64_t v26 = (void *)*--v23;
          char v25 = v26;
          void *v23 = 0;
          if (v26) {
            operator delete[](v25);
          }
        }
        while (v23 != v22);
        uint64_t v24 = v41;
      }
      unsigned int v42 = v22;
      operator delete(v24);
    }
    if (v37 != v40) {
      free(v37);
    }
  }
  return v9;
}

BOOL mlir::cf::SwitchOp::readProperties(uint64_t a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = (void *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) <= 5)
  {
    uint64_t v17 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v17)) {
      return 0;
    }
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v17) >= 4)
    {
      int v15 = "size mismatch for operand/result_segment_size";
      __int16 v16 = 259;
      (*(void (**)(void *__return_ptr, uint64_t, const char **))(*(void *)a1 + 16))(v18, a1, &v15);
      if (v18[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
      }
      if (v25)
      {
        unint64_t v4 = (void **)__p;
        if (__p)
        {
          unint64_t v5 = v24;
          unint64_t v6 = __p;
          if (v24 != __p)
          {
            do
              unint64_t v5 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v5 - 1);
            while (v5 != v4);
            unint64_t v6 = __p;
          }
          uint64_t v24 = v4;
          operator delete(v6);
        }
        unint64_t v7 = v21;
        if (v21)
        {
          uint64_t v8 = v22;
          uint64_t v9 = v21;
          if (v22 != v21)
          {
            do
            {
              uint64_t v11 = (void *)*--v8;
              uint64_t v10 = v11;
              void *v8 = 0;
              if (v11) {
                operator delete[](v10);
              }
            }
            while (v8 != v7);
            uint64_t v9 = v21;
          }
          unint64_t v22 = v7;
          operator delete(v9);
        }
        if (v19 != &v20) {
          free(v19);
        }
      }
      return 0;
    }
    int v12 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v17);
    if (v13) {
      memmove(v3 + 2, v12, 4 * v13);
    }
  }
  return (unint64_t)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1) < 6
      || mlir::DialectBytecodeReader::readSparseArray<int>(a1, (_DWORD *)v3 + 4, (const char *)3);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    unint64_t v3 = operator new(0x20uLL);
    v3[1] = 0;
    v3[2] = 0;
    void *v3 = 0;
    *((_DWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &unk_1E8EBA000;
    {
      unint64_t v4 = (void *)&unk_1E8EBA000;
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 106;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = (void *)&unk_1E8EBA000;
      }
    }
    a1[33] = v4[77];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::DenseIntElementsAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  uint64_t v40 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v40)) {
    return 0;
  }
  uint64_t v4 = v40;
  if (!v40) {
    return 1;
  }
  int v5 = mlir::DenseIntElementsAttr::classof(v40);
  uint64_t v6 = v5 ? v4 : 0;
  *a2 = v6;
  if (v5) {
    return 1;
  }
  v39[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v45, a1, v39);
  if (v45)
  {
    LODWORD(v41) = 3;
    unint64_t v42 = (unint64_t)"expected ";
    uint64_t v43 = 9;
    unint64_t v9 = &v41;
    uint64_t v10 = (char *)v47;
    if (v48 >= v49)
    {
      unint64_t v33 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        int64_t v36 = (char *)&v41 - (unsigned char *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v33, 24);
        uint64_t v10 = (char *)v47;
        unint64_t v9 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v33, 24);
        unint64_t v9 = &v41;
        uint64_t v10 = (char *)v47;
      }
    }
    unint64_t v11 = &v10[24 * v48];
    long long v12 = *(_OWORD *)v9;
    *((void *)v11 + 2) = v9[2];
    *(_OWORD *)unint64_t v11 = v12;
    ++v48;
  }
  unint64_t v41 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::DenseIntElementsAttr]";
  unint64_t v42 = 76;
  unint64_t v13 = llvm::StringRef::find((uint64_t *)&v41, "DesiredTypeName = ", 0x12uLL, 0);
  if (v45)
  {
    if (v42 >= v13) {
      unint64_t v14 = v13;
    }
    else {
      unint64_t v14 = v42;
    }
    uint64_t v15 = 18;
    if (v42 - v14 < 0x12) {
      uint64_t v15 = v42 - v14;
    }
    unint64_t v16 = v42 - v14 - v15;
    if (v16 >= v16 - 1) {
      --v16;
    }
    __int16 v44 = 261;
    unint64_t v41 = (const void **)((char *)v41 + v14 + v15);
    unint64_t v42 = v16;
    mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
    if (v45)
    {
      LODWORD(v41) = 3;
      unint64_t v42 = (unint64_t)", but got: ";
      uint64_t v43 = 11;
      uint64_t v17 = &v41;
      long long v18 = (char *)v47;
      if (v48 >= v49)
      {
        unint64_t v34 = v48 + 1;
        if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
        {
          int64_t v37 = (char *)&v41 - (unsigned char *)v47;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
          long long v18 = (char *)v47;
          uint64_t v17 = (const void ***)((char *)v47 + v37);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
          uint64_t v17 = &v41;
          long long v18 = (char *)v47;
        }
      }
      int v19 = &v18[24 * v48];
      long long v20 = *(_OWORD *)v17;
      *((void *)v19 + 2) = v17[2];
      *(_OWORD *)int v19 = v20;
      ++v48;
      if (v45)
      {
        unint64_t v21 = &v41;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v41, v40);
        unint64_t v22 = (char *)v47;
        if (v48 >= v49)
        {
          unint64_t v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            int64_t v38 = (char *)&v41 - (unsigned char *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            unint64_t v22 = (char *)v47;
            unint64_t v21 = (const void ***)((char *)v47 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            unint64_t v21 = &v41;
            unint64_t v22 = (char *)v47;
          }
        }
        char v23 = &v22[24 * v48];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)char v23 = v24;
        ++v48;
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  }
  if (v55)
  {
    char v25 = (void **)__p;
    if (__p)
    {
      uint64_t v26 = v54;
      unint64_t v27 = __p;
      if (v54 != __p)
      {
        do
          uint64_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        unint64_t v27 = __p;
      }
      char v54 = v25;
      operator delete(v27);
    }
    unint64_t v28 = v51;
    if (v51)
    {
      int64_t v29 = v52;
      int64_t v30 = v51;
      if (v52 != v51)
      {
        do
        {
          unint64_t v32 = (void *)*--v29;
          uint64_t v31 = v32;
          *int64_t v29 = 0;
          if (v32) {
            operator delete[](v31);
          }
        }
        while (v29 != v28);
        int64_t v30 = v51;
      }
      int64_t v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50) {
      free(v47);
    }
  }
  return v7;
}

uint64_t mlir::cf::SwitchOp::writeProperties(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(*(void *)a1 + 44))) {
    unint64_t v4 = *(void *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(void *)a1 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a2 + 16))(a2, *(void *)v4);
  (*(void (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(v4 + 8));
  if ((*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(void *)a1 + 24));
    uint64_t v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 16, 3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a2 + 16))(a2, v6);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a2 + 104))(a2);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 16), 3);
  }
  return result;
}

BOOL mlir::cf::SwitchOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    unint64_t v3 = 0;
  }
  unint64_t v4 = *(void **)v3;
  if (*(void *)v3)
  {
    uint64_t v5 = *(void *)(v3 + 8);
    v67[0] = v2;
    if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(v5, (const void **)"case_values", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
    v67[0] = *this;
    }
    if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(v4, (const void **)"case_operand_segments", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0; {
    unint64_t v6 = *((unsigned int *)*this + 11);
    }
    uint64_t v7 = (uint64_t)&(*this)[2 * ((v6 >> 23) & 1) + 8];
    if (!HIBYTE(*((_DWORD *)*this + 11))) {
      uint64_t v7 = 0;
    }
    uint64_t v8 = (const char *)*(unsigned int *)(v7 + 16);
    if ((v6 & 0x800000) != 0)
    {
      uint64_t v9 = (*this)[9];
      if (v8) {
        goto LABEL_11;
      }
    }
    else
    {
      uint64_t v9 = 0;
      if (v8)
      {
LABEL_11:
        uint64_t v10 = 0;
        do
        {
          unint64_t v11 = *(void *)(*(void *)(v9 + 32 * (void)v10 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
          if (*(_UNKNOWN **)(*(void *)v11 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
          {
            long long v12 = *this;
            __int16 v63 = 261;
            v62[0] = (const void **)"operand";
            v62[1] = (const void **)7;
            mlir::Operation::emitOpError(v12, v62, (uint64_t)v67);
            if (v67[0])
            {
              int v64 = 3;
              long long v65 = " #";
              uint64_t v66 = 2;
              unint64_t v13 = (char *)v68;
              if (v69 >= v70)
              {
                unint64_t v40 = v69 + 1;
                if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
                {
                  int64_t v46 = (char *)&v64 - (unsigned char *)v68;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v40, 24);
                  unint64_t v13 = (char *)v68;
                  unint64_t v14 = (int *)((char *)v68 + v46);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v40, 24);
                  unint64_t v14 = &v64;
                  unint64_t v13 = (char *)v68;
                }
              }
              else
              {
                unint64_t v14 = &v64;
              }
              uint64_t v15 = &v13[24 * v69];
              long long v16 = *(_OWORD *)v14;
              *((void *)v15 + 2) = *((void *)v14 + 2);
              *(_OWORD *)uint64_t v15 = v16;
              uint64_t v17 = ++v69;
              if (v67[0])
              {
                int v64 = 5;
                long long v65 = v10;
                long long v18 = (char *)v68;
                if (v17 >= v70)
                {
                  unint64_t v41 = v17 + 1;
                  BOOL v42 = (char *)v68 + 24 * v17 > (char *)&v64;
                  if (v68 <= &v64 && v42)
                  {
                    int64_t v47 = (char *)&v64 - (unsigned char *)v68;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v41, 24);
                    long long v18 = (char *)v68;
                    int v19 = (int *)((char *)v68 + v47);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v41, 24);
                    int v19 = &v64;
                    long long v18 = (char *)v68;
                  }
                }
                else
                {
                  int v19 = &v64;
                }
                long long v20 = &v18[24 * v69];
                long long v21 = *(_OWORD *)v19;
                *((void *)v20 + 2) = *((void *)v19 + 2);
                *(_OWORD *)long long v20 = v21;
                uint64_t v22 = ++v69;
                if (v67[0])
                {
                  int v64 = 3;
                  long long v65 = " must be integer, but got ";
                  uint64_t v66 = 26;
                  char v23 = (char *)v68;
                  if (v22 >= v70)
                  {
                    unint64_t v43 = v22 + 1;
                    BOOL v44 = (char *)v68 + 24 * v22 > (char *)&v64;
                    if (v68 <= &v64 && v44)
                    {
                      int64_t v48 = (char *)&v64 - (unsigned char *)v68;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v43, 24);
                      char v23 = (char *)v68;
                      long long v24 = (int *)((char *)v68 + v48);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v43, 24);
                      long long v24 = &v64;
                      char v23 = (char *)v68;
                    }
                  }
                  else
                  {
                    long long v24 = &v64;
                  }
                  char v25 = &v23[24 * v69];
                  long long v26 = *(_OWORD *)v24;
                  *((void *)v25 + 2) = *((void *)v24 + 2);
                  *(_OWORD *)char v25 = v26;
                  ++v69;
                  if (v67[0])
                  {
                    unint64_t v27 = &v64;
                    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v11);
                    unint64_t v28 = (char *)v68;
                    if (v69 >= v70)
                    {
                      unint64_t v45 = v69 + 1;
                      if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
                      {
                        int64_t v49 = (char *)&v64 - (unsigned char *)v68;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v45, 24);
                        unint64_t v28 = (char *)v68;
                        unint64_t v27 = (int *)((char *)v68 + v49);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v45, 24);
                        unint64_t v27 = &v64;
                        unint64_t v28 = (char *)v68;
                      }
                    }
                    int64_t v29 = &v28[24 * v69];
                    long long v30 = *(_OWORD *)v27;
                    *((void *)v29 + 2) = *((void *)v27 + 2);
                    *(_OWORD *)int64_t v29 = v30;
                    ++v69;
                  }
                }
              }
            }
            char v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v67);
            if (v67[0]) {
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
            }
            if (v76)
            {
              unint64_t v32 = (void **)__p;
              if (__p)
              {
                unint64_t v33 = v75;
                unint64_t v34 = __p;
                if (v75 != __p)
                {
                  do
                    unint64_t v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                  while (v33 != v32);
                  unint64_t v34 = __p;
                }
                unint64_t v75 = v32;
                operator delete(v34);
              }
              unint64_t v35 = v72;
              if (v72)
              {
                int64_t v36 = v73;
                int64_t v37 = v72;
                if (v73 != v72)
                {
                  do
                  {
                    unsigned int v39 = (void *)*--v36;
                    int64_t v38 = v39;
                    *int64_t v36 = 0;
                    if (v39) {
                      operator delete[](v38);
                    }
                  }
                  while (v36 != v35);
                  int64_t v37 = v72;
                }
                uint64_t v73 = v35;
                operator delete(v37);
              }
              if (v68 != v71) {
                free(v68);
              }
            }
            if (!v31) {
              return 0;
            }
          }
        }
        while (++v10 != v8);
      }
    }
    if (HIBYTE(*((_DWORD *)*this + 11))) {
      int v59 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
    }
    else {
      int v59 = 0;
    }
    uint64_t v60 = (*((_DWORD *)v59 + 5) + *((_DWORD *)v59 + 4));
    return mlir::OpTrait::impl::verifyValueSizeAttr((uint64_t)*this, "case_operand_segments", 0x15uLL, (const void **)"caseOperands", (const char *)0xC, (const char *)((*((_DWORD *)v59 + 6) + v60) - v60)) != 0;
  }
  else
  {
    v62[0] = (const void **)"requires attribute 'case_operand_segments'";
    __int16 v63 = 259;
    mlir::OpState::emitOpError(this, v62, (uint64_t)v67);
    uint64_t v50 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v67);
    if (v67[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    }
    if (v76)
    {
      int64_t v51 = (void **)__p;
      if (__p)
      {
        int64_t v52 = v75;
        long long v53 = __p;
        if (v75 != __p)
        {
          do
            int64_t v52 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v52 - 1);
          while (v52 != v51);
          long long v53 = __p;
        }
        unint64_t v75 = v51;
        operator delete(v53);
      }
      char v54 = v72;
      if (v72)
      {
        char v55 = v73;
        uint64_t v56 = v72;
        if (v73 != v72)
        {
          do
          {
            uint64_t v58 = (void *)*--v55;
            long long v57 = v58;
            *char v55 = 0;
            if (v58) {
              operator delete[](v57);
            }
          }
          while (v55 != v54);
          uint64_t v56 = v72;
        }
        uint64_t v73 = v54;
        operator delete(v56);
      }
      if (v68 != v71) {
        free(v68);
      }
    }
  }
  return v50;
}

BOOL mlir::cf::SwitchOp::parse(void *a1, mlir::OperationState *a2)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  memset(v96, 0, 24);
  v68[0] = (uint64_t)v96;
  v68[1] = 1;
  unsigned int v95 = 0;
  v67[0] = &v95;
  v67[1] = 1;
  uint64_t v66 = 0;
  int64_t v92 = v94;
  uint64_t v93 = 0x400000000;
  v90[0] = &v91;
  v90[1] = (void *)0x100000000;
  int64_t v87 = v89;
  uint64_t v88 = 0x200000000;
  int64_t v84 = v86;
  uint64_t v85 = 0x400000000;
  int64_t v81 = v83;
  uint64_t v82 = 0xC00000000;
  unint64_t v78 = &v80;
  uint64_t v79 = 0x100000000;
  uint64_t v4 = (*(uint64_t (**)(void *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(void *, void **, uint64_t))(*(void *)a1 + 672))(a1, v96, 1)) {
    goto LABEL_112;
  }
  if (!(*(unsigned __int8 (**)(void *))(*(void *)a1 + 104))(a1)) {
    goto LABEL_112;
  }
  unint64_t v72 = 0;
  if (!mlir::AsmParser::parseType<mlir::IntegerType>((uint64_t)a1, &v72)) {
    goto LABEL_112;
  }
  unsigned int v95 = v72;
  if (!(*(unsigned __int8 (**)(void *))(*(void *)a1 + 120))(a1)
    || !(*(unsigned __int8 (**)(void *))(*(void *)a1 + 296))(a1))
  {
    goto LABEL_112;
  }
  uint64_t v60 = (*(uint64_t (**)(void *))(*(void *)a1 + 40))(a1);
  uint64_t v5 = (*(uint64_t (**)(void *))(*(void *)a1 + 40))(a1);
  unint64_t v75 = v77;
  uint64_t v76 = 0x100000000;
  unint64_t v72 = v74;
  uint64_t v73 = 0x100000000;
  v105[8] = 257;
  uint64_t v61 = v4;
  uint64_t v62 = a2;
  uint64_t v59 = v5;
  if (!(*(unsigned __int8 (**)(void *, const char *, uint64_t, llvm::APInt **))(*(void *)a1 + 368))(a1, "default", 7, &v103)|| !(*(unsigned __int8 (**)(void *))(*(void *)a1 + 104))(a1)|| !(*(unsigned __int8 (**)(void *, mlir::Block **))(*(void *)a1 + 768))(a1, &v66)|| (*(unsigned __int8 (**)(void *))(*(void *)a1 + 272))(a1)&& (!(*(unsigned __int8 (**)(void *, void **, void, void, uint64_t))(*(void *)a1 + 688))(a1, &v92, 0, 0, 0xFFFFFFFFLL)|| !(*(unsigned __int8 (**)(void *, void **))(*(void *)a1 + 552))(a1, v90)|| !(*(unsigned __int8 (**)(void *))(*(void *)a1 + 280))(a1)))
  {
    goto LABEL_89;
  }
  uint64_t v103 = (llvm::APInt *)v105;
  uint64_t v104 = 0x300000000;
  unsigned int IntOrFloatBitWidth = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v95);
  unint64_t v7 = 0xFFFFFFFFFFFFFFFFLL >> -(char)IntOrFloatBitWidth;
  if (!IntOrFloatBitWidth) {
    unint64_t v7 = 0;
  }
  unint64_t v58 = v7;
  while ((*(unsigned __int8 (**)(void *))(*(void *)a1 + 128))(a1))
  {
    unint64_t v70 = 0;
    if (!mlir::AsmParser::parseInteger<long long>((uint64_t)a1, (uint64_t *)&v70)) {
      goto LABEL_60;
    }
    LODWORD(v98) = IntOrFloatBitWidth;
    if (IntOrFloatBitWidth > 0x40) {
      llvm::APInt::initSlowCase((llvm::APInt *)&__p, v70, 0);
    }
    else {
      __p = (void *)(v70 & v58);
    }
    Address = llvm::SmallVectorTemplateBase<llvm::APInt,false>::reserveForParamAndGetAddress((uint64_t)&v103, (unint64_t)&__p, 1);
    uint64_t v9 = (char *)v103 + 16 * v104;
    *((_DWORD *)v9 + 2) = *((_DWORD *)Address + 2);
    *(void *)uint64_t v9 = *(void *)Address;
    *((_DWORD *)Address + 2) = 0;
    LODWORD(v104) = v104 + 1;
    if (v98 >= 0x41 && __p) {
      operator delete[](__p);
    }
    uint64_t v69 = 0;
    BOOL v100 = v102;
    uint64_t v101 = 0x100000000;
    __p = v99;
    uint64_t v98 = 0x600000000;
    if ((*(unsigned __int8 (**)(void *))(*(void *)a1 + 104))(a1)
      && (*(unsigned __int8 (**)(void *, uint64_t *))(*(void *)a1 + 768))(a1, &v69)
      && (!(*(unsigned __int8 (**)(void *))(*(void *)a1 + 272))(a1)
       || (*(unsigned __int8 (**)(void *, unsigned char **, void, void, uint64_t))(*(void *)a1 + 688))(a1, &v100, 0, 0, 0xFFFFFFFFLL)&& (*(unsigned __int8 (**)(void *, void **))(*(void *)a1 + 552))(a1, &__p)&& (*(unsigned __int8 (**)(void *))(*(void *)a1 + 280))(a1)))
    {
      uint64_t v10 = v69;
      uint64_t v11 = v88;
      if (v88 >= (unint64_t)HIDWORD(v88))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v89, v88 + 1, 8);
        uint64_t v11 = v88;
      }
      *((void *)v87 + v11) = v10;
      LODWORD(v88) = v88 + 1;
      if (v76 >= HIDWORD(v76))
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,1u>,false>::growAndEmplaceBack<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,1u>&>((uint64_t)&v75, (uint64_t)&v100);
        uint64_t v18 = v73;
        if (v73 < HIDWORD(v73)) {
          goto LABEL_47;
        }
      }
      else
      {
        long long v12 = (char *)v75 + 48 * v76;
        unint64_t v13 = v12 + 16;
        *(void *)long long v12 = v12 + 16;
        *((void *)v12 + 1) = 0x100000000;
        if (v12 != (char *)&v100)
        {
          int v14 = v101;
          if (v101)
          {
            if (v101 < 2)
            {
              size_t v15 = 32;
LABEL_44:
              memcpy(v13, v100, v15);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v12, v12 + 16, v101, 32);
              if (v101)
              {
                unint64_t v13 = *(void **)v12;
                size_t v15 = 32 * v101;
                goto LABEL_44;
              }
            }
            *((_DWORD *)v12 + 2) = v14;
          }
        }
        LODWORD(v76) = v76 + 1;
        uint64_t v18 = v73;
        if (v73 < HIDWORD(v73))
        {
LABEL_47:
          int v19 = (void **)((char *)v72 + 64 * v18);
          long long v20 = v19 + 2;
          int *v19 = v19 + 2;
          v19[1] = (void *)0x600000000;
          if (v19 != &__p)
          {
            int v21 = v98;
            if (v98)
            {
              if (v98 < 7uLL)
              {
                uint64_t v22 = v98;
LABEL_53:
                memcpy(v20, __p, 8 * v22);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v19, v19 + 2, v98, 8);
                uint64_t v22 = v98;
                if (v98)
                {
                  long long v20 = *v19;
                  goto LABEL_53;
                }
              }
              *((_DWORD *)v19 + 2) = v21;
            }
          }
          LODWORD(v73) = v73 + 1;
          char v16 = 1;
          uint64_t v17 = __p;
          if (__p == v99) {
            goto LABEL_41;
          }
LABEL_40:
          free(v17);
          goto LABEL_41;
        }
      }
      llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Type,6u>,false>::growAndEmplaceBack<llvm::SmallVector<mlir::Type,6u>&>((uint64_t)&v72, (uint64_t)&__p);
      char v16 = 1;
      uint64_t v17 = __p;
      if (__p == v99) {
        goto LABEL_41;
      }
      goto LABEL_40;
    }
    char v16 = 0;
    uint64_t v17 = __p;
    if (__p != v99) {
      goto LABEL_40;
    }
LABEL_41:
    if (v100 != v102) {
      free(v100);
    }
    if ((v16 & 1) == 0)
    {
LABEL_60:
      uint64_t v23 = 0;
      int v24 = 0;
      goto LABEL_67;
    }
  }
  if (!v104)
  {
    uint64_t v23 = 0;
    int v24 = 1;
    unint64_t v28 = v103;
    goto LABEL_74;
  }
  __p = (void *)v104;
  char v25 = (void *)mlir::VectorType::get((uint64_t)&__p, 1uLL, (uint64_t)v95, 0, 0);
  uint64_t v26 = (uint64_t)v25;
  uint64_t v27 = v25 ? mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v25 + 8) : 0;
  uint64_t v23 = mlir::DenseElementsAttr::get(v26, v27, v103, v104);
  int v24 = 1;
LABEL_67:
  unint64_t v28 = v103;
  if (v104)
  {
    uint64_t v63 = v23;
    uint64_t v29 = 16 * v104;
    do
    {
      if (*(_DWORD *)((char *)v28 + v29 - 8) >= 0x41u)
      {
        long long v30 = *(void **)((char *)v28 + v29 - 16);
        if (v30) {
          operator delete[](v30);
        }
      }
      v29 -= 16;
    }
    while (v29);
    unint64_t v28 = v103;
    uint64_t v23 = v63;
  }
LABEL_74:
  if (v28 != (llvm::APInt *)v105) {
    free(v28);
  }
  if (!v24)
  {
LABEL_89:
    char v38 = 1;
    uint64_t v39 = v73;
    unint64_t v40 = (const void **)v72;
    if (!v73) {
      goto LABEL_95;
    }
    goto LABEL_90;
  }
  if (v23) {
    *(void *)(mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(v62)
  }
              + 8) = v23;
  if (v76)
  {
    char v31 = (char *)v75;
    int v64 = (char *)v75 + 48 * v76;
    do
    {
      unint64_t v32 = *(const void **)v31;
      uint64_t v33 = *((unsigned int *)v31 + 2);
      unsigned int v34 = v85;
      unint64_t v35 = v85 + v33;
      if (v35 > HIDWORD(v85))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v86, v35, 32);
        unsigned int v34 = v85;
      }
      if (v33)
      {
        memcpy((char *)v84 + 32 * v34, v32, 32 * v33);
        unsigned int v34 = v85;
      }
      LODWORD(v85) = v34 + v33;
      unsigned int v36 = *((_DWORD *)v31 + 2);
      uint64_t v37 = v82;
      if (v82 >= (unint64_t)HIDWORD(v82))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v83, v82 + 1, 4);
        uint64_t v37 = v82;
      }
      *((_DWORD *)v81 + v37) = v36;
      LODWORD(v82) = v82 + 1;
      v31 += 48;
    }
    while (v31 != v64);
  }
  unint64_t v40 = (const void **)v72;
  if (v73)
  {
    long long v65 = (const void **)((char *)v72 + 64 * (unint64_t)v73);
    unsigned int v54 = v79;
    do
    {
      char v55 = *v40;
      uint64_t v56 = *((unsigned int *)v40 + 2);
      unint64_t v57 = v56 + v54;
      if (v57 > HIDWORD(v79))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, &v80, v57, 8);
        unsigned int v54 = v79;
      }
      if (v56)
      {
        memcpy((char *)v78 + 8 * v54, v55, 8 * v56);
        unsigned int v54 = v79;
      }
      v54 += v56;
      LODWORD(v79) = v54;
      v40 += 8;
    }
    while (v40 != v65);
    char v38 = 0;
    uint64_t v39 = v73;
    unint64_t v40 = (const void **)v72;
    if (!v73)
    {
LABEL_95:
      if (v40 != v74) {
        goto LABEL_96;
      }
      goto LABEL_97;
    }
LABEL_90:
    uint64_t v41 = v39 << 6;
    do
    {
      BOOL v42 = *(char **)((char *)v40 + v41 - 64);
      if ((char *)v40 + v41 - 48 != v42) {
        free(v42);
      }
      v41 -= 64;
    }
    while (v41);
    unint64_t v40 = (const void **)v72;
    goto LABEL_95;
  }
  char v38 = 0;
  if (v72 != v74) {
LABEL_96:
  }
    free(v40);
LABEL_97:
  unint64_t v43 = (char *)v75;
  if (v76)
  {
    uint64_t v44 = 48 * v76;
    do
    {
      unint64_t v45 = *(char **)&v43[v44 - 48];
      if (&v43[v44 - 32] != v45) {
        free(v45);
      }
      v44 -= 48;
    }
    while (v44);
    unint64_t v43 = (char *)v75;
  }
  if (v43 != v77) {
    free(v43);
  }
  if ((v38 & 1) == 0)
  {
    if ((*(unsigned __int8 (**)(void *))(*(void *)a1 + 312))(a1))
    {
      uint64_t v103 = (llvm::APInt *)(*(uint64_t (**)(void *))(*(void *)a1 + 40))(a1);
      if ((*(unsigned __int8 (**)(void *, void *))(*(void *)a1 + 456))(a1, (void *)v62 + 14))
      {
        uint64_t v46 = *((void *)v62 + 1);
        unint64_t v72 = a1;
        uint64_t v73 = (uint64_t)&v103;
        v74[0] = v62;
        if (mlir::cf::SwitchOp::verifyInherentAttrs(v46, (uint64_t)v62 + 112, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::SwitchOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v72))
        {
          mlir::OperationState::addSuccessors(v62, v66);
          mlir::BlockRange::BlockRange(v71, (uint64_t)v87, v88);
          mlir::OperationState::addSuccessors((unsigned int *)v62, v71[0], v71[1]);
          int v47 = v93;
          int v48 = v85;
          int64_t v49 = (_DWORD *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(v62);
          v49[4] = 1;
          v49[5] = v47;
          v49[6] = v48;
          uint64_t v50 = (mlir::MLIRContext **)(*(uint64_t (**)(void *))(*(void *)a1 + 32))(a1);
          uint64_t DenseI32ArrayAttr = mlir::Builder::getDenseI32ArrayAttr(v50, (uint64_t)v81, v82);
          *(void *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(v62) = DenseI32ArrayAttr;
          if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>((uint64_t)a1, v68, v67, v61, (uint64_t)v62 + 16))
          {
            if (mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>((uint64_t)a1, (uint64_t *)&v92, (uint64_t)v90, v60, (uint64_t)v62 + 16))
            {
              BOOL v52 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>((uint64_t)a1, (uint64_t *)&v84, (uint64_t)&v78, v59, (uint64_t)v62 + 16) != 0;
              goto LABEL_113;
            }
          }
        }
      }
    }
  }
LABEL_112:
  BOOL v52 = 0;
LABEL_113:
  if (v78 != &v80) {
    free(v78);
  }
  if (v81 != v83) {
    free(v81);
  }
  if (v84 != v86) {
    free(v84);
  }
  if (v87 != v89) {
    free(v87);
  }
  if (v90[0] != &v91) {
    free(v90[0]);
  }
  if (v92 != v94) {
    free(v92);
  }
  return v52;
}

void mlir::cf::SwitchOp::print(Operation **this, mlir::OpAsmPrinter *a2)
{
  v101[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = (unsigned char *)*((void *)v4 + 4);
  if ((unint64_t)v5 >= *((void *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((void *)v4 + 4) = v5 + 1;
    unsigned char *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 160))(a2, *(void *)(*((void *)*this + 9) + 24));
  unint64_t v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  unint64_t v7 = (unsigned char *)*((void *)v6 + 4);
  if ((unint64_t)v7 >= *((void *)v6 + 3))
  {
    llvm::raw_ostream::write(v6, 32);
  }
  else
  {
    *((void *)v6 + 4) = v7 + 1;
    *unint64_t v7 = 32;
  }
  uint64_t v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v9 = (unsigned char *)*((void *)v8 + 4);
  if (*((unsigned char **)v8 + 3) == v9)
  {
    llvm::raw_ostream::write(v8, ":", 1uLL);
  }
  else
  {
    *uint64_t v9 = 58;
    ++*((void *)v8 + 4);
  }
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (unsigned char *)*((void *)v10 + 4);
  if ((unint64_t)v11 >= *((void *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((void *)v10 + 4) = v11 + 1;
    unsigned char *v11 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(void *)a2 + 32))(a2, *(void *)(*(void *)(*((void *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  long long v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  unint64_t v13 = (unsigned char *)*((void *)v12 + 4);
  if (*((unsigned char **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ",", 1uLL);
  }
  else
  {
    unsigned char *v13 = 44;
    ++*((void *)v12 + 4);
  }
  int v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  size_t v15 = (unsigned char *)*((void *)v14 + 4);
  if ((unint64_t)v15 >= *((void *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((void *)v14 + 4) = v15 + 1;
    unsigned char *v15 = 32;
  }
  char v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v17 = (unsigned char *)*((void *)v16 + 4);
  if (*((unsigned char **)v16 + 3) == v17)
  {
    llvm::raw_ostream::write(v16, "[", 1uLL);
  }
  else
  {
    unsigned char *v17 = 91;
    ++*((void *)v16 + 4);
  }
  (*(void (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 128))(a2);
  uint64_t v18 = (uint64_t)*this + 80;
  uint64_t v19 = *(void *)(((v18 + (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 24);
  if (!HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v18 = 0;
  }
  uint64_t v20 = *(unsigned int *)(v18 + 16);
  uint64_t v21 = *((void *)*this + 9) + 32 * v20;
  unint64_t v22 = (*(_DWORD *)(v18 + 20) + v20) - v20;
  v76[0] = v21;
  v76[1] = v22;
  mlir::OperandRange::getTypes(v76, &v77);
  mlir::ValueRange::ValueRange((unint64_t *)&v91, v77 + 32 * v78, v79 - v78);
  mlir::TypeRange::TypeRange(&v99, (uint64_t)v91, v92);
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    unint64_t v23 = (unint64_t)*this + 16 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 64;
  }
  else {
    unint64_t v23 = 0;
  }
  uint64_t v24 = *(void *)(v23 + 8);
  char v25 = mlir::SuccessorRange::SuccessorRange((unint64_t *)&v91, *this);
  uint64_t v26 = v91;
  uint64_t v27 = (uint64_t *)mlir::SuccessorRange::SuccessorRange(v25, *this);
  unint64_t v28 = *((unsigned int *)*this + 11);
  uint64_t v29 = (uint64_t *)((char *)*this + 16 * ((v28 >> 23) & 1) + 64);
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    long long v30 = (_DWORD *)((char *)*this + 16 * ((v28 >> 23) & 1) + 64);
  }
  else {
    long long v30 = 0;
  }
  int v31 = v30[4];
  int v32 = v30[5];
  int v33 = v30[6];
  if ((v28 & 0x800000) != 0) {
    uint64_t v34 = *((void *)*this + 9);
  }
  else {
    uint64_t v34 = 0;
  }
  uint64_t v35 = (v32 + v31);
  uint64_t v91 = (char *)(v34 + 32 * v35);
  unint64_t v92 = (v33 + v35) - v35;
  mlir::OperandRange::split(v27, *v29, v75);
  unint64_t v36 = *((unsigned int *)*this + 11);
  uint64_t v37 = (uint64_t *)((char *)*this + 16 * ((v36 >> 23) & 1) + 64);
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    char v38 = (_DWORD *)((char *)*this + 16 * ((v36 >> 23) & 1) + 64);
  }
  else {
    char v38 = 0;
  }
  int v39 = v38[4];
  int v40 = v38[5];
  int v41 = v38[6];
  if ((v36 & 0x800000) != 0) {
    uint64_t v42 = *((void *)*this + 9);
  }
  else {
    uint64_t v42 = 0;
  }
  uint64_t v43 = (v40 + v39);
  uint64_t v91 = (char *)(v42 + 32 * v43);
  unint64_t v92 = (v41 + v43) - v43;
  mlir::OperandRange::split((uint64_t *)&v91, *v37, v74);
  __n128 Types = mlir::OperandRangeRange::getTypes((mlir::OperandRangeRange *)v74, (uint64_t)&v91);
  uint64_t v88 = v24;
  unint64_t v45 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *, __n128))(*(void *)a2 + 16))(a2, Types);
  uint64_t v46 = *((void *)v45 + 4);
  if ((unint64_t)(*((void *)v45 + 3) - v46) > 0xA)
  {
    *(_DWORD *)(v46 + 7) = 540701804;
    *(void *)uint64_t v46 = *(void *)"  default: ";
    *((void *)v45 + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(v45, "  default: ", 0xBuLL);
  }
  mlir::ValueRange::ValueRange(v101, v21, v22);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, unint64_t, unint64_t))(*(void *)a2 + 184))(a2, v19, v101[0], v101[1]);
  if (v24)
  {
    uint64_t v73 = (mlir::cf::SwitchOp *)this;
    mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)&v88, (uint64_t)&v83);
    long long v81 = v83;
    long long v82 = v84;
    uint64_t v47 = v85;
    int v48 = v86;
    uint64_t v49 = v87;
    uint64_t v80 = 0;
    if ((void)v83 != v85 || BYTE8(v81) != v86 || (void)v82 != v87)
    {
      uint64_t v50 = 0;
      int64_t v51 = v26 + 32;
      do
      {
        mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v81, (llvm::APInt *)&v89);
        LODWORD(v84) = v90;
        *(void *)&long long v83 = v50;
        *((void *)&v83 + 1) = v89;
        BOOL v52 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
        long long v53 = (unsigned char *)*((void *)v52 + 4);
        if ((unint64_t)v53 >= *((void *)v52 + 3))
        {
          llvm::raw_ostream::write(v52, 44);
        }
        else
        {
          *((void *)v52 + 4) = v53 + 1;
          unsigned char *v53 = 44;
        }
        (*(void (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 128))(a2);
        unsigned int v54 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
        char v55 = (_WORD *)*((void *)v54 + 4);
        if (*((void *)v54 + 3) - (void)v55 > 1uLL)
        {
          *char v55 = 8224;
          *((void *)v54 + 4) += 2;
          int v56 = v84;
          unint64_t v57 = (unint64_t *)&v83 + 1;
          if (v84 < 0x41) {
            goto LABEL_55;
          }
        }
        else
        {
          llvm::raw_ostream::write(v54, "  ", 2uLL);
          int v56 = v84;
          unint64_t v57 = (unint64_t *)&v83 + 1;
          if (v84 < 0x41) {
            goto LABEL_55;
          }
        }
        if (v56 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)((char *)&v83 + 8)) <= 0x40)
        {
          unint64_t v57 = (unint64_t *)*((void *)&v83 + 1);
LABEL_55:
          unint64_t v58 = *v57;
          goto LABEL_56;
        }
        unint64_t v58 = -1;
LABEL_56:
        uint64_t v59 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
        llvm::raw_ostream::operator<<(v59, v58);
        uint64_t v60 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
        uint64_t v61 = (_WORD *)*((void *)v60 + 4);
        if (*((void *)v60 + 3) - (void)v61 > 1uLL)
        {
          _WORD *v61 = 8250;
          *((void *)v60 + 4) += 2;
        }
        else
        {
          llvm::raw_ostream::write(v60, ": ", 2uLL);
        }
        uint64_t v62 = *(void *)&v51[32 * v83 + 24];
        uint64_t v63 = mlir::OperandRangeRange::dereference(v75, v75[2] + v83);
        mlir::ValueRange::ValueRange(v100, v63, v64);
        (*(void (**)(mlir::OpAsmPrinter *, uint64_t, unint64_t, unint64_t))(*(void *)a2 + 184))(a2, v62, v100[0], v100[1]);
        if (v84 >= 0x41 && *((void *)&v83 + 1)) {
          operator delete[](*((void **)&v83 + 1));
        }
        uint64_t v50 = v80 + 1;
        uint64_t v65 = v82 + 1;
        ++v80;
        *(void *)&long long v82 = v82 + 1;
      }
      while ((void)v81 != v47 || BYTE8(v81) != v48 || v65 != v49);
    }
    (*(void (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 128))(a2);
    this = (Operation **)v73;
  }
  if (v98)
  {
    if (v97 == v96)
    {
      (*(void (**)(void *))(v96[0] + 32))(v96);
      if (!(_BYTE)v95) {
        goto LABEL_77;
      }
      goto LABEL_71;
    }
    if (v97) {
      (*(void (**)(void))(*v97 + 40))();
    }
  }
  if (!(_BYTE)v95) {
    goto LABEL_77;
  }
LABEL_71:
  if (v94 == &v92)
  {
    (*(void (**)(unint64_t *))(v92 + 32))(&v92);
  }
  else if (v94)
  {
    (*(void (**)(void))(*v94 + 40))();
  }
LABEL_77:
  uint64_t v66 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v67 = (unsigned char *)*((void *)v66 + 4);
  if (*((unsigned char **)v66 + 3) == v67)
  {
    llvm::raw_ostream::write(v66, "]", 1uLL);
  }
  else
  {
    *long long v67 = 93;
    ++*((void *)v66 + 4);
  }
  uint64_t v91 = (char *)v93;
  v93[0] = "operandSegmentSizes";
  v93[1] = 19;
  unsigned int v94 = (unint64_t *)"case_operand_segments";
  uint64_t v95 = 21;
  unint64_t v92 = 0x200000002;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v91, v93, 3uLL, 16);
  char v68 = &v91[16 * v92];
  *(void *)char v68 = "case_values";
  *((void *)v68 + 1) = 11;
  LODWORD(v92) = v92 + 1;
  uint64_t v69 = *this;
  if (*((unsigned char *)*this + 47))
  {
    *(void *)&long long v83 = mlir::Operation::getAttrDictionary(v69);
    unint64_t v70 = (mlir::ArrayAttr *)&v83;
  }
  else
  {
    unint64_t v70 = (mlir::Operation *)((char *)v69 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v70);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, char *, void))(*(void *)a2 + 192))(a2, Value, v72, v91, v92);
  if (v91 != (char *)v93) {
    free(v91);
  }
}

uint64_t mlir::Dialect::materializeConstant()
{
  return 0;
}

uint64_t collapseBranch(uint64_t *a1, void *a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  if (*(void *)(*(void *)(v4 + 40) + 8) != v4 + 32) {
    return 0;
  }
  mlir::Block::getTerminator((mlir::GenericProgramPoint **)v4);
  if (!v7
    || *(void *)(*(void *)(v7 + 48) + 16) != (void)&mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id)
  {
    return 0;
  }
  uint64_t v10 = *(void **)(*a1 + 48);
  uint64_t v11 = *(void **)(*a1 + 56);
  if (v11 != v10)
  {
    long long v12 = *(void **)(*a1 + 48);
    do
    {
      unint64_t v13 = (void *)*v12;
      while (1)
      {
        unint64_t v13 = (void *)*v13;
        if (!v13) {
          break;
        }
        if (v13[2] != v7) {
          return 0;
        }
      }
      ++v12;
    }
    while (v12 != v11);
  }
  unint64_t v14 = *(unsigned int *)(v7 + 44);
  uint64_t v15 = *(void *)(((v7 + 16 * ((v14 >> 23) & 1) + ((v14 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8) + 24);
  if (v15 == *a1) {
    return 0;
  }
  if ((v14 & 0x800000) == 0)
  {
    if (v11 != v10) {
      goto LABEL_30;
    }
    unint64_t v17 = 0;
    uint64_t v16 = 0;
LABEL_33:
    *a1 = v15;
    mlir::ValueRange::ValueRange((unint64_t *)&v23, v16, v17);
    goto LABEL_34;
  }
  uint64_t v16 = *(void *)(v7 + 72);
  unint64_t v17 = *(unsigned int *)(v7 + 68);
  if (v11 == v10) {
    goto LABEL_33;
  }
  if (v17)
  {
    uint64_t v18 = (uint64_t *)(v16 + 24);
    do
    {
      uint64_t v19 = *v18;
      if ((~*(_DWORD *)(*v18 + 8) & 7) != 0) {
        uint64_t v20 = 0;
      }
      else {
        uint64_t v20 = *v18;
      }
      if (v20 && *(void *)(v20 + 16) == *a1) {
        uint64_t v19 = mlir::ValueRange::dereference_iterator(a2, *(unsigned int *)(v20 + 24));
      }
      unint64_t v21 = *(unsigned int *)(a3 + 8);
      if (v21 >= *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v21 + 1, 8);
        unint64_t v21 = *(unsigned int *)(a3 + 8);
      }
      *(void *)(*(void *)a3 + 8 * v21) = v19;
      unsigned int v22 = *(_DWORD *)(a3 + 8) + 1;
      *(_DWORD *)(a3 + 8) = v22;
      v18 += 4;
      --v17;
    }
    while (v17);
    goto LABEL_31;
  }
LABEL_30:
  unsigned int v22 = *(_DWORD *)(a3 + 8);
LABEL_31:
  *a1 = v15;
  mlir::ValueRange::ValueRange((unint64_t *)&v23, *(void *)a3, v22);
LABEL_34:
  *(_OWORD *)a2 = v23;
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::ValueRange &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v27[11] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"cf.br";
    void v21[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v23);
    llvm::report_fatal_error((llvm::Twine *)v23, 1);
  }
  mlir::OperationState::OperationState(v23, a2, v9);
  uint64_t v11 = *a3;
  uint64_t v12 = *a4;
  uint64_t v13 = a4[1];
  unsigned int v14 = v25;
  if (v25 >= v26)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v24, v27, v25 + 1, 8);
    unsigned int v14 = v25;
  }
  *(void *)(v24 + 8 * v14) = v11;
  ++v25;
  mlir::OperationState::addOperands((uint64_t)v23, v12, v13);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v23);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v23);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v28[11] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"cf.br";
    void v21[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v24);
    llvm::report_fatal_error((llvm::Twine *)v24, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  uint64_t v11 = *a3;
  mlir::ValueRange::ValueRange(v23, *(void *)a4, *(void *)(a4 + 8));
  uint64_t v12 = v23[0];
  uint64_t v13 = v23[1];
  unsigned int v14 = v26;
  if (v26 >= v27)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v26 + 1, 8);
    unsigned int v14 = v26;
  }
  *(void *)(v25 + 8 * v14) = v11;
  ++v26;
  mlir::OperationState::addOperands((uint64_t)v24, v12, v13);
  uint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id) {
    uint64_t v16 = v15;
  }
  else {
    uint64_t v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v16;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *,mlir::OperandRange,llvm::SmallVector<llvm::APInt,3u> &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v45[38] = *MEMORY[0x1E4F143B8];
  uint64_t v38 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v38);
  uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.switch", (const unsigned __int8 *)9, Context);
  if (!v18)
  {
    __int16 v42 = 1283;
    v41[2] = (uint64_t)"cf.switch";
    v41[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v40 = 259;
    llvm::operator+(v41, (uint64_t *)&v39, (uint64_t)v45);
    llvm::report_fatal_error((llvm::Twine *)v45, 1);
  }
  uint64_t v37 = a1;
  mlir::OperationState::OperationState(v45, a2, v17);
  uint64_t v19 = *a3;
  uint64_t v20 = *a4;
  mlir::ValueRange::ValueRange(v44, *(void *)a5, *(void *)(a5 + 8));
  unint64_t v21 = *(llvm::APInt **)a6;
  uint64_t v22 = *(unsigned int *)(a6 + 8);
  mlir::BlockRange::BlockRange(v43, *(void *)a7, *(unsigned int *)(a7 + 8));
  uint64_t v23 = *(void *)a8;
  uint64_t v24 = *(unsigned int *)(a8 + 8);
  uint64_t v25 = v44[0];
  uint64_t v26 = v44[1];
  uint64_t v28 = v43[0];
  uint64_t v27 = v43[1];
  if (v22)
  {
    uint64_t v36 = v20;
    v41[0] = v22;
    uint64_t v29 = (void *)mlir::VectorType::get((uint64_t)v41, 1uLL, *(void *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8, 0, 0);
    uint64_t v30 = (uint64_t)v29;
    if (v29) {
      uint64_t v31 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v29 + 8);
    }
    else {
      uint64_t v31 = 0;
    }
    uint64_t v32 = mlir::DenseElementsAttr::get(v30, v31, v21, v22);
    uint64_t v20 = v36;
  }
  else
  {
    uint64_t v32 = 0;
  }
  mlir::cf::SwitchOp::build(v37, (uint64_t)v45, v19, v25, v26, v23, v24, v32, v20, v28, v27);
  int v33 = mlir::OpBuilder::create((mlir::OpBuilder *)v37, (const mlir::OperationState *)v45);
  if (*(_UNKNOWN **)(*((void *)v33 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id) {
    uint64_t v34 = v33;
  }
  else {
    uint64_t v34 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v45);
  return v34;
}

void foldSwitch(uint64_t a1, uint64_t a2, const void **a3)
{
  uint64_t v5 = a1 + 64;
  if (HIBYTE(*(_DWORD *)(a1 + 44))) {
    unint64_t v6 = a1 + 64 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1);
  }
  else {
    unint64_t v6 = 0;
  }
  v43[0] = *(void *)(v6 + 8);
  v43[1] = v43[0] != 0;
  mlir::DenseElementsAttr::getValues<llvm::APInt>((mlir::DenseElementsAttr *)v43, (uint64_t)&v38);
  long long v36 = v38;
  long long v37 = v39;
  uint64_t v7 = v40;
  int v8 = v41;
  uint64_t v9 = v42;
  uint64_t v35 = 0;
  if ((void)v38 != v40 || BYTE8(v36) != v41 || (void)v37 != v42)
  {
    uint64_t v10 = 0;
    do
    {
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v36, (llvm::APInt *)&v38);
      unsigned int v34 = DWORD2(v38);
      uint64_t v11 = (void *)v38;
      uint64_t v32 = v10;
      __p = (void *)v38;
      if (DWORD2(v38) > 0x40)
      {
        if (llvm::APInt::equalSlowCase((const void **)&__p, a3))
        {
LABEL_24:
          mlir::SuccessorRange::SuccessorRange((unint64_t *)&v38, (Operation *)a1);
          uint64_t v19 = v38;
          mlir::SuccessorRange::SuccessorRange((unint64_t *)&v38, (Operation *)a1);
          uint64_t v31 = *(void *)(v19 + 32 * v32 + 56);
          unint64_t v20 = *(unsigned int *)(a1 + 44);
          unint64_t v21 = (uint64_t *)(v5 + 16 * ((v20 >> 23) & 1));
          if (HIBYTE(*(_DWORD *)(a1 + 44))) {
            uint64_t v22 = (_DWORD *)(v5 + 16 * ((v20 >> 23) & 1));
          }
          else {
            uint64_t v22 = 0;
          }
          int v23 = v22[4];
          int v24 = v22[5];
          int v25 = v22[6];
          if ((v20 & 0x800000) != 0) {
            uint64_t v26 = *(void *)(a1 + 72);
          }
          else {
            uint64_t v26 = 0;
          }
          uint64_t v27 = (v24 + v23);
          v44[0] = v26 + 32 * v27;
          v44[1] = (v25 + v27) - v27;
          mlir::OperandRange::split(v44, *v21, &v38);
          *(void *)&long long v38 = mlir::OperandRangeRange::dereference(&v38, v39 + v32);
          *((void *)&v38 + 1) = v28;
          uint64_t v29 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(void *)(a1 + 24), &v31, (uint64_t)&v38);
          (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v29);
          if (v34 >= 0x41)
          {
            if (__p) {
              operator delete[](__p);
            }
          }
          return;
        }
        if (v11) {
          operator delete[](v11);
        }
      }
      else if ((const void *)v38 == *a3)
      {
        goto LABEL_24;
      }
      uint64_t v10 = v35 + 1;
      uint64_t v12 = v37 + 1;
      ++v35;
      *(void *)&long long v37 = v37 + 1;
    }
    while ((void)v36 != v7 || BYTE8(v36) != v8 || v12 != v9);
  }
  unint64_t v13 = *(unsigned int *)(a1 + 44);
  uint64_t v35 = *(void *)(((v5 + 16 * ((v13 >> 23) & 1) + ((v13 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 24);
  if (BYTE3(v13)) {
    uint64_t v14 = v5 + 16 * ((v13 >> 23) & 1);
  }
  else {
    uint64_t v14 = 0;
  }
  uint64_t v15 = *(unsigned int *)(v14 + 16);
  int v16 = *(_DWORD *)(v14 + 20);
  if ((v13 & 0x800000) != 0) {
    uint64_t v17 = *(void *)(a1 + 72);
  }
  else {
    uint64_t v17 = 0;
  }
  *(void *)&long long v38 = v17 + 32 * v15;
  *((void *)&v38 + 1) = (v16 + v15) - v15;
  char v18 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(void *)(a1 + 24), &v35, (uint64_t)&v38);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v18);
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v14 = 0;
  unint64_t v3 = (_DWORD *)(a1 + 16);
  uint64_t v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 64, &v14);
  uint64_t v5 = v4;
  unint64_t v6 = *(_DWORD **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = v7 << 6;
    uint64_t v9 = v4;
    do
    {
      *uint64_t v9 = v9 + 2;
      v9[1] = 0x600000000;
      if (v6[2]) {
        llvm::SmallVectorImpl<mlir::Value>::operator=((uint64_t)v9, (uint64_t)v6);
      }
      v9 += 8;
      v6 += 16;
      v8 -= 64;
    }
    while (v8);
    unint64_t v6 = *(_DWORD **)a1;
    uint64_t v10 = *(unsigned int *)(a1 + 8);
    if (v10)
    {
      uint64_t v11 = v10 << 6;
      do
      {
        uint64_t v12 = *(char **)((char *)v6 + v11 - 64);
        if ((char *)v6 + v11 - 48 != v12) {
          free(v12);
        }
        v11 -= 64;
      }
      while (v11);
      unint64_t v6 = *(_DWORD **)a1;
    }
  }
  int v13 = v14;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Value,6u>,false>::growAndEmplaceBack<>(uint64_t a1)
{
  unint64_t v16 = 0;
  unint64_t v2 = (_DWORD *)(a1 + 16);
  unint64_t v3 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 64, &v16);
  uint64_t v4 = v3;
  uint64_t v5 = &v3[8 * (unint64_t)*(unsigned int *)(a1 + 8)];
  void *v5 = v5 + 2;
  v5[1] = 0x600000000;
  unint64_t v6 = *(_DWORD **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = v7 << 6;
    uint64_t v9 = v3;
    do
    {
      *uint64_t v9 = v9 + 2;
      v9[1] = 0x600000000;
      if (v6[2]) {
        llvm::SmallVectorImpl<mlir::Value>::operator=((uint64_t)v9, (uint64_t)v6);
      }
      v9 += 8;
      v6 += 16;
      v8 -= 64;
    }
    while (v8);
    unint64_t v6 = *(_DWORD **)a1;
    uint64_t v10 = *(unsigned int *)(a1 + 8);
    if (v10)
    {
      uint64_t v11 = v10 << 6;
      do
      {
        uint64_t v12 = *(char **)((char *)v6 + v11 - 64);
        if ((char *)v6 + v11 - 48 != v12) {
          free(v12);
        }
        v11 -= 64;
      }
      while (v11);
      unint64_t v6 = *(_DWORD **)a1;
    }
  }
  int v13 = v16;
  if (v6 != v2) {
    free(v6);
  }
  *(void *)a1 = v4;
  uint64_t v14 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v14;
  *(_DWORD *)(a1 + 12) = v13;
  return (uint64_t)&v4[8 * v14 - 8];
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::SwitchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::DenseIntElementsAttr &,llvm::SmallVector<mlir::Block *,6u> &,llvm::SmallVector<mlir::ValueRange,3u> &>(mlir::MLIRContext **a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  v33[38] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v27);
  uint64_t v17 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.switch", (const unsigned __int8 *)9, Context);
  if (!v18)
  {
    __int16 v31 = 1283;
    v30[2] = (uint64_t)"cf.switch";
    v30[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v29 = 259;
    llvm::operator+(v30, (uint64_t *)&v28, (uint64_t)v33);
    llvm::report_fatal_error((llvm::Twine *)v33, 1);
  }
  mlir::OperationState::OperationState(v33, a2, v17);
  uint64_t v19 = *a3;
  uint64_t v20 = *a4;
  uint64_t v22 = *a5;
  uint64_t v21 = a5[1];
  uint64_t v23 = *a6;
  mlir::BlockRange::BlockRange(v32, *(void *)a7, *(unsigned int *)(a7 + 8));
  mlir::cf::SwitchOp::build(a1, (uint64_t)v33, v19, v22, v21, *(void *)a8, *(unsigned int *)(a8 + 8), v23, v20, v32[0], v32[1]);
  int v24 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v33);
  if (*(_UNKNOWN **)(*((void *)v24 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id) {
    int v25 = v24;
  }
  else {
    int v25 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v33);
  return v25;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>(uint64_t *a1, llvm *a2, uint64_t *a3)
{
  int v4 = *((_DWORD *)a1 + 4);
  if (!v4)
  {
    uint64_t v14 = 0;
    *a3 = 0;
    return v14;
  }
  uint64_t v6 = *a1;
  unsigned int v19 = 0;
  char v18 = (void *)-1;
  unsigned int v17 = 0;
  __p = (void *)-2;
  uint64_t v7 = 0;
  unsigned int v8 = v4 - 1;
  int v9 = 1;
  unsigned int v10 = llvm::DenseMapInfo<llvm::APInt,void>::getHashValue(a2, a2) & (v4 - 1);
  uint64_t v11 = v6 + 16 * v10;
  unsigned int v12 = *((_DWORD *)a2 + 2);
  if (v12 != *(_DWORD *)(v11 + 8)) {
    goto LABEL_7;
  }
LABEL_3:
  if (v12 > 0x40)
  {
    if (!llvm::APInt::equalSlowCase((const void **)a2, (const void **)v11)) {
      goto LABEL_7;
    }
  }
  else if (*(void *)a2 != *(void *)v11)
  {
LABEL_7:
    while (!llvm::DenseMapInfo<llvm::APInt,void>::isEqual(v11, (uint64_t)&v18))
    {
      if (llvm::DenseMapInfo<llvm::APInt,void>::isEqual(v11, (uint64_t)&__p) && v7 == 0) {
        uint64_t v7 = v11;
      }
      unsigned int v13 = v10 + v9++;
      unsigned int v10 = v13 & v8;
      uint64_t v11 = v6 + 16 * (v13 & v8);
      unsigned int v12 = *((_DWORD *)a2 + 2);
      if (v12 == *(_DWORD *)(v11 + 8)) {
        goto LABEL_3;
      }
    }
    uint64_t v14 = 0;
    if (v7) {
      uint64_t v11 = v7;
    }
    *a3 = v11;
    if (v17 < 0x41) {
      goto LABEL_15;
    }
    goto LABEL_13;
  }
  uint64_t v14 = 1;
  *a3 = v11;
  if (v17 >= 0x41)
  {
LABEL_13:
    if (__p) {
      operator delete[](__p);
    }
  }
LABEL_15:
  if (v19 >= 0x41 && v18) {
    operator delete[](v18);
  }
  return v14;
}

BOOL llvm::DenseMapInfo<llvm::APInt,void>::isEqual(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(a1 + 8);
  if (v2 != *(_DWORD *)(a2 + 8)) {
    return 0;
  }
  if (v2 > 0x40) {
    return llvm::APInt::equalSlowCase((const void **)a1, (const void **)a2);
  }
  return *(void *)a1 == *(void *)a2;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::InsertIntoBucketImpl<llvm::APInt>(uint64_t a1, uint64_t a2, llvm *a3, uint64_t a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
LABEL_8:
    llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::grow(a1, v7);
    uint64_t v9 = 0;
    llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>((uint64_t *)a1, a3, &v9);
    a4 = v9;
    ++*(_DWORD *)(a1 + 8);
    if (*(_DWORD *)(a4 + 8)) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3) {
    goto LABEL_8;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*(_DWORD *)(a4 + 8))
  {
LABEL_5:
    --*(_DWORD *)(a1 + 12);
    return a4;
  }
LABEL_4:
  if (*(void *)a4 != -1) {
    goto LABEL_5;
  }
  return a4;
}

char *llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  int v4 = *(llvm::APInt **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    unsigned int v10 = (char *)(16 * v3);
    llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::moveFromOldBuckets(a1, v4, (llvm::APInt *)&v10[(void)v4]);
    llvm::deallocate_buffer(v4, v10);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v11 = *(unsigned int *)(a1 + 16);
  if (v11)
  {
    uint64_t v12 = 16 * v11;
    unsigned int v13 = result + 8;
    do
    {
      _DWORD *v13 = 0;
      *((void *)v13 - 1) = -1;
      v13 += 4;
      v12 -= 16;
    }
    while (v12);
  }
  return result;
}

void llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::moveFromOldBuckets(uint64_t a1, llvm::APInt *this, llvm::APInt *a3)
{
  *(void *)(a1 + 8) = 0;
  unsigned int v15 = 0;
  __p = (void *)-1;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6)
  {
    int v7 = *(llvm::APInt **)a1;
    uint64_t v8 = 16 * v6;
    do
    {
      while (1)
      {
        unsigned int v9 = v15;
        *((_DWORD *)v7 + 2) = v15;
        if (v9 <= 0x40) {
          break;
        }
        llvm::APInt::initSlowCase(v7, (const void **)&__p);
        int v7 = (llvm::APInt *)((char *)v7 + 16);
        v8 -= 16;
        if (!v8) {
          goto LABEL_6;
        }
      }
      *(void *)int v7 = __p;
      int v7 = (llvm::APInt *)((char *)v7 + 16);
      v8 -= 16;
    }
    while (v8);
LABEL_6:
    if (v15 >= 0x41 && __p) {
      operator delete[](__p);
    }
  }
  unsigned int v15 = 0;
  __p = (void *)-1;
  unsigned int v13 = 0;
  uint64_t v12 = (void *)-2;
  if (this == a3) {
    goto LABEL_31;
  }
  do
  {
    unsigned int v10 = *((_DWORD *)this + 2);
    if (v10 == v15)
    {
      if (v10 > 0x40)
      {
        if (llvm::APInt::equalSlowCase((const void **)this, (const void **)&__p)) {
          goto LABEL_23;
        }
      }
      else if (*(void **)this == __p)
      {
        goto LABEL_12;
      }
    }
    if (v10 != v13) {
      goto LABEL_25;
    }
    if (v10 <= 0x40)
    {
      if (*(void **)this == v12) {
        goto LABEL_12;
      }
LABEL_25:
      uint64_t v16 = 0;
      llvm::DenseMapBase<llvm::DenseMap<llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>,llvm::APInt,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<llvm::APInt,void>,llvm::detail::DenseSetPair<llvm::APInt>>::LookupBucketFor<llvm::APInt>((uint64_t *)a1, this, &v16);
      uint64_t v11 = v16;
      if (*(_DWORD *)(v16 + 8) >= 0x41u && *(void *)v16) {
        operator delete[](*(void **)v16);
      }
      *(void *)uint64_t v11 = *(void *)this;
      *(_DWORD *)(v11 + 8) = *((_DWORD *)this + 2);
      *((_DWORD *)this + 2) = 0;
      ++*(_DWORD *)(a1 + 8);
      goto LABEL_12;
    }
    if (!llvm::APInt::equalSlowCase((const void **)this, (const void **)&v12)) {
      goto LABEL_25;
    }
LABEL_23:
    if (*(void *)this) {
      operator delete[](*(void **)this);
    }
LABEL_12:
    this = (llvm::APInt *)((char *)this + 16);
  }
  while (this != a3);
  if (v13 >= 0x41 && v12) {
    operator delete[](v12);
  }
LABEL_31:
  if (v15 >= 0x41)
  {
    if (__p) {
      operator delete[](__p);
    }
  }
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  unsigned int v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

uint64_t mlir::AsmParser::parseInteger<long long>(uint64_t a1, uint64_t *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v5 = mlir::AsmParser::parseOptionalInteger<long long>(a1, a2);
  if ((unsigned __int16)v5 <= 0xFFu)
  {
    unsigned int v15 = "expected integer value";
    __int16 v16 = 259;
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t, const char **))(*(void *)a1 + 24))(v17, a1, v4, &v15);
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v17);
    if (v17[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v17);
    }
    if (v24)
    {
      uint64_t v6 = (void **)__p;
      if (__p)
      {
        int v7 = v23;
        uint64_t v8 = __p;
        if (v23 != __p)
        {
          do
            int v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          uint64_t v8 = __p;
        }
        uint64_t v23 = v6;
        operator delete(v8);
      }
      unsigned int v9 = v20;
      if (v20)
      {
        unsigned int v10 = v21;
        uint64_t v11 = v20;
        if (v21 != v20)
        {
          do
          {
            unsigned int v13 = (void *)*--v10;
            uint64_t v12 = v13;
            void *v10 = 0;
            if (v13) {
              operator delete[](v12);
            }
          }
          while (v10 != v9);
          uint64_t v11 = v20;
        }
        uint64_t v21 = v9;
        operator delete(v11);
      }
      if (v18 != &v19) {
        free(v18);
      }
    }
  }
  return v5;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,1u>,false>::growAndEmplaceBack<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,1u>&>(uint64_t a1, uint64_t a2)
{
  unint64_t v22 = 0;
  uint64_t v4 = (_DWORD *)(a1 + 16);
  uint64_t v5 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 48, &v22);
  uint64_t v6 = &v5[6 * *(unsigned int *)(a1 + 8)];
  int v7 = v6 + 2;
  void *v6 = v6 + 2;
  v6[1] = 0x100000000;
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  if (v6 != (void *)a2 && v8 != 0)
  {
    if (v8 < 2)
    {
      size_t v11 = 32;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, v6 + 2, *(unsigned int *)(a2 + 8), 32);
      uint64_t v10 = *(unsigned int *)(a2 + 8);
      if (!v10)
      {
LABEL_10:
        *((_DWORD *)v6 + 2) = v8;
        goto LABEL_11;
      }
      int v7 = (void *)*v6;
      size_t v11 = 32 * v10;
    }
    memcpy(v7, *(const void **)a2, v11);
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v12 = *(_DWORD **)a1;
  uint64_t v13 = *(unsigned int *)(a1 + 8);
  if (v13)
  {
    uint64_t v14 = 48 * v13;
    unsigned int v15 = v5;
    do
    {
      void *v15 = v15 + 2;
      v15[1] = 0x100000000;
      if (v12[2]) {
        llvm::SmallVectorImpl<mlir::OpAsmParser::UnresolvedOperand>::operator=((uint64_t)v15, (uint64_t)v12);
      }
      v15 += 6;
      v12 += 12;
      v14 -= 48;
    }
    while (v14);
    uint64_t v12 = *(_DWORD **)a1;
    uint64_t v16 = *(unsigned int *)(a1 + 8);
    if (v16)
    {
      uint64_t v17 = 12 * v16;
      do
      {
        char v18 = *(_DWORD **)&v12[v17 - 12];
        if (&v12[v17 - 8] != v18) {
          free(v18);
        }
        v17 -= 12;
      }
      while (v17 * 4);
      uint64_t v12 = *(_DWORD **)a1;
    }
  }
  int v19 = v22;
  if (v12 != v4) {
    free(v12);
  }
  *(void *)a1 = v5;
  unsigned int v20 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v20;
  *(_DWORD *)(a1 + 12) = v19;
  return (uint64_t)&v5[6 * v20 - 6];
}

uint64_t llvm::SmallVectorImpl<mlir::OpAsmParser::UnresolvedOperand>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 != v5)
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      int v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_16;
    }
    int v7 = (_DWORD *)(a2 + 8);
    unint64_t v8 = *(unsigned int *)(a2 + 8);
    uint64_t v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if (v8) {
        memmove(*(void **)a1, v4, 32 * v8 - 4);
      }
      goto LABEL_15;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if (v9)
      {
        memmove(*(void **)a1, v4, 32 * v9 - 4);
        uint64_t v10 = *v7;
        if (v9 == v10)
        {
LABEL_15:
          *(_DWORD *)(a1 + 8) = v8;
LABEL_16:
          *int v7 = 0;
          return a1;
        }
      }
      else
      {
        uint64_t v9 = 0;
        uint64_t v10 = *v7;
        if (!*v7) {
          goto LABEL_15;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 32);
      uint64_t v9 = 0;
      uint64_t v10 = *v7;
      if (!*v7) {
        goto LABEL_15;
      }
    }
    memcpy((void *)(*(void *)a1 + 32 * v9), (const void *)(*(void *)a2 + 32 * v9), *(void *)a2 + 32 * v10 - (*(void *)a2 + 32 * v9));
    goto LABEL_15;
  }
  return a1;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<mlir::Type,6u>,false>::growAndEmplaceBack<llvm::SmallVector<mlir::Type,6u>&>(uint64_t a1, uint64_t a2)
{
  unint64_t v21 = 0;
  uint64_t v4 = (_DWORD *)(a1 + 16);
  uint64_t v5 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 64, &v21);
  uint64_t v6 = &v5[8 * (unint64_t)*(unsigned int *)(a1 + 8)];
  int v7 = v6 + 2;
  void *v6 = v6 + 2;
  v6[1] = 0x600000000;
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  if (v6 != (void *)a2 && v8 != 0)
  {
    if (v8 < 7)
    {
      unsigned int v10 = *(_DWORD *)(a2 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, v6 + 2, *(unsigned int *)(a2 + 8), 8);
      unsigned int v10 = *(_DWORD *)(a2 + 8);
      if (!v10)
      {
LABEL_10:
        *((_DWORD *)v6 + 2) = v8;
        goto LABEL_11;
      }
      int v7 = (void *)*v6;
    }
    memcpy(v7, *(const void **)a2, 8 * v10);
    goto LABEL_10;
  }
LABEL_11:
  size_t v11 = *(_DWORD **)a1;
  uint64_t v12 = *(unsigned int *)(a1 + 8);
  if (v12)
  {
    uint64_t v13 = v12 << 6;
    uint64_t v14 = v5;
    do
    {
      void *v14 = v14 + 2;
      v14[1] = 0x600000000;
      if (v11[2]) {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v14, (uint64_t)v11);
      }
      v14 += 8;
      v11 += 16;
      v13 -= 64;
    }
    while (v13);
    size_t v11 = *(_DWORD **)a1;
    uint64_t v15 = *(unsigned int *)(a1 + 8);
    if (v15)
    {
      uint64_t v16 = v15 << 6;
      do
      {
        uint64_t v17 = *(char **)((char *)v11 + v16 - 64);
        if ((char *)v11 + v16 - 48 != v17) {
          free(v17);
        }
        v16 -= 64;
      }
      while (v16);
      size_t v11 = *(_DWORD **)a1;
    }
  }
  int v18 = v21;
  if (v11 != v4) {
    free(v11);
  }
  *(void *)a1 = v5;
  uint64_t v19 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v19;
  *(_DWORD *)(a1 + 12) = v18;
  return (uint64_t)&v5[8 * v19 - 8];
}

uint64_t mlir::RegisteredOperationName::insert<mlir::cf::AssertOp>(uint64_t a1)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unsigned int v2 = operator new(0x70uLL);
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"cf.assert", 9, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::AssertOp,void>::id, (uint64_t)&v9);
  uint64_t v3 = v9;
  if (v10)
  {
    uint64_t v4 = 16 * v10;
    uint64_t v5 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v3 = v9;
  }
  if (v3 != v11) {
    free(v3);
  }
  *unsigned int v2 = &unk_1EC9ACEB0;
  unsigned int v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, (uint64_t)&mlir::cf::AssertOp::getAttributeNames(void)::attrNames, 1);
  uint64_t result = (uint64_t)v8;
  unsigned int v8 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  unsigned int v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    unsigned int v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  unsigned int v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    unsigned int v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::cf::AssertOp::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::cf::AssertOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                           + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 3 && (*(_WORD *)a3 == 29549 ? (BOOL v7 = *(unsigned char *)(a3 + 2) == 103) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 3 && *(_WORD *)result == 29549 && *(unsigned char *)(result + 2) == 103)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      void *v5 = v9;
    }
    else
    {
      void *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"msg", 3, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v7, (const void **)"msg", (const char *)3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::cf::AssertOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::cf::AssertOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::cf::AssertOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::readProperties(uint64_t a1, void *a2)
{
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::AssertOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>(uint64_t a1)
{
  unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v87 = a1;
    unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v19 = v18;
    a1 = v87;
    if (v19)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v94 = 83;
      unint64_t v20 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v20) {
        unint64_t v21 = v20;
      }
      else {
        unint64_t v21 = v94;
      }
      unint64_t v22 = &v93[v21];
      unint64_t v23 = v94 - v21;
      if (v94 - v21 >= 0x12) {
        uint64_t v24 = 18;
      }
      else {
        uint64_t v24 = v94 - v21;
      }
      unint64_t v25 = v23 - v24;
      if (v25 >= v25 - 1) {
        uint64_t v26 = v25 - 1;
      }
      else {
        uint64_t v26 = v25;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v22[v24], v26);
      unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v87;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v82 = v2;
    uint64_t v88 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v28 = v27;
    uint64_t v2 = v82;
    a1 = v88;
    if (v28)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      unint64_t v94 = 83;
      unint64_t v29 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v29) {
        unint64_t v30 = v29;
      }
      else {
        unint64_t v30 = v94;
      }
      __int16 v31 = &v93[v30];
      unint64_t v32 = v94 - v30;
      if (v94 - v30 >= 0x12) {
        uint64_t v33 = 18;
      }
      else {
        uint64_t v33 = v94 - v30;
      }
      unint64_t v34 = v32 - v33;
      if (v34 >= v34 - 1) {
        uint64_t v35 = v34 - 1;
      }
      else {
        uint64_t v35 = v34;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v31[v33], v35);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v82;
      a1 = v88;
    }
  }
  uint64_t v4 = v3[5];
  unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v83 = v2;
    uint64_t v89 = a1;
    uint64_t v78 = v4;
    unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v4 = v78;
    uint64_t v2 = v83;
    int v37 = v36;
    a1 = v89;
    if (v37)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v94 = 86;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v94;
      }
      uint64_t v40 = &v93[v39];
      unint64_t v41 = v94 - v39;
      if (v94 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v94 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v4 = v78;
      uint64_t v2 = v83;
      a1 = v89;
    }
  }
  uint64_t v6 = v5[12];
  unint64_t v7 = 0x1E8EB8000uLL;
  {
    uint64_t v84 = v2;
    uint64_t v90 = a1;
    uint64_t v75 = v6;
    uint64_t v79 = v4;
    unint64_t v7 = 0x1E8EB8000;
    uint64_t v6 = v75;
    uint64_t v4 = v79;
    int v46 = v45;
    uint64_t v2 = v84;
    a1 = v90;
    if (v46)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      unint64_t v94 = 82;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v94;
      }
      uint64_t v49 = &v93[v48];
      unint64_t v50 = v94 - v48;
      if (v94 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v94 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v7 = 0x1E8EB8000;
      uint64_t v6 = v75;
      uint64_t v4 = v79;
      uint64_t v2 = v84;
      a1 = v90;
    }
  }
  uint64_t v8 = *(void *)(v7 + 4080);
  uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v85 = v2;
    uint64_t v91 = a1;
    uint64_t v76 = v6;
    uint64_t v80 = v4;
    uint64_t v73 = v8;
    uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v73;
    uint64_t v6 = v76;
    uint64_t v4 = v80;
    uint64_t v2 = v85;
    int v55 = v54;
    a1 = v91;
    if (v55)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v94 = 84;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v94;
      }
      unint64_t v58 = &v93[v57];
      unint64_t v59 = v94 - v57;
      if (v94 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v94 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v73;
      uint64_t v6 = v76;
      uint64_t v4 = v80;
      uint64_t v2 = v85;
      a1 = v91;
    }
  }
  uint64_t v10 = v9[9];
  unint64_t v11 = 0x1E8EB8000uLL;
  {
    uint64_t v86 = v2;
    uint64_t v92 = a1;
    uint64_t v77 = v6;
    uint64_t v81 = v4;
    uint64_t v72 = v10;
    uint64_t v74 = v8;
    unint64_t v11 = 0x1E8EB8000;
    uint64_t v10 = v72;
    uint64_t v8 = v74;
    uint64_t v6 = v77;
    uint64_t v4 = v81;
    int v64 = v63;
    uint64_t v2 = v86;
    a1 = v92;
    if (v64)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v94 = 89;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v94;
      }
      long long v67 = &v93[v66];
      unint64_t v68 = v94 - v66;
      if (v94 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v94 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      unint64_t v11 = 0x1E8EB8000;
      uint64_t v10 = v72;
      uint64_t v8 = v74;
      uint64_t v6 = v77;
      uint64_t v4 = v81;
      uint64_t v2 = v86;
      a1 = v92;
    }
  }
  return v2 == a1 || v4 == a1 || v6 == a1 || v8 == a1 || v10 == a1 || *(void *)(v11 + 2744) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  unint64_t v7 = a2;
  mlir::cf::AssertOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyOneOperand(a1, v5))
  {
    return 0;
  }
  unint64_t v7 = a1;
  return mlir::cf::AssertOp::verifyInvariantsImpl((uint64_t **)&v7);
}

uint64_t mlir::Op<mlir::cf::AssertOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::BranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"cf.br", 5, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      unint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9ACF78;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::foldHook()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::cf::BranchOp::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::cf::BranchOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x1E4F143B8];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    unint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      unint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = (void *)*--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::BranchOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  *uint64_t v2 = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorOperands;
  v2[1] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorBlockArgument;
  v2[2] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorForOperands;
  v2[3] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::areTypesCompatible;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
      unint64_t v14 = 73;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3768), v2);
}

void mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorOperands(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0) {
    int v3 = *(_DWORD *)(a1 + 68);
  }
  else {
    int v3 = 0;
  }
  mlir::MutableOperandRange::MutableOperandRange((uint64_t)v4, a1, 0, v3, 0, 0);
  mlir::SuccessorOperands::SuccessorOperands(a2, v4);
  if (v5 != v6) {
    free(v5);
  }
}

unint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorBlockArgument(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void v21[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(unsigned int *)(a2 + 40);
  if (v3)
  {
    uint64_t v6 = 0;
    uint64_t v7 = a2 + 64;
    uint64_t v8 = 32 * v3;
    while (1)
    {
      if ((*(unsigned char *)(a2 + 46) & 0x80) != 0) {
        int v9 = *(_DWORD *)(a2 + 68);
      }
      else {
        int v9 = 0;
      }
      mlir::MutableOperandRange::MutableOperandRange((uint64_t)v19, a2, 0, v9, 0, 0);
      mlir::SuccessorOperands::SuccessorOperands((uint64_t)v16, v19);
      if (v20 != v21) {
        free(v20);
      }
      uint64_t BranchSuccessorArgument = mlir::detail::getBranchSuccessorArgument(v16, a3, *(void *)(((v7+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ v6+ 24));
      char v12 = v11;
      if (v17 != &v18) {
        free(v17);
      }
      if (v12) {
        break;
      }
      v6 += 32;
      if (v8 == v6)
      {
        unsigned __int8 v14 = 0;
        goto LABEL_15;
      }
    }
    unsigned __int8 v14 = BranchSuccessorArgument;
LABEL_15:
    unint64_t v13 = BranchSuccessorArgument & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    unsigned __int8 v14 = 0;
    unint64_t v13 = 0;
  }
  return v13 | v14;
}

uint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getSuccessorForOperands(uint64_t a1, uint64_t a2)
{
  return *(void *)(((a2
                     + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                     + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                     + 71) & 0xFFFFFFFFFFFFFFF8)
                   + 24);
}

BOOL mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::BranchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::BranchOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    char v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::BranchOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::BranchOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    char v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(uint64_t a1)
{
  uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v165 = a1;
    uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v31 = v30;
    a1 = v165;
    if (v31)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v176 = 83;
      unint64_t v32 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v32) {
        unint64_t v33 = v32;
      }
      else {
        unint64_t v33 = v176;
      }
      uint64_t v34 = &v175[v33];
      unint64_t v35 = v176 - v33;
      if (v176 - v33 >= 0x12) {
        uint64_t v36 = 18;
      }
      else {
        uint64_t v36 = v176 - v33;
      }
      unint64_t v37 = v35 - v36;
      if (v37 >= v37 - 1) {
        uint64_t v38 = v37 - 1;
      }
      else {
        uint64_t v38 = v37;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v34[v36], v38);
      uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v165;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v156 = v2;
    uint64_t v166 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v40 = v39;
    uint64_t v2 = v156;
    a1 = v166;
    if (v40)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      unint64_t v176 = 83;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v176;
      }
      unint64_t v43 = &v175[v42];
      unint64_t v44 = v176 - v42;
      if (v176 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v176 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v156;
      a1 = v166;
    }
  }
  uint64_t v4 = v3[5];
  unint64_t v5 = &unk_1E8EBA000;
  {
    uint64_t v157 = v2;
    uint64_t v167 = a1;
    uint64_t v148 = v4;
    unint64_t v5 = (void *)&unk_1E8EBA000;
    uint64_t v4 = v148;
    int v49 = v48;
    uint64_t v2 = v157;
    a1 = v167;
    if (v49)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneSuccessor<Empty>]";
      unint64_t v176 = 84;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v176;
      }
      unint64_t v52 = &v175[v51];
      unint64_t v53 = v176 - v51;
      if (v176 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v176 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneSuccessor<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneSuccessor>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      unint64_t v5 = (void *)&unk_1E8EBA000;
      uint64_t v4 = v148;
      uint64_t v2 = v157;
      a1 = v167;
    }
  }
  uint64_t v6 = v5[55];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v158 = v2;
    uint64_t v168 = a1;
    uint64_t v141 = v6;
    uint64_t v149 = v4;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v141;
    uint64_t v4 = v149;
    int v58 = v57;
    uint64_t v2 = v158;
    a1 = v168;
    if (v58)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      unint64_t v176 = 88;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v176;
      }
      unint64_t v61 = &v175[v60];
      unint64_t v62 = v176 - v60;
      if (v176 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v176 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v141;
      uint64_t v4 = v149;
      uint64_t v2 = v158;
      a1 = v168;
    }
  }
  uint64_t v8 = v7[14];
  uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v159 = v2;
    uint64_t v169 = a1;
    uint64_t v142 = v6;
    uint64_t v150 = v4;
    uint64_t v135 = v8;
    uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v135;
    uint64_t v6 = v142;
    uint64_t v4 = v150;
    int v67 = v66;
    uint64_t v2 = v159;
    a1 = v169;
    if (v67)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v176 = 84;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v176;
      }
      unint64_t v70 = &v175[v69];
      unint64_t v71 = v176 - v69;
      if (v176 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v176 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v135;
      uint64_t v6 = v142;
      uint64_t v4 = v150;
      uint64_t v2 = v159;
      a1 = v169;
    }
  }
  uint64_t v10 = v9[9];
  uint64_t v11 = &unk_1E8EBA000;
  {
    uint64_t v160 = v2;
    uint64_t v170 = a1;
    uint64_t v143 = v6;
    uint64_t v151 = v4;
    uint64_t v130 = v10;
    uint64_t v136 = v8;
    uint64_t v11 = (void *)&unk_1E8EBA000;
    uint64_t v10 = v130;
    uint64_t v8 = v136;
    uint64_t v6 = v143;
    uint64_t v4 = v151;
    int v76 = v75;
    uint64_t v2 = v160;
    a1 = v170;
    if (v76)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface::Trait<Empty>]";
      unint64_t v176 = 87;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v176;
      }
      uint64_t v79 = &v175[v78];
      unint64_t v80 = v176 - v78;
      if (v176 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v176 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      uint64_t v11 = (void *)&unk_1E8EBA000;
      uint64_t v10 = v130;
      uint64_t v8 = v136;
      uint64_t v6 = v143;
      uint64_t v4 = v151;
      uint64_t v2 = v160;
      a1 = v170;
    }
  }
  uint64_t v12 = v11[57];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v161 = v2;
    uint64_t v171 = a1;
    uint64_t v144 = v6;
    uint64_t v152 = v4;
    uint64_t v131 = v10;
    uint64_t v137 = v8;
    uint64_t v126 = v12;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v126;
    uint64_t v10 = v131;
    uint64_t v8 = v137;
    uint64_t v6 = v144;
    uint64_t v4 = v152;
    int v85 = v84;
    uint64_t v2 = v161;
    a1 = v171;
    if (v85)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v176 = 95;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v176;
      }
      uint64_t v88 = &v175[v87];
      unint64_t v89 = v176 - v87;
      if (v176 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v176 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v126;
      uint64_t v10 = v131;
      uint64_t v8 = v137;
      uint64_t v6 = v144;
      uint64_t v4 = v152;
      uint64_t v2 = v161;
      a1 = v171;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2776);
  unint64_t v15 = 0x1E8EB8000uLL;
  {
    uint64_t v162 = v2;
    uint64_t v172 = a1;
    uint64_t v145 = v6;
    uint64_t v153 = v4;
    uint64_t v132 = v10;
    uint64_t v138 = v8;
    uint64_t v123 = v14;
    uint64_t v127 = v12;
    unint64_t v15 = 0x1E8EB8000;
    uint64_t v14 = v123;
    uint64_t v12 = v127;
    uint64_t v10 = v132;
    uint64_t v8 = v138;
    uint64_t v6 = v145;
    uint64_t v4 = v153;
    int v94 = v93;
    uint64_t v2 = v162;
    a1 = v172;
    if (v94)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v176 = 99;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v176;
      }
      int v97 = &v175[v96];
      unint64_t v98 = v176 - v96;
      if (v176 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v176 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      unint64_t v15 = 0x1E8EB8000;
      uint64_t v14 = v123;
      uint64_t v12 = v127;
      uint64_t v10 = v132;
      uint64_t v8 = v138;
      uint64_t v6 = v145;
      uint64_t v4 = v153;
      uint64_t v2 = v162;
      a1 = v172;
    }
  }
  uint64_t v16 = *(void *)(v15 + 2912);
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v163 = v2;
    uint64_t v173 = a1;
    uint64_t v146 = v6;
    uint64_t v154 = v4;
    uint64_t v133 = v10;
    uint64_t v139 = v8;
    uint64_t v124 = v14;
    uint64_t v128 = v12;
    uint64_t v121 = v16;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v121;
    uint64_t v14 = v124;
    uint64_t v12 = v128;
    uint64_t v10 = v133;
    uint64_t v8 = v139;
    uint64_t v6 = v146;
    uint64_t v4 = v154;
    int v103 = v102;
    uint64_t v2 = v163;
    a1 = v173;
    if (v103)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v176 = 93;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v176;
      }
      uint64_t v106 = &v175[v105];
      unint64_t v107 = v176 - v105;
      if (v176 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v176 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v121;
      uint64_t v14 = v124;
      uint64_t v12 = v128;
      uint64_t v10 = v133;
      uint64_t v8 = v139;
      uint64_t v6 = v146;
      uint64_t v4 = v154;
      uint64_t v2 = v163;
      a1 = v173;
    }
  }
  uint64_t v18 = *(void *)(v17 + 3904);
  unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v164 = v2;
    uint64_t v174 = a1;
    uint64_t v147 = v6;
    uint64_t v155 = v4;
    uint64_t v134 = v10;
    uint64_t v140 = v8;
    uint64_t v125 = v14;
    uint64_t v129 = v12;
    uint64_t v120 = v18;
    uint64_t v122 = v16;
    unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v18 = v120;
    uint64_t v16 = v122;
    uint64_t v14 = v125;
    uint64_t v12 = v129;
    uint64_t v10 = v134;
    uint64_t v8 = v140;
    uint64_t v6 = v147;
    uint64_t v4 = v155;
    int v112 = v111;
    uint64_t v2 = v164;
    a1 = v174;
    if (v112)
    {
      unint64_t v175 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      unint64_t v176 = 84;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v175, "DesiredTypeName = ", 0x12uLL, 0);
      if (v176 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v176;
      }
      uint64_t v115 = &v175[v114];
      unint64_t v116 = v176 - v114;
      if (v176 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v176 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v18 = v120;
      uint64_t v16 = v122;
      uint64_t v14 = v125;
      uint64_t v12 = v129;
      uint64_t v10 = v134;
      uint64_t v8 = v140;
      uint64_t v6 = v147;
      uint64_t v4 = v155;
      uint64_t v2 = v164;
      a1 = v174;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v19[7] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::cf::BranchOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
      && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
      && mlir::OpTrait::impl::verifyOneSuccessor(a1, v4)
      && mlir::detail::BranchOpInterfaceTrait<mlir::cf::BranchOp>::verifyTrait((uint64_t)a1)
      && mlir::OpTrait::impl::verifyIsTerminator(a1, v5) != 0;
}

uint64_t mlir::detail::BranchOpInterfaceTrait<mlir::cf::BranchOp>::verifyTrait(uint64_t a1)
{
  v12[3] = *MEMORY[0x1E4F143B8];
  int v1 = *(_DWORD *)(a1 + 40);
  if (!v1) {
    return 1;
  }
  unsigned int v3 = 0;
  while (1)
  {
    if ((*(unsigned char *)(a1 + 46) & 0x80) != 0) {
      int v4 = *(_DWORD *)(a1 + 68);
    }
    else {
      int v4 = 0;
    }
    mlir::MutableOperandRange::MutableOperandRange((uint64_t)v10, a1, 0, v4, 0, 0);
    mlir::SuccessorOperands::SuccessorOperands((uint64_t)v7, v10);
    if (v11 != v12) {
      free(v11);
    }
    char v5 = mlir::detail::verifyBranchSuccessorOperands(a1, v3, v7);
    if (v8 != &v9) {
      free(v8);
    }
    if (!v5) {
      break;
    }
    if (v1 == ++v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t mlir::Op<mlir::cf::BranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::OneSuccessor,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::CondBranchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"cf.cond_br", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::CondBranchOp,void>::id, (uint64_t)&v9);
  int v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    int v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9ACDE8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getCanonicalizationPatterns(uint64_t a1, void *a2, uint64_t a3)
{
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, mlir::OperationState *a2)@<X8>)
{
  *a1 = mlir::cf::CondBranchOp::parse;
  a1[3] = (BOOL (*)(uint64_t, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                               + 2);
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  unint64_t v8 = *(unsigned int *)(a2 + 44);
  if (a4 == 19)
  {
    if (*a3 != 0x53646E617265706FLL
      || a3[1] != 0x6953746E656D6765
      || *(void *)((char *)a3 + 11) != 0x73657A6953746E65)
    {
      return 0;
    }
  }
  else
  {
    if (a4 != 21) {
      return 0;
    }
    BOOL v9 = *a3 == 0x5F646E617265706FLL && a3[1] == 0x5F746E656D676573;
    if (!v9 || *(void *)((char *)a3 + 13) != 0x73657A69735F746ELL) {
      return 0;
    }
  }
  if (BYTE3(v8)) {
    uint64_t v14 = a2 + 16 * ((v8 >> 23) & 1) + 64;
  }
  else {
    uint64_t v14 = 0;
  }
  return mlir::detail::DenseArrayAttrImpl<int>::get(Context, v14, 3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::cf::CondBranchOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v6 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v6, 3);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v7);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getOpPropertyByteSize()
{
  return 12;
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  if (a4)
  {
    uint64_t v4 = *a4;
    *(_DWORD *)(a3 + 8) = *((_DWORD *)a4 + 2);
    *(void *)a3 = v4;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = 0;
    *(void *)a3 = 0;
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::cf::CondBranchOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v4 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v4 = 0;
  }

  return mlir::cf::CondBranchOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
  *(void *)a2 = v3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(void *)a3 == *(void *)a2 && *(_DWORD *)(a3 + 8) == (unint64_t)*(unsigned int *)(a2 + 8);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::cf::CondBranchOp>::hashProperties(uint64_t a1, void *a2)
{
  return mlir::cf::CondBranchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v5 = (int *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v5 = 0;
  }
  if ((*(uint64_t (**)(uint64_t))(*(void *)a3 + 104))(a3) <= 5)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    uint64_t v7 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, (uint64_t)v5, 3);
    (*(void (**)(uint64_t, uint64_t))(*(void *)a3 + 16))(a3, v7);
  }
  uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)a3 + 104))(a3);
  if (result >= 6)
  {
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a3, v5, 3);
  }
  return result;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  *uint64_t v2 = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorOperands;
  v2[1] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorBlockArgument;
  v2[2] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorForOperands;
  v2[3] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::areTypesCompatible;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
      unint64_t v14 = 73;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3768), v2);
}

void mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorOperands(uint64_t a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  uint64_t v3 = a1;
  mlir::cf::CondBranchOp::getSuccessorOperands((mlir::cf::CondBranchOp *)&v3, a2, a3);
}

unint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorBlockArgument(uint64_t a1, uint64_t a2, unsigned int a3)
{
  void v18[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(unsigned int *)(a2 + 40);
  if (v3)
  {
    uint64_t v6 = 0;
    uint64_t v7 = a2 + 64;
    uint64_t v8 = 24;
    while (1)
    {
      uint64_t v15 = a2;
      mlir::cf::CondBranchOp::getSuccessorOperands((mlir::cf::CondBranchOp *)&v15, v6, (uint64_t)v16);
      uint64_t BranchSuccessorArgument = mlir::detail::getBranchSuccessorArgument(v16, a3, *(void *)(((v7+ 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)+ (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ v8));
      char v11 = v10;
      if (v17 != v18) {
        free(v17);
      }
      if (v11) {
        break;
      }
      ++v6;
      v8 += 32;
      if (v3 == v6)
      {
        unsigned __int8 v12 = 0;
        goto LABEL_10;
      }
    }
    unsigned __int8 v12 = BranchSuccessorArgument;
LABEL_10:
    unint64_t v13 = BranchSuccessorArgument & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    unsigned __int8 v12 = 0;
    unint64_t v13 = 0;
  }
  return v13 | v12;
}

uint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSuccessorForOperands(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  if (!*a3) {
    return 0;
  }
  int v4 = *(void **)(*(void *)v3 + 136);
  if (v4 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
    uint64_t v3 = 0;
  }
  uint64_t v12 = v3;
  if (v4 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
    return 0;
  }
  mlir::IntegerAttr::getValue(&v12, (llvm::APInt *)&__p);
  unsigned int v8 = v11;
  if (v11 > 0x40)
  {
    if (llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) == v8 - 1) {
      goto LABEL_9;
    }
LABEL_11:
    uint64_t v9 = 1;
    goto LABEL_12;
  }
  if (__p != (void *)1) {
    goto LABEL_11;
  }
LABEL_9:
  uint64_t v9 = 0;
LABEL_12:
  uint64_t v5 = *(void *)(((a2
                   + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * v9
                 + 24);
  if (v8 < 0x41 || !__p) {
    return v5;
  }
  operator delete[](__p);
  return v5;
}

BOOL mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::CondBranchOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::CondBranchOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(uint64_t a1)
{
  int v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v210 = a1;
    int v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v37 = v36;
    a1 = v210;
    if (v37)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v223 = 83;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v223;
      }
      int v40 = &v222[v39];
      unint64_t v41 = v223 - v39;
      if (v223 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v223 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      int v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v210;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v199 = v2;
    uint64_t v211 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v46 = v45;
    uint64_t v2 = v199;
    a1 = v211;
    if (v46)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      unint64_t v223 = 83;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v223;
      }
      int v49 = &v222[v48];
      unint64_t v50 = v223 - v48;
      if (v223 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v223 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v199;
      a1 = v211;
    }
  }
  uint64_t v4 = v3[5];
  unint64_t v5 = &unk_1E8EBA000;
  {
    uint64_t v200 = v2;
    uint64_t v212 = a1;
    uint64_t v189 = v4;
    unint64_t v5 = (void *)&unk_1E8EBA000;
    uint64_t v4 = v189;
    uint64_t v2 = v200;
    int v55 = v54;
    a1 = v212;
    if (v55)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NSuccessors<2>::Impl<Empty>]";
      unint64_t v223 = 92;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v223;
      }
      int v58 = &v222[v57];
      unint64_t v59 = v223 - v57;
      if (v223 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v223 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::NSuccessors<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NSuccessors<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      unint64_t v5 = (void *)&unk_1E8EBA000;
      uint64_t v4 = v189;
      uint64_t v2 = v200;
      a1 = v212;
    }
  }
  uint64_t v6 = v5[59];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v201 = v2;
    uint64_t v213 = a1;
    uint64_t v190 = v4;
    uint64_t v180 = v6;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v180;
    uint64_t v4 = v190;
    uint64_t v2 = v201;
    int v64 = v63;
    a1 = v213;
    if (v64)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      unint64_t v223 = 97;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v223;
      }
      int v67 = &v222[v66];
      unint64_t v68 = v223 - v66;
      if (v223 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v223 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v180;
      uint64_t v4 = v190;
      uint64_t v2 = v201;
      a1 = v213;
    }
  }
  uint64_t v8 = v7[13];
  uint64_t v9 = &unk_1E8EBA000;
  {
    uint64_t v202 = v2;
    uint64_t v214 = a1;
    uint64_t v191 = v4;
    uint64_t v172 = v8;
    uint64_t v181 = v6;
    uint64_t v9 = (void *)&unk_1E8EBA000;
    uint64_t v8 = v172;
    uint64_t v6 = v181;
    uint64_t v4 = v191;
    uint64_t v2 = v202;
    int v73 = v72;
    a1 = v214;
    if (v73)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      unint64_t v223 = 96;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v223;
      }
      int v76 = &v222[v75];
      unint64_t v77 = v223 - v75;
      if (v223 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v223 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      uint64_t v9 = (void *)&unk_1E8EBA000;
      uint64_t v8 = v172;
      uint64_t v6 = v181;
      uint64_t v4 = v191;
      uint64_t v2 = v202;
      a1 = v214;
    }
  }
  uint64_t v10 = v9[61];
  uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v203 = v2;
    uint64_t v215 = a1;
    uint64_t v192 = v4;
    uint64_t v173 = v8;
    uint64_t v182 = v6;
    uint64_t v165 = v10;
    uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v165;
    uint64_t v8 = v173;
    uint64_t v6 = v182;
    uint64_t v4 = v192;
    uint64_t v2 = v203;
    int v82 = v81;
    a1 = v215;
    if (v82)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v223 = 84;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v223;
      }
      int v85 = &v222[v84];
      unint64_t v86 = v223 - v84;
      if (v223 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v223 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v165;
      uint64_t v8 = v173;
      uint64_t v6 = v182;
      uint64_t v4 = v192;
      uint64_t v2 = v203;
      a1 = v215;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v204 = v2;
    uint64_t v216 = a1;
    uint64_t v193 = v4;
    uint64_t v174 = v8;
    uint64_t v183 = v6;
    uint64_t v159 = v12;
    uint64_t v166 = v10;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v159;
    uint64_t v10 = v166;
    uint64_t v8 = v174;
    uint64_t v6 = v183;
    uint64_t v4 = v193;
    uint64_t v2 = v204;
    int v91 = v90;
    a1 = v216;
    if (v91)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v223 = 89;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v223;
      }
      int v94 = &v222[v93];
      unint64_t v95 = v223 - v93;
      if (v223 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v223 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v159;
      uint64_t v10 = v166;
      uint64_t v8 = v174;
      uint64_t v6 = v183;
      uint64_t v4 = v193;
      uint64_t v2 = v204;
      a1 = v216;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2744);
  uint64_t v15 = &unk_1E8EBA000;
  {
    uint64_t v205 = v2;
    uint64_t v217 = a1;
    uint64_t v194 = v4;
    uint64_t v175 = v8;
    uint64_t v184 = v6;
    uint64_t v160 = v12;
    uint64_t v167 = v10;
    uint64_t v154 = v14;
    uint64_t v15 = (void *)&unk_1E8EBA000;
    uint64_t v14 = v154;
    uint64_t v12 = v160;
    uint64_t v10 = v167;
    uint64_t v8 = v175;
    uint64_t v6 = v184;
    uint64_t v4 = v194;
    uint64_t v2 = v205;
    int v100 = v99;
    a1 = v217;
    if (v100)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface::Trait<Empty>]";
      unint64_t v223 = 87;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v223;
      }
      int v103 = &v222[v102];
      unint64_t v104 = v223 - v102;
      if (v223 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v223 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      uint64_t v15 = (void *)&unk_1E8EBA000;
      uint64_t v14 = v154;
      uint64_t v12 = v160;
      uint64_t v10 = v167;
      uint64_t v8 = v175;
      uint64_t v6 = v184;
      uint64_t v4 = v194;
      uint64_t v2 = v205;
      a1 = v217;
    }
  }
  uint64_t v16 = v15[57];
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v206 = v2;
    uint64_t v218 = a1;
    uint64_t v195 = v4;
    uint64_t v176 = v8;
    uint64_t v185 = v6;
    uint64_t v161 = v12;
    uint64_t v168 = v10;
    uint64_t v150 = v16;
    uint64_t v155 = v14;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v150;
    uint64_t v14 = v155;
    uint64_t v12 = v161;
    uint64_t v10 = v168;
    uint64_t v8 = v176;
    uint64_t v6 = v185;
    uint64_t v4 = v195;
    uint64_t v2 = v206;
    int v109 = v108;
    a1 = v218;
    if (v109)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v223 = 95;
      unint64_t v110 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v110) {
        unint64_t v111 = v110;
      }
      else {
        unint64_t v111 = v223;
      }
      int v112 = &v222[v111];
      unint64_t v113 = v223 - v111;
      if (v223 - v111 >= 0x12) {
        uint64_t v114 = 18;
      }
      else {
        uint64_t v114 = v223 - v111;
      }
      unint64_t v115 = v113 - v114;
      if (v115 >= v115 - 1) {
        uint64_t v116 = v115 - 1;
      }
      else {
        uint64_t v116 = v115;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v150;
      uint64_t v14 = v155;
      uint64_t v12 = v161;
      uint64_t v10 = v168;
      uint64_t v8 = v176;
      uint64_t v6 = v185;
      uint64_t v4 = v195;
      uint64_t v2 = v206;
      a1 = v218;
    }
  }
  uint64_t v18 = *(void *)(v17 + 2776);
  unint64_t v19 = 0x1E8EB8000uLL;
  {
    uint64_t v207 = v2;
    uint64_t v219 = a1;
    uint64_t v196 = v4;
    uint64_t v177 = v8;
    uint64_t v186 = v6;
    uint64_t v162 = v12;
    uint64_t v169 = v10;
    uint64_t v151 = v16;
    uint64_t v156 = v14;
    uint64_t v147 = v18;
    unint64_t v19 = 0x1E8EB8000;
    uint64_t v18 = v147;
    uint64_t v16 = v151;
    uint64_t v14 = v156;
    uint64_t v12 = v162;
    uint64_t v10 = v169;
    uint64_t v8 = v177;
    uint64_t v6 = v186;
    uint64_t v4 = v196;
    uint64_t v2 = v207;
    int v118 = v117;
    a1 = v219;
    if (v118)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v223 = 99;
      unint64_t v119 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v119) {
        unint64_t v120 = v119;
      }
      else {
        unint64_t v120 = v223;
      }
      uint64_t v121 = &v222[v120];
      unint64_t v122 = v223 - v120;
      if (v223 - v120 >= 0x12) {
        uint64_t v123 = 18;
      }
      else {
        uint64_t v123 = v223 - v120;
      }
      unint64_t v124 = v122 - v123;
      if (v124 >= v124 - 1) {
        uint64_t v125 = v124 - 1;
      }
      else {
        uint64_t v125 = v124;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v121[v123], v125);
      unint64_t v19 = 0x1E8EB8000;
      uint64_t v18 = v147;
      uint64_t v16 = v151;
      uint64_t v14 = v156;
      uint64_t v12 = v162;
      uint64_t v10 = v169;
      uint64_t v8 = v177;
      uint64_t v6 = v186;
      uint64_t v4 = v196;
      uint64_t v2 = v207;
      a1 = v219;
    }
  }
  uint64_t v20 = *(void *)(v19 + 2912);
  unint64_t v21 = 0x1E8EB8000uLL;
  {
    uint64_t v208 = v2;
    uint64_t v220 = a1;
    uint64_t v197 = v4;
    uint64_t v178 = v8;
    uint64_t v187 = v6;
    uint64_t v163 = v12;
    uint64_t v170 = v10;
    uint64_t v152 = v16;
    uint64_t v157 = v14;
    uint64_t v145 = v20;
    uint64_t v148 = v18;
    unint64_t v21 = 0x1E8EB8000;
    uint64_t v20 = v145;
    uint64_t v18 = v148;
    uint64_t v16 = v152;
    uint64_t v14 = v157;
    uint64_t v12 = v163;
    uint64_t v10 = v170;
    uint64_t v8 = v178;
    uint64_t v6 = v187;
    uint64_t v4 = v197;
    uint64_t v2 = v208;
    int v127 = v126;
    a1 = v220;
    if (v127)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v223 = 93;
      unint64_t v128 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v128) {
        unint64_t v129 = v128;
      }
      else {
        unint64_t v129 = v223;
      }
      uint64_t v130 = &v222[v129];
      unint64_t v131 = v223 - v129;
      if (v223 - v129 >= 0x12) {
        uint64_t v132 = 18;
      }
      else {
        uint64_t v132 = v223 - v129;
      }
      unint64_t v133 = v131 - v132;
      if (v133 >= v133 - 1) {
        uint64_t v134 = v133 - 1;
      }
      else {
        uint64_t v134 = v133;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v130[v132], v134);
      unint64_t v21 = 0x1E8EB8000;
      uint64_t v20 = v145;
      uint64_t v18 = v148;
      uint64_t v16 = v152;
      uint64_t v14 = v157;
      uint64_t v12 = v163;
      uint64_t v10 = v170;
      uint64_t v8 = v178;
      uint64_t v6 = v187;
      uint64_t v4 = v197;
      uint64_t v2 = v208;
      a1 = v220;
    }
  }
  uint64_t v22 = *(void *)(v21 + 3904);
  uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v209 = v2;
    uint64_t v221 = a1;
    uint64_t v198 = v4;
    uint64_t v179 = v8;
    uint64_t v188 = v6;
    uint64_t v164 = v12;
    uint64_t v171 = v10;
    uint64_t v153 = v16;
    uint64_t v158 = v14;
    uint64_t v146 = v20;
    uint64_t v149 = v18;
    uint64_t v144 = v22;
    uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v22 = v144;
    uint64_t v20 = v146;
    uint64_t v18 = v149;
    uint64_t v16 = v153;
    uint64_t v14 = v158;
    uint64_t v12 = v164;
    uint64_t v10 = v171;
    uint64_t v8 = v179;
    uint64_t v6 = v188;
    uint64_t v4 = v198;
    uint64_t v2 = v209;
    int v136 = v135;
    a1 = v221;
    if (v136)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      unint64_t v223 = 84;
      unint64_t v137 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v137) {
        unint64_t v138 = v137;
      }
      else {
        unint64_t v138 = v223;
      }
      uint64_t v139 = &v222[v138];
      unint64_t v140 = v223 - v138;
      if (v223 - v138 >= 0x12) {
        uint64_t v141 = 18;
      }
      else {
        uint64_t v141 = v223 - v138;
      }
      unint64_t v142 = v140 - v141;
      if (v142 >= v142 - 1) {
        uint64_t v143 = v142 - 1;
      }
      else {
        uint64_t v143 = v142;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v139[v141], v143);
      uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v22 = v144;
      uint64_t v20 = v146;
      uint64_t v18 = v149;
      uint64_t v16 = v153;
      uint64_t v14 = v158;
      uint64_t v12 = v164;
      uint64_t v10 = v171;
      uint64_t v8 = v179;
      uint64_t v6 = v188;
      uint64_t v4 = v198;
      uint64_t v2 = v209;
      a1 = v221;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v23[7] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::cf::CondBranchOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::CondBranchOp>,mlir::OpTrait::ZeroResults<mlir::cf::CondBranchOp>,mlir::OpTrait::NSuccessors<2u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::CondBranchOp>,mlir::OpTrait::OpInvariants<mlir::cf::CondBranchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::CondBranchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::IsTerminator<mlir::cf::CondBranchOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::CondBranchOp>,mlir::OpTrait::ZeroResults<mlir::cf::CondBranchOp>,mlir::OpTrait::NSuccessors<2u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::CondBranchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::CondBranchOp>,mlir::OpTrait::OpInvariants<mlir::cf::CondBranchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::CondBranchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::CondBranchOp>,mlir::OpTrait::IsTerminator<mlir::cf::CondBranchOp>>(uint64_t a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyNSuccessors((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)1)
    && mlir::OpTrait::impl::verifyOperandSizeAttr(a1, "operandSegmentSizes", 0x13uLL))
  {
    unint64_t v4 = *(unsigned int *)(a1 + 44);
    uint64_t v5 = *(unsigned int *)(a1 + 16 * ((v4 >> 23) & 1) + 64);
    if ((v4 & 0x800000) != 0)
    {
      uint64_t v6 = *(void *)(a1 + 72);
      if (v5) {
        goto LABEL_8;
      }
    }
    else
    {
      uint64_t v6 = 0;
      if (v5)
      {
LABEL_8:
        uint64_t v7 = 0;
        uint64_t v8 = v6 + 24;
        while (mlir::complex::__mlir_ods_local_type_constraint_ComplexOps3((uint64_t *)a1, *(void *)(*(void *)v8 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v7))
        {
          ++v7;
          v8 += 32;
          if (v5 == v7) {
            goto LABEL_11;
          }
        }
        return 0;
      }
    }
LABEL_11:
    if (mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>>(a1)) {
      return mlir::OpTrait::impl::verifyIsTerminator((mlir::OpTrait::impl *)a1, v9) != 0;
    }
  }
  return 0;
}

uint64_t mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::CondBranchOp>>(uint64_t a1)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1;
  int v1 = *(_DWORD *)(a1 + 40);
  if (!v1) {
    return 1;
  }
  unsigned int v3 = 0;
  while (1)
  {
    mlir::cf::CondBranchOp::getSuccessorOperands((mlir::cf::CondBranchOp *)&v6, v3, (uint64_t)v7);
    char v4 = mlir::detail::verifyBranchSuccessorOperands(a1, v3, v7);
    if (v8 != v9) {
      free(v8);
    }
    if (!v4) {
      break;
    }
    if (v1 == ++v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t mlir::Op<mlir::cf::CondBranchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::NSuccessors<2u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::SwitchOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"cf.switch", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::SwitchOp,void>::id, (uint64_t)&v9);
  char v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    char v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9AD040;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::foldHook()
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v4 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v0, v1, v2, v3);
    }
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::cf::SwitchOp::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getParseAssemblyFn(BOOL (**a1)(void *a1, mlir::OperationState *a2)@<X8>)
{
  *a1 = mlir::cf::SwitchOp::parse;
  a1[3] = (BOOL (*)(void *, mlir::OperationState *))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                              + 2);
}

void mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::printAssembly(uint64_t a1, Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                        + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::cf::SwitchOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::cf::SwitchOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }
  if (*v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"case_operand_segments", 21, *v6);
  }
  uint64_t v7 = v6[1];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"case_values", 11, v7);
  }
  uint64_t v8 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, (uint64_t)(v6 + 2), 3);

  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v8);
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9 = (void *)mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  BOOL result = 0;
  if (!v9
    || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps2(v9, (const void **)"case_operand_segments", (const char *)0x15, a4, a5))
  {
    uint64_t v10 = mlir::NamedAttrList::get(a3, *(void *)(*(void *)(a2 + 96) + 8));
    if (!v10
      || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps1(v10, (const void **)"case_values", (const char *)0xB, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getOpPropertyByteSize()
{
  return 32;
}

double mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::initProperties(uint64_t a1, uint64_t a2, long long *a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    *a3 = *a4;
    a3[1] = v5;
  }
  else
  {
    *(void *)&long long v4 = 0;
    *a3 = 0u;
    a3[1] = 0u;
  }
  return *(double *)&v4;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::cf::SwitchOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::cf::SwitchOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)(a3 + 12);
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)a3 != *(void *)a2) {
    return 0;
  }
  if (*(void *)(a3 + 8) != *(void *)(a2 + 8)) {
    return 0;
  }
  return *(void *)(a3 + 16) == *(void *)(a2 + 16)
      && *(_DWORD *)(a3 + 24) == (unint64_t)*(unsigned int *)(a2 + 24);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::cf::SwitchOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::cf::SwitchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::cf::SwitchOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  *uint64_t v2 = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorOperands;
  v2[1] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorBlockArgument;
  v2[2] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorForOperands;
  v2[3] = mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::areTypesCompatible;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
      unint64_t v14 = 73;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3768), v2);
}

void mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorOperands(mlir::Operation *a1@<X1>, int a2@<W2>, uint64_t a3@<X8>)
{
  unint64_t v3 = a1;
  mlir::cf::SwitchOp::getSuccessorOperands(&v3, a2, a3);
}

unint64_t mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorBlockArgument(uint64_t a1, unsigned int *a2, unsigned int a3)
{
  void v18[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a2[10];
  if (v3)
  {
    uint64_t v6 = 0;
    uint64_t v7 = a2 + 16;
    uint64_t v8 = 24;
    while (1)
    {
      uint64_t v15 = (mlir::Operation *)a2;
      mlir::cf::SwitchOp::getSuccessorOperands(&v15, v6, (uint64_t)v16);
      uint64_t BranchSuccessorArgument = mlir::detail::getBranchSuccessorArgument(v16, a3, *(void *)((((unint64_t)&v7[4 * (((unint64_t)a2[11] >> 23) & 1) + 1]+ (((unint64_t)a2[11] >> 21) & 0x7F8)+ 3) & 0xFFFFFFFFFFFFFFF8)+ v8));
      char v11 = v10;
      if (v17 != v18) {
        free(v17);
      }
      if (v11) {
        break;
      }
      ++v6;
      v8 += 32;
      if (v3 == v6)
      {
        unsigned __int8 v12 = 0;
        goto LABEL_10;
      }
    }
    unsigned __int8 v12 = BranchSuccessorArgument;
LABEL_10:
    unint64_t v13 = BranchSuccessorArgument & 0xFFFFFFFFFFFFFF00;
  }
  else
  {
    unsigned __int8 v12 = 0;
    unint64_t v13 = 0;
  }
  return v13 | v12;
}

void **mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getSuccessorForOperands(uint64_t a1, Operation *a2, uint64_t *a3)
{
  int v4 = a2;
  return mlir::cf::SwitchOp::getSuccessorForOperands(&v4, a3);
}

BOOL mlir::detail::BranchOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::areTypesCompatible(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return a3 == a4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::SwitchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::SwitchOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unsigned __int8 v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::cf::SwitchOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::cf::SwitchOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unsigned __int8 v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      unint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>(uint64_t a1)
{
  uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v210 = a1;
    uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v37 = v36;
    a1 = v210;
    if (v37)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v223 = 83;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v223;
      }
      int v40 = &v222[v39];
      unint64_t v41 = v223 - v39;
      if (v223 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v223 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      uint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v210;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v199 = v2;
    uint64_t v211 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v46 = v45;
    uint64_t v2 = v199;
    a1 = v211;
    if (v46)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      unint64_t v223 = 83;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v223;
      }
      int v49 = &v222[v48];
      unint64_t v50 = v223 - v48;
      if (v223 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v223 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v199;
      a1 = v211;
    }
  }
  uint64_t v4 = v3[5];
  unint64_t v5 = &unk_1E8EBA000;
  {
    uint64_t v200 = v2;
    uint64_t v212 = a1;
    uint64_t v189 = v4;
    unint64_t v5 = (void *)&unk_1E8EBA000;
    uint64_t v4 = v189;
    uint64_t v2 = v200;
    int v55 = v54;
    a1 = v212;
    if (v55)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNSuccessors<1>::Impl<Empty>]";
      unint64_t v223 = 99;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v223;
      }
      int v58 = &v222[v57];
      unint64_t v59 = v223 - v57;
      if (v223 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v223 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNSuccessors<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNSuccessors<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      unint64_t v5 = (void *)&unk_1E8EBA000;
      uint64_t v4 = v189;
      uint64_t v2 = v200;
      a1 = v212;
    }
  }
  uint64_t v6 = v5[65];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v201 = v2;
    uint64_t v213 = a1;
    uint64_t v190 = v4;
    uint64_t v180 = v6;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v180;
    uint64_t v4 = v190;
    uint64_t v2 = v201;
    int v64 = v63;
    a1 = v213;
    if (v64)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      unint64_t v223 = 97;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v223;
      }
      int v67 = &v222[v66];
      unint64_t v68 = v223 - v66;
      if (v223 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v223 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v180;
      uint64_t v4 = v190;
      uint64_t v2 = v201;
      a1 = v213;
    }
  }
  uint64_t v8 = v7[13];
  uint64_t v9 = &unk_1E8EBA000;
  {
    uint64_t v202 = v2;
    uint64_t v214 = a1;
    uint64_t v191 = v4;
    uint64_t v172 = v8;
    uint64_t v181 = v6;
    uint64_t v9 = (void *)&unk_1E8EBA000;
    uint64_t v8 = v172;
    uint64_t v6 = v181;
    uint64_t v4 = v191;
    uint64_t v2 = v202;
    int v73 = v72;
    a1 = v214;
    if (v73)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      unint64_t v223 = 96;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v223;
      }
      int v76 = &v222[v75];
      unint64_t v77 = v223 - v75;
      if (v223 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v223 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      uint64_t v9 = (void *)&unk_1E8EBA000;
      uint64_t v8 = v172;
      uint64_t v6 = v181;
      uint64_t v4 = v191;
      uint64_t v2 = v202;
      a1 = v214;
    }
  }
  uint64_t v10 = v9[61];
  uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v203 = v2;
    uint64_t v215 = a1;
    uint64_t v192 = v4;
    uint64_t v173 = v8;
    uint64_t v182 = v6;
    uint64_t v165 = v10;
    uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v165;
    uint64_t v8 = v173;
    uint64_t v6 = v182;
    uint64_t v4 = v192;
    uint64_t v2 = v203;
    int v82 = v81;
    a1 = v215;
    if (v82)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v223 = 84;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v223;
      }
      int v85 = &v222[v84];
      unint64_t v86 = v223 - v84;
      if (v223 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v223 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v165;
      uint64_t v8 = v173;
      uint64_t v6 = v182;
      uint64_t v4 = v192;
      uint64_t v2 = v203;
      a1 = v215;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v204 = v2;
    uint64_t v216 = a1;
    uint64_t v193 = v4;
    uint64_t v174 = v8;
    uint64_t v183 = v6;
    uint64_t v159 = v12;
    uint64_t v166 = v10;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v159;
    uint64_t v10 = v166;
    uint64_t v8 = v174;
    uint64_t v6 = v183;
    uint64_t v4 = v193;
    uint64_t v2 = v204;
    int v91 = v90;
    a1 = v216;
    if (v91)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v223 = 89;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v223;
      }
      int v94 = &v222[v93];
      unint64_t v95 = v223 - v93;
      if (v223 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v223 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v159;
      uint64_t v10 = v166;
      uint64_t v8 = v174;
      uint64_t v6 = v183;
      uint64_t v4 = v193;
      uint64_t v2 = v204;
      a1 = v216;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2744);
  uint64_t v15 = &unk_1E8EBA000;
  {
    uint64_t v205 = v2;
    uint64_t v217 = a1;
    uint64_t v194 = v4;
    uint64_t v175 = v8;
    uint64_t v184 = v6;
    uint64_t v160 = v12;
    uint64_t v167 = v10;
    uint64_t v154 = v14;
    uint64_t v15 = (void *)&unk_1E8EBA000;
    uint64_t v14 = v154;
    uint64_t v12 = v160;
    uint64_t v10 = v167;
    uint64_t v8 = v175;
    uint64_t v6 = v184;
    uint64_t v4 = v194;
    uint64_t v2 = v205;
    int v100 = v99;
    a1 = v217;
    if (v100)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface::Trait<Empty>]";
      unint64_t v223 = 87;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v223;
      }
      int v103 = &v222[v102];
      unint64_t v104 = v223 - v102;
      if (v223 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v223 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BranchOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      uint64_t v15 = (void *)&unk_1E8EBA000;
      uint64_t v14 = v154;
      uint64_t v12 = v160;
      uint64_t v10 = v167;
      uint64_t v8 = v175;
      uint64_t v6 = v184;
      uint64_t v4 = v194;
      uint64_t v2 = v205;
      a1 = v217;
    }
  }
  uint64_t v16 = v15[57];
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v206 = v2;
    uint64_t v218 = a1;
    uint64_t v195 = v4;
    uint64_t v176 = v8;
    uint64_t v185 = v6;
    uint64_t v161 = v12;
    uint64_t v168 = v10;
    uint64_t v150 = v16;
    uint64_t v155 = v14;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v150;
    uint64_t v14 = v155;
    uint64_t v12 = v161;
    uint64_t v10 = v168;
    uint64_t v8 = v176;
    uint64_t v6 = v185;
    uint64_t v4 = v195;
    uint64_t v2 = v206;
    int v109 = v108;
    a1 = v218;
    if (v109)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v223 = 95;
      unint64_t v110 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v110) {
        unint64_t v111 = v110;
      }
      else {
        unint64_t v111 = v223;
      }
      int v112 = &v222[v111];
      unint64_t v113 = v223 - v111;
      if (v223 - v111 >= 0x12) {
        uint64_t v114 = 18;
      }
      else {
        uint64_t v114 = v223 - v111;
      }
      unint64_t v115 = v113 - v114;
      if (v115 >= v115 - 1) {
        uint64_t v116 = v115 - 1;
      }
      else {
        uint64_t v116 = v115;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v150;
      uint64_t v14 = v155;
      uint64_t v12 = v161;
      uint64_t v10 = v168;
      uint64_t v8 = v176;
      uint64_t v6 = v185;
      uint64_t v4 = v195;
      uint64_t v2 = v206;
      a1 = v218;
    }
  }
  uint64_t v18 = *(void *)(v17 + 2776);
  unint64_t v19 = 0x1E8EB8000uLL;
  {
    uint64_t v207 = v2;
    uint64_t v219 = a1;
    uint64_t v196 = v4;
    uint64_t v177 = v8;
    uint64_t v186 = v6;
    uint64_t v162 = v12;
    uint64_t v169 = v10;
    uint64_t v151 = v16;
    uint64_t v156 = v14;
    uint64_t v147 = v18;
    unint64_t v19 = 0x1E8EB8000;
    uint64_t v18 = v147;
    uint64_t v16 = v151;
    uint64_t v14 = v156;
    uint64_t v12 = v162;
    uint64_t v10 = v169;
    uint64_t v8 = v177;
    uint64_t v6 = v186;
    uint64_t v4 = v196;
    uint64_t v2 = v207;
    int v118 = v117;
    a1 = v219;
    if (v118)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v223 = 99;
      unint64_t v119 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v119) {
        unint64_t v120 = v119;
      }
      else {
        unint64_t v120 = v223;
      }
      uint64_t v121 = &v222[v120];
      unint64_t v122 = v223 - v120;
      if (v223 - v120 >= 0x12) {
        uint64_t v123 = 18;
      }
      else {
        uint64_t v123 = v223 - v120;
      }
      unint64_t v124 = v122 - v123;
      if (v124 >= v124 - 1) {
        uint64_t v125 = v124 - 1;
      }
      else {
        uint64_t v125 = v124;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v121[v123], v125);
      unint64_t v19 = 0x1E8EB8000;
      uint64_t v18 = v147;
      uint64_t v16 = v151;
      uint64_t v14 = v156;
      uint64_t v12 = v162;
      uint64_t v10 = v169;
      uint64_t v8 = v177;
      uint64_t v6 = v186;
      uint64_t v4 = v196;
      uint64_t v2 = v207;
      a1 = v219;
    }
  }
  uint64_t v20 = *(void *)(v19 + 2912);
  unint64_t v21 = 0x1E8EB8000uLL;
  {
    uint64_t v208 = v2;
    uint64_t v220 = a1;
    uint64_t v197 = v4;
    uint64_t v178 = v8;
    uint64_t v187 = v6;
    uint64_t v163 = v12;
    uint64_t v170 = v10;
    uint64_t v152 = v16;
    uint64_t v157 = v14;
    uint64_t v145 = v20;
    uint64_t v148 = v18;
    unint64_t v21 = 0x1E8EB8000;
    uint64_t v20 = v145;
    uint64_t v18 = v148;
    uint64_t v16 = v152;
    uint64_t v14 = v157;
    uint64_t v12 = v163;
    uint64_t v10 = v170;
    uint64_t v8 = v178;
    uint64_t v6 = v187;
    uint64_t v4 = v197;
    uint64_t v2 = v208;
    int v127 = v126;
    a1 = v220;
    if (v127)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v223 = 93;
      unint64_t v128 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v128) {
        unint64_t v129 = v128;
      }
      else {
        unint64_t v129 = v223;
      }
      uint64_t v130 = &v222[v129];
      unint64_t v131 = v223 - v129;
      if (v223 - v129 >= 0x12) {
        uint64_t v132 = 18;
      }
      else {
        uint64_t v132 = v223 - v129;
      }
      unint64_t v133 = v131 - v132;
      if (v133 >= v133 - 1) {
        uint64_t v134 = v133 - 1;
      }
      else {
        uint64_t v134 = v133;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v130[v132], v134);
      unint64_t v21 = 0x1E8EB8000;
      uint64_t v20 = v145;
      uint64_t v18 = v148;
      uint64_t v16 = v152;
      uint64_t v14 = v157;
      uint64_t v12 = v163;
      uint64_t v10 = v170;
      uint64_t v8 = v178;
      uint64_t v6 = v187;
      uint64_t v4 = v197;
      uint64_t v2 = v208;
      a1 = v220;
    }
  }
  uint64_t v22 = *(void *)(v21 + 3904);
  uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v209 = v2;
    uint64_t v221 = a1;
    uint64_t v198 = v4;
    uint64_t v179 = v8;
    uint64_t v188 = v6;
    uint64_t v164 = v12;
    uint64_t v171 = v10;
    uint64_t v153 = v16;
    uint64_t v158 = v14;
    uint64_t v146 = v20;
    uint64_t v149 = v18;
    uint64_t v144 = v22;
    uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v22 = v144;
    uint64_t v20 = v146;
    uint64_t v18 = v149;
    uint64_t v16 = v153;
    uint64_t v14 = v158;
    uint64_t v12 = v164;
    uint64_t v10 = v171;
    uint64_t v8 = v179;
    uint64_t v6 = v188;
    uint64_t v4 = v198;
    uint64_t v2 = v209;
    int v136 = v135;
    a1 = v221;
    if (v136)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      unint64_t v223 = 84;
      unint64_t v137 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v137) {
        unint64_t v138 = v137;
      }
      else {
        unint64_t v138 = v223;
      }
      uint64_t v139 = &v222[v138];
      unint64_t v140 = v223 - v138;
      if (v223 - v138 >= 0x12) {
        uint64_t v141 = 18;
      }
      else {
        uint64_t v141 = v223 - v138;
      }
      unint64_t v142 = v140 - v141;
      if (v142 >= v142 - 1) {
        uint64_t v143 = v142 - 1;
      }
      else {
        uint64_t v143 = v142;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v139[v141], v143);
      uint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v22 = v144;
      uint64_t v20 = v146;
      uint64_t v18 = v149;
      uint64_t v16 = v153;
      uint64_t v14 = v158;
      uint64_t v12 = v164;
      uint64_t v10 = v171;
      uint64_t v8 = v179;
      uint64_t v6 = v188;
      uint64_t v4 = v198;
      uint64_t v2 = v209;
      a1 = v221;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v23[7] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::cf::SwitchOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::SwitchOp>,mlir::OpTrait::ZeroResults<mlir::cf::SwitchOp>,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl<mlir::cf::SwitchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::SwitchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::SwitchOp>,mlir::OpTrait::OpInvariants<mlir::cf::SwitchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::SwitchOp>,mlir::BranchOpInterface::Trait<mlir::cf::SwitchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::SwitchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::SwitchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::SwitchOp>,mlir::OpTrait::IsTerminator<mlir::cf::SwitchOp>>(a1, a2))return 0; {
  uint64_t v4 = a1;
  }
  return mlir::cf::SwitchOp::verify(&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::cf::SwitchOp>,mlir::OpTrait::ZeroResults<mlir::cf::SwitchOp>,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl<mlir::cf::SwitchOp>,mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::cf::SwitchOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::cf::SwitchOp>,mlir::OpTrait::OpInvariants<mlir::cf::SwitchOp>,mlir::BytecodeOpInterface::Trait<mlir::cf::SwitchOp>,mlir::BranchOpInterface::Trait<mlir::cf::SwitchOp>,mlir::ConditionallySpeculatable::Trait<mlir::cf::SwitchOp>,mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::cf::SwitchOp>,mlir::MemoryEffectOpInterface::Trait<mlir::cf::SwitchOp>,mlir::OpTrait::IsTerminator<mlir::cf::SwitchOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    && mlir::OpTrait::impl::verifyAtLeastNSuccessors(a1, (mlir::Operation *)1)
    && mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1)
    && mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL)
    && (uint64_t v6 = a1, mlir::cf::SwitchOp::verifyInvariantsImpl((uint64_t **)&v6))
    && mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::SwitchOp>>(a1))
  {
    return mlir::OpTrait::impl::verifyIsTerminator(a1, v4) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::op_definition_impl::verifyTrait<mlir::BranchOpInterface::Trait<mlir::cf::SwitchOp>>(mlir::Operation *a1)
{
  v9[3] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = a1;
  int v1 = *((_DWORD *)a1 + 10);
  if (!v1) {
    return 1;
  }
  unsigned int v3 = 0;
  while (1)
  {
    mlir::cf::SwitchOp::getSuccessorOperands(&v6, v3, (uint64_t)v7);
    char v4 = mlir::detail::verifyBranchSuccessorOperands((uint64_t)a1, v3, v7);
    if (v8 != v9) {
      free(v8);
    }
    if (!v4) {
      break;
    }
    if (v1 == ++v3) {
      return 1;
    }
  }
  return 0;
}

uint64_t mlir::Op<mlir::cf::SwitchOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::AtLeastNSuccessors<1u>::Impl,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::BranchOpInterface::Trait,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

void anonymous namespace'::ControlFlowInlinerInterface::~ControlFlowInlinerInterface(_anonymous_namespace_::ControlFlowInlinerInterface *this)
{
  mlir::GenericProgramPoint::~GenericProgramPoint(this);

  operator delete(v1);
}

uint64_t anonymous namespace'::ControlFlowInlinerInterface::isLegalToInline(_anonymous_namespace_::ControlFlowInlinerInterface *this, Operation *a2, Operation *a3)
{
  return 1;
}

uint64_t anonymous namespace'::ControlFlowInlinerInterface::isLegalToInline()
{
  return 1;
}

void anonymous namespace'::SimplifyConstCondBranchPred::~SimplifyConstCondBranchPred(_anonymous_namespace_::SimplifyConstCondBranchPred *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unsigned int v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unsigned int v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::CondBranchOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::CondBranchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::CondBranchOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t anonymous namespace'::SimplifyConstCondBranchPred::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t v24 = mlir::m_NonZero(void)::{lambda(llvm::APInt const&)#1}::__invoke;
  v23[0] = v5;
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v23);
  if (DefiningOp
    && mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(void **))&v24, DefiningOp))
  {
    unint64_t v7 = *(unsigned int *)(a2 + 44);
    uint64_t v24 = *(BOOL (**)(llvm::APInt *))(((a2 + 16 * ((v7 >> 23) & 1) + 64 + ((v7 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                               + 24);
    if (BYTE3(v7)) {
      uint64_t v8 = (unsigned int *)(a2 + 16 * ((v7 >> 23) & 1) + 64);
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t v9 = *v8;
    unsigned int v10 = v8[1];
    if ((v7 & 0x800000) != 0) {
      uint64_t v11 = *(void *)(a2 + 72);
    }
    else {
      uint64_t v11 = 0;
    }
    uint64_t v12 = v10 + v9;
    uint64_t v13 = v11 + 32 * v9;
LABEL_17:
    v23[0] = v13;
    v23[1] = v12 - v9;
    uint64_t v22 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), (uint64_t *)&v24, (uint64_t)v23);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v22);
    return 1;
  }
  uint64_t v14 = *(void *)(*(void *)(a2 + 72) + 24);
  uint64_t v24 = mlir::m_Zero(void)::{lambda(llvm::APInt const&)#1}::__invoke;
  v23[0] = v14;
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v23);
  if (result)
  {
    uint64_t result = mlir::detail::constant_int_predicate_matcher::match((uint64_t (**)(void **))&v24, (mlir::Operation *)result);
    if (result)
    {
      unint64_t v16 = *(unsigned int *)(a2 + 44);
      uint64_t v24 = *(BOOL (**)(llvm::APInt *))(((a2 + 16 * ((v16 >> 23) & 1) + 64 + ((v16 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                                 + 56);
      if (BYTE3(v16)) {
        unint64_t v17 = (int *)(a2 + 16 * ((v16 >> 23) & 1) + 64);
      }
      else {
        unint64_t v17 = 0;
      }
      int v18 = *v17;
      int v19 = v17[1];
      int v20 = v17[2];
      if ((v16 & 0x800000) != 0) {
        uint64_t v21 = *(void *)(a2 + 72);
      }
      else {
        uint64_t v21 = 0;
      }
      uint64_t v9 = (v19 + v18);
      uint64_t v12 = (v20 + v9);
      uint64_t v13 = v21 + 32 * v9;
      goto LABEL_17;
    }
  }
  return result;
}

void anonymous namespace'::SimplifyPassThroughCondBranch::~SimplifyPassThroughCondBranch(_anonymous_namespace_::SimplifyPassThroughCondBranch *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unsigned int v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unsigned int v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace'::SimplifyPassThroughCondBranch::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2 + 64;
  unint64_t v6 = *(unsigned int *)(a2 + 44);
  unint64_t v7 = (a2 + 64 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8;
  uint64_t v8 = *(void *)(v7 + 24);
  uint64_t v25 = *(void *)(v7 + 56);
  uint64_t v26 = v8;
  if (BYTE3(v6)) {
    uint64_t v9 = (unsigned int *)(a2 + 64 + 16 * ((v6 >> 23) & 1));
  }
  else {
    uint64_t v9 = 0;
  }
  uint64_t v10 = *v9;
  unsigned int v11 = v9[1];
  if ((v6 & 0x800000) != 0) {
    uint64_t v12 = *(void *)(a2 + 72);
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)v32, v12 + 32 * v10, v11 + v10 - v10);
  unint64_t v13 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v14 = (int *)(v5 + 16 * ((v13 >> 23) & 1));
  }
  else {
    uint64_t v14 = 0;
  }
  int v15 = *v14;
  int v16 = v14[1];
  int v17 = v14[2];
  if ((v13 & 0x800000) != 0) {
    uint64_t v18 = *(void *)(a2 + 72);
  }
  else {
    uint64_t v18 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)v31, v18 + 32 * (v16 + v15), (v17 + v16 + v15) - (unint64_t)(v16 + v15));
  v29[0] = v30;
  v29[1] = (void *)0x400000000;
  v27[0] = v28;
  v27[1] = (void *)0x400000000;
  unsigned __int8 v19 = collapseBranch(&v26, v32, (uint64_t)v29);
  if (v19 | collapseBranch(&v25, v31, (uint64_t)v27))
  {
    uint64_t v24 = *(void *)(*(void *)(a2 + 72) + 24);
    uint64_t v22 = mlir::OpBuilder::create<mlir::cf::CondBranchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::Block *&,mlir::ValueRange &>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), &v24, &v26, v32, &v25, v31);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v22);
    uint64_t v20 = 1;
    uint64_t v21 = v27[0];
    if (v27[0] == v28) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v20 = 0;
  uint64_t v21 = v27[0];
  if (v27[0] != v28) {
LABEL_15:
  }
    free(v21);
LABEL_16:
  if (v29[0] != v30) {
    free(v29[0]);
  }
  return v20;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::CondBranchOp,mlir::detail::TypedValue<mlir::IntegerType>,mlir::Block *&,mlir::ValueRange &,mlir::Block *&,mlir::ValueRange &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, uint64_t *a7)
{
  v26[38] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  uint64_t v15 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.cond_br", (const unsigned __int8 *)0xA, Context);
  if (!v16)
  {
    __int16 v25 = 1283;
    v24[2] = (uint64_t)"cf.cond_br";
    void v24[3] = 10;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v23 = 259;
    llvm::operator+(v24, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v15);
  mlir::cf::CondBranchOp::build(v17, (uint64_t)v26, *a3, *a5, a5[1], *a7, a7[1], *a4, *a6);
  uint64_t v18 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (*(_UNKNOWN **)(*((void *)v18 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::CondBranchOp,void>::id) {
    unsigned __int8 v19 = v18;
  }
  else {
    unsigned __int8 v19 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v19;
}

void anonymous namespace'::SimplifyCondBranchIdenticalSuccessors::~SimplifyCondBranchIdenticalSuccessors(_anonymous_namespace_::SimplifyCondBranchIdenticalSuccessors *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unsigned int v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unsigned int v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace'::SimplifyCondBranchIdenticalSuccessors::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v39[8] = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *(unsigned int *)(a2 + 44);
  char v4 = (unsigned int *)(a2 + 16 * ((v3 >> 23) & 1) + 64);
  unint64_t v5 = ((unint64_t)v4 + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8;
  unint64_t v6 = *(mlir::Block **)(v5 + 24);
  int v36 = v6;
  if (v6 != *(mlir::Block **)(v5 + 56)) {
    return 0;
  }
  if (!BYTE3(v3)) {
    char v4 = 0;
  }
  uint64_t v10 = *v4;
  unsigned int v11 = v4[1];
  if ((v3 & 0x800000) != 0)
  {
    uint64_t v12 = *(void *)(a2 + 72);
    uint64_t v13 = v11 + v10;
    uint64_t v14 = v12 + 32 * v10;
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t v13 = v11 + v10;
    uint64_t v14 = 32 * v10;
  }
  unint64_t v15 = v13 - v10;
  v35[0] = v14;
  v35[1] = v13 - v10;
  unsigned int v16 = v4[2];
  uint64_t v17 = v16 + v13;
  if (v13 - v10 == v17 - v13)
  {
    if (!v11)
    {
LABEL_12:
      uint64_t v21 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), (uint64_t *)&v36, (uint64_t)v35);
      (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v21);
      return 1;
    }
    uint64_t v18 = (void *)(v12 + 32 * v13 + 24);
    unsigned __int8 v19 = (void *)(v14 + 24);
    uint64_t v20 = v13 - v10;
    while (*v19 == *v18)
    {
      v18 += 4;
      v19 += 4;
      if (!--v20) {
        goto LABEL_12;
      }
    }
  }
  if (mlir::Block::getUniquePredecessor(v6) != *(void *)(a2 + 16)) {
    return 0;
  }
  int v37 = v39;
  uint64_t v38 = 0x800000000;
  if (v15 >= 9) {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v15, 8);
  }
  uint64_t v34 = *(void *)(*(void *)(a2 + 72) + 24);
  if (v11 && v16)
  {
    uint64_t v22 = (char **)(v14 + 24);
    __int16 v23 = (uint64_t *)(v12 + 32 * v13 + 24);
    unint64_t v24 = v15 - 1;
    uint64_t v25 = ~v13 + v17;
    do
    {
      uint64_t v26 = *v22;
      uint64_t v27 = *v23;
      unint64_t v32 = v26;
      uint64_t v33 = v27;
      if (v26 != (char *)v27) {
        uint64_t v26 = (char *)mlir::OpBuilder::create<mlir::arith::SelectOp,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), &v34, (uint64_t *)&v32, &v33)- 16;
      }
      uint64_t v28 = v38;
      if (v38 >= (unint64_t)HIDWORD(v38))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 8);
        uint64_t v28 = v38;
      }
      *((void *)v37 + v28) = v26;
      LODWORD(v38) = v38 + 1;
      BOOL v29 = v25-- != 0;
      char v30 = v29;
      BOOL v29 = v24-- != 0;
      if (!v29) {
        break;
      }
      v22 += 4;
      v23 += 4;
    }
    while ((v30 & 1) != 0);
  }
  int v31 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,llvm::SmallVector<mlir::Value,8u> &>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), (uint64_t *)&v36, (uint64_t)&v37);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v31);
  if (v37 != v39) {
    free(v37);
  }
  return 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,llvm::SmallVector<mlir::Value,8u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v28[11] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v18);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    __int16 v22 = 1283;
    v21[2] = (uint64_t)"cf.br";
    void v21[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v20 = 259;
    llvm::operator+(v21, (uint64_t *)&v19, (uint64_t)v24);
    llvm::report_fatal_error((llvm::Twine *)v24, 1);
  }
  mlir::OperationState::OperationState(v24, a2, v9);
  uint64_t v11 = *a3;
  mlir::ValueRange::ValueRange(v23, *(void *)a4, *(unsigned int *)(a4 + 8));
  uint64_t v12 = v23[0];
  uint64_t v13 = v23[1];
  unsigned int v14 = v26;
  if (v26 >= v27)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v26 + 1, 8);
    unsigned int v14 = v26;
  }
  *(void *)(v25 + 8 * v14) = v11;
  ++v26;
  mlir::OperationState::addOperands((uint64_t)v24, v12, v13);
  unint64_t v15 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v24);
  if (*(_UNKNOWN **)(*((void *)v15 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id) {
    unsigned int v16 = v15;
  }
  else {
    unsigned int v16 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v24);
  return v16;
}

void anonymous namespace'::SimplifyCondBranchFromCondBranchOnSameCondition::~SimplifyCondBranchFromCondBranchOnSameCondition(_anonymous_namespace_::SimplifyCondBranchFromCondBranchOnSameCondition *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace'::SimplifyCondBranchFromCondBranchOnSameCondition::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5 = *(mlir::Block **)(a2 + 16);
  uint64_t result = mlir::Block::getSinglePredecessor(v5);
  if (result)
  {
    mlir::Block::getTerminator((mlir::GenericProgramPoint **)result);
    if (v7) {
      BOOL v8 = *(void *)(*(void *)(v7 + 48) + 16) == (void)&mlir::detail::TypeIDResolver<mlir::cf::CondBranchOp,void>::id;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      uint64_t v9 = *(void *)(a2 + 72);
      if (*(void *)(v9 + 24) == *(void *)(*(void *)(v7 + 72) + 24))
      {
        unint64_t v10 = (a2 + 80 + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8;
        if (HIBYTE(*(_DWORD *)(a2 + 44))) {
          uint64_t v11 = (unsigned int *)(a2 + 80);
        }
        else {
          uint64_t v11 = 0;
        }
        if (v5 == *(mlir::Block **)(((v7 + (((unint64_t)*(unsigned int *)(v7 + 44) >> 21) & 0x7F8) + 87) & 0xFFFFFFFFFFFFFFF8)
                                   + 24))
        {
          uint64_t v18 = *(void *)(v10 + 24);
          uint64_t v15 = *v11;
          unsigned int v14 = v11[1];
        }
        else
        {
          uint64_t v18 = *(void *)(v10 + 56);
          int v12 = *v11;
          unsigned int v13 = v11[1];
          unsigned int v14 = v11[2];
          uint64_t v15 = v13 + v12;
        }
        v17[0] = v9 + 32 * v15;
        v17[1] = v14 + v15 - v15;
        unsigned int v16 = mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *,mlir::OperandRange>((mlir::OpBuilder *)(a3 + 8), *(void *)(a2 + 24), &v18, (uint64_t)v17);
        (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a3 + 32))(a3, a2, v16);
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void anonymous namespace'::CondBranchTruthPropagation::~CondBranchTruthPropagation(_anonymous_namespace_::CondBranchTruthPropagation *this)
{
  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }
}

{
  char *v2;
  char *v3;
  uint64_t vars8;

  uint64_t v2 = (char *)*((void *)this + 10);
  if (v2 != (char *)this + 96) {
    free(v2);
  }
  unint64_t v3 = (char *)*((void *)this + 4);
  if (v3 != (char *)this + 48) {
    free(v3);
  }

  operator delete(this);
}

uint64_t anonymous namespace'::CondBranchTruthPropagation::matchAndRewrite(uint64_t a1, uint64_t a2, mlir::BoolAttr **a3)
{
  unint64_t v5 = a3 + 1;
  uint64_t I1Type = mlir::Builder::getI1Type((mlir::Builder *)(a3 + 1));
  uint64_t v6 = a2 + 64;
  uint64_t SinglePredecessor = mlir::Block::getSinglePredecessor(*(mlir::Block **)(((a2
                                                                          + 64
                                                                          + 16
                                                                          * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                                                                          + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                                                                          + 7) & 0xFFFFFFFFFFFFFFF8)
                                                                        + 24));
  unsigned int v8 = *(_DWORD *)(a2 + 44);
  if (SinglePredecessor)
  {
    uint64_t v9 = **(uint64_t ***)(*(void *)(a2 + 72) + 24);
    if (v9)
    {
      char v10 = 0;
      uint64_t v11 = 0;
      do
      {
        int v12 = (uint64_t *)*v9;
        uint64_t v13 = v9[2];
        if (*(void *)(v13 + 16) == *(void *)(((v6
                                                  + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                                                  + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                                                  + 7) & 0xFFFFFFFFFFFFFFF8)
                                                + 24))
        {
          if (!v11)
          {
            uint64_t v14 = *(void *)(a2 + 24);
            BoolAttr = (void *)mlir::Builder::getBoolAttr(v5, (mlir::MLIRContext *)1);
            uint64_t v11 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::BoolAttr>((mlir::OpBuilder *)v5, v14, &I1Type, &BoolAttr)- 16);
            uint64_t v13 = v9[2];
          }
          (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 9))(a3, v13);
          uint64_t v15 = (uint64_t *)v9[1];
          if (v15)
          {
            uint64_t *v15 = *v9;
            if (*v9) {
              *(void *)(*v9 + 8) = v9[1];
            }
          }
          v9[3] = (uint64_t)v11;
          v9[1] = (uint64_t)v11;
          uint64_t v16 = *v11;
          *uint64_t v9 = *v11;
          if (v16) {
            *(void *)(v16 + 8) = v9;
          }
          uint64_t *v11 = (uint64_t)v9;
          (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 10))(a3, v13);
          char v10 = 1;
        }
        uint64_t v9 = v12;
      }
      while (v12);
      unsigned int v8 = *(_DWORD *)(a2 + 44);
    }
    else
    {
      char v10 = 0;
    }
    char v17 = v10;
  }
  else
  {
    char v17 = 0;
  }
  if (mlir::Block::getSinglePredecessor(*(mlir::Block **)(((v6 + 16 * ((v8 >> 23) & 1) + ((v8 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                                                         + 56)))
  {
    uint64_t v18 = **(uint64_t ***)(*(void *)(a2 + 72) + 24);
    if (v18)
    {
      unsigned __int8 v19 = 0;
      do
      {
        __int16 v20 = (uint64_t *)*v18;
        uint64_t v21 = v18[2];
        if (*(void *)(v21 + 16) == *(void *)(((v6
                                                  + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                                                  + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                                                  + 7) & 0xFFFFFFFFFFFFFFF8)
                                                + 56))
        {
          if (!v19)
          {
            uint64_t v22 = *(void *)(a2 + 24);
            BoolAttr = (void *)mlir::Builder::getBoolAttr(v5, 0);
            unsigned __int8 v19 = (uint64_t *)((char *)mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::BoolAttr>((mlir::OpBuilder *)v5, v22, &I1Type, &BoolAttr)- 16);
            uint64_t v21 = v18[2];
          }
          (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 9))(a3, v21);
          __int16 v23 = (uint64_t *)v18[1];
          if (v23)
          {
            uint64_t *v23 = *v18;
            if (*v18) {
              *(void *)(*v18 + 8) = v18[1];
            }
          }
          void v18[3] = (uint64_t)v19;
          v18[1] = (uint64_t)v19;
          uint64_t v24 = *v19;
          uint64_t *v18 = *v19;
          if (v24) {
            *(void *)(v24 + 8) = v18;
          }
          uint64_t *v19 = (uint64_t)v18;
          (*((void (**)(mlir::BoolAttr **, uint64_t))*a3 + 10))(a3, v21);
          char v17 = 1;
        }
        uint64_t v18 = v20;
      }
      while (v20);
    }
  }
  return v17 & 1;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::arith::ConstantOp,mlir::Type &,mlir::BoolAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void **a4)
{
  v22[38] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"arith.constant", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v21 = 1283;
    uint64_t v20[2] = (uint64_t)"arith.constant";
    void v20[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v19 = 259;
    llvm::operator+(v20, (uint64_t *)&v18, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  uint64_t v11 = *a3;
  int v12 = *a4;
  if (v12) {
    uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::TypedAttr>(*v12 + 8);
  }
  else {
    uint64_t v13 = 0;
  }
  mlir::arith::ConstantOp::build((uint64_t)a1, (uint64_t)v22, v11, (uint64_t)v12, v13);
  uint64_t v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((void *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::arith::ConstantOp,void>::id) {
    uint64_t v15 = v14;
  }
  else {
    uint64_t v15 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v15;
}

void *mlir::RewritePatternSet::add<mlir::cf::SwitchOp>(mlir::LogicalResult (*)(mlir::cf::SwitchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::RewritePatternSet::add<mlir::cf::SwitchOp>(mlir::LogicalResult (*)(mlir::cf::SwitchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::SwitchOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::SwitchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::SwitchOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::RewritePatternSet::add<mlir::cf::SwitchOp>(mlir::LogicalResult (*)(mlir::cf::SwitchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::AssertOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void *mlir::RewritePatternSet::add<mlir::cf::AssertOp>(mlir::LogicalResult (*)(mlir::cf::AssertOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::RewritePatternSet::add<mlir::cf::AssertOp>(mlir::LogicalResult (*)(mlir::cf::AssertOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::AssertOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::AssertOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::AssertOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::RewritePatternSet::add<mlir::cf::AssertOp>(mlir::LogicalResult (*)(mlir::cf::AssertOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

uint64_t mlir::AsmParser::parseAttribute<mlir::StringAttr>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v20 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, uint64_t))(*(void *)a1 + 408))(a1, &v20, a3)) {
    return 0;
  }
  uint64_t v7 = v20;
  if (*(_UNKNOWN **)(*(void *)v20 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
    uint64_t v7 = 0;
  }
  *a2 = v7;
  if (v7) {
    return 1;
  }
  uint64_t v18 = "invalid kind of attribute specified";
  __int16 v19 = 259;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t, const char **))(*(void *)a1 + 24))(v21, a1, v6, &v18);
  uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
  if (v21[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
  }
  if (v28)
  {
    char v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = v27;
      int v12 = __p;
      if (v27 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        int v12 = __p;
      }
      unsigned int v27 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v24;
    if (v24)
    {
      uint64_t v14 = v25;
      uint64_t v15 = v24;
      if (v25 != v24)
      {
        do
        {
          uint64_t v17 = (void *)*--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v24;
      }
      uint64_t v25 = v13;
      operator delete(v15);
    }
    if (v22 != &v23) {
      free(v22);
    }
  }
  return v8;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::AssertOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    uint64_t v34 = "'";
    uint64_t v35 = 1;
    char v4 = &v33;
    unint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        unint64_t v5 = (char *)v40;
        char v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        char v4 = &v33;
        unint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  uint64_t v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  uint64_t AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    uint64_t v33 = AttrData;
    uint64_t v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      uint64_t v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          int v12 = (char *)v40;
        }
      }
      uint64_t v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)uint64_t v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    uint64_t v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    uint64_t v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      int v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      uint64_t v17 = v40;
      uint64_t v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    __int16 v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    uint64_t v24 = v44[0];
    if (v44[0])
    {
      uint64_t v25 = v44[1];
      unsigned int v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          unsigned int v27 = v28;
          *uint64_t v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        unsigned int v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void *mlir::RewritePatternSet::add<mlir::cf::BranchOp>(mlir::LogicalResult (*)(mlir::cf::BranchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::RewritePatternSet::add<mlir::cf::BranchOp>(mlir::LogicalResult (*)(mlir::cf::BranchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  unint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::BranchOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::BranchOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::cf::BranchOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::RewritePatternSet::add<mlir::cf::BranchOp>(mlir::LogicalResult (*)(mlir::cf::BranchOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::CondBranchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v3 = *a3;
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a3 + 2);
  *(void *)a2 = v3;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::cf::detail::SwitchOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  *(_OWORD *)(a2 + 12) = *(_OWORD *)(a3 + 12);
  *(__n128 *)a2 = result;
  return result;
}

uint64_t mlir::AsmParser::parseType<mlir::IntegerType>(uint64_t a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v18 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 504))(a1, &v18)) {
    return 0;
  }
  uint64_t v5 = v18;
  if (*(_UNKNOWN **)(*(void *)v18 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id) {
    uint64_t v5 = 0;
  }
  *a2 = v5;
  if (v5) {
    return 1;
  }
  uint64_t v16 = "invalid kind of type specified";
  __int16 v17 = 259;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t, const char **))(*(void *)a1 + 24))(v19, a1, v4, &v16);
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  }
  if (v26)
  {
    uint64_t v8 = (void **)__p;
    if (__p)
    {
      uint64_t v9 = v25;
      uint64_t v10 = __p;
      if (v25 != __p)
      {
        do
          uint64_t v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        uint64_t v10 = __p;
      }
      uint64_t v25 = v8;
      operator delete(v10);
    }
    uint64_t v11 = v22;
    if (v22)
    {
      int v12 = v23;
      uint64_t v13 = v22;
      if (v23 != v22)
      {
        do
        {
          unint64_t v15 = (void *)*--v12;
          long long v14 = v15;
          void *v12 = 0;
          if (v15) {
            operator delete[](v14);
          }
        }
        while (v12 != v11);
        uint64_t v13 = v22;
      }
      uint64_t v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21) {
      free(v20);
    }
  }
  return v6;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::cf::SwitchOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    uint64_t v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  uint64_t v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  uint64_t AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    uint64_t v33 = AttrData;
    uint64_t v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      uint64_t v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      int v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          int v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          int v12 = (char *)v40;
        }
      }
      uint64_t v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)uint64_t v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    uint64_t v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    __int16 v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      int v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      __int16 v17 = v40;
      uint64_t v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      uint64_t v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    uint64_t v24 = v44[0];
    if (v44[0])
    {
      uint64_t v25 = v44[1];
      char v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          char v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *uint64_t v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        char v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

uint64_t mlir::BranchOpInterface::getSuccessorOperands(mlir::BranchOpInterface *this, uint64_t a2)
{
  return (**((uint64_t (***)(void, void, uint64_t))this + 1))(*((void *)this + 1), *(void *)this, a2);
}

uint64_t mlir::BranchOpInterface::getSuccessorBlockArgument(mlir::BranchOpInterface *this, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(*((void *)this + 1) + 8))(*((void *)this + 1), *(void *)this, a2);
}

uint64_t mlir::BranchOpInterface::getSuccessorForOperands(void *a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(a1[1] + 16))(a1[1], *a1, a2, a3);
}

uint64_t mlir::RegionBranchOpInterface::getEntrySuccessorRegions(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t))(a1[1] + 8))(a1[1], *a1, a2, a3, a4);
}

uint64_t mlir::SuccessorOperands::SuccessorOperands(uint64_t a1, uint64_t *a2)
{
  *(_DWORD *)a1 = 0;
  long long v3 = *(_OWORD *)a2;
  *(void *)(a1 + 24) = a1 + 40;
  uint64_t v4 = a1 + 24;
  *(_OWORD *)(v4 - 16) = v3;
  *(void *)(v4 + 8) = 0x100000000;
  if (*((_DWORD *)a2 + 6)) {
    llvm::SmallVectorImpl<std::pair<unsigned int,mlir::NamedAttribute>>::operator=(v4, a2 + 2);
  }
  return a1;
}

uint64_t mlir::detail::getBranchSuccessorArgument(_DWORD *a1, unsigned int a2, uint64_t a3)
{
  uint64_t v9 = mlir::MutableOperandRange::operator mlir::OperandRange(a1 + 2);
  uint64_t v10 = v6;
  if (v6
    && (unsigned int BeginOperandIndex = mlir::OperandRange::getBeginOperandIndex((mlir::OperandRange *)&v9), a2 >= BeginOperandIndex)
    && v10 + (unint64_t)BeginOperandIndex > a2)
  {
    return *(void *)(*(void *)(a3 + 48) + 8 * (a2 - BeginOperandIndex + *a1));
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::detail::verifyBranchSuccessorOperands(uint64_t a1, unsigned int a2, unsigned int *a3)
{
  uint64_t v125 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *a3;
  unsigned int v5 = a3[5];
  uint64_t v6 = (const char *)a2;
  uint64_t v7 = *(void *)(((a1
                   + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)
                   + (((unint64_t)*(unsigned int *)(a1 + 44) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * a2
                 + 24);
  if (v5 + *a3 == ((*(void *)(v7 + 56) - *(void *)(v7 + 48)) >> 3))
  {
    if (!v5) {
      return 1;
    }
    uint64_t v9 = a3 + 2;
    while (1)
    {
      uint64_t v10 = *(void *)(a1 + 48);
      uint64_t v11 = *(void **)(v10 + 16);
      BOOL v12 = v11 == &mlir::detail::TypeIDResolver<void,void>::id;
      uint64_t v13 = v11 == &mlir::detail::TypeIDResolver<void,void>::id ? 0 : *(void *)(a1 + 48);
      if (!v12) {
        break;
      }
      v115[0] = *(void *)(v10 + 8);
      uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v115);
      if (Values)
      {
        uint64_t v17 = v10;
LABEL_12:
        uint64_t v15 = mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(Values, v17);
        goto LABEL_14;
      }
      uint64_t v15 = 0;
LABEL_14:
      uint64_t v18 = mlir::MutableOperandRange::operator[](v9, v4 - *a3);
      if (((*(uint64_t (**)(uint64_t, uint64_t, unint64_t, unint64_t))(v15 + 24))(v15, a1, *(void *)(*(void *)(v18 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, *(void *)(*(void *)(*(void *)(v7 + 48) + 8 * v4) + 8) & 0xFFFFFFFFFFFFFFF8) & 1) == 0)
      {
        __int16 v111 = 257;
        mlir::Operation::emitError((uint64_t *)a1, (uint64_t)v110, (uint64_t)v115);
        if (v115[0])
        {
          int v112 = 3;
          unint64_t v113 = "type mismatch for bb argument #";
          uint64_t v114 = 31;
          unint64_t v57 = &v112;
          int v58 = (char *)v116;
          if (v117 >= v118)
          {
            unint64_t v88 = v117 + 1;
            if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
            {
              int64_t v103 = (char *)&v112 - (unsigned char *)v116;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v88, 24);
              int v58 = (char *)v116;
              unint64_t v57 = (int *)((char *)v116 + v103);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v88, 24);
              unint64_t v57 = &v112;
              int v58 = (char *)v116;
            }
          }
          unint64_t v59 = &v58[24 * v117];
          long long v60 = *(_OWORD *)v57;
          *((void *)v59 + 2) = *((void *)v57 + 2);
          *(_OWORD *)unint64_t v59 = v60;
          uint64_t v61 = ++v117;
          if (v115[0])
          {
            int v112 = 5;
            unint64_t v113 = (const char *)v4;
            uint64_t v62 = &v112;
            int v63 = (char *)v116;
            if (v61 >= v118)
            {
              unint64_t v91 = v61 + 1;
              BOOL v92 = (char *)v116 + 24 * v61 > (char *)&v112;
              if (v116 <= &v112 && v92)
              {
                int64_t v105 = (char *)&v112 - (unsigned char *)v116;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v91, 24);
                int v63 = (char *)v116;
                uint64_t v62 = (int *)((char *)v116 + v105);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v91, 24);
                uint64_t v62 = &v112;
                int v63 = (char *)v116;
              }
            }
            int v64 = &v63[24 * v117];
            long long v65 = *(_OWORD *)v62;
            *((void *)v64 + 2) = *((void *)v62 + 2);
            *(_OWORD *)int v64 = v65;
            uint64_t v66 = ++v117;
            if (v115[0])
            {
              int v112 = 3;
              unint64_t v113 = " of successor #";
              uint64_t v114 = 15;
              int v67 = &v112;
              unint64_t v68 = (char *)v116;
              if (v66 >= v118)
              {
                unint64_t v95 = v66 + 1;
                BOOL v96 = (char *)v116 + 24 * v66 > (char *)&v112;
                if (v116 <= &v112 && v96)
                {
                  int64_t v107 = (char *)&v112 - (unsigned char *)v116;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
                  unint64_t v68 = (char *)v116;
                  int v67 = (int *)((char *)v116 + v107);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
                  int v67 = &v112;
                  unint64_t v68 = (char *)v116;
                }
              }
              uint64_t v69 = &v68[24 * v117];
              long long v70 = *(_OWORD *)v67;
              *((void *)v69 + 2) = *((void *)v67 + 2);
              *(_OWORD *)uint64_t v69 = v70;
              uint64_t v71 = ++v117;
              if (v115[0])
              {
                int v112 = 5;
                unint64_t v113 = v6;
                int v72 = &v112;
                int v73 = (char *)v116;
                if (v71 >= v118)
                {
                  unint64_t v98 = v71 + 1;
                  BOOL v99 = (char *)v116 + 24 * v71 > (char *)&v112;
                  if (v116 <= &v112 && v99)
                  {
                    int64_t v109 = (char *)&v112 - (unsigned char *)v116;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
                    int v73 = (char *)v116;
                    int v72 = (int *)((char *)v116 + v109);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
                    int v72 = &v112;
                    int v73 = (char *)v116;
                  }
                }
                unint64_t v74 = &v73[24 * v117];
                long long v75 = *(_OWORD *)v72;
                *((void *)v74 + 2) = *((void *)v72 + 2);
                *(_OWORD *)unint64_t v74 = v75;
                ++v117;
              }
            }
          }
        }
        uint64_t v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v115);
        if (v115[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
        }
        if (v124)
        {
          int v76 = (void **)__p;
          if (__p)
          {
            unint64_t v77 = v123;
            uint64_t v78 = __p;
            if (v123 != __p)
            {
              do
                unint64_t v77 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v77 - 1);
              while (v77 != v76);
              uint64_t v78 = __p;
            }
            uint64_t v123 = v76;
            operator delete(v78);
          }
          unint64_t v52 = v120;
          if (v120)
          {
            unint64_t v79 = v121;
            int v54 = v120;
            if (v121 == v120)
            {
LABEL_68:
              uint64_t v121 = v52;
              operator delete(v54);
              goto LABEL_69;
            }
            do
            {
              int v81 = (void *)*--v79;
              uint64_t v80 = v81;
              void *v79 = 0;
              if (v81) {
                operator delete[](v80);
              }
            }
            while (v79 != v52);
LABEL_67:
            int v54 = v120;
            goto LABEL_68;
          }
          goto LABEL_69;
        }
        return v19;
      }
      ++v4;
      if (!--v5) {
        return 1;
      }
    }
    unint64_t v14 = v13 | v10 & 0xFFFFFFFFFFFFFF00;
    uint64_t v15 = mlir::detail::InterfaceMap::lookup<mlir::BranchOpInterface>(v14 + 32);
    if (v15) {
      goto LABEL_14;
    }
    uint64_t Values = *(void *)(v14 + 24);
    uint64_t v17 = *(void *)(a1 + 48);
    goto LABEL_12;
  }
  __int16 v111 = 257;
  mlir::Operation::emitError((uint64_t *)a1, (uint64_t)v110, (uint64_t)v115);
  if (v115[0])
  {
    int v112 = 3;
    unint64_t v113 = "branch has ";
    uint64_t v114 = 11;
    unint64_t v20 = &v112;
    uint64_t v21 = (char *)v116;
    if (v117 >= v118)
    {
      unint64_t v83 = v117 + 1;
      if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
      {
        int64_t v100 = (char *)&v112 - (unsigned char *)v116;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v83, 24);
        uint64_t v21 = (char *)v116;
        unint64_t v20 = (int *)((char *)v116 + v100);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v83, 24);
        unint64_t v20 = &v112;
        uint64_t v21 = (char *)v116;
      }
    }
    uint64_t v22 = &v21[24 * v117];
    long long v23 = *(_OWORD *)v20;
    *((void *)v22 + 2) = *((void *)v20 + 2);
    *(_OWORD *)uint64_t v22 = v23;
    uint64_t v24 = ++v117;
    if (v115[0])
    {
      int v112 = 5;
      unint64_t v113 = (const char *)(v5 + v4);
      uint64_t v25 = &v112;
      char v26 = (char *)v116;
      if (v24 >= v118)
      {
        unint64_t v84 = v24 + 1;
        BOOL v85 = (char *)v116 + 24 * v24 > (char *)&v112;
        if (v116 <= &v112 && v85)
        {
          int64_t v101 = (char *)&v112 - (unsigned char *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v84, 24);
          char v26 = (char *)v116;
          uint64_t v25 = (int *)((char *)v116 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v84, 24);
          uint64_t v25 = &v112;
          char v26 = (char *)v116;
        }
      }
      uint64_t v27 = &v26[24 * v117];
      long long v28 = *(_OWORD *)v25;
      *((void *)v27 + 2) = *((void *)v25 + 2);
      *(_OWORD *)uint64_t v27 = v28;
      uint64_t v29 = ++v117;
      if (v115[0])
      {
        int v112 = 3;
        unint64_t v113 = " operands for successor #";
        uint64_t v114 = 25;
        unint64_t v30 = &v112;
        int64_t v31 = (char *)v116;
        if (v29 >= v118)
        {
          unint64_t v86 = v29 + 1;
          BOOL v87 = (char *)v116 + 24 * v29 > (char *)&v112;
          if (v116 <= &v112 && v87)
          {
            int64_t v102 = (char *)&v112 - (unsigned char *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v86, 24);
            int64_t v31 = (char *)v116;
            unint64_t v30 = (int *)((char *)v116 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v86, 24);
            unint64_t v30 = &v112;
            int64_t v31 = (char *)v116;
          }
        }
        int64_t v32 = &v31[24 * v117];
        long long v33 = *(_OWORD *)v30;
        *((void *)v32 + 2) = *((void *)v30 + 2);
        *(_OWORD *)int64_t v32 = v33;
        uint64_t v34 = ++v117;
        if (v115[0])
        {
          int v112 = 5;
          unint64_t v113 = v6;
          uint64_t v35 = &v112;
          __int16 v36 = (char *)v116;
          if (v34 >= v118)
          {
            unint64_t v89 = v34 + 1;
            BOOL v90 = (char *)v116 + 24 * v34 > (char *)&v112;
            if (v116 <= &v112 && v90)
            {
              int64_t v104 = (char *)&v112 - (unsigned char *)v116;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v89, 24);
              __int16 v36 = (char *)v116;
              uint64_t v35 = (int *)((char *)v116 + v104);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v89, 24);
              uint64_t v35 = &v112;
              __int16 v36 = (char *)v116;
            }
          }
          uint64_t v37 = &v36[24 * v117];
          long long v38 = *(_OWORD *)v35;
          *((void *)v37 + 2) = *((void *)v35 + 2);
          *(_OWORD *)uint64_t v37 = v38;
          uint64_t v39 = ++v117;
          if (v115[0])
          {
            int v112 = 3;
            unint64_t v113 = ", but target block has ";
            uint64_t v114 = 23;
            int v40 = &v112;
            unsigned int v41 = (char *)v116;
            if (v39 >= v118)
            {
              unint64_t v93 = v39 + 1;
              BOOL v94 = (char *)v116 + 24 * v39 > (char *)&v112;
              if (v116 <= &v112 && v94)
              {
                int64_t v106 = (char *)&v112 - (unsigned char *)v116;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
                unsigned int v41 = (char *)v116;
                int v40 = (int *)((char *)v116 + v106);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
                int v40 = &v112;
                unsigned int v41 = (char *)v116;
              }
            }
            unsigned int v42 = &v41[24 * v117];
            long long v43 = *(_OWORD *)v40;
            *((void *)v42 + 2) = *((void *)v40 + 2);
            *(_OWORD *)unsigned int v42 = v43;
            ++v117;
            if (v115[0])
            {
              unint64_t v44 = *(void *)(v7 + 56) - *(void *)(v7 + 48);
              int v112 = 5;
              unint64_t v113 = (const char *)(v44 >> 3);
              uint64_t v45 = &v112;
              int v46 = (char *)v116;
              if (v117 >= v118)
              {
                unint64_t v97 = v117 + 1;
                if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
                {
                  int64_t v108 = (char *)&v112 - (unsigned char *)v116;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
                  int v46 = (char *)v116;
                  uint64_t v45 = (int *)((char *)v116 + v108);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
                  uint64_t v45 = &v112;
                  int v46 = (char *)v116;
                }
              }
              uint64_t v47 = &v46[24 * v117];
              long long v48 = *(_OWORD *)v45;
              *((void *)v47 + 2) = *((void *)v45 + 2);
              *(_OWORD *)uint64_t v47 = v48;
              ++v117;
            }
          }
        }
      }
    }
  }
  uint64_t v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v115);
  if (v115[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
  }
  if (v124)
  {
    uint64_t v49 = (void **)__p;
    if (__p)
    {
      unint64_t v50 = v123;
      uint64_t v51 = __p;
      if (v123 != __p)
      {
        do
          unint64_t v50 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v50 - 1);
        while (v50 != v49);
        uint64_t v51 = __p;
      }
      uint64_t v123 = v49;
      operator delete(v51);
    }
    unint64_t v52 = v120;
    if (v120)
    {
      uint64_t v53 = v121;
      int v54 = v120;
      if (v121 == v120) {
        goto LABEL_68;
      }
      do
      {
        unint64_t v56 = (void *)*--v53;
        int v55 = v56;
        void *v53 = 0;
        if (v56) {
          operator delete[](v55);
        }
      }
      while (v53 != v52);
      goto LABEL_67;
    }
LABEL_69:
    if (v116 != v119) {
      free(v116);
    }
  }
  return v19;
}

uint64_t mlir::detail::verifyTypesAlongControlFlowEdges(mlir::detail *this, mlir::Operation *a2)
{
  uint64_t v2 = this;
  v79[6] = *MEMORY[0x1E4F143B8];
  int v76 = (uint64_t *)this;
  if (!this) {
    goto LABEL_11;
  }
  uint64_t v3 = *((void *)this + 6);
  unsigned int v4 = *(void **)(v3 + 16);
  BOOL v5 = v4 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *((void *)this + 6);
  }
  if (v5)
  {
    unint64_t v77 = *(void **)(v3 + 8);
    this = (mlir::detail *)mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v77);
    if (this)
    {
      uint64_t v8 = v3;
      goto LABEL_10;
    }
  }
  else
  {
    unint64_t v7 = v6 | v3 & 0xFFFFFFFFFFFFFF00;
    this = (mlir::detail *)mlir::detail::InterfaceMap::lookup<mlir::RegionBranchOpInterface>(v7 + 32);
    if (!this)
    {
      this = *(mlir::detail **)(v7 + 24);
      uint64_t v8 = *((void *)v2 + 6);
LABEL_10:
      this = (mlir::detail *)mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>((uint64_t)this, v8);
    }
  }
LABEL_11:
  v75[0] = v2;
  v75[1] = this;
  unint64_t v74 = v75;
  if (!verifyTypesAlongAllEdges(v76, 0, (void (*)(void *__return_ptr, void, void))llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_0>, (uint64_t)&v74))return 0; {
  int v73 = v75;
  }
  unint64_t v9 = *((unsigned int *)v76 + 11);
  if ((v9 & 0x7FFFFF) == 0) {
    return 1;
  }
  uint64_t v10 = (mlir::Region *)((((unint64_t)&v76[2 * ((v9 >> 23) & 1) + 8] + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                       + 32 * *((unsigned int *)v76 + 10));
  uint64_t v11 = (mlir::Region *)((char *)v10 + 24 * (v9 & 0x7FFFFF));
  while (2)
  {
    unint64_t v77 = v79;
    uint64_t v78 = 0x300000000;
    BOOL v12 = (mlir::Region *)*((void *)v10 + 1);
    if (v12 == v10)
    {
LABEL_98:
      int v66 = 3;
      int v67 = v77;
      if (v77 != v79) {
        goto LABEL_99;
      }
      goto LABEL_100;
    }
    do
    {
      if (v12) {
        unint64_t v14 = (mlir::GenericProgramPoint **)((char *)v12 - 8);
      }
      else {
        unint64_t v14 = 0;
      }
      mlir::Block::getTerminator(v14);
      uint64_t v16 = v15;
      uint64_t v17 = *(void *)(v15 + 48);
      uint64_t v18 = *(void **)(v17 + 16);
      if (v18 == &mlir::detail::TypeIDResolver<void,void>::id) {
        uint64_t v19 = 0;
      }
      else {
        uint64_t v19 = *(void *)(v15 + 48);
      }
      if (v18 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        uint64_t v69 = *(void ***)(v17 + 8);
        uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v69);
        if (!Values) {
          goto LABEL_53;
        }
      }
      else
      {
        {
          uint64_t v69 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
          unint64_t v70 = 89;
          unint64_t v52 = llvm::StringRef::find((uint64_t *)&v69, "DesiredTypeName = ", 0x12uLL, 0);
          if (v70 >= v52) {
            unint64_t v53 = v52;
          }
          else {
            unint64_t v53 = v70;
          }
          int v54 = (char *)v69 + v53;
          unint64_t v55 = v70 - v53;
          uint64_t v56 = 18;
          if (v55 < 0x12) {
            uint64_t v56 = v55;
          }
          unint64_t v57 = v55 - v56;
          if (v57 >= v57 - 1) {
            uint64_t v58 = v57 - 1;
          }
          else {
            uint64_t v58 = v57;
          }
          mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v54[v56], v58);
        }
        unint64_t v20 = *(unsigned int *)((v19 | v17 & 0xFFFFFFFFFFFFFF00) + 0x28);
        if (v20)
        {
          uint64_t v21 = *(void **)((v19 | v17 & 0xFFFFFFFFFFFFFF00) + 0x20);
          uint64_t v22 = &v21[2 * v20];
          do
          {
            unint64_t v23 = v20 >> 1;
            uint64_t v24 = &v21[2 * (v20 >> 1)];
            unint64_t v26 = *v24;
            uint64_t v25 = v24 + 2;
            v20 += ~(v20 >> 1);
            if (v26 < mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id) {
              uint64_t v21 = v25;
            }
            else {
              unint64_t v20 = v23;
            }
          }
          while (v20);
          if (v21 != v22
            && *v21 == mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id
            && v21[1])
          {
            goto LABEL_39;
          }
        }
        uint64_t Values = *(void *)((v19 | v17 & 0xFFFFFFFFFFFFFF00) + 0x18);
        uint64_t v17 = *(void *)(v16 + 48);
      }
      {
        uint64_t v43 = Values;
        uint64_t Values = v43;
        if (v44)
        {
          uint64_t v69 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
          unint64_t v70 = 89;
          unint64_t v45 = llvm::StringRef::find((uint64_t *)&v69, "DesiredTypeName = ", 0x12uLL, 0);
          if (v70 >= v45) {
            unint64_t v46 = v45;
          }
          else {
            unint64_t v46 = v70;
          }
          uint64_t v47 = (char *)v69 + v46;
          unint64_t v48 = v70 - v46;
          uint64_t v49 = 18;
          if (v48 < 0x12) {
            uint64_t v49 = v48;
          }
          unint64_t v50 = v48 - v49;
          if (v50 >= v50 - 1) {
            uint64_t v51 = v50 - 1;
          }
          else {
            uint64_t v51 = v50;
          }
          mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v47[v49], v51);
          uint64_t Values = v43;
        }
      }
      if (!(*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)Values + 104))(Values, mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id, v17))
      {
LABEL_53:
        uint64_t v16 = 0;
        uint64_t v41 = 0;
        goto LABEL_57;
      }
LABEL_39:
      uint64_t v28 = *(void *)(v16 + 48);
      uint64_t v29 = *(void **)(v28 + 16);
      if (v29 == &mlir::detail::TypeIDResolver<void,void>::id) {
        uint64_t v30 = 0;
      }
      else {
        uint64_t v30 = *(void *)(v16 + 48);
      }
      if (v29 == &mlir::detail::TypeIDResolver<void,void>::id)
      {
        uint64_t v69 = *(void ***)(v28 + 8);
        uint64_t v39 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v69);
        if (v39)
        {
          uint64_t v40 = v28;
          goto LABEL_56;
        }
        uint64_t v41 = 0;
      }
      else
      {
        {
          uint64_t v69 = (void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
          unint64_t v70 = 89;
          unint64_t v59 = llvm::StringRef::find((uint64_t *)&v69, "DesiredTypeName = ", 0x12uLL, 0);
          if (v70 >= v59) {
            unint64_t v60 = v59;
          }
          else {
            unint64_t v60 = v70;
          }
          uint64_t v61 = (char *)v69 + v60;
          unint64_t v62 = v70 - v60;
          uint64_t v63 = 18;
          if (v62 < 0x12) {
            uint64_t v63 = v62;
          }
          unint64_t v64 = v62 - v63;
          if (v64 >= v64 - 1) {
            uint64_t v65 = v64 - 1;
          }
          else {
            uint64_t v65 = v64;
          }
          mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
        }
        unint64_t v31 = v30 | v28 & 0xFFFFFFFFFFFFFF00;
        unint64_t v32 = *(unsigned int *)(v31 + 0x28);
        if (!v32) {
          goto LABEL_52;
        }
        long long v33 = *(void **)((v30 | v28 & 0xFFFFFFFFFFFFFF00) + 0x20);
        uint64_t v34 = &v33[2 * v32];
        do
        {
          unint64_t v35 = v32 >> 1;
          __int16 v36 = &v33[2 * (v32 >> 1)];
          unint64_t v38 = *v36;
          uint64_t v37 = v36 + 2;
          v32 += ~(v32 >> 1);
          if (v38 < mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id) {
            long long v33 = v37;
          }
          else {
            unint64_t v32 = v35;
          }
        }
        while (v32);
        if (v33 == v34
          || *v33 != mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id
          || (uint64_t v41 = v33[1]) == 0)
        {
LABEL_52:
          uint64_t v39 = *(void *)(v31 + 24);
          uint64_t v40 = *(void *)(v16 + 48);
LABEL_56:
          uint64_t v41 = mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchTerminatorOpInterface>(v39, v40);
        }
      }
LABEL_57:
      if (v16)
      {
        uint64_t v42 = v78;
        if (v78 >= (unint64_t)HIDWORD(v78))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v77, v79, v78 + 1, 16);
          uint64_t v42 = v78;
        }
        uint64_t v13 = (char *)v77 + 16 * v42;
        void *v13 = v16;
        v13[1] = v41;
        LODWORD(v78) = v78 + 1;
      }
      BOOL v12 = (mlir::Region *)*((void *)v12 + 1);
    }
    while (v12 != v10);
    if (!v78) {
      goto LABEL_98;
    }
    uint64_t v69 = &v77;
    unint64_t v70 = (unint64_t)&v73;
    uint64_t v71 = &v76;
    int v72 = v10;
    int v66 = verifyTypesAlongAllEdges(v76, v10, (void (*)(void *__return_ptr, void, void))llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_2>, (uint64_t)&v69) == 0;
    int v67 = v77;
    if (v77 == v79) {
      goto LABEL_100;
    }
LABEL_99:
    free(v67);
LABEL_100:
    if (v66 != 3 && v66) {
      return 0;
    }
    uint64_t v10 = (mlir::Region *)((char *)v10 + 24);
    if (v10 != v11) {
      continue;
    }
    return 1;
  }
}

uint64_t verifyTypesAlongAllEdges(uint64_t *a1, mlir::Region *a2, void (*a3)(void *__return_ptr, void, void), uint64_t a4)
{
  void (*v135)(void *__return_ptr, void, void);
  __n128 v136;
  uint64_t v137;
  __int16 v138;
  __n128 v139;
  void *v140;
  unsigned int v141;
  unsigned int v142;
  unsigned char v143[96];
  void *v144;
  void *v145;
  void *__p;
  void **v147;
  char v148;
  __n128 v149;
  uint64_t v150;
  uint64_t v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  char v155;
  unint64_t *v156;
  uint64_t v157;
  void v158[8];

  v158[6] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    goto LABEL_11;
  }
  uint64_t v8 = a1[6];
  unint64_t v9 = *(void **)(v8 + 16);
  BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = a1[6];
  }
  if (v10)
  {
    v139.n128_u64[0] = *(void *)(v8 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v139);
    if (Values)
    {
      uint64_t v15 = v8;
      goto LABEL_10;
    }
LABEL_11:
    uint64_t v13 = 0;
    goto LABEL_12;
  }
  unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
  uint64_t v13 = mlir::detail::InterfaceMap::lookup<mlir::RegionBranchOpInterface>(v12 + 32);
  if (!v13)
  {
    uint64_t Values = *(void *)(v12 + 24);
    uint64_t v15 = a1[6];
LABEL_10:
    uint64_t v13 = mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>(Values, v15);
  }
LABEL_12:
  uint64_t v156 = v158;
  uint64_t v157 = 0x200000000;
  (*(void (**)(uint64_t, uint64_t *, mlir::Region *, unint64_t **))(v13 + 16))(v13, a1, a2, &v156);
  if (!v157)
  {
    uint64_t v63 = 1;
    goto LABEL_85;
  }
  unint64_t v133 = a2;
  uint64_t v16 = v156;
  uint64_t v134 = &v156[3 * v157];
  int v135 = a3;
  while (1)
  {
    a3(&v153, a4, *v16);
    if (!v155)
    {
      uint64_t v63 = 0;
      goto LABEL_85;
    }
    int v136 = *(__n128 *)(v16 + 1);
    mlir::ValueRange::getTypes(&v136, &v149);
    unint64_t v18 = v149.n128_u64[1];
    unint64_t v17 = v149.n128_u64[0];
    uint64_t v19 = v150;
    uint64_t v139 = v149;
    if (v149.n128_u64[1])
    {
      unint64_t v17 = mlir::ValueRange::offset_base(&v139, v149.n128_i64[1]);
      unint64_t v18 = v139.n128_u64[1];
    }
    mlir::TypeRange::TypeRange((unint64_t *)&v151, v17, v19 - v18);
    unint64_t v20 = v154;
    if (v154 != v152) {
      break;
    }
    if (v154)
    {
      uint64_t v21 = 0;
      uint64_t v22 = v153;
      uint64_t v23 = v151;
      while (1)
      {
        unint64_t v24 = mlir::TypeRange::dereference_iterator(v22, v21);
        unint64_t v25 = mlir::TypeRange::dereference_iterator(v23, v21);
        if (((*(uint64_t (**)(uint64_t, uint64_t *, unint64_t, unint64_t))(v13 + 32))(v13, a1, v24, v25) & 1) == 0)break; {
        if (v20 == ++v21)
        }
          goto LABEL_14;
      }
      v136.n128_u64[0] = (unint64_t)" along control flow edge ";
      unint64_t v138 = 259;
      mlir::Operation::emitOpError(a1, (const void ***)&v136, (uint64_t)&v139);
      printRegionEdgeName((uint64_t *)&v139, v133, *v16);
      if (v139.n128_u64[0])
      {
        v136.n128_u32[0] = 3;
        v136.n128_u64[1] = (unint64_t)": source type #";
        unint64_t v137 = 15;
        unint64_t v26 = &v136;
        uint64_t v27 = (char *)v140;
        if (v141 >= v142)
        {
          unint64_t v101 = v141 + 1;
          if (v140 <= &v136 && (char *)v140 + 24 * v141 > (char *)&v136)
          {
            int64_t v121 = (char *)&v136 - (unsigned char *)v140;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v101, 24);
            uint64_t v27 = (char *)v140;
            unint64_t v26 = (__n128 *)((char *)v140 + v121);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v101, 24);
            unint64_t v26 = &v136;
            uint64_t v27 = (char *)v140;
          }
        }
        uint64_t v28 = &v27[24 * v141];
        __n128 v29 = *v26;
        *((void *)v28 + 2) = v26[1].n128_u64[0];
        *(__n128 *)uint64_t v28 = v29;
        uint64_t v30 = ++v141;
        if (v139.n128_u64[0])
        {
          v136.n128_u32[0] = 5;
          v136.n128_u64[1] = v21;
          unint64_t v31 = &v136;
          unint64_t v32 = (char *)v140;
          if (v30 >= v142)
          {
            unint64_t v102 = v30 + 1;
            BOOL v103 = (char *)v140 + 24 * v30 > (char *)&v136;
            if (v140 <= &v136 && v103)
            {
              int64_t v122 = (char *)&v136 - (unsigned char *)v140;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v102, 24);
              unint64_t v32 = (char *)v140;
              unint64_t v31 = (__n128 *)((char *)v140 + v122);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v102, 24);
              unint64_t v31 = &v136;
              unint64_t v32 = (char *)v140;
            }
          }
          long long v33 = &v32[24 * v141];
          __n128 v34 = *v31;
          *((void *)v33 + 2) = v31[1].n128_u64[0];
          *(__n128 *)long long v33 = v34;
          uint64_t v35 = ++v141;
          if (v139.n128_u64[0])
          {
            v136.n128_u32[0] = 3;
            v136.n128_u64[1] = (unint64_t)" ";
            unint64_t v137 = 1;
            __int16 v36 = &v136;
            uint64_t v37 = (char *)v140;
            if (v35 >= v142)
            {
              unint64_t v104 = v35 + 1;
              BOOL v105 = (char *)v140 + 24 * v35 > (char *)&v136;
              if (v140 <= &v136 && v105)
              {
                int64_t v123 = (char *)&v136 - (unsigned char *)v140;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v104, 24);
                uint64_t v37 = (char *)v140;
                __int16 v36 = (__n128 *)((char *)v140 + v123);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v104, 24);
                __int16 v36 = &v136;
                uint64_t v37 = (char *)v140;
              }
            }
            unint64_t v38 = &v37[24 * v141];
            __n128 v39 = *v36;
            *((void *)v38 + 2) = v36[1].n128_u64[0];
            *(__n128 *)unint64_t v38 = v39;
            ++v141;
            if (v139.n128_u64[0])
            {
              uint64_t v40 = &v136;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v136, v24);
              uint64_t v41 = (char *)v140;
              if (v141 >= v142)
              {
                unint64_t v106 = v141 + 1;
                if (v140 <= &v136 && (char *)v140 + 24 * v141 > (char *)&v136)
                {
                  int64_t v124 = (char *)&v136 - (unsigned char *)v140;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v106, 24);
                  uint64_t v41 = (char *)v140;
                  uint64_t v40 = (__n128 *)((char *)v140 + v124);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v106, 24);
                  uint64_t v40 = &v136;
                  uint64_t v41 = (char *)v140;
                }
              }
              uint64_t v42 = &v41[24 * v141];
              __n128 v43 = *v40;
              *((void *)v42 + 2) = v40[1].n128_u64[0];
              *(__n128 *)uint64_t v42 = v43;
              uint64_t v44 = ++v141;
              if (v139.n128_u64[0])
              {
                v136.n128_u32[0] = 3;
                v136.n128_u64[1] = (unint64_t)" should match input type #";
                unint64_t v137 = 26;
                unint64_t v45 = &v136;
                unint64_t v46 = (char *)v140;
                if (v44 >= v142)
                {
                  unint64_t v107 = v44 + 1;
                  BOOL v108 = (char *)v140 + 24 * v44 > (char *)&v136;
                  if (v140 <= &v136 && v108)
                  {
                    int64_t v125 = (char *)&v136 - (unsigned char *)v140;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v107, 24);
                    unint64_t v46 = (char *)v140;
                    unint64_t v45 = (__n128 *)((char *)v140 + v125);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v107, 24);
                    unint64_t v45 = &v136;
                    unint64_t v46 = (char *)v140;
                  }
                }
                uint64_t v47 = &v46[24 * v141];
                __n128 v48 = *v45;
                *((void *)v47 + 2) = v45[1].n128_u64[0];
                *(__n128 *)uint64_t v47 = v48;
                uint64_t v49 = ++v141;
                if (v139.n128_u64[0])
                {
                  v136.n128_u32[0] = 5;
                  v136.n128_u64[1] = v21;
                  unint64_t v50 = &v136;
                  uint64_t v51 = (char *)v140;
                  if (v49 >= v142)
                  {
                    unint64_t v110 = v49 + 1;
                    BOOL v111 = (char *)v140 + 24 * v49 > (char *)&v136;
                    if (v140 <= &v136 && v111)
                    {
                      int64_t v127 = (char *)&v136 - (unsigned char *)v140;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v110, 24);
                      uint64_t v51 = (char *)v140;
                      unint64_t v50 = (__n128 *)((char *)v140 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v110, 24);
                      unint64_t v50 = &v136;
                      uint64_t v51 = (char *)v140;
                    }
                  }
                  unint64_t v52 = &v51[24 * v141];
                  __n128 v53 = *v50;
                  *((void *)v52 + 2) = v50[1].n128_u64[0];
                  *(__n128 *)unint64_t v52 = v53;
                  uint64_t v54 = ++v141;
                  if (v139.n128_u64[0])
                  {
                    v136.n128_u32[0] = 3;
                    v136.n128_u64[1] = (unint64_t)" ";
                    unint64_t v137 = 1;
                    unint64_t v55 = &v136;
                    uint64_t v56 = (char *)v140;
                    if (v54 >= v142)
                    {
                      unint64_t v114 = v54 + 1;
                      BOOL v115 = (char *)v140 + 24 * v54 > (char *)&v136;
                      if (v140 <= &v136 && v115)
                      {
                        int64_t v129 = (char *)&v136 - (unsigned char *)v140;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v114, 24);
                        uint64_t v56 = (char *)v140;
                        unint64_t v55 = (__n128 *)((char *)v140 + v129);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v114, 24);
                        unint64_t v55 = &v136;
                        uint64_t v56 = (char *)v140;
                      }
                    }
                    unint64_t v57 = &v56[24 * v141];
                    __n128 v58 = *v55;
                    *((void *)v57 + 2) = v55[1].n128_u64[0];
                    *(__n128 *)unint64_t v57 = v58;
                    ++v141;
                    if (v139.n128_u64[0])
                    {
                      unint64_t v59 = &v136;
                      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v136, v25);
                      unint64_t v60 = (char *)v140;
                      if (v141 >= v142)
                      {
                        unint64_t v118 = v141 + 1;
                        if (v140 <= &v136 && (char *)v140 + 24 * v141 > (char *)&v136)
                        {
                          int64_t v131 = (char *)&v136 - (unsigned char *)v140;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v118, 24);
                          unint64_t v60 = (char *)v140;
                          unint64_t v59 = (__n128 *)((char *)v140 + v131);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v118, 24);
                          unint64_t v59 = &v136;
                          unint64_t v60 = (char *)v140;
                        }
                      }
                      uint64_t v61 = &v60[24 * v141];
                      __n128 v62 = *v59;
                      *((void *)v61 + 2) = v59[1].n128_u64[0];
                      *(__n128 *)uint64_t v61 = v62;
                      ++v141;
                    }
                  }
                }
              }
            }
          }
        }
      }
      uint64_t v63 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
      if (v139.n128_u64[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
      }
      if (v148)
      {
        unint64_t v64 = (void **)__p;
        if (__p)
        {
          uint64_t v65 = v147;
          int v66 = __p;
          if (v147 != __p)
          {
            do
              uint64_t v65 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v65 - 1);
            while (v65 != v64);
            int v66 = __p;
          }
          uint64_t v147 = v64;
          operator delete(v66);
        }
        int v67 = v144;
        if (v144)
        {
          unint64_t v68 = v145;
          uint64_t v69 = v144;
          if (v145 != v144)
          {
            do
            {
              uint64_t v71 = (void *)*--v68;
              unint64_t v70 = v71;
              *unint64_t v68 = 0;
              if (v71) {
                operator delete[](v70);
              }
            }
            while (v68 != v67);
            uint64_t v69 = v144;
          }
          uint64_t v145 = v67;
          operator delete(v69);
        }
        int v72 = v140;
        if (v140 != v143) {
          goto LABEL_59;
        }
      }
      goto LABEL_85;
    }
LABEL_14:
    v16 += 3;
    a3 = v135;
    if (v16 == v134)
    {
      uint64_t v63 = 1;
      goto LABEL_85;
    }
  }
  v136.n128_u64[0] = (unint64_t)" region control flow edge ";
  unint64_t v138 = 259;
  mlir::Operation::emitOpError(a1, (const void ***)&v136, (uint64_t)&v139);
  printRegionEdgeName((uint64_t *)&v139, v133, *v16);
  if (v139.n128_u64[0])
  {
    v136.n128_u32[0] = 3;
    v136.n128_u64[1] = (unint64_t)": source has ";
    unint64_t v137 = 13;
    int v73 = &v136;
    unint64_t v74 = (char *)v140;
    if (v141 >= v142)
    {
      unint64_t v109 = v141 + 1;
      if (v140 <= &v136 && (char *)v140 + 24 * v141 > (char *)&v136)
      {
        int64_t v126 = (char *)&v136 - (unsigned char *)v140;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v109, 24);
        unint64_t v74 = (char *)v140;
        int v73 = (__n128 *)((char *)v140 + v126);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v109, 24);
        int v73 = &v136;
        unint64_t v74 = (char *)v140;
      }
    }
    long long v75 = &v74[24 * v141];
    __n128 v76 = *v73;
    *((void *)v75 + 2) = v73[1].n128_u64[0];
    *(__n128 *)long long v75 = v76;
    uint64_t v77 = ++v141;
    if (v139.n128_u64[0])
    {
      v136.n128_u32[0] = 5;
      v136.n128_u64[1] = v154;
      uint64_t v78 = &v136;
      unint64_t v79 = (char *)v140;
      if (v77 >= v142)
      {
        unint64_t v112 = v77 + 1;
        BOOL v113 = (char *)v140 + 24 * v77 > (char *)&v136;
        if (v140 <= &v136 && v113)
        {
          int64_t v128 = (char *)&v136 - (unsigned char *)v140;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v112, 24);
          unint64_t v79 = (char *)v140;
          uint64_t v78 = (__n128 *)((char *)v140 + v128);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v112, 24);
          uint64_t v78 = &v136;
          unint64_t v79 = (char *)v140;
        }
      }
      uint64_t v80 = &v79[24 * v141];
      __n128 v81 = *v78;
      *((void *)v80 + 2) = v78[1].n128_u64[0];
      *(__n128 *)uint64_t v80 = v81;
      uint64_t v82 = ++v141;
      if (v139.n128_u64[0])
      {
        v136.n128_u32[0] = 3;
        v136.n128_u64[1] = (unint64_t)" operands, but target successor needs ";
        unint64_t v137 = 38;
        unint64_t v83 = &v136;
        unint64_t v84 = (char *)v140;
        if (v82 >= v142)
        {
          unint64_t v116 = v82 + 1;
          BOOL v117 = (char *)v140 + 24 * v82 > (char *)&v136;
          if (v140 <= &v136 && v117)
          {
            int64_t v130 = (char *)&v136 - (unsigned char *)v140;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v116, 24);
            unint64_t v84 = (char *)v140;
            unint64_t v83 = (__n128 *)((char *)v140 + v130);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v116, 24);
            unint64_t v83 = &v136;
            unint64_t v84 = (char *)v140;
          }
        }
        BOOL v85 = &v84[24 * v141];
        __n128 v86 = *v83;
        *((void *)v85 + 2) = v83[1].n128_u64[0];
        *(__n128 *)BOOL v85 = v86;
        uint64_t v87 = ++v141;
        if (v139.n128_u64[0])
        {
          v136.n128_u32[0] = 5;
          v136.n128_u64[1] = v152;
          unint64_t v88 = &v136;
          unint64_t v89 = (char *)v140;
          if (v87 >= v142)
          {
            unint64_t v119 = v87 + 1;
            BOOL v120 = (char *)v140 + 24 * v87 > (char *)&v136;
            if (v140 <= &v136 && v120)
            {
              int64_t v132 = (char *)&v136 - (unsigned char *)v140;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v119, 24);
              unint64_t v89 = (char *)v140;
              unint64_t v88 = (__n128 *)((char *)v140 + v132);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v140, v143, v119, 24);
              unint64_t v88 = &v136;
              unint64_t v89 = (char *)v140;
            }
          }
          BOOL v90 = &v89[24 * v141];
          __n128 v91 = *v88;
          *((void *)v90 + 2) = v88[1].n128_u64[0];
          *(__n128 *)BOOL v90 = v91;
          ++v141;
        }
      }
    }
  }
  uint64_t v63 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
  if (v139.n128_u64[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
  }
  if (v148)
  {
    BOOL v92 = (void **)__p;
    if (__p)
    {
      unint64_t v93 = v147;
      BOOL v94 = __p;
      if (v147 != __p)
      {
        do
          unint64_t v93 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v93 - 1);
        while (v93 != v92);
        BOOL v94 = __p;
      }
      uint64_t v147 = v92;
      operator delete(v94);
    }
    unint64_t v95 = v144;
    if (v144)
    {
      BOOL v96 = v145;
      unint64_t v97 = v144;
      if (v145 != v144)
      {
        do
        {
          BOOL v99 = (void *)*--v96;
          unint64_t v98 = v99;
          *BOOL v96 = 0;
          if (v99) {
            operator delete[](v98);
          }
        }
        while (v96 != v95);
        unint64_t v97 = v144;
      }
      uint64_t v145 = v95;
      operator delete(v97);
    }
    int v72 = v140;
    if (v140 != v143) {
LABEL_59:
    }
      free(v72);
  }
LABEL_85:
  if (v156 != v158) {
    free(v156);
  }
  return v63;
}

uint64_t llvm::SmallVectorImpl<std::pair<unsigned int,mlir::NamedAttribute>>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    BOOL v5 = a2 + 2;
    uint64_t v4 = *a2;
    if ((uint64_t *)*a2 != a2 + 2)
    {
      uint64_t v6 = *(char **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *a2;
      }
      *(void *)a1 = v4;
      unint64_t v7 = a2 + 1;
      *(void *)(a1 + 8) = a2[1];
      *a2 = (uint64_t)v5;
      *((_DWORD *)a2 + 3) = 0;
      goto LABEL_20;
    }
    unint64_t v7 = a2 + 1;
    unint64_t v8 = *((unsigned int *)a2 + 2);
    uint64_t v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if (v8)
      {
        uint64_t v11 = *(char **)a1;
        uint64_t v12 = v4 + 24 * v8;
        do
        {
          *(_DWORD *)uint64_t v11 = *(_DWORD *)v4;
          *(_OWORD *)(v11 + 8) = *(_OWORD *)(v4 + 8);
          v4 += 24;
          v11 += 24;
        }
        while (v4 != v12);
      }
      goto LABEL_19;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if (v9)
      {
        uint64_t v13 = v4 + 24 * v9;
        unint64_t v14 = *(char **)a1;
        do
        {
          *(_DWORD *)unint64_t v14 = *(_DWORD *)v4;
          *(_OWORD *)(v14 + 8) = *(_OWORD *)(v4 + 8);
          v4 += 24;
          v14 += 24;
        }
        while (v4 != v13);
        uint64_t v10 = *v7;
        if (v9 == v10) {
          goto LABEL_19;
        }
      }
      else
      {
        uint64_t v9 = 0;
        LODWORD(v10) = *v7;
        if (!*v7) {
          goto LABEL_19;
        }
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 24);
      uint64_t v9 = 0;
      LODWORD(v10) = *v7;
      if (!*v7) {
        goto LABEL_19;
      }
    }
    memcpy((void *)(*(void *)a1 + 24 * v9), (const void *)(*a2 + 24 * v9), *a2 + 24 * v10 - (*a2 + 24 * v9));
LABEL_19:
    *(_DWORD *)(a1 + 8) = v8;
LABEL_20:
    *unint64_t v7 = 0;
  }
  return a1;
}

uint64_t *printRegionEdgeName(uint64_t *a1, mlir::Region *this, unint64_t a3)
{
  if (*a1)
  {
    uint64_t v6 = (uint64_t)(a1 + 3);
    unint64_t v7 = a1[3];
    int v85 = 3;
    __n128 v86 = "from ";
    uint64_t v87 = 5;
    uint64_t v8 = *((unsigned int *)a1 + 8);
    uint64_t v9 = &v85;
    if (v8 >= *((_DWORD *)a1 + 9))
    {
      unint64_t v61 = v8 + 1;
      BOOL v62 = v7 + 24 * v8 > (unint64_t)&v85;
      if (v7 <= (unint64_t)&v85 && v62)
      {
        uint64_t v77 = (char *)&v85 - v7;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v6, a1 + 5, v61, 24);
        unint64_t v7 = a1[3];
        uint64_t v9 = (int *)&v77[v7];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v6, a1 + 5, v61, 24);
        unint64_t v7 = a1[3];
        uint64_t v9 = &v85;
      }
    }
    uint64_t v10 = v7 + 24 * *((unsigned int *)a1 + 8);
    long long v11 = *(_OWORD *)v9;
    *(void *)(v10 + 16) = *((void *)v9 + 2);
    *(_OWORD *)uint64_t v10 = v11;
    ++*((_DWORD *)a1 + 8);
  }
  uint64_t v12 = *a1;
  if (this)
  {
    if (v12)
    {
      uint64_t v13 = (uint64_t)(a1 + 3);
      unint64_t v14 = a1[3];
      int v85 = 3;
      __n128 v86 = "Region #";
      uint64_t v87 = 8;
      uint64_t v15 = *((unsigned int *)a1 + 8);
      uint64_t v16 = &v85;
      if (v15 >= *((_DWORD *)a1 + 9))
      {
        unint64_t v63 = v15 + 1;
        BOOL v64 = v14 + 24 * v15 > (unint64_t)&v85;
        if (v14 <= (unint64_t)&v85 && v64)
        {
          uint64_t v78 = (char *)&v85 - v14;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, a1 + 5, v63, 24);
          unint64_t v14 = a1[3];
          uint64_t v16 = (int *)&v78[v14];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v13, a1 + 5, v63, 24);
          unint64_t v14 = a1[3];
          uint64_t v16 = &v85;
        }
      }
      uint64_t v17 = v14 + 24 * *((unsigned int *)a1 + 8);
      long long v18 = *(_OWORD *)v16;
      *(void *)(v17 + 16) = *((void *)v16 + 2);
      *(_OWORD *)uint64_t v17 = v18;
      ++*((_DWORD *)a1 + 8);
    }
    unsigned int RegionNumber = mlir::Region::getRegionNumber((unint64_t)this);
    if (!*a1) {
      goto LABEL_17;
    }
    unsigned int v20 = RegionNumber;
    uint64_t v21 = (uint64_t)(a1 + 3);
    unint64_t v22 = a1[3];
    int v85 = 5;
    __n128 v86 = (const char *)v20;
    uint64_t v23 = *((unsigned int *)a1 + 8);
    unint64_t v24 = &v85;
    if (v23 >= *((_DWORD *)a1 + 9))
    {
      unint64_t v65 = v23 + 1;
      BOOL v66 = v22 + 24 * v23 > (unint64_t)&v85;
      if (v22 <= (unint64_t)&v85 && v66)
      {
        unint64_t v79 = (char *)&v85 - v22;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v21, a1 + 5, v65, 24);
        unint64_t v22 = a1[3];
        unint64_t v24 = (int *)&v79[v22];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v21, a1 + 5, v65, 24);
        unint64_t v22 = a1[3];
        unint64_t v24 = &v85;
      }
    }
    uint64_t v25 = v22 + 24 * *((unsigned int *)a1 + 8);
    long long v26 = *(_OWORD *)v24;
    *(void *)(v25 + 16) = *((void *)v24 + 2);
    *(_OWORD *)uint64_t v25 = v26;
    unsigned int v27 = *((_DWORD *)a1 + 8) + 1;
    *((_DWORD *)a1 + 8) = v27;
    if (!*a1) {
      goto LABEL_17;
    }
LABEL_15:
    uint64_t v34 = (uint64_t)(a1 + 3);
    unint64_t v35 = a1[3];
    int v85 = 3;
    __n128 v86 = " to ";
    uint64_t v87 = 4;
    __int16 v36 = &v85;
    if (v27 >= *((_DWORD *)a1 + 9))
    {
      unint64_t v67 = v27 + 1;
      BOOL v68 = v35 + 24 * v27 > (unint64_t)&v85;
      if (v35 <= (unint64_t)&v85 && v68)
      {
        uint64_t v80 = (char *)&v85 - v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v34, a1 + 5, v67, 24);
        unint64_t v35 = a1[3];
        __int16 v36 = (int *)&v80[v35];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v34, a1 + 5, v67, 24);
        unint64_t v35 = a1[3];
        __int16 v36 = &v85;
      }
    }
    uint64_t v37 = v35 + 24 * *((unsigned int *)a1 + 8);
    long long v38 = *(_OWORD *)v36;
    *(void *)(v37 + 16) = *((void *)v36 + 2);
    *(_OWORD *)uint64_t v37 = v38;
    ++*((_DWORD *)a1 + 8);
    goto LABEL_17;
  }
  if (v12)
  {
    uint64_t v28 = (uint64_t)(a1 + 3);
    unint64_t v29 = a1[3];
    int v85 = 3;
    __n128 v86 = "parent operands";
    uint64_t v87 = 15;
    uint64_t v30 = *((unsigned int *)a1 + 8);
    unint64_t v31 = &v85;
    if (v30 >= *((_DWORD *)a1 + 9))
    {
      unint64_t v73 = v30 + 1;
      BOOL v74 = v29 + 24 * v30 > (unint64_t)&v85;
      if (v29 <= (unint64_t)&v85 && v74)
      {
        unint64_t v83 = (char *)&v85 - v29;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v28, a1 + 5, v73, 24);
        unint64_t v29 = a1[3];
        unint64_t v31 = (int *)&v83[v29];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v28, a1 + 5, v73, 24);
        unint64_t v29 = a1[3];
        unint64_t v31 = &v85;
      }
    }
    uint64_t v32 = v29 + 24 * *((unsigned int *)a1 + 8);
    long long v33 = *(_OWORD *)v31;
    *(void *)(v32 + 16) = *((void *)v31 + 2);
    *(_OWORD *)uint64_t v32 = v33;
    unsigned int v27 = *((_DWORD *)a1 + 8) + 1;
    *((_DWORD *)a1 + 8) = v27;
    if (*a1) {
      goto LABEL_15;
    }
  }
LABEL_17:
  uint64_t v39 = *a1;
  if (a3)
  {
    if (v39)
    {
      uint64_t v40 = (uint64_t)(a1 + 3);
      unint64_t v41 = a1[3];
      int v85 = 3;
      __n128 v86 = "Region #";
      uint64_t v87 = 8;
      uint64_t v42 = *((unsigned int *)a1 + 8);
      __n128 v43 = &v85;
      if (v42 >= *((_DWORD *)a1 + 9))
      {
        unint64_t v69 = v42 + 1;
        BOOL v70 = v41 + 24 * v42 > (unint64_t)&v85;
        if (v41 <= (unint64_t)&v85 && v70)
        {
          __n128 v81 = (char *)&v85 - v41;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v40, a1 + 5, v69, 24);
          unint64_t v41 = a1[3];
          __n128 v43 = (int *)&v81[v41];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v40, a1 + 5, v69, 24);
          unint64_t v41 = a1[3];
          __n128 v43 = &v85;
        }
      }
      uint64_t v44 = v41 + 24 * *((unsigned int *)a1 + 8);
      long long v45 = *(_OWORD *)v43;
      *(void *)(v44 + 16) = *((void *)v43 + 2);
      *(_OWORD *)uint64_t v44 = v45;
      ++*((_DWORD *)a1 + 8);
    }
    unsigned int v46 = mlir::Region::getRegionNumber(a3);
    if (*a1)
    {
      unsigned int v47 = v46;
      uint64_t v48 = (uint64_t)(a1 + 3);
      unint64_t v49 = a1[3];
      int v85 = 5;
      __n128 v86 = (const char *)v47;
      uint64_t v50 = *((unsigned int *)a1 + 8);
      uint64_t v51 = &v85;
      if (v50 >= *((_DWORD *)a1 + 9))
      {
        unint64_t v71 = v50 + 1;
        BOOL v72 = v49 + 24 * v50 > (unint64_t)&v85;
        if (v49 <= (unint64_t)&v85 && v72)
        {
          uint64_t v82 = (char *)&v85 - v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v48, a1 + 5, v71, 24);
          unint64_t v49 = a1[3];
          uint64_t v51 = (int *)&v82[v49];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v48, a1 + 5, v71, 24);
          unint64_t v49 = a1[3];
          uint64_t v51 = &v85;
        }
      }
      uint64_t v52 = v49 + 24 * *((unsigned int *)a1 + 8);
      long long v53 = *(_OWORD *)v51;
      *(void *)(v52 + 16) = *((void *)v51 + 2);
      *(_OWORD *)uint64_t v52 = v53;
LABEL_27:
      ++*((_DWORD *)a1 + 8);
    }
  }
  else if (v39)
  {
    uint64_t v54 = (uint64_t)(a1 + 3);
    unint64_t v55 = a1[3];
    int v85 = 3;
    __n128 v86 = "parent results";
    uint64_t v87 = 14;
    uint64_t v56 = *((unsigned int *)a1 + 8);
    unint64_t v57 = &v85;
    if (v56 >= *((_DWORD *)a1 + 9))
    {
      unint64_t v75 = v56 + 1;
      BOOL v76 = v55 + 24 * v56 > (unint64_t)&v85;
      if (v55 <= (unint64_t)&v85 && v76)
      {
        unint64_t v84 = (char *)&v85 - v55;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v54, a1 + 5, v75, 24);
        unint64_t v55 = a1[3];
        unint64_t v57 = (int *)&v84[v55];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v54, a1 + 5, v75, 24);
        unint64_t v55 = a1[3];
        unint64_t v57 = &v85;
      }
    }
    uint64_t v58 = v55 + 24 * *((unsigned int *)a1 + 8);
    long long v59 = *(_OWORD *)v57;
    *(void *)(v58 + 16) = *((void *)v57 + 2);
    *(_OWORD *)uint64_t v58 = v59;
    goto LABEL_27;
  }
  return a1;
}

double llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_0>@<D0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v10[2] = *MEMORY[0x1E4F143B8];
  v5[0] = (**(uint64_t (***)(void))(*(void *)a1 + 8))();
  v5[1] = v3;
  mlir::OperandRange::getTypes(v5, &v6);
  mlir::ValueRange::ValueRange(v10, v6 + 32 * v7, v8 - v7);
  mlir::TypeRange::TypeRange(v9, v10[0], v10[1]);
  double result = *(double *)v9;
  *(_OWORD *)a2 = *(_OWORD *)v9;
  *(unsigned char *)(a2 + 16) = 1;
  return result;
}

void llvm::function_ref<mlir::FailureOr<mlir::TypeRange> ()(mlir::RegionBranchPoint)>::callback_fn<mlir::detail::verifyTypesAlongControlFlowEdges(mlir::Operation *)::$_2>(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  LOBYTE(v41) = 0;
  char v42 = 0;
  uint64_t v3 = *(uint64_t **)a1;
  uint64_t v4 = *(unsigned int *)(*(void *)a1 + 8);
  if (!v4)
  {
LABEL_20:
    mlir::OperandRange::getTypes((uint64_t *)&v41, &v47);
    mlir::ValueRange::ValueRange((unint64_t *)&v43, v47 + 32 * v48, (unint64_t)v50 - v48);
    *((unsigned char *)mlir::TypeRange::TypeRange((unint64_t *)a3, (uint64_t)v43, (unint64_t)v44) + 16) = 1;
    return;
  }
  uint64_t v7 = *v3;
  uint64_t v33 = *v3 + 16 * v4;
  while (1)
  {
    (**(void (***)(uint64_t *__return_ptr))(v7 + 8))(&v47);
    uint64_t v8 = mlir::MutableOperandRange::operator mlir::OperandRange((unsigned int *)&v47);
    uint64_t v10 = v9;
    if (v49 != v51) {
      free(v49);
    }
    *(void *)&long long v40 = v8;
    *((void *)&v40 + 1) = v10;
    if (!v42)
    {
      long long v41 = v40;
      char v42 = 1;
      goto LABEL_4;
    }
    uint64_t v11 = *(void *)(a1 + 8);
    mlir::OperandRange::getTypes((uint64_t *)&v41, &v37);
    mlir::ValueRange::ValueRange((unint64_t *)&v47, v37 + 32 * v38, v39 - v38);
    mlir::TypeRange::TypeRange((unint64_t *)&v59, v47, v48);
    mlir::OperandRange::getTypes((uint64_t *)&v40, &v34);
    mlir::ValueRange::ValueRange((unint64_t *)&v47, v34 + 32 * v35, v36 - v35);
    mlir::TypeRange::TypeRange(v58, v47, v48);
    uint64_t v12 = v60;
    if (v60 != v58[1]) {
      goto LABEL_14;
    }
    if (v60) {
      break;
    }
LABEL_4:
    v7 += 16;
    if (v7 == v33) {
      goto LABEL_20;
    }
  }
  uint64_t v13 = 0;
  uint64_t v14 = v59;
  uint64_t v15 = v58[0];
  while (1)
  {
    mlir::TypeRange::dereference_iterator(v14, v13);
    mlir::TypeRange::dereference_iterator(v15, v13);
    if (!(*(unsigned int (**)(void))(*(void *)(*(void *)v11 + 8) + 32))()) {
      break;
    }
    if (v12 == ++v13) {
      goto LABEL_4;
    }
  }
LABEL_14:
  uint64_t v16 = **(uint64_t ***)(a1 + 16);
  __n128 v43 = (const void **)" along control flow edge";
  __int16 v46 = 259;
  mlir::Operation::emitOpError(v16, &v43, (uint64_t)&v47);
  printRegionEdgeName(&v47, *(mlir::Region **)(a1 + 24), a2);
  if (!v47)
  {
    *(unsigned char *)a3 = 0;
    *(unsigned char *)(a3 + 16) = 0;
    if (!v57) {
      return;
    }
    goto LABEL_22;
  }
  LODWORD(v43) = 3;
  uint64_t v44 = " operands mismatch between return-like terminators";
  uint64_t v45 = 50;
  uint64_t v17 = &v43;
  long long v18 = (char *)v50;
  if (v51[0] >= v51[1])
  {
    unint64_t v30 = v51[0] + 1;
    if (v50 <= &v43 && (char *)v50 + 24 * v51[0] > (char *)&v43)
    {
      int64_t v31 = (char *)&v43 - (unsigned char *)v50;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v30, 24);
      long long v18 = (char *)v50;
      uint64_t v17 = (const void ***)((char *)v50 + v31);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v50, v52, v30, 24);
      uint64_t v17 = &v43;
      long long v18 = (char *)v50;
    }
  }
  uint64_t v19 = &v18[24 * v51[0]];
  long long v20 = *(_OWORD *)v17;
  *((void *)v19 + 2) = v17[2];
  *(_OWORD *)uint64_t v19 = v20;
  ++v51[0];
  uint64_t v21 = v47;
  *(unsigned char *)a3 = 0;
  *(unsigned char *)(a3 + 16) = 0;
  if (v21) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v47);
  }
  if (v57)
  {
LABEL_22:
    unint64_t v22 = (void **)__p;
    if (__p)
    {
      uint64_t v23 = v56;
      unint64_t v24 = __p;
      if (v56 != __p)
      {
        do
          uint64_t v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        unint64_t v24 = __p;
      }
      uint64_t v56 = v22;
      operator delete(v24);
    }
    uint64_t v25 = v53;
    if (v53)
    {
      long long v26 = v54;
      unsigned int v27 = v53;
      if (v54 != v53)
      {
        do
        {
          unint64_t v29 = (void *)*--v26;
          uint64_t v28 = v29;
          void *v26 = 0;
          if (v29) {
            operator delete[](v28);
          }
        }
        while (v26 != v25);
        unsigned int v27 = v53;
      }
      uint64_t v54 = v25;
      operator delete(v27);
    }
    if (v50 != v52) {
      free(v50);
    }
  }
}

uint64_t mlir::OpTrait::util::staticallyKnownBroadcastable(const void *a1, uint64_t a2, char *a3, uint64_t a4)
{
  v50[14] = *MEMORY[0x1E4F143B8];
  __int16 v46 = &v48;
  uint64_t v47 = 0x200000000;
  size_t v9 = 8 * a2;
  unint64_t v48 = v50;
  uint64_t v49 = 0x600000000;
  if ((unint64_t)(8 * a2) < 0x31)
  {
    int v10 = 0;
    if (!a2) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v50, (8 * a2) >> 3, 8);
  int v10 = v49;
  if (a2)
  {
LABEL_5:
    memcpy(&v48[v10], a1, v9);
    int v10 = v49;
  }
LABEL_6:
  uint64_t v11 = (v47 + 1);
  LODWORD(v49) = v10 + (v9 >> 3);
  LODWORD(v47) = v11;
  uint64_t v44 = &a3[8 * a4];
  uint64_t v45 = a3;
  if (v11 < HIDWORD(v47))
  {
    uint64_t v12 = (char *)v46 + 64 * v11;
    void *v12 = v12 + 2;
    v12[1] = 0x600000000;
    int64_t v13 = 8 * a4;
    if ((unint64_t)(8 * a4) < 0x31)
    {
      unsigned int v14 = 0;
      if (!a4) {
        goto LABEL_12;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v12, v12 + 2, v13 >> 3, 8);
      unsigned int v14 = *((_DWORD *)v12 + 2);
      if (!a4)
      {
LABEL_12:
        *((_DWORD *)v12 + 2) = v14 + a4;
        LODWORD(v47) = v47 + 1;
        uint64_t v15 = (unsigned int *)v46;
        uint64_t v16 = v47;
        unint64_t v17 = *((unsigned int *)v46 + 2);
        unint64_t v18 = (unint64_t)v47 << 6;
        if (v47 == 1) {
          goto LABEL_13;
        }
LABEL_16:
        uint64_t v20 = v16 - 1;
        if ((unint64_t)(v16 - 1) >= 4)
        {
          unint64_t v21 = v20 & 0xFFFFFFFFFFFFFFFCLL | 1;
          int8x16_t v22 = (int8x16_t)vdupq_n_s64(v17);
          uint64_t v23 = v15 + 66;
          unint64_t v4 = v20 & 0xFFFFFFFFFFFFFFFCLL;
          int8x16_t v24 = v22;
          do
          {
            v25.i64[0] = *(v23 - 48);
            v25.i64[1] = *(v23 - 32);
            int8x16_t v26 = v25;
            v25.i64[0] = *(v23 - 16);
            v25.i64[1] = *v23;
            int8x16_t v22 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v22, (uint64x2_t)v26), v22, v26);
            int8x16_t v24 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v24, (uint64x2_t)v25), v24, v25);
            v23 += 64;
            v4 -= 4;
          }
          while (v4);
          int8x16_t v27 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v22, (uint64x2_t)v24), v22, v24);
          unint64_t v28 = vextq_s8(v27, v27, 8uLL).u64[0];
          unint64_t v17 = (unint64_t)vbsl_s8((int8x8_t)vcgtd_u64(v27.u64[0], v28), *(int8x8_t *)v27.i8, (int8x8_t)v28);
          if (v20 == (v20 & 0xFFFFFFFFFFFFFFFCLL)) {
            goto LABEL_25;
          }
        }
        else
        {
          unint64_t v21 = 1;
        }
        uint64_t v29 = v16 - v21;
        unint64_t v30 = &v15[16 * v21 + 2];
        do
        {
          unsigned int v32 = *v30;
          v30 += 16;
          unint64_t v31 = v32;
          if (v17 <= v32) {
            unint64_t v17 = v31;
          }
          --v29;
        }
        while (v29);
LABEL_25:
        if (!v17)
        {
LABEL_43:
          uint64_t v19 = 1;
          if (v16) {
            goto LABEL_46;
          }
          goto LABEL_49;
        }
        if (!v16)
        {
          uint64_t v19 = 1;
          if (v15 != (unsigned int *)&v48) {
            goto LABEL_50;
          }
          return v19;
        }
        goto LABEL_27;
      }
    }
    memcpy((void *)(*v12 + 8 * v14), a3, v13);
    unsigned int v14 = *((_DWORD *)v12 + 2);
    goto LABEL_12;
  }
  llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,6u>,false>::growAndEmplaceBack<long long const*,long long const*>((uint64_t)&v46, &v45, (const void **)&v44);
  uint64_t v15 = (unsigned int *)v46;
  uint64_t v16 = v47;
  unint64_t v17 = *((unsigned int *)v46 + 2);
  unint64_t v18 = (unint64_t)v47 << 6;
  if (v47 != 1) {
    goto LABEL_16;
  }
LABEL_13:
  if (!v17)
  {
    uint64_t v19 = 1;
    goto LABEL_46;
  }
LABEL_27:
  unint64_t v33 = 0;
LABEL_29:
  char v34 = 0;
  uint64_t v35 = 0;
  v4 &= 0xFFFFFFFFFFFFFF00;
  unint64_t v36 = v18;
  uint64_t v37 = v15 + 2;
  while (1)
  {
    unint64_t v39 = *v37;
    if (v33 >= v39 || (unint64_t v40 = *(void *)(*((void *)v37 - 1) + 8 * (v39 + ~v33)), v40 == 1))
    {
      uint64_t v38 = v35;
      goto LABEL_31;
    }
    if (v40 == 0x8000000000000000)
    {
      if (v34 & 1 | (v35 != 0)) {
        break;
      }
      uint64_t v38 = 1;
      unint64_t v4 = 0x8000000000000000;
      char v34 = 1;
      goto LABEL_31;
    }
    uint64_t v38 = 1;
    if (!v35)
    {
      unint64_t v4 = v40;
      goto LABEL_31;
    }
    BOOL v41 = v40 == v4;
    unint64_t v4 = v40;
    if (!v41) {
      break;
    }
LABEL_31:
    v37 += 16;
    uint64_t v35 = v38;
    v36 -= 64;
    if (!v36)
    {
      if (++v33 == v17) {
        goto LABEL_43;
      }
      goto LABEL_29;
    }
  }
  uint64_t v19 = 0;
  if (!v16) {
    goto LABEL_49;
  }
  do
  {
LABEL_46:
    char v42 = *(char **)((char *)v15 + v18 - 64);
    if ((char *)v15 + v18 - 48 != v42) {
      free(v42);
    }
    v18 -= 64;
  }
  while (v18);
  uint64_t v15 = (unsigned int *)v46;
LABEL_49:
  if (v15 != (unsigned int *)&v48) {
LABEL_50:
  }
    free(v15);
  return v19;
}

uint64_t mlir::OpTrait::util::getBroadcastedShape(uint64_t *a1, unint64_t a2, uint64_t *a3, unint64_t a4, uint64_t a5)
{
  *(_DWORD *)(a5 + 8) = 0;
  if (a2 <= a4)
  {
    if (!a4) {
      return 1;
    }
    unsigned int v10 = 0;
    uint64_t v14 = 8 * a4;
    uint64_t v15 = a3;
    do
    {
      uint64_t v16 = *v15;
      if (v10 >= *(_DWORD *)(a5 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v10 + 1, 8);
        unsigned int v10 = *(_DWORD *)(a5 + 8);
      }
      *(void *)(*(void *)a5 + 8 * v10) = v16;
      unsigned int v10 = *(_DWORD *)(a5 + 8) + 1;
      *(_DWORD *)(a5 + 8) = v10;
      ++v15;
      v14 -= 8;
    }
    while (v14);
  }
  else
  {
    unsigned int v10 = 0;
    uint64_t v11 = 8 * a2;
    uint64_t v12 = a1;
    do
    {
      uint64_t v13 = *v12;
      if (v10 >= *(_DWORD *)(a5 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v10 + 1, 8);
        unsigned int v10 = *(_DWORD *)(a5 + 8);
      }
      *(void *)(*(void *)a5 + 8 * v10) = v13;
      unsigned int v10 = *(_DWORD *)(a5 + 8) + 1;
      *(_DWORD *)(a5 + 8) = v10;
      ++v12;
      v11 -= 8;
    }
    while (v11);
  }
  uint64_t result = 1;
  if (a2 && a4)
  {
    uint64_t v18 = 8 * a2 - 8;
    uint64_t v19 = (unint64_t *)(*(void *)a5 + 8 * v10 - 8);
    uint64_t v20 = 8 * a4 - 8;
    while (1)
    {
      uint64_t v21 = *(uint64_t *)((char *)a1 + v18);
      uint64_t v22 = *(uint64_t *)((char *)a3 + v20);
      if (v21 == 0x8000000000000000) {
        break;
      }
      if (v22 == 0x8000000000000000)
      {
        unint64_t v23 = *(uint64_t *)((char *)a1 + v18);
        if (v21 > 1) {
          goto LABEL_27;
        }
        goto LABEL_21;
      }
      BOOL v24 = v21 == v22 || v22 == 1;
      unint64_t v23 = *(uint64_t *)((char *)a1 + v18);
      if (!v24)
      {
        unint64_t v23 = *(uint64_t *)((char *)a3 + v20);
        if (v21 != 1)
        {
          uint64_t result = 0;
          *(_DWORD *)(a5 + 8) = 0;
          return result;
        }
      }
LABEL_27:
      *v19-- = v23;
      if (v18)
      {
        v18 -= 8;
        uint64_t v25 = v20;
        v20 -= 8;
        if (v25) {
          continue;
        }
      }
      return result;
    }
    unint64_t v23 = *(uint64_t *)((char *)a3 + v20);
    if (v22 > 1) {
      goto LABEL_27;
    }
    unint64_t v23 = *(uint64_t *)((char *)a1 + v18);
    if (v22 == 1) {
      goto LABEL_27;
    }
LABEL_21:
    unint64_t v23 = 0x8000000000000000;
    goto LABEL_27;
  }
  return result;
}

uint64_t mlir::OpTrait::util::getBroadcastedType(void *a1, void *a2, uint64_t a3)
{
  uint64_t ElementTypeOrSelf = a3;
  unint64_t v5 = (unint64_t)a1;
  v27[4] = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(a1);
    if (ElementTypeOrSelf != mlir::getElementTypeOrSelf(a2)) {
      return 0;
    }
  }
  uint64_t v6 = *(void *)v5;
  uint64_t v7 = *(void **)(*(void *)v5 + 136);
  uint64_t v8 = *(void **)(*a2 + 136);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v8 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) {
      return 0;
    }
    return mlir::UnrankedTensorType::get(ElementTypeOrSelf);
  }
  if (v8 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) {
      return 0;
    }
    return mlir::UnrankedTensorType::get(ElementTypeOrSelf);
  }
  BOOL v10 = v8 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
     || v8 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id;
  if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t v12 = 0;
    if (!v10) {
      uint64_t v8 = 0;
    }
    if (v7 != v8 && v10) {
      return v12;
    }
    BOOL v10 = 1;
  }
  else if (v10)
  {
    uint64_t v7 = *(void **)(*a2 + 136);
  }
  else
  {
    uint64_t v7 = 0;
  }
  uint64_t v25 = v27;
  size_t v26 = 0x400000000;
  if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v6 + 8))
  {
    uint64_t v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(void *)v5 + 8);
    unint64_t v23 = (void *)v5;
    uint64_t v24 = v14;
    if (v5)
    {
      ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v23);
      unint64_t v5 = v16;
      uint64_t v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
      if (v17) {
        goto LABEL_34;
      }
LABEL_42:
      unint64_t v23 = 0;
      uint64_t v24 = v17;
      goto LABEL_43;
    }
  }
  else
  {
    unint64_t v5 = 0;
    unint64_t v23 = 0;
    uint64_t v24 = 0;
  }
  ArgAttrsAttr = 0;
  uint64_t v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
  if (!v17) {
    goto LABEL_42;
  }
LABEL_34:
  uint64_t v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*a2 + 8);
  unint64_t v23 = a2;
  uint64_t v24 = v18;
  if (a2)
  {
    uint64_t v19 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v23);
    if (mlir::OpTrait::util::getBroadcastedShape(ArgAttrsAttr, v5, v19, v20, (uint64_t)&v25)) {
      goto LABEL_36;
    }
LABEL_44:
    uint64_t v12 = 0;
    uint64_t v21 = v25;
    if (v25 == v27) {
      return v12;
    }
    goto LABEL_51;
  }
LABEL_43:
  if (!mlir::OpTrait::util::getBroadcastedShape(ArgAttrsAttr, v5, 0, 0, (uint64_t)&v25)) {
    goto LABEL_44;
  }
LABEL_36:
  if (v10 && v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
    uint64_t v12 = mlir::VectorType::get((uint64_t)v25, v26, ElementTypeOrSelf, 0, 0);
    uint64_t v21 = v25;
    if (v25 == v27) {
      return v12;
    }
    goto LABEL_51;
  }
  if (v10 && v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    uint64_t v12 = mlir::RankedTensorType::get((uint64_t)v25, v26, ElementTypeOrSelf, 0);
    uint64_t v21 = v25;
    if (v25 == v27) {
      return v12;
    }
    goto LABEL_51;
  }
  uint64_t v12 = ElementTypeOrSelf;
  uint64_t v21 = v25;
  if (v25 != v27) {
LABEL_51:
  }
    free(v21);
  return v12;
}

uint64_t mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(mlir::OpTrait::impl *this, mlir::Operation *a2)
{
  uint64_t v177 = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 46) & 0x80) != 0)
  {
    uint64_t v3 = *((void *)this + 9);
    uint64_t v4 = *((unsigned int *)this + 17);
  }
  else
  {
    uint64_t v3 = 0;
    uint64_t v4 = 0;
  }
  uint64_t v165 = (void *)v3;
  uint64_t v166 = v4;
  mlir::OperandRange::getTypes((uint64_t *)&v165, &v154);
  if (v154 == v156 && v157 == v155)
  {
    BOOL v5 = 0;
    BOOL v6 = 1;
    goto LABEL_42;
  }
  uint64_t v7 = *(void **)(*(void *)(*(void *)(*(void *)(v154 + 32 * v155 + 24) + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
  BOOL v9 = v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (v154 == v156)
  {
    if (v9)
    {
      BOOL v5 = 1;
      goto LABEL_37;
    }
    uint64_t v14 = (uint64_t *)(v154 + 32 * v155 + 56);
    uint64_t v15 = v157 - v155;
    while (1)
    {
      BOOL v5 = --v15 != 0;
      if (!v15) {
        break;
      }
      uint64_t v16 = *v14;
      v14 += 4;
      uint64_t v17 = *(void **)(*(void *)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
      if (v17 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
        || v17 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
      {
        goto LABEL_31;
      }
    }
  }
  else
  {
    if (v9)
    {
      BOOL v5 = 1;
      goto LABEL_33;
    }
    BOOL v10 = (uint64_t *)(v154 + 32 * v155 + 56);
    do
    {
      uint64_t v11 = *v10;
      v10 += 4;
      uint64_t v12 = *(void **)(*(void *)(*(void *)(v11 + 8) & 0xFFFFFFFFFFFFFFF8) + 136);
    }
    while (v12 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
         && v12 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id);
LABEL_31:
    BOOL v5 = 1;
  }
  if (v154 != v156)
  {
LABEL_33:
    if (v7 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
    {
      uint64_t v19 = (uint64_t *)(v154 + 32 * v155 + 56);
      do
      {
        uint64_t v20 = *v19;
        v19 += 4;
      }
      while (*(_UNKNOWN **)(*(void *)(*(void *)(v20 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id);
    }
    goto LABEL_41;
  }
LABEL_37:
  if (v7 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
LABEL_41:
    BOOL v6 = 0;
    goto LABEL_42;
  }
  uint64_t v21 = (uint64_t *)(v154 + 32 * v155 + 56);
  uint64_t v22 = v157 - v155;
  while (1)
  {
    BOOL v6 = --v22 == 0;
    if (!v22) {
      break;
    }
    uint64_t v23 = *v21;
    v21 += 4;
    if (*(_UNKNOWN **)(*(void *)(*(void *)(v23 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) {
      goto LABEL_41;
    }
  }
LABEL_42:
  uint64_t v24 = *((unsigned int *)this + 9);
  uint64_t v25 = (char *)this - 16;
  if (!v24) {
    uint64_t v25 = 0;
  }
  uint64_t v165 = v25;
  uint64_t v166 = v24;
  mlir::OperandRange::getTypes((uint64_t *)&v165, &v150);
  uint64_t v26 = v150;
  uint64_t v27 = v151;
  uint64_t v28 = v153;
  BOOL v29 = v150 != v152;
  if (v150 == v152 && v151 == v153)
  {
    BOOL v30 = 1;
    goto LABEL_71;
  }
  unint64_t v31 = *(void **)(*(void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v150, v151) + 8) & 0xFFFFFFFFFFFFFFF8)
                 + 136);
  BOOL v33 = v31 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
     || v31 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (v29)
  {
    if (!v33)
    {
      uint64_t v34 = v27 + 1;
      do
        uint64_t v35 = *(void **)(*(void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v26, v34++) + 8) & 0xFFFFFFFFFFFFFFF8)
                       + 136);
      while (v35 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
           && v35 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id);
    }
    goto LABEL_70;
  }
  if (v33)
  {
LABEL_70:
    BOOL v30 = 0;
    goto LABEL_71;
  }
  uint64_t v37 = v27 + 1;
  while (1)
  {
    BOOL v30 = v28 == v37;
    if (v28 == v37) {
      break;
    }
    uint64_t v38 = *(void **)(*(void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v26, v37++) + 8) & 0xFFFFFFFFFFFFFFF8)
                   + 136);
    if (v38 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      || v38 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_70;
    }
  }
LABEL_71:
  uint64_t v40 = v150;
  uint64_t v41 = v151;
  uint64_t v42 = v153;
  BOOL v43 = v150 != v152;
  if (v150 == v152 && v151 == v153)
  {
    BOOL v44 = 1;
    goto LABEL_84;
  }
  uint64_t v45 = *(void **)(*(void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v150, v151) + 8) & 0xFFFFFFFFFFFFFFF8)
                 + 136);
  if (v43)
  {
    if (v45 != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
    {
      uint64_t v46 = v41 + 1;
      do
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v40, v46++);
      while (*(_UNKNOWN **)(*(void *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id);
    }
    goto LABEL_83;
  }
  if (v45 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id)
  {
LABEL_83:
    BOOL v44 = 0;
    goto LABEL_84;
  }
  uint64_t v48 = v41 + 1;
  while (1)
  {
    BOOL v44 = v42 == v48;
    if (v42 == v48) {
      break;
    }
    uint64_t v49 = mlir::detail::OpResultImpl::getNextResultAtOffset(v40, v48++);
    if (*(_UNKNOWN **)(*(void *)(*(void *)(v49 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) {
      goto LABEL_83;
    }
  }
LABEL_84:
  BOOL v50 = !v5 && v30;
  if (v50 || v6 && v44)
  {
    if ((*((unsigned char *)this + 46) & 0x80) != 0)
    {
      uint64_t v60 = (void *)*((void *)this + 9);
      uint64_t v61 = *((unsigned int *)this + 17);
    }
    else
    {
      uint64_t v60 = 0;
      uint64_t v61 = 0;
    }
    uint64_t __src = v60;
    uint64_t v163 = v61;
    mlir::OperandRange::getTypes((uint64_t *)&__src, (uint64_t *)&v165);
    uint64_t v63 = (uint64_t)v165;
    uint64_t v62 = v166;
    BOOL v64 = (char *)v168;
    BOOL v65 = v165 != v167;
    if (v165 != v167 || (void *)v166 != v168)
    {
      if (v165 == v167)
      {
        uint64_t v69 = (uint64_t)&v165[4 * v166 + 3];
        while (*(_UNKNOWN **)(*(void *)(*(void *)(*(void *)v69 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        {
          ++v62;
          v69 += 32;
          if (v168 == (void *)v62)
          {
            uint64_t v62 = (uint64_t)v168;
            break;
          }
        }
      }
      else
      {
        BOOL v66 = &v165[4 * v166];
        if (*(_UNKNOWN **)(*(void *)(*(void *)(v66[3] + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        {
          unint64_t v67 = v66 + 7;
          do
          {
            uint64_t v68 = *v67;
            v67 += 4;
            ++v62;
          }
          while (*(_UNKNOWN **)(*(void *)(*(void *)(v68 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
        }
      }
    }
    if (v165 == v167 && (void *)v62 == v168) {
      return 1;
    }
    uint64_t __src = v164;
    uint64_t v163 = 0x400000000;
    BOOL v70 = (void *)(*(void *)(v165[4 * v62 + 3] + 8) & 0xFFFFFFFFFFFFFFF8);
    if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8))
    {
      uint64_t v71 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v70 + 8);
      uint64_t v165 = v70;
      uint64_t v166 = v71;
      if (v70)
      {
        ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v165);
LABEL_128:
        mlir::OpTrait::util::getBroadcastedShape(ArgAttrsAttr, v73, 0, 0, (uint64_t)&__src);
        while (1)
        {
          if (!v65 && v62 == (void)v64)
          {
            unint64_t v97 = (const char *)*((unsigned int *)this + 9);
            unint64_t v98 = (char *)this - 16;
            if (!v97) {
              unint64_t v98 = 0;
            }
            __dst = v98;
            uint64_t v159 = (uint64_t)v97;
            mlir::OperandRange::getTypes((uint64_t *)&__dst, (uint64_t *)&v165);
            uint64_t v99 = (uint64_t)v165;
            int64_t v100 = (char *)v166;
            unint64_t v101 = (char *)v168;
            BOOL v102 = v165 != v167;
            if (v165 != v167 || (void *)v166 != v168)
            {
              if (v165 == v167)
              {
                do
                {
                  if (*(_UNKNOWN **)(*(void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)goto LABEL_184; {
                  ++v100;
                  }
                }
                while (v101 != v100);
                int64_t v100 = v101;
              }
              else
              {
                do
                  uint64_t v103 = mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100++);
                while (*(_UNKNOWN **)(*(void *)(*(void *)(v103 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
                --v100;
              }
            }
LABEL_184:
            unint64_t v104 = v167;
            BOOL v105 = (char *)v168;
            BOOL v106 = (void *)v99 == v167 && v100 == v168;
            if (v106 || ((void *)v99 == v167 ? (BOOL v107 = v100 == v168) : (BOOL v107 = 0), v107))
            {
              unsigned int v145 = 1;
LABEL_220:
              unint64_t v118 = __src;
              if (__src == v164) {
                return v145;
              }
              goto LABEL_221;
            }
            while (2)
            {
              BOOL v108 = v100;
              unint64_t v109 = (void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100) + 8) & 0xFFFFFFFFFFFFFFF8);
              if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8))
              {
                uint64_t v110 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                uint64_t v165 = v109;
                uint64_t v166 = v110;
                if (v109)
                {
                  BOOL v111 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v165);
                  uint64_t v113 = v163;
                  if (v112 > v163)
                  {
                    v111 += v112 - v163;
LABEL_199:
                    if (v113)
                    {
                      unint64_t v114 = __src;
                      uint64_t v115 = 8 * v113 - 8;
                      while (1)
                      {
                        uint64_t v116 = v115;
                        if (*v111 != 0x8000000000000000 && *v114 != 0x8000000000000000 && *v114 != *v111) {
                          break;
                        }
                        ++v114;
                        ++v111;
                        v115 -= 8;
                        if (!v116) {
                          goto LABEL_208;
                        }
                      }
LABEL_224:
                      __int16 v149 = 257;
                      mlir::Operation::emitOpError((uint64_t *)this, v148, (uint64_t)&v165);
                      if (v165)
                      {
                        LODWORD(__dst) = 3;
                        uint64_t v159 = (uint64_t)"result type ";
                        v160[0] = 12;
                        p_dst = &__dst;
                        int64_t v121 = (char *)v168;
                        if (v169 >= v170)
                        {
                          unint64_t v141 = v169 + 1;
                          if (v168 <= &__dst && (char *)v168 + 24 * v169 > (char *)&__dst)
                          {
                            int64_t v143 = (char *)&__dst - (unsigned char *)v168;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v141, 24);
                            int64_t v121 = (char *)v168;
                            p_dst = (void **)((char *)v168 + v143);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v141, 24);
                            p_dst = &__dst;
                            int64_t v121 = (char *)v168;
                          }
                        }
                        int64_t v122 = &v121[24 * v169];
                        long long v123 = *(_OWORD *)p_dst;
                        *((void *)v122 + 2) = p_dst[2];
                        *(_OWORD *)int64_t v122 = v123;
                        ++v169;
                      }
                      uint64_t v124 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                      if (v124) {
                        uint64_t v124 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v109 + 8);
                      }
                      else {
                        unint64_t v109 = 0;
                      }
                      __dst = v109;
                      uint64_t v159 = v124;
                      if (v109)
                      {
                        int64_t v125 = (unint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__dst);
                        uint64_t v127 = v126;
                      }
                      else
                      {
                        uint64_t v127 = 0;
                        int64_t v125 = 0;
                      }
                      getShapeString(&v147, v125, v127);
                      if (v165)
                      {
                        __int16 v161 = 260;
                        __dst = &v147;
                        mlir::Diagnostic::operator<<((uint64_t)&v166, (const void ***)&__dst);
                        if (v165)
                        {
                          LODWORD(__dst) = 3;
                          uint64_t v159 = (uint64_t)" not broadcast compatible with broadcasted operands's shapes ";
                          v160[0] = 61;
                          int64_t v128 = &__dst;
                          int64_t v129 = (char *)v168;
                          if (v169 >= v170)
                          {
                            unint64_t v142 = v169 + 1;
                            if (v168 <= &__dst && (char *)v168 + 24 * v169 > (char *)&__dst)
                            {
                              int64_t v144 = (char *)&__dst - (unsigned char *)v168;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v142, 24);
                              int64_t v129 = (char *)v168;
                              int64_t v128 = (void **)((char *)v168 + v144);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v168, v171, v142, 24);
                              int64_t v128 = &__dst;
                              int64_t v129 = (char *)v168;
                            }
                          }
                          int64_t v130 = &v129[24 * v169];
                          long long v131 = *(_OWORD *)v128;
                          *((void *)v130 + 2) = v128[2];
                          *(_OWORD *)int64_t v130 = v131;
                          ++v169;
                        }
                      }
                      getShapeString(&v146, (unint64_t *)__src, v163);
                      if (v165)
                      {
                        __int16 v161 = 260;
                        __dst = &v146;
                        mlir::Diagnostic::operator<<((uint64_t)&v166, (const void ***)&__dst);
                      }
                      unsigned int v132 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
                      if ((SHIBYTE(v146.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
                      {
                        if ((SHIBYTE(v147.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                          goto LABEL_241;
                        }
LABEL_256:
                        operator delete(v147.__r_.__value_.__l.__data_);
                        if (!v165) {
                          goto LABEL_243;
                        }
LABEL_242:
                        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
                        goto LABEL_243;
                      }
                      operator delete(v146.__r_.__value_.__l.__data_);
                      if (SHIBYTE(v147.__r_.__value_.__r.__words[2]) < 0) {
                        goto LABEL_256;
                      }
LABEL_241:
                      if (v165) {
                        goto LABEL_242;
                      }
LABEL_243:
                      if (v176)
                      {
                        unint64_t v133 = (void **)__p;
                        if (__p)
                        {
                          uint64_t v134 = v175;
                          int v135 = __p;
                          if (v175 != __p)
                          {
                            do
                              uint64_t v134 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v134 - 1);
                            while (v134 != v133);
                            int v135 = __p;
                          }
                          uint64_t v175 = v133;
                          operator delete(v135);
                        }
                        int v136 = v172;
                        if (v172)
                        {
                          unint64_t v137 = v173;
                          unint64_t v138 = v172;
                          if (v173 != v172)
                          {
                            do
                            {
                              unint64_t v140 = (void *)*--v137;
                              uint64_t v139 = v140;
                              *unint64_t v137 = 0;
                              if (v140) {
                                operator delete[](v139);
                              }
                            }
                            while (v137 != v136);
                            unint64_t v138 = v172;
                          }
                          uint64_t v173 = v136;
                          operator delete(v138);
                        }
                        if (v168 != v171) {
                          free(v168);
                        }
                      }
                      unsigned int v145 = v132;
                      unint64_t v118 = __src;
                      if (__src == v164) {
                        return v145;
                      }
LABEL_221:
                      free(v118);
                      return v145;
                    }
LABEL_208:
                    int64_t v100 = v101;
                    if (v102 || v108 + 1 != v101)
                    {
                      int64_t v100 = v108 + 1;
                      if (v102)
                      {
                        int64_t v100 = v108;
                        do
                          ++v100;
                        while (*(_UNKNOWN **)(*(void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
                      }
                      else
                      {
                        while (*(_UNKNOWN **)(*(void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v99, (uint64_t)v100)+ 8) & 0xFFFFFFFFFFFFFFF8)+ 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
                        {
                          if (v101 == ++v100)
                          {
                            int64_t v100 = v101;
                            break;
                          }
                        }
                      }
                    }
                    if ((void *)v99 == v104)
                    {
                      unsigned int v145 = 1;
                      if (v100 == v105) {
                        goto LABEL_220;
                      }
                    }
                    continue;
                  }
LABEL_198:
                  if (v113 != v112) {
                    goto LABEL_224;
                  }
                  goto LABEL_199;
                }
              }
              else
              {
                uint64_t v165 = 0;
                uint64_t v166 = 0;
              }
              break;
            }
            BOOL v111 = 0;
            unint64_t v112 = 0;
            uint64_t v113 = v163;
            goto LABEL_198;
          }
          BOOL v74 = (char *)(v62 + 1);
          unint64_t v75 = v64;
          if (v65 || v62 + 1 != (void)v64)
          {
            if (!v65)
            {
              uint64_t v78 = v63 + 56 + 32 * v62;
              while (*(_UNKNOWN **)(*(void *)(*(void *)(*(void *)v78 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
              {
                ++v74;
                v78 += 32;
                if (v64 == v74)
                {
                  unint64_t v75 = v64;
                  goto LABEL_142;
                }
              }
LABEL_141:
              unint64_t v75 = v74;
              goto LABEL_142;
            }
            if (*(_UNKNOWN **)(*(void *)(*(void *)(*(void *)(v63 + 32 * (void)v74 + 24) + 8) & 0xFFFFFFFFFFFFFFF8)
                              + 136) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
              goto LABEL_141;
            BOOL v76 = (uint64_t *)(v63 + 88 + 32 * v62);
            unint64_t v75 = (char *)(v62 + 1);
            do
            {
              uint64_t v77 = *v76;
              v76 += 4;
              ++v75;
            }
            while (*(_UNKNOWN **)(*(void *)(*(void *)(v77 + 8) & 0xFFFFFFFFFFFFFFF8) + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id);
          }
LABEL_142:
          uint64_t v79 = *(void *)(*(void *)(v63 + 32 * v62 + 24) + 8);
          __dst = v160;
          uint64_t v159 = 0x400000000;
          unint64_t v80 = v163;
          __n128 v81 = v160;
          if (!v163) {
            goto LABEL_148;
          }
          uint64_t v82 = v160;
          uint64_t v83 = v163;
          if (v163 < 5uLL) {
            goto LABEL_146;
          }
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__dst, v160, v163, 8);
          uint64_t v83 = v163;
          if (v163)
          {
            uint64_t v82 = __dst;
LABEL_146:
            memcpy(v82, __src, 8 * v83);
          }
          LODWORD(v159) = v80;
          __n128 v81 = (uint64_t *)__dst;
LABEL_148:
          unint64_t v84 = (void *)(v79 & 0xFFFFFFFFFFFFFFF8);
          if (mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v84 + 8))
          {
            uint64_t v85 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v84 + 8);
            uint64_t v165 = v84;
            uint64_t v166 = v85;
            if (v84)
            {
              __n128 v86 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v165);
              char BroadcastedShape = mlir::OpTrait::util::getBroadcastedShape(v81, v80, v86, v87, (uint64_t)&__src);
              if ((BroadcastedShape & 1) == 0) {
                goto LABEL_154;
              }
              goto LABEL_172;
            }
          }
          else
          {
            uint64_t v165 = 0;
            uint64_t v166 = 0;
          }
          char BroadcastedShape = mlir::OpTrait::util::getBroadcastedShape(v81, v80, 0, 0, (uint64_t)&__src);
          if ((BroadcastedShape & 1) == 0)
          {
LABEL_154:
            v148[0] = (const void **)"operands don't have broadcast-compatible shapes";
            __int16 v149 = 259;
            mlir::Operation::emitOpError((uint64_t *)this, v148, (uint64_t)&v165);
            unsigned int v145 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
            if (v165) {
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
            }
            if (v176)
            {
              unint64_t v89 = (void **)__p;
              if (__p)
              {
                BOOL v90 = v175;
                __n128 v91 = __p;
                if (v175 != __p)
                {
                  do
                    BOOL v90 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v90 - 1);
                  while (v90 != v89);
                  __n128 v91 = __p;
                }
                uint64_t v175 = v89;
                operator delete(v91);
              }
              BOOL v92 = v172;
              if (v172)
              {
                unint64_t v93 = v173;
                BOOL v94 = v172;
                if (v173 != v172)
                {
                  do
                  {
                    BOOL v96 = (void *)*--v93;
                    unint64_t v95 = v96;
                    *unint64_t v93 = 0;
                    if (v96) {
                      operator delete[](v95);
                    }
                  }
                  while (v93 != v92);
                  BOOL v94 = v172;
                }
                uint64_t v173 = v92;
                operator delete(v94);
              }
              if (v168 != v171) {
                free(v168);
              }
            }
          }
LABEL_172:
          if (__dst != v160) {
            free(__dst);
          }
          uint64_t v62 = (uint64_t)v75;
          if ((BroadcastedShape & 1) == 0) {
            goto LABEL_220;
          }
        }
      }
    }
    else
    {
      uint64_t v165 = 0;
      uint64_t v166 = 0;
    }
    unint64_t v73 = 0;
    ArgAttrsAttr = 0;
    goto LABEL_128;
  }
  uint64_t __src = "cannot broadcast vector with tensor";
  v164[8] = 259;
  mlir::Operation::emitError((uint64_t *)this, (uint64_t)&__src, (uint64_t)&v165);
  uint64_t v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v165);
  if (v165) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v165);
  }
  if (v176)
  {
    uint64_t v52 = (void **)__p;
    if (__p)
    {
      long long v53 = v175;
      uint64_t v54 = __p;
      if (v175 != __p)
      {
        do
          long long v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
        while (v53 != v52);
        uint64_t v54 = __p;
      }
      uint64_t v175 = v52;
      operator delete(v54);
    }
    unint64_t v55 = v172;
    if (v172)
    {
      uint64_t v56 = v173;
      char v57 = v172;
      if (v173 != v172)
      {
        do
        {
          uint64_t v59 = (void *)*--v56;
          uint64_t v58 = v59;
          *uint64_t v56 = 0;
          if (v59) {
            operator delete[](v58);
          }
        }
        while (v56 != v55);
        char v57 = v172;
      }
      uint64_t v173 = v55;
      operator delete(v57);
    }
    if (v168 != v171) {
      free(v168);
    }
  }
  return v51;
}

void getShapeString(std::string *a1, unint64_t *a2, uint64_t a3)
{
  __p[0] = 0;
  __p[1] = 0;
  uint64_t v25 = 0;
  int v16 = 0;
  char v20 = 0;
  uint64_t v21 = 0;
  int v22 = 1;
  uint64_t v18 = 0;
  uint64_t v19 = 0;
  uint64_t v17 = 0;
  uint64_t v15 = &unk_1EC9A38B8;
  uint64_t v23 = __p;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v15, 0, 0, 0);
  BOOL v6 = v19;
  if (v19 >= v18)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 39);
    if (!a3) {
      goto LABEL_12;
    }
    goto LABEL_5;
  }
  ++v19;
  unsigned char *v6 = 39;
  if (a3)
  {
LABEL_5:
    if (*a2 == 0x8000000000000000)
    {
      uint64_t v7 = v19;
      if (v19 >= v18)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 63);
        if (a3 == 1) {
          goto LABEL_12;
        }
      }
      else
      {
        ++v19;
        *uint64_t v7 = 63;
        if (a3 == 1) {
          goto LABEL_12;
        }
      }
    }
    else
    {
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v15, *a2);
      if (a3 == 1) {
        goto LABEL_12;
      }
    }
    uint64_t v11 = a2 + 1;
    for (uint64_t i = 8 * a3 - 8; i; i -= 8)
    {
      if (v18 == v19)
      {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v15, "x", 1uLL);
        unint64_t v13 = *v11;
        if (*v11 == 0x8000000000000000)
        {
LABEL_27:
          uint64_t v14 = v19;
          if (v19 >= v18)
          {
            llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 63);
          }
          else
          {
            ++v19;
            unsigned char *v14 = 63;
          }
          goto LABEL_22;
        }
      }
      else
      {
        *v19++ = 120;
        unint64_t v13 = *v11;
        if (*v11 == 0x8000000000000000) {
          goto LABEL_27;
        }
      }
      llvm::raw_ostream::operator<<((llvm::raw_ostream *)&v15, v13);
LABEL_22:
      ++v11;
    }
  }
LABEL_12:
  uint64_t v8 = v19;
  if (v19 >= v18)
  {
    llvm::raw_ostream::write((llvm::raw_ostream *)&v15, 39);
    BOOL v9 = v23;
    if ((*((char *)v23 + 23) & 0x80000000) == 0)
    {
LABEL_14:
      long long v10 = *(_OWORD *)v9;
      a1->__r_.__value_.__r.__words[2] = (std::string::size_type)v9[2];
      *(_OWORD *)&a1->__r_.__value_.__l.__data_ = v10;
      llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
      if ((SHIBYTE(v25) & 0x80000000) == 0) {
        return;
      }
      goto LABEL_15;
    }
  }
  else
  {
    ++v19;
    unsigned char *v8 = 39;
    BOOL v9 = v23;
    if ((*((char *)v23 + 23) & 0x80000000) == 0) {
      goto LABEL_14;
    }
  }
  std::string::__init_copy_ctor_external(a1, (const std::string::value_type *)*v9, (std::string::size_type)v9[1]);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v15);
  if (SHIBYTE(v25) < 0) {
LABEL_15:
  }
    operator delete(__p[0]);
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,6u>,false>::growAndEmplaceBack<long long const*,long long const*>(uint64_t a1, const void **a2, const void **a3)
{
  unint64_t v23 = 0;
  BOOL v6 = (_DWORD *)(a1 + 16);
  uint64_t v7 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 64, &v23);
  uint64_t v8 = &v7[8 * (unint64_t)*(unsigned int *)(a1 + 8)];
  BOOL v9 = *a2;
  long long v10 = *a3;
  void *v8 = v8 + 2;
  v8[1] = 0x600000000;
  uint64_t v11 = v10 - v9;
  if ((unint64_t)(v10 - v9) < 0x31)
  {
    unsigned int v12 = 0;
    if (v9 == v10) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v8, v8 + 2, v11 >> 3, 8);
  unsigned int v12 = *((_DWORD *)v8 + 2);
  if (v9 != v10)
  {
LABEL_5:
    memcpy((void *)(*v8 + 8 * v12), v9, v10 - v9);
    unsigned int v12 = *((_DWORD *)v8 + 2);
  }
LABEL_6:
  *((_DWORD *)v8 + 2) = v12 + ((unint64_t)v11 >> 3);
  unint64_t v13 = *(_DWORD **)a1;
  uint64_t v14 = *(unsigned int *)(a1 + 8);
  if (v14)
  {
    uint64_t v15 = v14 << 6;
    int v16 = v7;
    do
    {
      *int v16 = v16 + 2;
      v16[1] = 0x600000000;
      if (v13[2]) {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v16, (uint64_t)v13);
      }
      v16 += 8;
      v13 += 16;
      v15 -= 64;
    }
    while (v15);
    unint64_t v13 = *(_DWORD **)a1;
    uint64_t v17 = *(unsigned int *)(a1 + 8);
    if (v17)
    {
      uint64_t v18 = v17 << 6;
      do
      {
        uint64_t v19 = *(char **)((char *)v13 + v18 - 64);
        if ((char *)v13 + v18 - 48 != v19) {
          free(v19);
        }
        v18 -= 64;
      }
      while (v18);
      unint64_t v13 = *(_DWORD **)a1;
    }
  }
  int v20 = v23;
  if (v13 != v6) {
    free(v13);
  }
  *(void *)a1 = v7;
  uint64_t v21 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v21;
  *(_DWORD *)(a1 + 12) = v20;
  return (uint64_t)&v7[8 * v21 - 8];
}

void mlir::applyPermutationToVector<long long,6u>(uint64_t a1, uint64_t *a2)
{
  v17[6] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void **)a1;
  unint64_t v5 = *(unsigned int *)(a1 + 8);
  uint64_t v15 = v17;
  uint64_t v16 = 0x600000000;
  if (v5 < 7)
  {
    unsigned int v6 = 0;
    uint64_t v7 = v17;
    if (!v5) {
      goto LABEL_6;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15, v17, v5, 8);
    unsigned int v6 = v16;
    uint64_t v7 = v15;
  }
  uint64_t v8 = v6;
  unint64_t v9 = v5;
  do
  {
    uint64_t v10 = *a2++;
    v7[v8++] = v4[v10];
    --v9;
  }
  while (v9);
LABEL_6:
  unint64_t v11 = v6 + v5;
  LODWORD(v16) = v11;
  if (&v15 == (void **)a1) {
    goto LABEL_22;
  }
  if (v7 != v17)
  {
    if (*(void *)a1 != a1 + 16)
    {
      free(*(void **)a1);
      uint64_t v7 = v15;
      LODWORD(v11) = v16;
    }
    *(void *)a1 = v7;
    int v12 = HIDWORD(v16);
    *(_DWORD *)(a1 + 8) = v11;
    *(_DWORD *)(a1 + 12) = v12;
    uint64_t v15 = v17;
    HIDWORD(v16) = 0;
    goto LABEL_21;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 8);
  if (v13 >= v11)
  {
    if (v11) {
      memmove(*(void **)a1, v17, 8 * v11);
    }
    goto LABEL_20;
  }
  if (*(_DWORD *)(a1 + 12) < v11)
  {
    *(_DWORD *)(a1 + 8) = 0;
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v11, 8);
    uint64_t v13 = 0;
    uint64_t v14 = v16;
    if (!v16) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  if (!v13)
  {
    uint64_t v13 = 0;
    uint64_t v14 = v16;
    if (!v16) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  memmove(*(void **)a1, v17, 8 * v13);
  uint64_t v14 = v16;
  if (v13 != v16) {
LABEL_19:
  }
    memcpy((void *)(*(void *)a1 + 8 * v13), (char *)v15 + 8 * v13, 8 * v14 - 8 * v13);
LABEL_20:
  *(_DWORD *)(a1 + 8) = v11;
LABEL_21:
  LODWORD(v16) = 0;
  uint64_t v7 = v15;
LABEL_22:
  if (v7 != v17) {
    free(v7);
  }
}

void *llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::InsertIntoBucket<long long const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, void *a2, void *a3)
{
  int v6 = *(_DWORD *)a1;
  int v7 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v8 = 4;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v7 + 4 >= 3 * v8)
  {
    v8 *= 2;
  }
  else if (v8 + ~v7 - *(_DWORD *)(a1 + 4) > v8 >> 3)
  {
    int v9 = *(_DWORD *)a1 & 1;
    goto LABEL_7;
  }
  llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(a1, v8);
  uint64_t v11 = a1 + 8;
  int v6 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v12 = 4;
  }
  else
  {
    int v12 = *(_DWORD *)(a1 + 16);
    if (!v12)
    {
      int v9 = 0;
      a2 = 0;
      goto LABEL_7;
    }
    uint64_t v11 = *(void *)(a1 + 8);
  }
  int v9 = *(_DWORD *)a1 & 1;
  int v13 = v12 - 1;
  unsigned int v14 = (37 * *a3) & (v12 - 1);
  a2 = (void *)(v11 + 8 * v14);
  uint64_t v15 = *a2;
  if (*a3 != *a2)
  {
    uint64_t v16 = 0;
    int v17 = 1;
    while (v15 != 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == 0x8000000000000000;
      }
      if (v18) {
        uint64_t v16 = a2;
      }
      unsigned int v19 = v14 + v17++;
      unsigned int v14 = v19 & v13;
      a2 = (void *)(v11 + 8 * (v19 & v13));
      uint64_t v15 = *a2;
      if (*a3 == *a2) {
        goto LABEL_7;
      }
    }
    if (v16) {
      a2 = v16;
    }
  }
LABEL_7:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*a2 != 0x7FFFFFFFFFFFFFFFLL) {
    --*(_DWORD *)(a1 + 4);
  }
  *a2 = *a3;
  return a2;
}

void llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(uint64_t a1, unsigned int a2)
{
  void v16[3] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(uint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v13 = a2;
      *(void *)(a1 + 8) = llvm::allocate_buffer(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v13;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    unsigned int v14 = (char *)(8 * v7);
    llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets((_DWORD *)a1, v6, (uint64_t *)&v14[(void)v6]);
    llvm::deallocate_buffer((llvm *)v6, v14);
  }
  unsigned int v8 = &v15;
  if ((unint64_t)(*(void *)(a1 + 8) - 0x7FFFFFFFFFFFFFFFLL) >= 2)
  {
    uint64_t v15 = *(void *)(a1 + 8);
    unsigned int v8 = v16;
    uint64_t v9 = *(void *)(a1 + 16);
    if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) < 2)
    {
LABEL_10:
      uint64_t v10 = *(void *)(a1 + 24);
      if ((unint64_t)(v10 - 0x7FFFFFFFFFFFFFFFLL) < 2) {
        goto LABEL_11;
      }
      goto LABEL_21;
    }
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 16);
    if ((unint64_t)(v9 - 0x7FFFFFFFFFFFFFFFLL) < 2) {
      goto LABEL_10;
    }
  }
  *v8++ = v9;
  uint64_t v10 = *(void *)(a1 + 24);
  if ((unint64_t)(v10 - 0x7FFFFFFFFFFFFFFFLL) < 2)
  {
LABEL_11:
    uint64_t v11 = *(void *)(a1 + 32);
    if ((unint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) < 2) {
      goto LABEL_12;
    }
LABEL_22:
    *v8++ = v11;
    if (a2 < 5) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
LABEL_21:
  *v8++ = v10;
  uint64_t v11 = *(void *)(a1 + 32);
  if ((unint64_t)(v11 - 0x7FFFFFFFFFFFFFFFLL) >= 2) {
    goto LABEL_22;
  }
LABEL_12:
  if (a2 >= 5)
  {
LABEL_13:
    *(_DWORD *)a1 &= ~1u;
    uint64_t v12 = a2;
    *(void *)(a1 + 8) = llvm::allocate_buffer(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v12;
  }
LABEL_14:
  llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets((_DWORD *)a1, &v15, v8);
}

void llvm::DenseMapBase<llvm::SmallDenseMap<long long,llvm::detail::DenseSetEmpty,4u,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::moveFromOldBuckets(_DWORD *a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *a1;
  *(void *)a1 = *a1 & 1;
  uint64_t v7 = a1 + 2;
  if (v6)
  {
    uint64_t v8 = 4;
    uint64_t v9 = a1 + 2;
  }
  else
  {
    uint64_t v8 = a1[4];
    if (!v8) {
      goto LABEL_6;
    }
    uint64_t v9 = (void *)*((void *)a1 + 1);
  }
  memset_pattern16(v9, &unk_1811011A0, 8 * v8);
LABEL_6:
  while (a2 != a3)
  {
    uint64_t v16 = *a2;
    if ((unint64_t)(*a2 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
    {
      if (*(unsigned char *)a1)
      {
        int v11 = 4;
        uint64_t v10 = v7;
      }
      else
      {
        uint64_t v10 = (_DWORD *)*((void *)a1 + 1);
        int v11 = a1[4];
      }
      int v12 = v11 - 1;
      unsigned int v13 = (v11 - 1) & (37 * v16);
      unsigned int v14 = &v10[2 * v13];
      uint64_t v15 = *v14;
      if (v16 != *v14)
      {
        int v17 = 0;
        int v18 = 1;
        while (v15 != 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v17) {
            BOOL v19 = 0;
          }
          else {
            BOOL v19 = v15 == 0x8000000000000000;
          }
          if (v19) {
            int v17 = v14;
          }
          unsigned int v20 = v13 + v18++;
          unsigned int v13 = v20 & v12;
          unsigned int v14 = &v10[2 * (v20 & v12)];
          uint64_t v15 = *v14;
          if (v16 == *v14) {
            goto LABEL_10;
          }
        }
        if (v17) {
          unsigned int v14 = v17;
        }
      }
LABEL_10:
      void *v14 = v16;
      *a1 += 2;
    }
    ++a2;
  }
}

void llvm::DenseMapBase<llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>,long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::try_emplace<llvm::detail::DenseSetEmpty&>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6 = *(void *)a1;
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (!v7) {
    goto LABEL_23;
  }
  unsigned int v8 = v7 - 1;
  unsigned int v9 = (37 * *a2) & (v7 - 1);
  uint64_t v10 = (uint64_t *)(v6 + 8 * v9);
  uint64_t v11 = *v10;
  if (*a2 == *v10)
  {
LABEL_3:
    char v12 = 0;
    goto LABEL_10;
  }
  unsigned int v14 = 0;
  int v15 = 1;
  while (v11 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v14) {
      BOOL v16 = 0;
    }
    else {
      BOOL v16 = v11 == 0x8000000000000000;
    }
    if (v16) {
      unsigned int v14 = v10;
    }
    unsigned int v17 = v9 + v15++;
    unsigned int v9 = v17 & v8;
    uint64_t v10 = (uint64_t *)(v6 + 8 * (v17 & v8));
    uint64_t v11 = *v10;
    if (*a2 == *v10) {
      goto LABEL_3;
    }
  }
  if (v14) {
    uint64_t v10 = v14;
  }
  int v18 = *(_DWORD *)(a1 + 8);
  if (4 * v18 + 4 < 3 * v7)
  {
    if (v7 + ~v18 - *(_DWORD *)(a1 + 12) > v7 >> 3) {
      goto LABEL_6;
    }
  }
  else
  {
LABEL_23:
    v7 *= 2;
  }
  llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(a1, v7);
  uint64_t v6 = *(void *)a1;
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  uint64_t v13 = *a2;
  unsigned int v19 = v7 - 1;
  unsigned int v20 = (37 * *a2) & (v7 - 1);
  uint64_t v10 = (uint64_t *)(*(void *)a1 + 8 * v20);
  uint64_t v21 = *v10;
  if (*a2 == *v10) {
    goto LABEL_7;
  }
  int v22 = 0;
  int v23 = 1;
  while (v21 != 0x7FFFFFFFFFFFFFFFLL)
  {
    if (v22) {
      BOOL v24 = 0;
    }
    else {
      BOOL v24 = v21 == 0x8000000000000000;
    }
    if (v24) {
      int v22 = v10;
    }
    unsigned int v25 = v20 + v23++;
    unsigned int v20 = v25 & v19;
    uint64_t v10 = (uint64_t *)(v6 + 8 * (v25 & v19));
    uint64_t v21 = *v10;
    if (v13 == *v10) {
      goto LABEL_7;
    }
  }
  if (v22) {
    uint64_t v10 = v22;
  }
LABEL_6:
  uint64_t v13 = *v10;
LABEL_7:
  ++*(_DWORD *)(a1 + 8);
  if (v13 != 0x7FFFFFFFFFFFFFFFLL) {
    --*(_DWORD *)(a1 + 12);
  }
  uint64_t *v10 = *a2;
  char v12 = 1;
LABEL_10:
  *(void *)a3 = v10;
  *(void *)(a3 + 8) = v6 + 8 * v7;
  *(unsigned char *)(a3 + 16) = v12;
}

void llvm::DenseMap<long long,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<long long,void>,llvm::detail::DenseSetPair<long long>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  buffer = (char *)llvm::allocate_buffer(8 * v8, (std::align_val_t)8uLL);
  uint64_t v10 = buffer;
  *(void *)a1 = buffer;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11) {
      memset_pattern16(buffer, &unk_1811011A0, 8 * v11);
    }
    if (v3)
    {
      int v12 = 0;
      int v13 = v11 - 1;
      unsigned int v14 = v4;
      do
      {
        uint64_t v17 = *(void *)v14;
        if ((unint64_t)(*(void *)v14 - 0x7FFFFFFFFFFFFFFFLL) >= 2)
        {
          unsigned int v18 = (37 * v17) & v13;
          BOOL v16 = &v10[8 * v18];
          uint64_t v19 = *(void *)v16;
          if (v17 != *(void *)v16)
          {
            unsigned int v20 = 0;
            int v21 = 1;
            while (v19 != 0x7FFFFFFFFFFFFFFFLL)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == 0x8000000000000000;
              }
              if (v22) {
                unsigned int v20 = v16;
              }
              unsigned int v23 = v18 + v21++;
              unsigned int v18 = v23 & v13;
              BOOL v16 = &v10[8 * (v23 & v13)];
              uint64_t v19 = *(void *)v16;
              if (v17 == *(void *)v16) {
                goto LABEL_16;
              }
            }
            if (v20) {
              BOOL v16 = v20;
            }
          }
LABEL_16:
          *(void *)BOOL v16 = v17;
          *(_DWORD *)(a1 + 8) = ++v12;
        }
        unsigned int v14 = (llvm *)((char *)v14 + 8);
      }
      while (v14 != (llvm *)((char *)v4 + 8 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(8 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v15 = *(unsigned int *)(a1 + 16);
  if (v15)
  {
    memset_pattern16(buffer, &unk_1811011A0, 8 * v15);
  }
}

void mlir::getReassociationIndicesForCollapse(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  v43[4] = *MEMORY[0x1E4F143B8];
  if (a2 <= a4)
  {
    *(unsigned char *)a5 = 0;
    *(unsigned char *)(a5 + 48) = 0;
    return;
  }
  uint64_t v41 = v43;
  uint64_t v42 = 0x100000000;
  if (a4 >= 2) {
    llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v41, a4);
  }
  LODWORD(v9) = 0;
  uint64_t v38 = v40;
  uint64_t v39 = 0x200000000;
  while (1)
  {
    uint64_t v10 = v42;
    if (a4 == v42) {
      break;
    }
    uint64_t v11 = *(void *)(a3 + 8 * v42);
    unint64_t v12 = v9;
    if (a2 <= v9)
    {
      uint64_t v15 = 1;
LABEL_19:
      uint64_t v18 = *(void *)(a1 + 8 * v12);
      if (v18 != 0x8000000000000000)
      {
LABEL_24:
        if (v11 == 0x8000000000000000) {
          goto LABEL_57;
        }
        goto LABEL_25;
      }
    }
    else
    {
      uint64_t v13 = 1;
      while (1)
      {
        uint64_t v14 = *(void *)(a1 + 8 * v12);
        uint64_t v15 = v14 * v13;
        if (v14 == 0x8000000000000000 || v15 >= v11) {
          break;
        }
        uint64_t v17 = v39;
        if (v39 >= (unint64_t)HIDWORD(v39))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v40, v39 + 1, 8);
          uint64_t v17 = v39;
        }
        unint64_t v9 = (v9 + 1);
        *((void *)v38 + v17) = v12;
        LODWORD(v39) = v39 + 1;
        unint64_t v12 = v9;
        uint64_t v13 = v15;
        if (a2 <= v9) {
          goto LABEL_19;
        }
      }
      uint64_t v15 = v13;
      uint64_t v18 = *(void *)(a1 + 8 * v12);
      if (v18 != 0x8000000000000000) {
        goto LABEL_24;
      }
    }
    if (v11 != 0x8000000000000000 || v15 != 1) {
      goto LABEL_57;
    }
LABEL_25:
    if (v18 * v15 != v11) {
      goto LABEL_57;
    }
    uint64_t v19 = v39;
    if (v39 >= (unint64_t)HIDWORD(v39))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v40, v39 + 1, 8);
      uint64_t v19 = v39;
    }
    *((void *)v38 + v19) = v12;
    LODWORD(v39) = v39 + 1;
    uint64_t __src = v37;
    uint64_t v36 = 0x200000000;
    if (v42 >= HIDWORD(v42))
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::growAndEmplaceBack<llvm::SmallVector<long long,2u>>((uint64_t)&v41, (uint64_t)&__src);
      unsigned int v23 = __src;
      if (__src == v37) {
        goto LABEL_5;
      }
    }
    else
    {
      unsigned int v20 = (void **)((char *)v41 + 32 * v42);
      *unsigned int v20 = v20 + 2;
      v20[1] = (void *)0x200000000;
      if (v20 != &__src)
      {
        int v21 = v36;
        if (v36)
        {
          if (__src == v37)
          {
            uint64_t v22 = v36;
            if (v36 < 3uLL
              || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v20, v20 + 2, v36, 8),
                  uint64_t v22 = v36,
                  v36))
            {
              memcpy(*v20, __src, 8 * v22);
            }
            *((_DWORD *)v20 + 2) = v21;
          }
          else
          {
            *unsigned int v20 = __src;
            *((_DWORD *)v20 + 2) = v21;
            *((_DWORD *)v20 + 3) = HIDWORD(v36);
            uint64_t __src = v37;
            HIDWORD(v36) = 0;
          }
          LODWORD(v36) = 0;
        }
      }
      LODWORD(v42) = v42 + 1;
      unsigned int v23 = __src;
      if (__src == v37) {
        goto LABEL_5;
      }
    }
    free(v23);
LABEL_5:
    LODWORD(v9) = v9 + 1;
    llvm::SmallVectorImpl<long long>::swap((uint64_t)v41 + 32 * v42 - 32, (uint64_t)&v38);
    if (a2 <= v9)
    {
      uint64_t v10 = v42;
      break;
    }
  }
  if (a4 != v10)
  {
LABEL_57:
    *(unsigned char *)a5 = 0;
    *(unsigned char *)(a5 + 48) = 0;
    BOOL v30 = v38;
    if (v38 == v40) {
      goto LABEL_59;
    }
    goto LABEL_58;
  }
  unint64_t v24 = v9;
  if (a2 > v9)
  {
    unsigned int v25 = v9 + 1;
    while (1)
    {
      uint64_t v26 = *(void *)(a1 + 8 * v24);
      if (v26 != 0x8000000000000000 && v26 != 1) {
        goto LABEL_57;
      }
      if (v42)
      {
        uint64_t v28 = (char *)v41 + 32 * v42;
        unint64_t v29 = *((unsigned int *)v28 - 6);
        if (v29 >= *((unsigned int *)v28 - 5))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v28 - 32), v28 - 16, v29 + 1, 8);
          unint64_t v29 = *((unsigned int *)v28 - 6);
        }
        *(void *)(*((void *)v28 - 4) + 8 * v29) = v24;
        ++*((_DWORD *)v28 - 6);
      }
      unint64_t v24 = v25++;
      if (a2 <= v24)
      {
        LODWORD(v10) = v42;
        break;
      }
    }
  }
  *(void *)a5 = a5 + 16;
  *(void *)(a5 + 8) = 0x100000000;
  if (v10) {
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(a5, (uint64_t)&v41);
  }
  *(unsigned char *)(a5 + 48) = 1;
  BOOL v30 = v38;
  if (v38 != v40) {
LABEL_58:
  }
    free(v30);
LABEL_59:
  unint64_t v31 = (char *)v41;
  if (v42)
  {
    uint64_t v32 = 32 * v42;
    do
    {
      BOOL v33 = *(char **)&v31[v32 - 32];
      if (&v31[v32 - 16] != v33) {
        free(v33);
      }
      v32 -= 32;
    }
    while (v32);
    unint64_t v31 = (char *)v41;
  }
  if (v31 != (char *)v43) {
    free(v31);
  }
}

void mlir::composeReassociationIndices(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t a4@<X3>, uint64_t a5@<X8>)
{
  v47[4] = *MEMORY[0x1E4F143B8];
  uint64_t v45 = v47;
  uint64_t v46 = 0x100000000;
  if (a2 == a4) {
    goto LABEL_45;
  }
  if (a2 < a4) {
    unint64_t v6 = a2;
  }
  else {
    unint64_t v6 = a4;
  }
  if (a2 < a4) {
    uint64_t v7 = a1;
  }
  else {
    uint64_t v7 = a3;
  }
  if (a2 < a4) {
    uint64_t v8 = a3;
  }
  else {
    uint64_t v8 = a1;
  }
  if (a2 < a4) {
    unint64_t v9 = a4;
  }
  else {
    unint64_t v9 = a2;
  }
  if (!v6)
  {
    *(void *)a5 = a5 + 16;
    *(void *)(a5 + 8) = 0x100000000;
    *(unsigned char *)(a5 + 48) = 1;
    return;
  }
  unint64_t v10 = (v6 - 1) & 0x7FFFFFFFFFFFFFFLL;
  if (v10 >= 4)
  {
    unint64_t v13 = v10 + 1;
    uint64_t v14 = v13 & 3;
    if ((v13 & 3) == 0) {
      uint64_t v14 = 4;
    }
    unint64_t v15 = v13 - v14;
    uint64_t v12 = v7 + 32 * v15;
    int32x2_t v16 = 0;
    uint64_t v17 = (int32x2_t *)(v7 + 72);
    int32x2_t v18 = 0;
    do
    {
      int32x2_t v19 = vzip1_s32(v17[-8], v17[-4]);
      int32x2_t v20 = v17[4];
      int32x2_t v21 = *v17;
      v17 += 16;
      int32x2_t v16 = vadd_s32(v19, v16);
      int32x2_t v18 = vadd_s32(vzip1_s32(v21, v20), v18);
      v15 -= 4;
    }
    while (v15);
    int32x2_t v22 = vadd_s32(v18, v16);
    unsigned __int32 v11 = vpadd_s32(v22, v22).u32[0];
  }
  else
  {
    unsigned __int32 v11 = 0;
    uint64_t v12 = v7;
  }
  uint64_t v23 = v7 + 32 * v6;
  do
  {
    v11 += *(_DWORD *)(v12 + 8);
    v12 += 32;
  }
  while (v12 != v23);
  if (v9 != v11)
  {
LABEL_45:
    *(unsigned char *)a5 = 0;
    *(unsigned char *)(a5 + 48) = 0;
    return;
  }
  do
  {
    unint64_t v24 = *(void **)v7;
    uint64_t v25 = *(unsigned int *)(v7 + 8);
    uint64_t v42 = v44;
    uint64_t v43 = 0x200000000;
    if (v25)
    {
      unsigned int v26 = 0;
      uint64_t v27 = 8 * v25;
      do
      {
        uint64_t v28 = v8 + 32 * *v24;
        unint64_t v29 = *(const void **)v28;
        uint64_t v30 = *(unsigned int *)(v28 + 8);
        unint64_t v31 = v30 + v26;
        if (v31 > HIDWORD(v43))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v42, v44, v31, 8);
          unsigned int v26 = v43;
        }
        if (v30)
        {
          memcpy((char *)v42 + 8 * v26, v29, 8 * v30);
          unsigned int v26 = v43;
        }
        v26 += v30;
        LODWORD(v43) = v26;
        ++v24;
        v27 -= 8;
      }
      while (v27);
    }
    uint64_t v32 = (char *)v45;
    if (v46 >= HIDWORD(v46))
    {
      unint64_t v35 = v46 + 1;
      if (v45 <= &v42 && (char *)v45 + 32 * v46 > (char *)&v42)
      {
        int64_t v36 = (char *)&v42 - (unsigned char *)v45;
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v45, v35);
        uint64_t v32 = (char *)v45;
        BOOL v33 = (void **)((char *)v45 + v36);
      }
      else
      {
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow((uint64_t)&v45, v35);
        BOOL v33 = &v42;
        uint64_t v32 = (char *)v45;
      }
    }
    else
    {
      BOOL v33 = &v42;
    }
    uint64_t v34 = &v32[32 * v46];
    *(void *)uint64_t v34 = v34 + 16;
    *((void *)v34 + 1) = 0x200000000;
    if (*((_DWORD *)v33 + 2)) {
      llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v34, (uint64_t)v33);
    }
    LODWORD(v46) = v46 + 1;
    if (v42 != v44) {
      free(v42);
    }
    v7 += 32;
  }
  while (v7 != v23);
  int v37 = v46;
  *(void *)a5 = a5 + 16;
  *(void *)(a5 + 8) = 0x100000000;
  if (v37)
  {
    llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(a5, (uint64_t)&v45);
    uint64_t v38 = v46;
    *(unsigned char *)(a5 + 48) = 1;
    uint64_t v39 = (char *)v45;
    if (!v38) {
      goto LABEL_55;
    }
    uint64_t v40 = 32 * v38;
    do
    {
      uint64_t v41 = *(char **)&v39[v40 - 32];
      if (&v39[v40 - 16] != v41) {
        free(v41);
      }
      v40 -= 32;
    }
    while (v40);
  }
  else
  {
    *(unsigned char *)(a5 + 48) = 1;
  }
  uint64_t v39 = (char *)v45;
LABEL_55:
  if (v39 != (char *)v47) {
    free(v39);
  }
}

void mlir::convertReassociationIndicesToExprs(mlir::MLIRContext *a1@<X0>, unsigned int **a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  v22[2] = *MEMORY[0x1E4F143B8];
  *(void *)a4 = a4 + 16;
  *(void *)(a4 + 8) = 0x200000000;
  if (a3)
  {
    unint64_t v5 = a2;
    uint64_t v7 = &a2[4 * a3];
    do
    {
      int32x2_t v20 = v22;
      uint64_t v21 = 0x200000000;
      unint64_t v8 = *((unsigned int *)v5 + 2);
      if (v8 >= 3)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v8, 8);
        unint64_t v8 = *((unsigned int *)v5 + 2);
      }
      if (v8)
      {
        unint64_t v9 = *v5;
        uint64_t v10 = 8 * v8;
        do
        {
          uint64_t AffineDimExpr = mlir::getAffineDimExpr((mlir *)*v9, a1, (mlir::MLIRContext *)v8);
          uint64_t v12 = v21;
          if (v21 >= (unint64_t)HIDWORD(v21))
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v21 + 1, 8);
            uint64_t v12 = v21;
          }
          *((void *)v20 + v12) = AffineDimExpr;
          LODWORD(v21) = v21 + 1;
          v9 += 2;
          v10 -= 8;
        }
        while (v10);
      }
      uint64_t v13 = *(unsigned int *)(a4 + 8);
      unint64_t v14 = *(void *)a4;
      if (v13 >= *(_DWORD *)(a4 + 12))
      {
        unint64_t v17 = v13 + 1;
        BOOL v18 = v14 + 32 * v13 > (unint64_t)&v20;
        if (v14 <= (unint64_t)&v20 && v18)
        {
          int32x2_t v19 = (char *)&v20 - v14;
          llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a4, v17);
          unint64_t v14 = *(void *)a4;
          unint64_t v15 = (void **)&v19[*(void *)a4];
          goto LABEL_13;
        }
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a4, v17);
        unint64_t v14 = *(void *)a4;
      }
      unint64_t v15 = &v20;
LABEL_13:
      int32x2_t v16 = (void *)(v14 + 32 * *(unsigned int *)(a4 + 8));
      *int32x2_t v16 = v16 + 2;
      v16[1] = 0x200000000;
      if (*((_DWORD *)v15 + 2)) {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v16, (uint64_t)v15);
      }
      ++*(_DWORD *)(a4 + 8);
      if (v20 != v22) {
        free(v20);
      }
      v5 += 4;
    }
    while (v5 != v7);
  }
}

uint64_t mlir::getReassociationIndicesAttribute(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  void v16[4] = *MEMORY[0x1E4F143B8];
  unint64_t v6 = 32 * a3;
  unint64_t v14 = v16;
  uint64_t v15 = 0x400000000;
  if ((unint64_t)(32 * a3) < 0x81)
  {
    uint64_t v7 = 0;
    int v9 = 0;
    unint64_t v8 = v16;
    if (!a3) {
      goto LABEL_8;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, (32 * a3) >> 5, 8);
    uint64_t v7 = v15;
    unint64_t v8 = v14;
    int v9 = v15;
    if (!a3) {
      goto LABEL_8;
    }
  }
  uint64_t v10 = a2 + v6;
  unsigned __int32 v11 = &v8[v7];
  do
  {
    *v11++ = mlir::Builder::getI64ArrayAttr(a1, *(void ***)a2, *(unsigned int *)(a2 + 8));
    a2 += 32;
  }
  while (a2 != v10);
  int v9 = v15;
  unint64_t v8 = v14;
LABEL_8:
  LODWORD(v15) = v9 + (v6 >> 5);
  uint64_t ArrayAttr = mlir::Builder::getArrayAttr((mlir::MLIRContext **)a1, (uint64_t)v8, v15);
  if (v14 != v16) {
    free(v14);
  }
  return ArrayAttr;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::push_back(uint64_t a1, unint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = *(void *)a1;
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    unint64_t v11 = v4 + 1;
    unint64_t v12 = v5 + 32 * v4;
    if (v5 <= a2 && v12 > a2)
    {
      unint64_t v14 = a2 - v5;
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v11);
      unint64_t v5 = *(void *)a1;
      a2 = *(void *)a1 + v14;
    }
    else
    {
      llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v11);
      unint64_t v5 = *(void *)a1;
    }
  }
  unint64_t v6 = (void *)(v5 + 32 * *(unsigned int *)(a1 + 8));
  uint64_t v7 = v6 + 2;
  void *v6 = v6 + 2;
  v6[1] = 0x200000000;
  unsigned int v8 = *(_DWORD *)(a2 + 8);
  if (v6 != (void *)a2 && v8 != 0)
  {
    if (v8 < 3)
    {
      unsigned int v10 = *(_DWORD *)(a2 + 8);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v6, v6 + 2, *(unsigned int *)(a2 + 8), 8);
      unsigned int v10 = *(_DWORD *)(a2 + 8);
      if (!v10)
      {
LABEL_11:
        *((_DWORD *)v6 + 2) = v8;
        goto LABEL_12;
      }
      uint64_t v7 = (void *)*v6;
    }
    memcpy(v7, *(const void **)a2, 8 * v10);
    goto LABEL_11;
  }
LABEL_12:
  ++*(_DWORD *)(a1 + 8);
}

void mlir::getSymbolLessAffineMaps(uint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v18 = 0;
  if (a2)
  {
    uint64_t v5 = a1;
    uint64_t v6 = a1;
    uint64_t v7 = a1 + 32 * a2;
    do
    {
      uint64_t v8 = *(unsigned int *)(v6 + 8);
      if (v8)
      {
        int v9 = *(uint64_t **)v6;
        uint64_t v10 = 8 * v8;
        do
        {
          uint64_t v17 = *v9;
          v19[0] = &unk_1EC9CEAD0;
          v19[1] = &v18;
          int32x2_t v20 = v19;
          mlir::AffineExpr::walk(&v17, v19);
          if (v20 == v19)
          {
            (*(void (**)(void *))(v19[0] + 32))(v19);
          }
          else if (v20)
          {
            (*(void (**)(void))(*v20 + 40))();
          }
          ++v9;
          v10 -= 8;
        }
        while (v10);
      }
      v6 += 32;
    }
    while (v6 != v7);
    int v11 = v18 + 1;
    *(void *)a3 = a3 + 16;
    *(void *)(a3 + 8) = 0x400000000;
    if (a2 >= 5) {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), a2, 8);
    }
    do
    {
      unint64_t v12 = *(mlir::BytecodeWriterConfig **)v5;
      uint64_t v13 = *(unsigned int *)(v5 + 8);
      DesiredBytecodeVersion = (void *)mlir::BytecodeWriterConfig::getDesiredBytecodeVersion(*(mlir::BytecodeWriterConfig **)v5);
      uint64_t v15 = mlir::AffineMap::get(v11, 0, (uint64_t)v12, v13, DesiredBytecodeVersion);
      unint64_t v16 = *(unsigned int *)(a3 + 8);
      if (v16 >= *(unsigned int *)(a3 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v16 + 1, 8);
        unint64_t v16 = *(unsigned int *)(a3 + 8);
      }
      *(void *)(*(void *)a3 + 8 * v16) = v15;
      ++*(_DWORD *)(a3 + 8);
      v5 += 32;
    }
    while (v5 != v7);
  }
  else
  {
    *(void *)a3 = a3 + 16;
    *(void *)(a3 + 8) = 0x400000000;
  }
}

uint64_t mlir::isReassociationValid(mlir::AffineMap *a1, uint64_t a2, _DWORD *a3)
{
  if (!a2) {
    return 1;
  }
  uint64_t v5 = a1;
  int NumDims = mlir::AffineMap::getNumDims(a1);
  int v7 = 0;
  int v8 = 0;
  int v9 = (mlir::AffineMap *)((char *)v5 + 8 * a2);
  do
  {
    uint64_t v17 = *(void *)v5;
    if (mlir::AffineMap::getNumDims((mlir::AffineMap *)&v17) != NumDims
      || mlir::AffineMap::getNumSymbols((mlir::AffineMap *)&v17))
    {
      goto LABEL_15;
    }
    uint64_t Results = mlir::AffineMap::getResults((mlir::AffineMap *)&v17);
    if (v11)
    {
      unint64_t v12 = (uint64_t *)Results;
      uint64_t v13 = 8 * v11;
      while (1)
      {
        uint64_t v14 = *v12;
        uint64_t v18 = *v12;
        if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v18) == 6)
        {
          mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v18, v14);
          uint64_t v16 = v18;
          if (!v18) {
            break;
          }
        }
        else
        {
          mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v18, 0);
          uint64_t v16 = v18;
          if (!v18) {
            break;
          }
        }
        if (v7 != mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v16)) {
          break;
        }
        ++v7;
        ++v12;
        v13 -= 8;
        if (!v13) {
          goto LABEL_3;
        }
      }
LABEL_15:
      if (a3) {
        *a3 = v8;
      }
      return 0;
    }
LABEL_3:
    ++v8;
    uint64_t v5 = (mlir::AffineMap *)((char *)v5 + 8);
  }
  while (v5 != v9);
  if (v7 == NumDims) {
    return 1;
  }
  uint64_t result = 0;
  if (a3) {
    *a3 = a2 - 1;
  }
  return result;
}

uint64_t mlir::reshapeLikeShapesAreCompatible(uint64_t (*a1)(uint64_t, void **), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (!a8) {
    return 1;
  }
  uint64_t v12 = a7 + 32 * a8;
  if (a9)
  {
    unsigned int v13 = 0;
    for (uint64_t i = 0; ; ++i)
    {
      v9 &= 0xFFFFFFFFFFFFFF00;
      uint64_t v49 = 1;
      uint64_t v15 = v13;
      uint64_t v16 = *(unsigned int *)(a7 + 8);
      if (v16)
      {
        int v17 = 0;
        uint64_t v18 = 0;
        uint64_t v19 = 8 * v16;
        uint64_t v20 = 1;
        uint64_t v21 = a5 + 8 * v13;
        do
        {
          while (1)
          {
            uint64_t v22 = *(void *)(v21 + 8 * v18);
            if (v22 == 0x8000000000000000) {
              break;
            }
            v20 *= v22;
            uint64_t v49 = v20;
            ++v18;
            v19 -= 8;
            if (!v19) {
              goto LABEL_10;
            }
          }
          if (v17)
          {
            uint64_t v33 = i;
            v34[0] = "invalid to have a single dimension (";
            v34[2] = &v33;
            __int16 v35 = 2819;
            v36[0] = v34;
            v36[2] = ") expanded into multiple dynamic dims (";
            __int16 v30 = 770;
            __int16 v37 = 770;
            uint64_t v32 = v9 + v15;
            v38[0] = v36;
            v38[2] = &v32;
            __int16 v39 = 3586;
            v40[0] = v38;
            uint64_t v41 = ",";
            __int16 v42 = 770;
            uint64_t v31 = v15 + v18;
            v43[0] = v40;
            BOOL v44 = (const char *)&v31;
            __int16 v45 = 2818;
            uint64_t v46 = v43;
            uint64_t v47 = ")";
            goto LABEL_31;
          }
          int v17 = 1;
          uint64_t v9 = v18++;
          v19 -= 8;
        }
        while (v19);
LABEL_10:
        if (!v17) {
          goto LABEL_14;
        }
        if (*(void *)(a3 + 8 * i) != 0x8000000000000000) {
          goto LABEL_28;
        }
      }
      else
      {
        uint64_t v20 = 1;
LABEL_14:
        if (*(void *)(a3 + 8 * i) != v20) {
          goto LABEL_30;
        }
      }
      unsigned int v13 = v16 + v15;
      a7 += 32;
      if (a7 == v12) {
        return 1;
      }
    }
  }
  unsigned int v24 = 0;
  for (uint64_t i = 0; ; ++i)
  {
    uint64_t v49 = 1;
    uint64_t v25 = *(unsigned int *)(a7 + 8);
    uint64_t v26 = 1;
    if (!v25) {
      break;
    }
    int v27 = 0;
    uint64_t v28 = 8 * v25;
    uint64_t v26 = 1;
    unint64_t v29 = (void *)(a5 + 8 * v24);
    do
    {
      while (*v29 != 0x8000000000000000)
      {
        v26 *= *v29;
        uint64_t v49 = v26;
        ++v29;
        v28 -= 8;
        if (!v28) {
          goto LABEL_26;
        }
      }
      int v27 = 1;
      ++v29;
      v28 -= 8;
    }
    while (v28);
LABEL_26:
    if (!v27) {
      break;
    }
    if (*(void *)(a3 + 8 * i) != 0x8000000000000000)
    {
LABEL_28:
      v40[0] = i;
      v43[0] = "expected dimension ";
      BOOL v44 = (const char *)v40;
      __int16 v45 = 2819;
      uint64_t v46 = v43;
      uint64_t v47 = " of collapsed type to be dynamic since one or more of the corresponding dimensions in the expanded type is dynamic";
      __int16 v30 = 770;
      goto LABEL_31;
    }
LABEL_20:
    v24 += v25;
    a7 += 32;
    if (a7 == v12) {
      return 1;
    }
  }
  if (*(void *)(a3 + 8 * i) == v26) {
    goto LABEL_20;
  }
LABEL_30:
  v38[0] = i;
  v40[0] = "expected dimension ";
  uint64_t v41 = (const char *)v38;
  __int16 v42 = 2819;
  v43[0] = v40;
  BOOL v44 = " of collapsed type to be static value of ";
  __int16 v45 = 770;
  uint64_t v46 = v43;
  uint64_t v47 = (const char *)&v49;
  __int16 v30 = 3586;
LABEL_31:
  __int16 v48 = v30;
  return a1(a2, &v46);
}

uint64_t mlir::hasNonIdentityLayout(uint64_t a1)
{
  if (*(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    uint64_t v1 = a1;
  }
  else {
    uint64_t v1 = 0;
  }
  uint64_t v5 = v1;
  if (!v1) {
    return 0;
  }
  v4[0] = mlir::DenseElementsAttr::getRawStringData((mlir::DenseElementsAttr *)&v5);
  v4[1] = v2;
  return mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v4) ^ 1;
}

uint64_t llvm::SmallVectorImpl<llvm::SmallVector<long long,2u>>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = a2 + 16;
    uint64_t v4 = *(void *)a2;
    if (*(void *)a2 != a2 + 16)
    {
      uint64_t v6 = *(char **)a1;
      uint64_t v7 = *(unsigned int *)(a1 + 8);
      if (v7)
      {
        uint64_t v8 = 32 * v7;
        do
        {
          uint64_t v9 = *(char **)&v6[v8 - 32];
          if (&v6[v8 - 16] != v9) {
            free(v9);
          }
          v8 -= 32;
        }
        while (v8);
        uint64_t v6 = *(char **)a1;
      }
      if (v6 != (char *)(a1 + 16)) {
        free(v6);
      }
      *(void *)a1 = *(void *)a2;
      uint64_t v10 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
LABEL_12:
      _DWORD *v10 = 0;
      return a1;
    }
    uint64_t v10 = (_DWORD *)(a2 + 8);
    unint64_t v12 = *(unsigned int *)(a2 + 8);
    uint64_t v13 = *(unsigned int *)(a1 + 8);
    if (v13 < v12)
    {
      if (*(_DWORD *)(a1 + 12) >= v12)
      {
        if (!v13)
        {
          uint64_t v13 = 0;
          uint64_t v23 = *(void *)a2;
          uint64_t v24 = *(unsigned int *)(a2 + 8);
          if (*(_DWORD *)(a2 + 8))
          {
LABEL_32:
            uint64_t v25 = *(char **)a1;
            uint64_t v26 = 32 * v13;
            uint64_t v27 = 32 * v24;
            do
            {
              uint64_t v28 = &v25[v26];
              *(void *)uint64_t v28 = &v25[v26 + 16];
              *((void *)v28 + 1) = 0x200000000;
              if (*(_DWORD *)(v23 + v26 + 8)) {
                llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v28, v23 + v26);
              }
              v25 += 32;
              v27 -= 32;
              v23 += 32;
            }
            while (v26 != v27);
            uint64_t v23 = *(void *)a2;
          }
LABEL_37:
          *(_DWORD *)(a1 + 8) = v12;
          uint64_t v29 = *v10;
          if (v29)
          {
            uint64_t v30 = 32 * v29;
            do
            {
              uint64_t v31 = *(void **)(v23 + v30 - 32);
              if ((void *)(v23 + v30 - 16) != v31) {
                free(v31);
              }
              v30 -= 32;
            }
            while (v30);
          }
          goto LABEL_12;
        }
        uint64_t v21 = *(void *)a1;
        uint64_t v22 = 32 * v13;
        do
        {
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v21, v4);
          v4 += 32;
          v21 += 32;
          v22 -= 32;
        }
        while (v22);
      }
      else
      {
        if (v13)
        {
          uint64_t v14 = *(void *)a1;
          uint64_t v15 = 32 * v13;
          do
          {
            uint64_t v16 = *(void **)(v14 + v15 - 32);
            if ((void *)(v14 + v15 - 16) != v16) {
              free(v16);
            }
            v15 -= 32;
          }
          while (v15);
        }
        *(_DWORD *)(a1 + 8) = 0;
        llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(a1, v12);
        uint64_t v13 = 0;
      }
      uint64_t v23 = *(void *)a2;
      uint64_t v24 = *(unsigned int *)(a2 + 8);
      if (v13 != v24) {
        goto LABEL_32;
      }
      goto LABEL_37;
    }
    uint64_t v17 = *(void *)a1;
    if (v12)
    {
      uint64_t v18 = 0;
      do
      {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=(v17 + v18, v4 + v18);
        v18 += 32;
      }
      while (32 * v12 != v18);
      uint64_t v19 = v17 + v18;
      uint64_t v20 = *(void *)a1 + 32 * *(unsigned int *)(a1 + 8);
      if (v20 == v17 + v18)
      {
LABEL_47:
        *(_DWORD *)(a1 + 8) = v12;
        uint64_t v35 = *(unsigned int *)(a2 + 8);
        if (v35)
        {
          uint64_t v36 = *(void *)a2;
          uint64_t v37 = 32 * v35;
          do
          {
            uint64_t v38 = *(void **)(v36 + v37 - 32);
            if ((void *)(v36 + v37 - 16) != v38) {
              free(v38);
            }
            v37 -= 32;
          }
          while (v37);
        }
        goto LABEL_12;
      }
    }
    else
    {
      uint64_t v19 = *(void *)a1;
      uint64_t v20 = v17 + 32 * v13;
      if (v20 == v17) {
        goto LABEL_47;
      }
    }
    uint64_t v32 = (char *)(v20 - 16);
    do
    {
      uint64_t v34 = (char *)*((void *)v32 - 2);
      if (v32 != v34) {
        free(v34);
      }
      uint64_t v33 = v32 - 16;
      v32 -= 32;
    }
    while (v33 != (char *)v19);
    goto LABEL_47;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v14 = 0;
  uint64_t v3 = (_DWORD *)(a1 + 16);
  uint64_t v4 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 32, &v14);
  uint64_t v5 = v4;
  uint64_t v6 = *(_DWORD **)a1;
  uint64_t v7 = *(unsigned int *)(a1 + 8);
  if (v7)
  {
    uint64_t v8 = 32 * v7;
    uint64_t v9 = v4;
    do
    {
      *uint64_t v9 = v9 + 2;
      v9[1] = 0x200000000;
      if (v6[2]) {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v9, (uint64_t)v6);
      }
      v9 += 4;
      v6 += 8;
      v8 -= 32;
    }
    while (v8);
    uint64_t v6 = *(_DWORD **)a1;
    uint64_t v10 = *(unsigned int *)(a1 + 8);
    if (v10)
    {
      uint64_t v11 = 8 * v10;
      do
      {
        unint64_t v12 = *(_DWORD **)&v6[v11 - 8];
        if (&v6[v11 - 4] != v12) {
          free(v12);
        }
        v11 -= 8;
      }
      while (v11 * 4);
      uint64_t v6 = *(_DWORD **)a1;
    }
  }
  int v13 = v14;
  if (v6 != v3) {
    free(v6);
  }
  *(void *)a1 = v5;
  *(_DWORD *)(a1 + 12) = v13;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallVector<long long,2u>,false>::growAndEmplaceBack<llvm::SmallVector<long long,2u>>(uint64_t a1, uint64_t a2)
{
  unint64_t v17 = 0;
  uint64_t v4 = (_DWORD *)(a1 + 16);
  uint64_t v5 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 32, &v17);
  uint64_t v6 = &v5[4 * *(unsigned int *)(a1 + 8)];
  void *v6 = v6 + 2;
  v6[1] = 0x200000000;
  if (*(_DWORD *)(a2 + 8)) {
    llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v6, a2);
  }
  uint64_t v7 = *(_DWORD **)a1;
  uint64_t v8 = *(unsigned int *)(a1 + 8);
  if (v8)
  {
    uint64_t v9 = 32 * v8;
    uint64_t v10 = v5;
    do
    {
      void *v10 = v10 + 2;
      v10[1] = 0x200000000;
      if (v7[2]) {
        llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)v10, (uint64_t)v7);
      }
      v10 += 4;
      v7 += 8;
      v9 -= 32;
    }
    while (v9);
    uint64_t v7 = *(_DWORD **)a1;
    uint64_t v11 = *(unsigned int *)(a1 + 8);
    if (v11)
    {
      uint64_t v12 = 8 * v11;
      do
      {
        int v13 = *(_DWORD **)&v7[v12 - 8];
        if (&v7[v12 - 4] != v13) {
          free(v13);
        }
        v12 -= 8;
      }
      while (v12 * 4);
      uint64_t v7 = *(_DWORD **)a1;
    }
  }
  int v14 = v17;
  if (v7 != v4) {
    free(v7);
  }
  *(void *)a1 = v5;
  uint64_t v15 = (*(_DWORD *)(a1 + 8) + 1);
  *(_DWORD *)(a1 + 8) = v15;
  *(_DWORD *)(a1 + 12) = v14;
  return (uint64_t)&v5[4 * v15 - 4];
}

void llvm::SmallVectorImpl<long long>::swap(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    unint64_t v4 = *(void *)a1;
    if (*(void *)a1 != a1 + 16 && *(void *)a2 != a2 + 16)
    {
      *(void *)a1 = *(void *)a2;
      *(void *)a2 = v4;
      int v5 = *(_DWORD *)(a1 + 8);
      *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = v5;
      int v6 = *(_DWORD *)(a1 + 12);
      *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 12);
      *(_DWORD *)(a2 + 12) = v6;
      return;
    }
    unint64_t v7 = *(unsigned int *)(a2 + 8);
    if (*(_DWORD *)(a1 + 12) >= v7)
    {
      unint64_t v8 = *(unsigned int *)(a1 + 8);
      if (*(_DWORD *)(a2 + 12) >= v8)
      {
LABEL_7:
        uint64_t v9 = v8;
        uint64_t v10 = *(unsigned int *)(a2 + 8);
        if (v8 >= v10) {
          uint64_t v11 = v10;
        }
        else {
          uint64_t v11 = v8;
        }
        if (!v11) {
          goto LABEL_30;
        }
LABEL_17:
        unint64_t v13 = *(void *)a1;
        unint64_t v14 = *(void *)a2;
        if (v11 >= 4 && (v13 < v14 + 8 * v11 ? (BOOL v15 = v14 >= v13 + 8 * v11) : (BOOL v15 = 1), v15))
        {
          uint64_t v16 = v11 & 0xFFFFFFFC;
          unint64_t v17 = (long long *)(v13 + 16);
          uint64_t v18 = (long long *)(v14 + 16);
          uint64_t v19 = v16;
          do
          {
            long long v20 = *(v17 - 1);
            long long v21 = *v17;
            long long v22 = *v18;
            *(v17 - 1) = *(v18 - 1);
            long long *v17 = v22;
            *(v18 - 1) = v20;
            long long *v18 = v21;
            v17 += 2;
            v18 += 2;
            v19 -= 4;
          }
          while (v19);
          if (v16 == v11) {
            goto LABEL_30;
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
        uint64_t v23 = v11 - v16;
        uint64_t v24 = 8 * v16;
        uint64_t v25 = (uint64_t *)(v13 + v24);
        uint64_t v26 = (uint64_t *)(v14 + v24);
        do
        {
          uint64_t v27 = *v25;
          *v25++ = *v26;
          *v26++ = v27;
          --v23;
        }
        while (v23);
LABEL_30:
        if (v10 >= v9)
        {
          if (v10 > v9)
          {
            int v29 = v10 - v9;
            memcpy((void *)(*(void *)a1 + 8 * v9), (const void *)(*(void *)a2 + 8 * v11), *(void *)a2 + 8 * v10 - (*(void *)a2 + 8 * v11));
            *(_DWORD *)(a1 + 8) += v29;
            *(_DWORD *)(a2 + 8) = v11;
          }
        }
        else
        {
          int v28 = v9 - v10;
          memcpy((void *)(*(void *)a2 + 8 * v10), (const void *)(*(void *)a1 + 8 * v11), *(void *)a1 + 8 * v9 - (*(void *)a1 + 8 * v11));
          *(_DWORD *)(a2 + 8) += v28;
          *(_DWORD *)(a1 + 8) = v11;
        }
        return;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v7, 8);
      unint64_t v8 = *(unsigned int *)(a1 + 8);
      if (*(_DWORD *)(a2 + 12) >= v8) {
        goto LABEL_7;
      }
    }
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v8, 8);
    unsigned int v12 = *(_DWORD *)(a1 + 8);
    uint64_t v9 = v12;
    uint64_t v10 = *(unsigned int *)(a2 + 8);
    if (v12 >= v10) {
      uint64_t v11 = v10;
    }
    else {
      uint64_t v11 = v12;
    }
    if (!v11) {
      goto LABEL_30;
    }
    goto LABEL_17;
  }
}

void *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9CEAD0;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CEAD0;
  a2[1] = v2;
  return result;
}

void *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::operator()(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = *a2;
  uint64_t v7 = *a2;
  if (mlir::AffineExpr::getKind((mlir::AffineExpr *)&v7) == 6)
  {
    uint64_t result = mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v7, v3);
    if (!v7) {
      return result;
    }
  }
  else
  {
    uint64_t result = mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(&v7, 0);
    if (!v7) {
      return result;
    }
  }
  int v5 = *(int **)(a1 + 8);
  uint64_t result = (void *)mlir::AffineDimExpr::getPosition((mlir::AffineDimExpr *)&v7);
  int v6 = *v5;
  if (*v5 <= result) {
    int v6 = (int)result;
  }
  **(_DWORD **)(a1 + 8) = v6;
  return result;
}

uint64_t std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x8000000181101255) {
    return a1 + 8;
  }
  if (((v3 & 0x8000000181101255 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x8000000181101255)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x8000000181101255 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1},std::allocator<unsigned int getMaxPosOfType<mlir::AffineDimExpr>(llvm::ArrayRef<llvm::SmallVector<mlir::AffineExpr,2u>>)::{lambda(mlir::AffineExpr)#1}>,void ()(mlir::AffineExpr)>::target_type()
{
}

void mlir::clone(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  v32[38] = *MEMORY[0x1E4F143B8];
  v23[0] = 0;
  v23[1] = 0;
  int v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0;
  int v27 = 0;
  int v28 = 0;
  uint64_t v29 = 0;
  unsigned int v30 = 0;
  uint64_t v12 = *(void *)(a2 + 24);
  uint64_t v13 = *(void *)(a2 + 48);
  if (*(unsigned char *)(a2 + 47))
  {
    v32[0] = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
    unint64_t v14 = (mlir::ArrayAttr *)v32;
  }
  else
  {
    unint64_t v14 = (mlir::ArrayAttr *)(a2 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v14);
  uint64_t v17 = v16;
  mlir::BlockRange::BlockRange(v31, 0, 0);
  mlir::OperationState::OperationState(v32, v12, v13, a5, a6, a3, a4, v18, Value, v17, v31[0], v31[1], 0, 0);
  unint64_t v19 = *(unsigned int *)(a2 + 44);
  if ((v19 & 0x7FFFFF) != 0)
  {
    long long v20 = (mlir::Region *)(((a2 + 16 * ((v19 >> 23) & 1) + ((v19 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                         + 32 * *(unsigned int *)(a2 + 40));
    uint64_t v21 = 24 * (v19 & 0x7FFFFF);
    do
    {
      long long v22 = (mlir::Region *)mlir::OperationState::addRegion((mlir::OperationState *)v32);
      mlir::Region::cloneInto(v20, v22, (mlir::IRMapping *)v23);
      long long v20 = (mlir::Region *)((char *)v20 + 24);
      v21 -= 24;
    }
    while (v21);
  }
  mlir::OpBuilder::create(a1, (const mlir::OperationState *)v32);
  mlir::OperationState::~OperationState((mlir::OperationState *)v32);
  llvm::deallocate_buffer(v28, (void *)(16 * v30));
}

void sub_1803E6950(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, llvm *a19, uint64_t a20,unsigned int a21)
{
}

void sub_1803E6964(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, llvm *a16, uint64_t a17, unsigned int a18)
{
}

uint64_t sub_1803E6978()
{
  return v0;
}

void mlir::getPrunedAttributeList(unsigned char *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  int v24 = 0;
  uint64_t v25 = 0;
  uint64_t v26 = 0x800000000;
  if (a3)
  {
    uint64_t v6 = a2;
    uint64_t v7 = a2 + 16 * a3;
    do
    {
      unint64_t v8 = *(int8x16_t **)v6;
      uint64_t v9 = *(const unsigned __int8 **)(v6 + 8);
      v6 += 16;
      llvm::StringMap<std::nullopt_t,llvm::MallocAllocator>::try_emplace<>((uint64_t)&v24, v8, v9);
    }
    while (v6 != v7);
  }
  *(void *)a4 = a4 + 16;
  *(void *)(a4 + 8) = 0x300000000;
  if (a1[47])
  {
    *(void *)&long long v23 = mlir::Operation::getAttrDictionary((mlir::Operation *)a1);
    uint64_t Value = (long long *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v23);
    if (!v10) {
      goto LABEL_16;
    }
  }
  else
  {
    uint64_t Value = (long long *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)(a1 + 56));
    if (!v10) {
      goto LABEL_16;
    }
  }
  uint64_t v12 = 16 * v10;
  do
  {
    long long v23 = *Value;
    uint64_t CallableRegion = mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v23);
    uint64_t AttrData = (int8x16_t *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&CallableRegion);
    int Key = llvm::StringMapImpl::FindKey((uint64_t *)&v24, AttrData, v16);
    if (Key == -1 || Key == (unint64_t)v25)
    {
      long long v13 = v23;
      unint64_t v14 = *(unsigned int *)(a4 + 8);
      if (v14 >= *(unsigned int *)(a4 + 12))
      {
        long long v21 = v23;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v14 + 1, 16);
        long long v13 = v21;
        unint64_t v14 = *(unsigned int *)(a4 + 8);
      }
      *(_OWORD *)(*(void *)a4 + 16 * v14) = v13;
      ++*(_DWORD *)(a4 + 8);
    }
    ++Value;
    v12 -= 16;
  }
  while (v12);
LABEL_16:
  if (HIDWORD(v25) && v25)
  {
    uint64_t v18 = 0;
    do
    {
      unint64_t v19 = *(llvm **)((char *)v24 + v18);
      if (v19 != (llvm *)-8 && v19 != 0) {
        llvm::deallocate_buffer(v19, (void *)(*(void *)v19 + 9));
      }
      v18 += 8;
    }
    while (8 * v25 != v18);
  }
  free(v24);
}

void mlir::dispatchIndexOpFoldResult(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = a1 & 0xFFFFFFFFFFFFFFF8;
  if ((a1 & 4) != 0 && v4)
  {
    uint64_t v6 = *(unsigned int *)(a2 + 8);
    if (v6 >= *(_DWORD *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v6 + 1, 8);
      LODWORD(v6) = *(_DWORD *)(a2 + 8);
    }
    *(void *)(*(void *)a2 + 8 * v6) = v4;
    ++*(_DWORD *)(a2 + 8);
    uint64_t v7 = *(unsigned int *)(a3 + 8);
    if (v7 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v7 + 1, 8);
      LODWORD(v7) = *(_DWORD *)(a3 + 8);
    }
    *(void *)(*(void *)a3 + 8 * v7) = 0x8000000000000000;
    ++*(_DWORD *)(a3 + 8);
  }
  else
  {
    unint64_t v10 = a1 & 0xFFFFFFFFFFFFFFF8;
    mlir::IntegerAttr::getValue(&v10, (llvm::APInt *)&__p);
    if (v12 > 0x40) {
      uint64_t v8 = *(void *)__p;
    }
    else {
      uint64_t v8 = (uint64_t)((void)__p << -(uint64_t)v12) >> -(uint64_t)v12;
    }
    uint64_t v9 = *(unsigned int *)(a3 + 8);
    if (v9 >= *(_DWORD *)(a3 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v9 + 1, 8);
      LODWORD(v9) = *(_DWORD *)(a3 + 8);
    }
    *(void *)(*(void *)a3 + 8 * v9) = v8;
    ++*(_DWORD *)(a3 + 8);
    if (v12 >= 0x41 && __p) {
      operator delete[](__p);
    }
  }
}

void mlir::dispatchIndexOpFoldResults(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (a2)
  {
    uint64_t v7 = 8 * a2;
    do
    {
      uint64_t v8 = *a1++;
      mlir::dispatchIndexOpFoldResult(v8, a3, a4);
      v7 -= 8;
    }
    while (v7);
  }
}

uint64_t mlir::getAsOpFoldResult(uint64_t a1)
{
  v8[1] = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 0;
  }
  uint64_t v6 = a1;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v6);
  if (!DefiningOp) {
    return a1 | 4;
  }
  uint64_t v3 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((void *)(DefiningOp + 48))) {
    return a1 | 4;
  }
  v7[0] = v8;
  v7[1] = (void *)0x100000000;
  mlir::Operation::fold(v3, 0, 0, (uint64_t)v7);
  unint64_t v4 = *(void *)v7[0] & 0xFFFFFFFFFFFFFFF8;
  if (v7[0] != v8) {
    free(v7[0]);
  }
  if (!v4) {
    return a1 | 4;
  }
  return v4;
}

void mlir::getAsOpFoldResult(uint64_t a1@<X0>, unint64_t a2@<X1>, void *a3@<X8>)
{
  v21[1] = *MEMORY[0x1E4F143B8];
  *a3 = a3 + 2;
  a3[1] = 0x600000000;
  if (a2 < 7)
  {
    uint64_t v18 = a1;
    long long v19 = xmmword_1811012D0;
    if (!a2)
    {
      int v16 = 0;
      goto LABEL_20;
    }
    uint64_t v6 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a3, a3 + 2, a2, 8);
    uint64_t v6 = *((unsigned int *)a3 + 2);
    uint64_t v18 = a1;
    long long v19 = xmmword_1811012D0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = (unint64_t *)(*a3 + 8 * v6);
  do
  {
    uint64_t v11 = mlir::ValueRange::dereference_iterator(&v18, v7);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v17 = v11;
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v17);
      if (!DefiningOp) {
        goto LABEL_6;
      }
      uint64_t v14 = DefiningOp;
      if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((void *)(DefiningOp + 48))) {
        goto LABEL_6;
      }
      v20[0] = v21;
      v20[1] = (void *)0x100000000;
      mlir::Operation::fold(v14, 0, 0, (uint64_t)v20);
      uint64_t v15 = *(void *)v20[0];
      if (v20[0] != v21) {
        free(v20[0]);
      }
      unint64_t v9 = v15 & 0xFFFFFFFFFFFFFFF8;
      if ((v15 & 0xFFFFFFFFFFFFFFF8) == 0) {
LABEL_6:
      }
        unint64_t v9 = v12 | 4;
    }
    else
    {
      unint64_t v9 = 0;
    }
    *v8++ = v9;
    uint64_t v7 = v19 + 1;
    *(void *)&long long v19 = v19 + 1;
  }
  while (v18 != a1 || v7 != a2);
  int v16 = *((_DWORD *)a3 + 2);
LABEL_20:
  *((_DWORD *)a3 + 2) = v16 + a2;
}

unint64_t mlir::getConstantIntValue(uint64_t a1)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = (void *)(a1 & 0xFFFFFFFFFFFFFFF8);
  if ((a1 & 4) != 0 && v1)
  {
    unsigned int v17 = 1;
    char v18 = 0;
    p_p = &__p;
    __p = 0;
    unint64_t v19 = a1 & 0xFFFFFFFFFFFFFFF8;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v19);
    if (!DefiningOp) {
      goto LABEL_28;
    }
    uint64_t v3 = DefiningOp;
    if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((void *)(DefiningOp + 48))) {
      goto LABEL_28;
    }
    long long v20 = v22;
    uint64_t v21 = 0x100000000;
    mlir::Operation::fold(v3, 0, 0, (uint64_t)&v20);
    unint64_t v4 = *(void *)v20 & 0xFFFFFFFFFFFFFFF8;
    if (v20 != v22) {
      free(v20);
    }
    if (v4
      && ((int v5 = *(void **)(*(void *)(*(void *)(v3 - 8) & 0xFFFFFFFFFFFFFFF8) + 136),
           v5 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
        ? (BOOL v6 = v5 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        : (BOOL v6 = 1),
          !v6 ? (BOOL v7 = v5 == &mlir::detail::TypeIDResolver<mlir::VectorType,void>::id) : (BOOL v7 = 1),
          !v7 ? (BOOL v8 = v5 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) : (BOOL v8 = 1),
          v8))
    {
      int v9 = mlir::detail::constant_int_value_binder::match((uint64_t *)&p_p, v4);
      unsigned int v10 = v17;
      if (v9)
      {
        if (v17 > 0x40) {
          uint64_t v11 = *(void *)__p;
        }
        else {
          uint64_t v11 = (uint64_t)((void)__p << -(char)v17) >> -(char)v17;
        }
        unint64_t v13 = v11 & 0xFFFFFFFFFFFFFF00;
      }
      else
      {
        LOBYTE(v11) = 0;
        unint64_t v13 = 0;
      }
    }
    else
    {
LABEL_28:
      LOBYTE(v11) = 0;
      unint64_t v13 = 0;
      unsigned int v10 = v17;
    }
    if (v10 >= 0x41 && __p) {
      operator delete[](__p);
    }
  }
  else
  {
    if (!v1 || (a1 & 4) != 0) {
      goto LABEL_27;
    }
    uint64_t v12 = *(void **)(*(void *)v1 + 136);
    if (v12 != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
      uint64_t v1 = 0;
    }
    __p = v1;
    if (v12 == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      mlir::IntegerAttr::getValue(&__p, (llvm::APInt *)&v20);
      if (v21 > 0x40)
      {
        uint64_t v11 = *(void *)v20;
        operator delete[](v20);
      }
      else
      {
        uint64_t v11 = (uint64_t)((void)v20 << -(uint64_t)v21) >> -(uint64_t)v21;
      }
      unint64_t v13 = v11 & 0xFFFFFFFFFFFFFF00;
    }
    else
    {
LABEL_27:
      LOBYTE(v11) = 0;
      unint64_t v13 = 0;
    }
  }
  return v13 & 0xFFFFFFFFFFFFFF00 | v11;
}

BOOL mlir::isConstantIntValue(uint64_t a1, uint64_t a2)
{
  ConstantIntuint64_t Value = mlir::getConstantIntValue(a1);
  return v4 && ConstantIntValue == a2;
}

uint64_t mlir::isEqualConstantIntOrValue(uint64_t a1, uint64_t a2)
{
  ConstantIntuint64_t Value = mlir::getConstantIntValue(a1);
  char v6 = v5;
  unint64_t v7 = mlir::getConstantIntValue(a2);
  if (v6 && v8 && ConstantIntValue == v7) {
    return 1;
  }
  BOOL v10 = (a1 & 0xFFFFFFFFFFFFFFF8) != 0
     && (a1 & 0xFFFFFFFFFFFFFFF8) == (a2 & (a2 << 61 >> 63) & 0xFFFFFFFFFFFFFFF8);
  return (a1 & 4) != 0 && v10;
}

void mlir::getMixedValues(void **a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, mlir::Builder *a5@<X4>, uint64_t a6@<X8>)
{
  LODWORD(v7) = a2;
  uint64_t v16[2] = *MEMORY[0x1E4F143B8];
  v16[0] = a3;
  v16[1] = a4;
  BOOL v10 = (void *)(a6 + 16);
  *(void *)a6 = a6 + 16;
  *(void *)(a6 + 8) = 0x600000000;
  if (a2 >= 7) {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v10, a2, 8);
  }
  uint64_t v7 = v7;
  if (v7)
  {
    unsigned int v11 = 0;
    do
    {
      unint64_t v13 = *a1++;
      uint64_t v12 = v13;
      if (v13 == (void *)0x8000000000000000) {
        unint64_t v14 = mlir::ValueRange::dereference_iterator(v16, v11++) | 4;
      }
      else {
        unint64_t v14 = mlir::Builder::getI64IntegerAttr(a5, v12) & 0xFFFFFFFFFFFFFFFBLL;
      }
      unint64_t v15 = *(unsigned int *)(a6 + 8);
      if (v15 >= *(unsigned int *)(a6 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a6, v10, v15 + 1, 8);
        unint64_t v15 = *(unsigned int *)(a6 + 8);
      }
      *(void *)(*(void *)a6 + 8 * v15) = v14;
      ++*(_DWORD *)(a6 + 8);
      --v7;
    }
    while (v7);
  }
}

uint64_t mlir::constantTripCount(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1 == a2) {
    return 0;
  }
  ConstantIntuint64_t Value = mlir::getConstantIntValue(a1);
  if (!v6) {
    return 0;
  }
  unint64_t v7 = ConstantIntValue;
  unint64_t v8 = mlir::getConstantIntValue(a2);
  if (!v9) {
    return 0;
  }
  unint64_t v10 = v8;
  int64_t v11 = mlir::getConstantIntValue(a3);
  if (!v12) {
    return 0;
  }
  int64_t v13 = v10 - v7;
  if (v10 == v7 || (uint64_t)(v10 - v7) < 1 == v11 > 0) {
    return v13 / v11;
  }
  if (v11 <= 0) {
    int64_t v14 = v13 + 1;
  }
  else {
    int64_t v14 = v13 - 1;
  }
  return v14 / v11 + 1;
}

uint64_t mlir::foldDynamicIndexList(uint64_t a1, char a2)
{
  v17[1] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(unsigned int *)(a1 + 8);
  if (v2)
  {
    uint64_t v3 = *(unint64_t **)a1;
    char v4 = 0;
    uint64_t v5 = 8 * v2;
    if (a2)
    {
      do
      {
        if ((*v3 & 4) != 0)
        {
          unint64_t v14 = *v3 & 0xFFFFFFFFFFFFFFF8;
          uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v14);
          if (DefiningOp)
          {
            uint64_t v7 = DefiningOp;
            if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((void *)(DefiningOp + 48)))
            {
              unint64_t v15 = v17;
              uint64_t v16 = 0x100000000;
              mlir::Operation::fold(v7, 0, 0, (uint64_t)&v15);
              uint64_t v8 = *(void *)v15;
              if (v15 != v17) {
                free(v15);
              }
              unint64_t v9 = v8 & 0xFFFFFFFFFFFFFFF8;
              if (v9 && (mlir::getConstantIntValue(v9) & 0x8000000000000000) == 0)
              {
                unint64_t *v3 = v9;
                char v4 = 1;
              }
            }
          }
        }
        ++v3;
        v5 -= 8;
      }
      while (v5);
    }
    else
    {
      do
      {
        if ((*v3 & 4) != 0)
        {
          unint64_t v14 = *v3 & 0xFFFFFFFFFFFFFFF8;
          uint64_t v10 = mlir::Value::getDefiningOp((mlir::Value *)&v14);
          if (v10)
          {
            uint64_t v11 = v10;
            if (mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((void *)(v10 + 48)))
            {
              unint64_t v15 = v17;
              uint64_t v16 = 0x100000000;
              mlir::Operation::fold(v11, 0, 0, (uint64_t)&v15);
              uint64_t v12 = *(void *)v15;
              if (v15 != v17) {
                free(v15);
              }
              if ((v12 & 0xFFFFFFFFFFFFFFF8) != 0)
              {
                unint64_t *v3 = v12 & 0xFFFFFFFFFFFFFFF8;
                char v4 = 1;
              }
            }
          }
        }
        ++v3;
        v5 -= 8;
      }
      while (v5);
    }
  }
  else
  {
    char v4 = 0;
  }
  return v4 & 1;
}

mlir::func::FuncDialect *mlir::func::FuncDialect::FuncDialect(mlir::func::FuncDialect *this, mlir::MLIRContext *a2)
{
  uint64_t v3 = (void *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"func", 4, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::FuncDialect,void>::id);
  void *v3 = &unk_1EC9CC5B8;
  mlir::Dialect::addOperations<mlir::func::CallIndirectOp,mlir::func::CallOp,mlir::func::ConstantOp,mlir::func::FuncOp,mlir::func::ReturnOp>((uint64_t)v3);
  mlir::Dialect::declarePromisedInterface<mlir::func::FuncDialect,mlir::DialectInlinerInterface>((uint64_t)this);
  return this;
}

void mlir::func::FuncDialect::~FuncDialect(llvm **this)
{
}

void sub_1803E7700(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::Dialect::addOperations<mlir::func::CallIndirectOp,mlir::func::CallOp,mlir::func::ConstantOp,mlir::func::FuncOp,mlir::func::ReturnOp>(uint64_t a1)
{
  mlir::RegisteredOperationName::insert<mlir::func::CallIndirectOp>(a1);
  uint64_t v2 = operator new(0x70uLL);
  uint64_t v10 = mlir::RegisteredOperationName::Model<mlir::func::CallOp>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::CallOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v3 = (uint64_t)v10;
  uint64_t v10 = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  char v4 = operator new(0x70uLL);
  uint64_t v10 = mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::ConstantOp::getAttributeNames(void)::attrNames, 1);
  uint64_t v5 = (uint64_t)v10;
  uint64_t v10 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  char v6 = operator new(0x70uLL);
  uint64_t v10 = mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, (uint64_t)&mlir::func::FuncOp::getAttributeNames(void)::attrNames, 5);
  uint64_t v7 = (uint64_t)v10;
  uint64_t v10 = 0;
  if (v7) {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
  }
  uint64_t v8 = operator new(0x70uLL);
  uint64_t v10 = mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::Model(v8, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v10, 0, 0);
  uint64_t result = (uint64_t)v10;
  uint64_t v10 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t mlir::Dialect::declarePromisedInterface<mlir::func::FuncDialect,mlir::DialectInlinerInterface>(uint64_t a1)
{
  uint64_t v1 = (uint64_t *)(a1 + 72);
  unint64_t v2 = 0x1E8EB8000uLL;
  {
    unint64_t v2 = 0x1E8EB8000;
    if (v5)
    {
      int64_t v13 = (uint64_t *)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      unint64_t v14 = 79;
      unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v6) {
        unint64_t v7 = v6;
      }
      else {
        unint64_t v7 = v14;
      }
      uint64_t v8 = (char *)v13 + v7;
      unint64_t v9 = v14 - v7;
      if (v14 - v7 >= 0x12) {
        uint64_t v10 = 18;
      }
      else {
        uint64_t v10 = v14 - v7;
      }
      unint64_t v11 = v9 - v10;
      if (v11 >= v11 - 1) {
        uint64_t v12 = v11 - 1;
      }
      else {
        uint64_t v12 = v11;
      }
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v3 = *(void *)(v2 + 3896);
  int64_t v13 = &mlir::detail::TypeIDResolver<mlir::func::FuncDialect,void>::id;
  unint64_t v14 = v3;
  unint64_t v15 = 0;
  uint64_t result = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>(v1, (uint64_t *)&v13, &v15);
  if ((result & 1) == 0)
  {
    uint64_t result = (uint64_t)llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::InsertIntoBucketImpl<std::pair<mlir::TypeID,mlir::TypeID>>((uint64_t)v1, (uint64_t)&v13, (uint64_t *)&v13, v15);
    *(void *)uint64_t result = v13;
    *(void *)(result + 8) = v14;
  }
  return result;
}

mlir::GenericProgramPoint *mlir::func::FuncDialect::materializeConstant(uint64_t a1, mlir::OpBuilder *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v12 = a4;
  if (*(_UNKNOWN **)(*(void *)a3 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
    uint64_t v5 = a3;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v13 = v5;
  if (!v5) {
    return 0;
  }
  mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v13);
  if (v10 || *(_UNKNOWN **)(*(void *)a4 + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id) {
    return 0;
  }
  uint64_t v13 = a3;
  return mlir::OpBuilder::create<mlir::func::ConstantOp,mlir::Type &,mlir::FlatSymbolRefAttr>(a2, a5, &v12, &v13);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::func::ConstantOp,mlir::Type &,mlir::FlatSymbolRefAttr>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v26[28] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"func.constant", (const unsigned __int8 *)0xD, Context);
  if (!v10)
  {
    __int16 v21 = 1283;
    uint64_t v20[2] = (uint64_t)"func.constant";
    void v20[3] = 13;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v19 = 259;
    llvm::operator+(v20, (uint64_t *)&v18, (uint64_t)v22);
    llvm::report_fatal_error((llvm::Twine *)v22, 1);
  }
  mlir::OperationState::OperationState(v22, a2, v9);
  uint64_t v11 = *a3;
  uint64_t v12 = *a4;
  *(void *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(v22) = v12;
  unsigned int v13 = v24;
  if (v24 >= v25)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v23, v26, v24 + 1, 8);
    unsigned int v13 = v24;
  }
  *(void *)(v23 + 8 * v13) = v11;
  ++v24;
  unint64_t v14 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v22);
  if (*(_UNKNOWN **)(*((void *)v14 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::func::ConstantOp,void>::id) {
    unint64_t v15 = v14;
  }
  else {
    unint64_t v15 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v22);
  return v15;
}

uint64_t mlir::func::CallOp::verifySymbolUses(uint64_t *a1, uint64_t a2)
{
  uint64_t v150 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  if (*(unsigned char *)(*a1 + 47) && (uint64_t InherentAttr = mlir::Operation::getInherentAttr(*a1, (uint64_t)"callee", 6), v6))
  {
    uint64_t v7 = InherentAttr;
    if (!InherentAttr) {
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v7 = mlir::DictionaryAttr::get(v4 + 56, "callee", 6uLL);
    if (!v7)
    {
LABEL_10:
      uint64_t v134 = 0;
      goto LABEL_11;
    }
  }
  uint64_t v8 = *(void **)(*(void *)v7 + 136);
  BOOL v9 = v8 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v8 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
    uint64_t v10 = v7;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v139 = v10;
  if (!v9) {
    goto LABEL_10;
  }
  mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v139);
  if (v20) {
    uint64_t v21 = 0;
  }
  else {
    uint64_t v21 = v7;
  }
  uint64_t v134 = v21;
  if (!v21)
  {
LABEL_11:
    int v135 = (const void **)"requires a 'callee' symbol reference attribute";
    __int16 v138 = 259;
    mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
    if (v139) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
    }
    if (v149)
    {
      uint64_t v12 = v147;
      if (v147)
      {
        unsigned int v13 = v148;
        unint64_t v14 = v147;
        if (v148 != v147)
        {
          do
            unsigned int v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          unint64_t v14 = v147;
        }
        uint64_t v148 = v12;
        operator delete(v14);
      }
      unint64_t v15 = v145;
      if (!v145) {
        goto LABEL_147;
      }
      uint64_t v16 = v146;
      uint64_t v17 = v145;
      if (v146 == v145)
      {
LABEL_146:
        std::string v146 = v15;
        operator delete(v17);
LABEL_147:
        if (v141 != (const void ***)v144) {
          free(v141);
        }
        return v11;
      }
      do
      {
        __int16 v19 = (void *)*--v16;
        char v18 = v19;
        *uint64_t v16 = 0;
        if (v19) {
          operator delete[](v18);
        }
      }
      while (v16 != v15);
LABEL_145:
      uint64_t v17 = v145;
      goto LABEL_146;
    }
    return v11;
  }
  uint64_t v22 = mlir::SymbolTableCollection::lookupNearestSymbolFrom(a2, (mlir::SymbolTable *)*a1, v21);
  if (v22 && *(_UNKNOWN **)(*(void *)(v22 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    if (HIBYTE(*(_DWORD *)(v22 + 44))) {
      unint64_t v39 = v22 + 16 * (((unint64_t)*(unsigned int *)(v22 + 44) >> 23) & 1) + 64;
    }
    else {
      unint64_t v39 = 0;
    }
    uint64_t v139 = *(void *)(v39 + 8);
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v139);
    int Kind = mlir::AffineExpr::getKind((mlir::AffineExpr *)&Value);
    if ((*(unsigned char *)(*a1 + 46) & 0x80) != 0)
    {
      if (Kind == *(_DWORD *)(*a1 + 68)) {
        goto LABEL_57;
      }
    }
    else if (!Kind)
    {
LABEL_57:
      int v41 = mlir::AffineExpr::getKind((mlir::AffineExpr *)&Value);
      if (v41)
      {
        __int16 v42 = 0;
        int v43 = v41;
        uint64_t v44 = 24;
        while (1)
        {
          unint64_t v45 = *(void *)(*(void *)(*(void *)(*a1 + 72) + v44) + 8) & 0xFFFFFFFFFFFFFFF8;
          if (*(void *)(mlir::FunctionType::getInputs((mlir::FunctionType *)&Value) + 8 * (void)v42) != v45) {
            break;
          }
          ++v42;
          v44 += 32;
          if (v43 == v42) {
            goto LABEL_61;
          }
        }
        int v135 = (const void **)"operand type mismatch: expected operand type ";
        __int16 v138 = 259;
        mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
        uint64_t Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
        if (v139)
        {
          BOOL v65 = &v130;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v130, *(void *)(Inputs + 8 * (void)v42));
          BOOL v66 = v141;
          if (v142 >= v143)
          {
            unint64_t v113 = v142 + 1;
            if (v141 <= &v130 && &v141[3 * v142] > &v130)
            {
              int64_t v123 = (char *)&v130 - (char *)v141;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v113, 24);
              BOOL v66 = v141;
              BOOL v65 = (const void ***)((char *)v141 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v113, 24);
              BOOL v65 = &v130;
              BOOL v66 = v141;
            }
          }
          unint64_t v67 = &v66[3 * v142];
          long long v68 = *(_OWORD *)v65;
          void v67[2] = v65[2];
          *(_OWORD *)unint64_t v67 = v68;
          uint64_t v69 = ++v142;
          if (v139)
          {
            LODWORD(v130) = 3;
            long long v131 = ", but provided ";
            uint64_t v132 = 15;
            BOOL v70 = &v130;
            uint64_t v71 = v141;
            if (v69 >= v143)
            {
              unint64_t v114 = v69 + 1;
              BOOL v115 = &v141[3 * v69] > &v130;
              if (v141 <= &v130 && v115)
              {
                int64_t v124 = (char *)&v130 - (char *)v141;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v114, 24);
                uint64_t v71 = v141;
                BOOL v70 = (const void ***)((char *)v141 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v114, 24);
                BOOL v70 = &v130;
                uint64_t v71 = v141;
              }
            }
            BOOL v72 = &v71[3 * v142];
            long long v73 = *(_OWORD *)v70;
            void v72[2] = v70[2];
            *(_OWORD *)BOOL v72 = v73;
            ++v142;
            if (v139)
            {
              unint64_t v74 = *(void *)(*(void *)(*(void *)(*a1 + 72) + v44) + 8) & 0xFFFFFFFFFFFFFFF8;
              unint64_t v75 = &v130;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v130, v74);
              BOOL v76 = v141;
              if (v142 >= v143)
              {
                unint64_t v116 = v142 + 1;
                if (v141 <= &v130 && &v141[3 * v142] > &v130)
                {
                  int64_t v125 = (char *)&v130 - (char *)v141;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v116, 24);
                  BOOL v76 = v141;
                  unint64_t v75 = (const void ***)((char *)v141 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v116, 24);
                  unint64_t v75 = &v130;
                  BOOL v76 = v141;
                }
              }
              uint64_t v77 = &v76[3 * v142];
              long long v78 = *(_OWORD *)v75;
              v77[2] = v75[2];
              *(_OWORD *)uint64_t v77 = v78;
              uint64_t v79 = ++v142;
              if (v139)
              {
                LODWORD(v130) = 3;
                long long v131 = " for operand number ";
                uint64_t v132 = 20;
                unint64_t v80 = &v130;
                __n128 v81 = v141;
                if (v79 >= v143)
                {
                  unint64_t v117 = v79 + 1;
                  BOOL v118 = &v141[3 * v79] > &v130;
                  if (v141 <= &v130 && v118)
                  {
                    int64_t v126 = (char *)&v130 - (char *)v141;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v117, 24);
                    __n128 v81 = v141;
                    unint64_t v80 = (const void ***)((char *)v141 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v117, 24);
                    unint64_t v80 = &v130;
                    __n128 v81 = v141;
                  }
                }
                uint64_t v82 = &v81[3 * v142];
                long long v83 = *(_OWORD *)v80;
                v82[2] = v80[2];
                *(_OWORD *)uint64_t v82 = v83;
                uint64_t v84 = ++v142;
                if (v139)
                {
                  LODWORD(v130) = 5;
                  long long v131 = v42;
                  uint64_t v85 = &v130;
                  __n128 v86 = v141;
                  if (v84 >= v143)
                  {
                    unint64_t v119 = v84 + 1;
                    BOOL v120 = &v141[3 * v84] > &v130;
                    if (v141 <= &v130 && v120)
                    {
                      int64_t v127 = (char *)&v130 - (char *)v141;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v119, 24);
                      __n128 v86 = v141;
                      uint64_t v85 = (const void ***)((char *)v141 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v119, 24);
                      uint64_t v85 = &v130;
                      __n128 v86 = v141;
                    }
                  }
                  unint64_t v87 = &v86[3 * v142];
                  long long v88 = *(_OWORD *)v85;
                  v87[2] = v85[2];
                  *(_OWORD *)unint64_t v87 = v88;
                  ++v142;
                }
              }
            }
          }
        }
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        }
        if (v149)
        {
          unint64_t v89 = v147;
          if (v147)
          {
            BOOL v90 = v148;
            __n128 v91 = v147;
            if (v148 != v147)
            {
              do
                BOOL v90 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v90 - 1);
              while (v90 != v89);
              __n128 v91 = v147;
            }
            uint64_t v148 = v89;
            operator delete(v91);
          }
          unint64_t v15 = v145;
          if (!v145) {
            goto LABEL_147;
          }
          BOOL v92 = v146;
          uint64_t v17 = v145;
          if (v146 == v145) {
            goto LABEL_146;
          }
          do
          {
            BOOL v94 = (void *)*--v92;
            unint64_t v93 = v94;
            *BOOL v92 = 0;
            if (v94) {
              operator delete[](v93);
            }
          }
          while (v92 != v15);
          goto LABEL_145;
        }
        return v11;
      }
LABEL_61:
      if (mlir::FunctionType::getNumResults((mlir::FunctionType *)&Value) != *(_DWORD *)(*a1 + 36))
      {
        int v135 = (const void **)"incorrect number of results for callee";
        __int16 v138 = 259;
        mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
        uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
        if (v139) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
        }
        if (v149)
        {
          uint64_t v58 = v147;
          if (v147)
          {
            uint64_t v59 = v148;
            uint64_t v60 = v147;
            if (v148 != v147)
            {
              do
                uint64_t v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
              while (v59 != v58);
              uint64_t v60 = v147;
            }
            uint64_t v148 = v58;
            operator delete(v60);
          }
          unint64_t v15 = v145;
          if (!v145) {
            goto LABEL_147;
          }
          uint64_t v61 = v146;
          uint64_t v17 = v145;
          if (v146 == v145) {
            goto LABEL_146;
          }
          do
          {
            uint64_t v63 = (void *)*--v61;
            uint64_t v62 = v63;
            void *v61 = 0;
            if (v63) {
              operator delete[](v62);
            }
          }
          while (v61 != v15);
          goto LABEL_145;
        }
        return v11;
      }
      unsigned int v128 = 0;
      Numuint64_t Results = mlir::FunctionType::getNumResults((mlir::FunctionType *)&Value);
      if (NumResults)
      {
        int v47 = NumResults;
        unint64_t v48 = *(void *)(*a1 - 8) & 0xFFFFFFFFFFFFFFF8;
        if (*(void *)mlir::FunctionType::getResults((mlir::FunctionType *)&Value) != v48)
        {
LABEL_64:
          int64_t v130 = (const void **)"result type mismatch at index ";
          __int16 v133 = 259;
          mlir::OpState::emitOpError((uint64_t **)a1, &v130, (uint64_t)&v135);
          uint64_t v49 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)&v135, &v128);
          mlir::InFlightDiagnostic::InFlightDiagnostic((uint64_t)&v139, v49);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v135);
          uint64_t v50 = mlir::Diagnostic::attachNote(v140, 0, 0);
          uint64_t v51 = mlir::Diagnostic::operator<<(v50, "      op result types: ");
          uint64_t v52 = (const char *)*(unsigned int *)(*a1 + 36);
          long long v53 = (const void **)(*a1 - 16);
          if (!v52) {
            long long v53 = 0;
          }
          int64_t v130 = v53;
          long long v131 = v52;
          mlir::OperandRange::getTypes((uint64_t *)&v130, (uint64_t *)&v135);
          mlir::Diagnostic::operator<<<mlir::ValueTypeRange<mlir::ResultRange>,mlir::Type>(v51, (uint64_t)&v135);
          uint64_t v54 = mlir::Diagnostic::attachNote(v140, 0, 0);
          uint64_t v55 = mlir::Diagnostic::operator<<(v54, "function result types: ");
          uint64_t Results = (uint64_t *)mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
          int v135 = (const void **)", ";
          llvm::interleave<mlir::Type const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(llvm::ArrayRef<mlir::Type> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(void)#1},void>(Results, &Results[v57], v55, v55, (const char **)&v135);
          uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v139);
          return v11;
        }
        unsigned int v128 = 1;
        if (v47 != 1)
        {
          unint64_t v95 = *(void *)(*a1 - 24) & 0xFFFFFFFFFFFFFFF8;
          if (*(void *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 8) != v95) {
            goto LABEL_64;
          }
          unsigned int v128 = 2;
          if (v47 != 2)
          {
            unint64_t v96 = *(void *)(*a1 - 40) & 0xFFFFFFFFFFFFFFF8;
            if (*(void *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 16) != v96) {
              goto LABEL_64;
            }
            unsigned int v128 = 3;
            if (v47 != 3)
            {
              unint64_t v97 = *(void *)(*a1 - 56) & 0xFFFFFFFFFFFFFFF8;
              if (*(void *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 24) != v97) {
                goto LABEL_64;
              }
              unsigned int v128 = 4;
              if (v47 != 4)
              {
                unint64_t v98 = *(void *)(*a1 - 72) & 0xFFFFFFFFFFFFFFF8;
                if (*(void *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 32) != v98) {
                  goto LABEL_64;
                }
                unsigned int v128 = 5;
                if (v47 != 5)
                {
                  unint64_t v99 = *(void *)(*a1 - 88) & 0xFFFFFFFFFFFFFFF8;
                  if (*(void *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 40) != v99) {
                    goto LABEL_64;
                  }
                  unsigned int v128 = 6;
                  if (v47 != 6)
                  {
                    unsigned int v100 = 6;
                    while (1)
                    {
                      unsigned int v101 = v100 + 1;
                      uint64_t v102 = *a1 - 16 * (v100 + 1);
                      if (v100 > 5) {
                        uint64_t v102 = *a1 - 24 * (v100 - 5) - 96;
                      }
                      unint64_t v103 = *(void *)(v102 + 8) & 0xFFFFFFFFFFFFFFF8;
                      if (*(void *)(mlir::FunctionType::getResults((mlir::FunctionType *)&Value) + 8 * v100) != v103) {
                        break;
                      }
                      unsigned int v128 = ++v100;
                      if (v47 == v101) {
                        return 1;
                      }
                    }
                    goto LABEL_64;
                  }
                }
              }
            }
          }
        }
      }
      return 1;
    }
    int v135 = (const void **)"incorrect number of operands for callee";
    __int16 v138 = 259;
    mlir::OpState::emitOpError((uint64_t **)a1, &v135, (uint64_t)&v139);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
    if (v139) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
    }
    if (v149)
    {
      BOOL v106 = v147;
      if (v147)
      {
        BOOL v107 = v148;
        BOOL v108 = v147;
        if (v148 != v147)
        {
          do
            BOOL v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
          while (v107 != v106);
          BOOL v108 = v147;
        }
        uint64_t v148 = v106;
        operator delete(v108);
      }
      unint64_t v15 = v145;
      if (!v145) {
        goto LABEL_147;
      }
      unint64_t v109 = v146;
      uint64_t v17 = v145;
      if (v146 == v145) {
        goto LABEL_146;
      }
      do
      {
        BOOL v111 = (void *)*--v109;
        uint64_t v110 = v111;
        *unint64_t v109 = 0;
        if (v111) {
          operator delete[](v110);
        }
      }
      while (v109 != v15);
      goto LABEL_145;
    }
    return v11;
  }
  __int16 v133 = 257;
  mlir::OpState::emitOpError((uint64_t **)a1, &v130, (uint64_t)&v139);
  if (v139)
  {
    LODWORD(v135) = 3;
    int v136 = "'";
    uint64_t v137 = 1;
    uint64_t v23 = &v135;
    unsigned int v24 = v141;
    if (v142 >= v143)
    {
      unint64_t v104 = v142 + 1;
      if (v141 <= &v135 && &v141[3 * v142] > &v135)
      {
        int64_t v121 = (char *)&v135 - (char *)v141;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v104, 24);
        unsigned int v24 = v141;
        uint64_t v23 = (const void ***)((char *)v141 + v121);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v104, 24);
        uint64_t v23 = &v135;
        unsigned int v24 = v141;
      }
    }
    unsigned int v25 = &v24[3 * v142];
    long long v26 = *(_OWORD *)v23;
    void v25[2] = v23[2];
    *(_OWORD *)unsigned int v25 = v26;
    ++v142;
  }
  int v135 = (const void **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v134);
  uint64_t AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v135);
  if (v139)
  {
    __int16 v138 = 261;
    int v135 = AttrData;
    int v136 = v28;
    mlir::Diagnostic::operator<<((uint64_t)v140, &v135);
    if (v139)
    {
      LODWORD(v135) = 3;
      int v136 = "' does not reference a valid function";
      uint64_t v137 = 37;
      uint64_t v29 = &v135;
      unsigned int v30 = v141;
      if (v142 >= v143)
      {
        unint64_t v105 = v142 + 1;
        if (v141 <= &v135 && &v141[3 * v142] > &v135)
        {
          int64_t v122 = (char *)&v135 - (char *)v141;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v105, 24);
          unsigned int v30 = v141;
          uint64_t v29 = (const void ***)((char *)v141 + v122);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v141, v144, v105, 24);
          uint64_t v29 = &v135;
          unsigned int v30 = v141;
        }
      }
      uint64_t v31 = &v30[3 * v142];
      long long v32 = *(_OWORD *)v29;
      uint64_t v31[2] = v29[2];
      *(_OWORD *)uint64_t v31 = v32;
      ++v142;
    }
  }
  uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v139);
  if (v139) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v139);
  }
  if (v149)
  {
    uint64_t v33 = v147;
    if (v147)
    {
      uint64_t v34 = v148;
      uint64_t v35 = v147;
      if (v148 != v147)
      {
        do
          uint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        uint64_t v35 = v147;
      }
      uint64_t v148 = v33;
      operator delete(v35);
    }
    unint64_t v15 = v145;
    if (!v145) {
      goto LABEL_147;
    }
    uint64_t v36 = v146;
    uint64_t v17 = v145;
    if (v146 == v145) {
      goto LABEL_146;
    }
    do
    {
      uint64_t v38 = (void *)*--v36;
      uint64_t v37 = v38;
      *uint64_t v36 = 0;
      if (v38) {
        operator delete[](v37);
      }
    }
    while (v36 != v15);
    goto LABEL_145;
  }
  return v11;
}

uint64_t mlir::func::FuncOp::getFunctionType(mlir::func::FuncOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  uint64_t v3 = *(void *)(v1 + 8);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v3);
}

uint64_t mlir::Diagnostic::operator<<<mlir::ValueTypeRange<mlir::ResultRange>,mlir::Type>(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = ", ";
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(mlir::ValueTypeRange<mlir::ResultRange> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(void)#1},void>(*(mlir::detail::OpResultImpl **)a2, *(void *)(a2 + 8), *(mlir::detail::OpResultImpl **)(a2 + 16), *(void *)(a2 + 24), a1, a1, &v4);
  return a1;
}

uint64_t mlir::func::CallIndirectOp::canonicalize(uint64_t a1, uint64_t a2)
{
  void v18[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(*(void *)(a1 + 72) + 24);
  unint64_t v14 = 0;
  uint64_t v15 = v4;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v15);
  if (!DefiningOp) {
    return 0;
  }
  uint64_t v6 = DefiningOp;
  if (!mlir::OperationName::hasTrait<mlir::OpTrait::ConstantLike>((void *)(DefiningOp + 48))) {
    return 0;
  }
  v17[0] = v18;
  v17[1] = (void *)0x100000000;
  mlir::Operation::fold(v6, 0, 0, (uint64_t)v17);
  BOOL v7 = (*(void *)v17[0] & 0xFFFFFFFFFFFFFFF8) == 0
    || *(void *)(*(void *)(*(void *)v17[0] & 0xFFFFFFFFFFFFFFF8) + 136) != (void)&mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (!v7) {
    unint64_t v14 = *(void *)v17[0] & 0xFFFFFFFFFFFFFFF8;
  }
  if (v17[0] != v18) {
    free(v17[0]);
  }
  if (v7) {
    return 0;
  }
  uint64_t v9 = *(unsigned int *)(a1 + 36);
  uint64_t v10 = a1 - 16;
  if (!v9) {
    uint64_t v10 = 0;
  }
  uint64_t v15 = v10;
  uint64_t v16 = v9;
  mlir::OperandRange::getTypes(&v15, (uint64_t *)v17);
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0)
  {
    uint64_t v11 = *(void *)(a1 + 72);
    uint64_t v12 = *(unsigned int *)(a1 + 68) - 1;
  }
  else
  {
    uint64_t v11 = 0;
    uint64_t v12 = -1;
  }
  uint64_t v15 = v11 + 32;
  uint64_t v16 = v12;
  unsigned int v13 = mlir::OpBuilder::create<mlir::func::CallOp,mlir::SymbolRefAttr &,mlir::ValueTypeRange<mlir::ResultRange>,mlir::OperandRange>((mlir::OpBuilder *)(a2 + 8), *(void *)(a1 + 24), (uint64_t *)&v14, (uint64_t *)v17, (uint64_t)&v15);
  (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v13);
  return 1;
}

uint64_t mlir::func::ConstantOp::verify(uint64_t **this)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  int v43 = (const void **)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v43);
  uint64_t AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&Value);
  uint64_t v4 = v3;
  uint64_t v5 = (uint64_t)*this;
  unint64_t v6 = *(*this - 1) & 0xFFFFFFFFFFFFFFF8;
  while (1)
  {
    BOOL v7 = *(mlir::Block **)(v5 + 16);
    if (!v7) {
      break;
    }
    uint64_t ParentOp = mlir::Block::getParentOp(v7);
    uint64_t v5 = ParentOp;
    if (!ParentOp
      || *(_UNKNOWN **)(*(void *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::ModuleOp,void>::id)
    {
      goto LABEL_7;
    }
  }
  uint64_t v5 = 0;
LABEL_7:
  uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(v5 + 24));
  LOWORD(v50) = 261;
  uint64_t Value = (uint64_t)AttrData;
  unint64_t v48 = v4;
  uint64_t v10 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&Value);
  uint64_t v11 = mlir::SymbolTable::lookupSymbolIn((unsigned int *)v5, v10);
  if (v11 && *(_UNKNOWN **)(*(void *)(v11 + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id)
  {
    if (HIBYTE(*(_DWORD *)(v11 + 44))) {
      unint64_t v29 = v11 + 16 * (((unint64_t)*(unsigned int *)(v11 + 44) >> 23) & 1) + 64;
    }
    else {
      unint64_t v29 = 0;
    }
    uint64_t Value = *(void *)(v29 + 8);
    if (mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value) == v6) {
      return 1;
    }
    int v43 = (const void **)"reference to function with mismatched type";
    __int16 v46 = 259;
    mlir::OpState::emitOpError(this, &v43, (uint64_t)&Value);
    uint64_t v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    }
    if (v57)
    {
      unsigned int v30 = (void **)__p;
      if (__p)
      {
        uint64_t v31 = v56;
        long long v32 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
          while (v31 != v30);
          long long v32 = __p;
        }
        uint64_t v56 = v30;
        operator delete(v32);
      }
      unsigned int v24 = v53;
      if (!v53) {
        goto LABEL_49;
      }
      uint64_t v33 = v54;
      long long v26 = v53;
      if (v54 == v53) {
        goto LABEL_48;
      }
      do
      {
        uint64_t v35 = (void *)*--v33;
        uint64_t v34 = v35;
        void *v33 = 0;
        if (v35) {
          operator delete[](v34);
        }
      }
      while (v33 != v24);
      goto LABEL_47;
    }
  }
  else
  {
    __int16 v42 = 257;
    mlir::OpState::emitOpError(this, &v41, (uint64_t)&Value);
    if (Value)
    {
      LODWORD(v43) = 3;
      uint64_t v44 = "reference to undefined function '";
      uint64_t v45 = 33;
      uint64_t v12 = &v43;
      unsigned int v13 = (char *)v49;
      if (v50 >= v51)
      {
        unint64_t v37 = v50 + 1;
        if (v49 <= &v43 && (char *)v49 + 24 * v50 > (char *)&v43)
        {
          int64_t v39 = (char *)&v43 - (unsigned char *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v37, 24);
          unsigned int v13 = (char *)v49;
          uint64_t v12 = (const void ***)((char *)v49 + v39);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v37, 24);
          uint64_t v12 = &v43;
          unsigned int v13 = (char *)v49;
        }
      }
      unint64_t v14 = &v13[24 * v50];
      long long v15 = *(_OWORD *)v12;
      *((void *)v14 + 2) = v12[2];
      *(_OWORD *)unint64_t v14 = v15;
      ++v50;
      if (Value)
      {
        __int16 v46 = 261;
        int v43 = AttrData;
        uint64_t v44 = v4;
        mlir::Diagnostic::operator<<((uint64_t)&v48, &v43);
        if (Value)
        {
          LODWORD(v43) = 3;
          uint64_t v44 = "'";
          uint64_t v45 = 1;
          uint64_t v16 = &v43;
          uint64_t v17 = (char *)v49;
          if (v50 >= v51)
          {
            unint64_t v38 = v50 + 1;
            if (v49 <= &v43 && (char *)v49 + 24 * v50 > (char *)&v43)
            {
              int64_t v40 = (char *)&v43 - (unsigned char *)v49;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v38, 24);
              uint64_t v17 = (char *)v49;
              uint64_t v16 = (const void ***)((char *)v49 + v40);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v38, 24);
              uint64_t v16 = &v43;
              uint64_t v17 = (char *)v49;
            }
          }
          char v18 = &v17[24 * v50];
          long long v19 = *(_OWORD *)v16;
          *((void *)v18 + 2) = v16[2];
          *(_OWORD *)char v18 = v19;
          ++v50;
        }
      }
    }
    uint64_t v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    }
    if (v57)
    {
      uint64_t v21 = (void **)__p;
      if (__p)
      {
        uint64_t v22 = v56;
        uint64_t v23 = __p;
        if (v56 != __p)
        {
          do
            uint64_t v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
          while (v22 != v21);
          uint64_t v23 = __p;
        }
        uint64_t v56 = v21;
        operator delete(v23);
      }
      unsigned int v24 = v53;
      if (!v53) {
        goto LABEL_49;
      }
      unsigned int v25 = v54;
      long long v26 = v53;
      if (v54 == v53)
      {
LABEL_48:
        uint64_t v54 = v24;
        operator delete(v26);
LABEL_49:
        if (v49 != v52) {
          free(v49);
        }
        return v20;
      }
      do
      {
        int v28 = (void *)*--v25;
        int v27 = v28;
        *unsigned int v25 = 0;
        if (v28) {
          operator delete[](v27);
        }
      }
      while (v25 != v24);
LABEL_47:
      long long v26 = v53;
      goto LABEL_48;
    }
  }
  return v20;
}

uint64_t mlir::func::FuncOp::create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  v17[38] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a1;
  v15[0] = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  memset(&v15[1], 0, 24);
  mlir::OperationState::OperationState(v17, v16, (uint64_t)"func.func", 9);
  mlir::func::FuncOp::build(v15, (uint64_t)v17, a2, a3, a4, a5, a6, v11, 0, 0);
  uint64_t v13 = mlir::Operation::create((mlir::Operation *)v17, v12);
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v13;
}

void mlir::func::FuncOp::build(mlir::StringAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10)
{
  __int16 v23 = 261;
  v22[0] = a3;
  v22[1] = a4;
  uint64_t StringAttr = mlir::Builder::getStringAttr(a1, (mlir::MLIRContext *)v22);
  uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  __int16 v26 = 261;
  unsigned int v24 = "sym_name";
  uint64_t v25 = 8;
  uint64_t v17 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v24);
  mlir::NamedAttribute::NamedAttribute(v27, v17, StringAttr);
  mlir::NamedAttrList::push_back(a2 + 112, v27[0], v27[1]);
  uint64_t v18 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8);
  uint64_t v19 = mlir::TypeAttr::get(a5);
  mlir::NamedAttribute::NamedAttribute(&v24, v18, v19);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v24, v25);
  *(void *)(a2 + 192) = 0;
  uint64_t v20 = *(unsigned int *)(a2 + 120);
  unint64_t v21 = v20 + ((16 * a7) >> 4);
  if (v21 > *(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), v21, 16);
    LODWORD(v20) = *(_DWORD *)(a2 + 120);
  }
  if (a7)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v20), a6, 16 * a7);
    LODWORD(v20) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v20 + a7;
  mlir::OperationState::addRegion((mlir::OperationState *)a2);
  if (a10) {
    mlir::function_interface_impl::addArgAndResultAttrs(a1, a2, a9, a10, 0, 0, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
  }
}

uint64_t mlir::func::FuncOp::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::func::FuncOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

void mlir::func::FuncOp::print(mlir::func::FuncOp *this, mlir::OpAsmPrinter *a2)
{
  uint64_t v4 = *(void *)this;
  if (!*(void *)this) {
    goto LABEL_11;
  }
  uint64_t v5 = *(void *)(v4 + 48);
  unint64_t v6 = *(void **)(v5 + 16);
  BOOL v7 = v6 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = *(void *)(v4 + 48);
  }
  if (v7)
  {
    uint64_t v16 = *(void *)(v5 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (Values)
    {
      uint64_t v12 = v5;
      goto LABEL_10;
    }
LABEL_11:
    uint64_t v10 = 0;
    goto LABEL_12;
  }
  unint64_t v9 = v8 | v5 & 0xFFFFFFFFFFFFFF00;
  uint64_t v10 = mlir::detail::InterfaceMap::lookup<mlir::FunctionOpInterface>(v9 + 32);
  if (!v10)
  {
    uint64_t Values = *(void *)(v9 + 24);
    uint64_t v12 = *(void *)(v4 + 48);
LABEL_10:
    uint64_t v10 = mlir::Dialect::getRegisteredInterfaceForOp<mlir::FunctionOpInterface>(Values, v12);
  }
LABEL_12:
  uint64_t v16 = *(void *)(*(void *)(*(void *)(*(void *)this + 48) + 96) + 8);
  uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v16);
  unint64_t v14 = *(uint64_t **)(*(void *)(*(void *)this + 48) + 96);
  mlir::function_interface_impl::printFunctionOp((uint64_t)a2, v4, v10, 0, AttrData, v15, *v14, v14[2]);
}

uint64_t mlir::func::ReturnOp::verify(uint64_t **this)
{
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = (mlir::Block *)(*this)[2];
  if (v2) {
    uint64_t ParentOp = (unsigned int *)mlir::Block::getParentOp(v2);
  }
  else {
    uint64_t ParentOp = 0;
  }
  if (HIBYTE(ParentOp[11])) {
    unint64_t v4 = (unint64_t)&ParentOp[4 * (((unint64_t)ParentOp[11] >> 23) & 1) + 16];
  }
  else {
    unint64_t v4 = 0;
  }
  uint64_t Value = *(void *)(v4 + 8);
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  uint64_t Results = mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
  uint64_t v7 = Results;
  uint64_t v8 = v6;
  unint64_t v9 = *this;
  if ((*((unsigned char *)*this + 46) & 0x80) != 0)
  {
    if (v6 == (const char *)*((unsigned int *)v9 + 17)) {
      goto LABEL_9;
    }
  }
  else if (!v6)
  {
LABEL_9:
    if (!v6) {
      return 1;
    }
    uint64_t v10 = 0;
    uint64_t v11 = v9[9];
    for (uint64_t i = 24;
          *(void *)(Results + 8 * (void)v10) == (*(void *)(*(void *)(v11 + i) + 8) & 0xFFFFFFFFFFFFFFF8);
          i += 32)
    {
      if (v6 == ++v10) {
        return 1;
      }
    }
    __int16 v125 = 257;
    mlir::OpState::emitError(this, (uint64_t)v124, (uint64_t)&Value);
    if (Value)
    {
      LODWORD(SymbolName) = 3;
      int64_t v127 = "type of return operand ";
      uint64_t v128 = 23;
      uint64_t v15 = &SymbolName;
      uint64_t v16 = (char *)v132;
      if (v133 >= v134)
      {
        unint64_t v99 = v133 + 1;
        if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
        {
          int64_t v116 = (char *)&SymbolName - (unsigned char *)v132;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
          uint64_t v16 = (char *)v132;
          uint64_t v15 = (const void ***)((char *)v132 + v116);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v99, 24);
          uint64_t v15 = &SymbolName;
          uint64_t v16 = (char *)v132;
        }
      }
      uint64_t v17 = &v16[24 * v133];
      long long v18 = *(_OWORD *)v15;
      *((void *)v17 + 2) = v15[2];
      *(_OWORD *)uint64_t v17 = v18;
      uint64_t v19 = ++v133;
      if (Value)
      {
        LODWORD(SymbolName) = 5;
        int64_t v127 = v10;
        uint64_t v20 = &SymbolName;
        unint64_t v21 = (char *)v132;
        if (v19 >= v134)
        {
          unint64_t v100 = v19 + 1;
          BOOL v101 = (char *)v132 + 24 * v19 > (char *)&SymbolName;
          if (v132 <= &SymbolName && v101)
          {
            int64_t v117 = (char *)&SymbolName - (unsigned char *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v100, 24);
            unint64_t v21 = (char *)v132;
            uint64_t v20 = (const void ***)((char *)v132 + v117);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v100, 24);
            uint64_t v20 = &SymbolName;
            unint64_t v21 = (char *)v132;
          }
        }
        uint64_t v22 = &v21[24 * v133];
        long long v23 = *(_OWORD *)v20;
        *((void *)v22 + 2) = v20[2];
        *(_OWORD *)uint64_t v22 = v23;
        uint64_t v24 = ++v133;
        if (Value)
        {
          LODWORD(SymbolName) = 3;
          int64_t v127 = " (";
          uint64_t v128 = 2;
          uint64_t v25 = &SymbolName;
          __int16 v26 = (char *)v132;
          if (v24 >= v134)
          {
            unint64_t v102 = v24 + 1;
            BOOL v103 = (char *)v132 + 24 * v24 > (char *)&SymbolName;
            if (v132 <= &SymbolName && v103)
            {
              int64_t v118 = (char *)&SymbolName - (unsigned char *)v132;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
              __int16 v26 = (char *)v132;
              uint64_t v25 = (const void ***)((char *)v132 + v118);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v102, 24);
              uint64_t v25 = &SymbolName;
              __int16 v26 = (char *)v132;
            }
          }
          int v27 = &v26[24 * v133];
          long long v28 = *(_OWORD *)v25;
          *((void *)v27 + 2) = v25[2];
          *(_OWORD *)int v27 = v28;
          ++v133;
          if (Value)
          {
            unint64_t v29 = *(void *)(*(void *)((*this)[9] + i) + 8) & 0xFFFFFFFFFFFFFFF8;
            unsigned int v30 = &SymbolName;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&SymbolName, v29);
            uint64_t v31 = (char *)v132;
            if (v133 >= v134)
            {
              unint64_t v104 = v133 + 1;
              if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
              {
                int64_t v119 = (char *)&SymbolName - (unsigned char *)v132;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
                uint64_t v31 = (char *)v132;
                unsigned int v30 = (const void ***)((char *)v132 + v119);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v104, 24);
                unsigned int v30 = &SymbolName;
                uint64_t v31 = (char *)v132;
              }
            }
            long long v32 = &v31[24 * v133];
            long long v33 = *(_OWORD *)v30;
            *((void *)v32 + 2) = v30[2];
            *(_OWORD *)long long v32 = v33;
            uint64_t v34 = ++v133;
            if (Value)
            {
              LODWORD(SymbolName) = 3;
              int64_t v127 = ") doesn't match function result type (";
              uint64_t v128 = 38;
              uint64_t v35 = &SymbolName;
              uint64_t v36 = (char *)v132;
              if (v34 >= v134)
              {
                unint64_t v105 = v34 + 1;
                BOOL v106 = (char *)v132 + 24 * v34 > (char *)&SymbolName;
                if (v132 <= &SymbolName && v106)
                {
                  int64_t v120 = (char *)&SymbolName - (unsigned char *)v132;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v105, 24);
                  uint64_t v36 = (char *)v132;
                  uint64_t v35 = (const void ***)((char *)v132 + v120);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v105, 24);
                  uint64_t v35 = &SymbolName;
                  uint64_t v36 = (char *)v132;
                }
              }
              unint64_t v37 = &v36[24 * v133];
              long long v38 = *(_OWORD *)v35;
              *((void *)v37 + 2) = v35[2];
              *(_OWORD *)unint64_t v37 = v38;
              ++v133;
              if (Value)
              {
                uint64_t v39 = *(void *)(v7 + 8 * (void)v10);
                int64_t v40 = &SymbolName;
                mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&SymbolName, v39);
                int v41 = (char *)v132;
                if (v133 >= v134)
                {
                  unint64_t v107 = v133 + 1;
                  if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
                  {
                    int64_t v121 = (char *)&SymbolName - (unsigned char *)v132;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v107, 24);
                    int v41 = (char *)v132;
                    int64_t v40 = (const void ***)((char *)v132 + v121);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v107, 24);
                    int64_t v40 = &SymbolName;
                    int v41 = (char *)v132;
                  }
                }
                __int16 v42 = &v41[24 * v133];
                long long v43 = *(_OWORD *)v40;
                *((void *)v42 + 2) = v40[2];
                *(_OWORD *)__int16 v42 = v43;
                uint64_t v44 = ++v133;
                if (Value)
                {
                  LODWORD(SymbolName) = 3;
                  int64_t v127 = ")";
                  uint64_t v128 = 1;
                  uint64_t v45 = &SymbolName;
                  __int16 v46 = (char *)v132;
                  if (v44 >= v134)
                  {
                    unint64_t v108 = v44 + 1;
                    BOOL v109 = (char *)v132 + 24 * v44 > (char *)&SymbolName;
                    if (v132 <= &SymbolName && v109)
                    {
                      int64_t v122 = (char *)&SymbolName - (unsigned char *)v132;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
                      __int16 v46 = (char *)v132;
                      uint64_t v45 = (const void ***)((char *)v132 + v122);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v108, 24);
                      uint64_t v45 = &SymbolName;
                      __int16 v46 = (char *)v132;
                    }
                  }
                  int v47 = &v46[24 * v133];
                  long long v48 = *(_OWORD *)v45;
                  *((void *)v47 + 2) = v45[2];
                  *(_OWORD *)int v47 = v48;
                  uint64_t v49 = ++v133;
                  if (Value)
                  {
                    LODWORD(SymbolName) = 3;
                    int64_t v127 = " in function @";
                    uint64_t v128 = 14;
                    unsigned int v50 = &SymbolName;
                    unsigned int v51 = (char *)v132;
                    if (v49 >= v134)
                    {
                      unint64_t v110 = v49 + 1;
                      BOOL v111 = (char *)v132 + 24 * v49 > (char *)&SymbolName;
                      if (v132 <= &SymbolName && v111)
                      {
                        int64_t v123 = (char *)&SymbolName - (unsigned char *)v132;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                        unsigned int v51 = (char *)v132;
                        unsigned int v50 = (const void ***)((char *)v132 + v123);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v110, 24);
                        unsigned int v50 = &SymbolName;
                        unsigned int v51 = (char *)v132;
                      }
                    }
                    uint64_t v52 = &v51[24 * v133];
                    long long v53 = *(_OWORD *)v50;
                    *((void *)v52 + 2) = v50[2];
                    *(_OWORD *)uint64_t v52 = v53;
                    ++v133;
                  }
                }
              }
            }
          }
        }
      }
    }
    SymbolName = (const void **)mlir::SymbolTable::getSymbolName((mlir::SymbolTable *)ParentOp, v14);
    uint64_t AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymbolName);
    if (Value)
    {
      __int16 v129 = 261;
      SymbolName = AttrData;
      int64_t v127 = v55;
      mlir::Diagnostic::operator<<((uint64_t)v131, &SymbolName);
    }
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    }
    if (v140)
    {
      uint64_t v56 = (void **)__p;
      if (__p)
      {
        char v57 = v139;
        uint64_t v58 = __p;
        if (v139 != __p)
        {
          do
            char v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
          while (v57 != v56);
          uint64_t v58 = __p;
        }
        uint64_t v139 = v56;
        operator delete(v58);
      }
      uint64_t v59 = v136;
      if (!v136) {
        goto LABEL_76;
      }
      uint64_t v60 = v137;
      uint64_t v61 = v136;
      if (v137 == v136)
      {
LABEL_75:
        uint64_t v137 = v59;
        operator delete(v61);
LABEL_76:
        if (v132 != v135) {
          free(v132);
        }
        return v13;
      }
      do
      {
        uint64_t v63 = (void *)*--v60;
        uint64_t v62 = v63;
        *uint64_t v60 = 0;
        if (v63) {
          operator delete[](v62);
        }
      }
      while (v60 != v59);
LABEL_74:
      uint64_t v61 = v136;
      goto LABEL_75;
    }
    return v13;
  }
  v124[0] = (const void **)"has ";
  __int16 v125 = 259;
  mlir::OpState::emitOpError(this, v124, (uint64_t)&Value);
  if ((*((unsigned char *)*this + 46) & 0x80) != 0)
  {
    unsigned int v65 = *((_DWORD *)*this + 17);
    if (!Value) {
      goto LABEL_54;
    }
  }
  else
  {
    unsigned int v65 = 0;
    if (!Value) {
      goto LABEL_54;
    }
  }
  LODWORD(SymbolName) = 5;
  int64_t v127 = (const char *)v65;
  p_SymbolName = &SymbolName;
  unint64_t v67 = (char *)v132;
  if (v133 >= v134)
  {
    unint64_t v93 = v133 + 1;
    if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
    {
      int64_t v112 = (char *)&SymbolName - (unsigned char *)v132;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
      unint64_t v67 = (char *)v132;
      p_SymbolName = (const void ***)((char *)v132 + v112);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v93, 24);
      p_SymbolName = &SymbolName;
      unint64_t v67 = (char *)v132;
    }
  }
  long long v68 = &v67[24 * v133];
  long long v69 = *(_OWORD *)p_SymbolName;
  *((void *)v68 + 2) = p_SymbolName[2];
  *(_OWORD *)long long v68 = v69;
  uint64_t v70 = ++v133;
  if (Value)
  {
    LODWORD(SymbolName) = 3;
    int64_t v127 = " operands, but enclosing function (@";
    uint64_t v128 = 36;
    uint64_t v71 = &SymbolName;
    BOOL v72 = (char *)v132;
    if (v70 >= v134)
    {
      unint64_t v94 = v70 + 1;
      BOOL v95 = (char *)v132 + 24 * v70 > (char *)&SymbolName;
      if (v132 <= &SymbolName && v95)
      {
        int64_t v113 = (char *)&SymbolName - (unsigned char *)v132;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
        BOOL v72 = (char *)v132;
        uint64_t v71 = (const void ***)((char *)v132 + v113);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v94, 24);
        uint64_t v71 = &SymbolName;
        BOOL v72 = (char *)v132;
      }
    }
    long long v73 = &v72[24 * v133];
    long long v74 = *(_OWORD *)v71;
    *((void *)v73 + 2) = v71[2];
    *(_OWORD *)long long v73 = v74;
    ++v133;
  }
LABEL_54:
  SymbolName = (const void **)mlir::SymbolTable::getSymbolName((mlir::SymbolTable *)ParentOp, v64);
  unint64_t v75 = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymbolName);
  if (Value)
  {
    __int16 v129 = 261;
    SymbolName = v75;
    int64_t v127 = v76;
    mlir::Diagnostic::operator<<((uint64_t)v131, &SymbolName);
    if (Value)
    {
      LODWORD(SymbolName) = 3;
      int64_t v127 = ") returns ";
      uint64_t v128 = 10;
      uint64_t v77 = &SymbolName;
      long long v78 = (char *)v132;
      if (v133 >= v134)
      {
        unint64_t v96 = v133 + 1;
        if (v132 <= &SymbolName && (char *)v132 + 24 * v133 > (char *)&SymbolName)
        {
          int64_t v114 = (char *)&SymbolName - (unsigned char *)v132;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
          long long v78 = (char *)v132;
          uint64_t v77 = (const void ***)((char *)v132 + v114);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v96, 24);
          uint64_t v77 = &SymbolName;
          long long v78 = (char *)v132;
        }
      }
      uint64_t v79 = &v78[24 * v133];
      long long v80 = *(_OWORD *)v77;
      *((void *)v79 + 2) = v77[2];
      *(_OWORD *)uint64_t v79 = v80;
      uint64_t v81 = ++v133;
      if (Value)
      {
        LODWORD(SymbolName) = 5;
        int64_t v127 = v8;
        uint64_t v82 = &SymbolName;
        long long v83 = (char *)v132;
        if (v81 >= v134)
        {
          unint64_t v97 = v81 + 1;
          BOOL v98 = (char *)v132 + 24 * v81 > (char *)&SymbolName;
          if (v132 <= &SymbolName && v98)
          {
            int64_t v115 = (char *)&SymbolName - (unsigned char *)v132;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v97, 24);
            long long v83 = (char *)v132;
            uint64_t v82 = (const void ***)((char *)v132 + v115);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v132, v135, v97, 24);
            uint64_t v82 = &SymbolName;
            long long v83 = (char *)v132;
          }
        }
        uint64_t v84 = &v83[24 * v133];
        long long v85 = *(_OWORD *)v82;
        *((void *)v84 + 2) = v82[2];
        *(_OWORD *)uint64_t v84 = v85;
        ++v133;
      }
    }
  }
  uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v140)
  {
    __n128 v86 = (void **)__p;
    if (__p)
    {
      unint64_t v87 = v139;
      long long v88 = __p;
      if (v139 != __p)
      {
        do
          unint64_t v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
        while (v87 != v86);
        long long v88 = __p;
      }
      uint64_t v139 = v86;
      operator delete(v88);
    }
    uint64_t v59 = v136;
    if (!v136) {
      goto LABEL_76;
    }
    unint64_t v89 = v137;
    uint64_t v61 = v136;
    if (v137 == v136) {
      goto LABEL_75;
    }
    do
    {
      __n128 v91 = (void *)*--v89;
      BOOL v90 = v91;
      *unint64_t v89 = 0;
      if (v91) {
        operator delete[](v90);
      }
    }
    while (v89 != v59);
    goto LABEL_74;
  }
  return v13;
}

uint64_t mlir::func::CallIndirectOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *this;
  unint64_t v3 = *(void *)(*(void *)(v2[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_UNKNOWN **)(*(void *)v3 + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    __int16 v79 = 261;
    uint64_t v77 = (const void **)"operand";
    uint64_t v78 = 7;
    mlir::Operation::emitOpError(v2, &v77, (uint64_t)&v83);
    if (v83)
    {
      LODWORD(v80) = 3;
      uint64_t v81 = " #";
      uint64_t v82 = 2;
      unint64_t v4 = &v80;
      uint64_t v5 = (char *)v85;
      if (v86 >= v87)
      {
        unint64_t v67 = v86 + 1;
        if (v85 <= &v80 && (char *)v85 + 24 * v86 > (char *)&v80)
        {
          int64_t v73 = (char *)&v80 - (unsigned char *)v85;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v67, 24);
          uint64_t v5 = (char *)v85;
          unint64_t v4 = (unint64_t *)((char *)v85 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v67, 24);
          unint64_t v4 = &v80;
          uint64_t v5 = (char *)v85;
        }
      }
      unint64_t v6 = &v5[24 * v86];
      long long v7 = *(_OWORD *)v4;
      *((void *)v6 + 2) = v4[2];
      *(_OWORD *)unint64_t v6 = v7;
      uint64_t v8 = ++v86;
      if (v83)
      {
        LODWORD(v80) = 5;
        uint64_t v81 = 0;
        unint64_t v9 = &v80;
        uint64_t v10 = (char *)v85;
        if (v8 >= v87)
        {
          unint64_t v68 = v8 + 1;
          BOOL v69 = (char *)v85 + 24 * v8 > (char *)&v80;
          if (v85 <= &v80 && v69)
          {
            int64_t v74 = (char *)&v80 - (unsigned char *)v85;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v68, 24);
            uint64_t v10 = (char *)v85;
            unint64_t v9 = (unint64_t *)((char *)v85 + v74);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v68, 24);
            unint64_t v9 = &v80;
            uint64_t v10 = (char *)v85;
          }
        }
        uint64_t v11 = &v10[24 * v86];
        long long v12 = *(_OWORD *)v9;
        *((void *)v11 + 2) = v9[2];
        *(_OWORD *)uint64_t v11 = v12;
        uint64_t v13 = ++v86;
        if (v83)
        {
          LODWORD(v80) = 3;
          uint64_t v81 = " must be function type, but got ";
          uint64_t v82 = 32;
          unint64_t v14 = &v80;
          uint64_t v15 = (char *)v85;
          if (v13 >= v87)
          {
            unint64_t v70 = v13 + 1;
            BOOL v71 = (char *)v85 + 24 * v13 > (char *)&v80;
            if (v85 <= &v80 && v71)
            {
              int64_t v75 = (char *)&v80 - (unsigned char *)v85;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v70, 24);
              uint64_t v15 = (char *)v85;
              unint64_t v14 = (unint64_t *)((char *)v85 + v75);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v70, 24);
              unint64_t v14 = &v80;
              uint64_t v15 = (char *)v85;
            }
          }
          uint64_t v16 = &v15[24 * v86];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v86;
          if (v83)
          {
            long long v18 = &v80;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v80, v3);
            uint64_t v19 = (char *)v85;
            if (v86 >= v87)
            {
              unint64_t v72 = v86 + 1;
              if (v85 <= &v80 && (char *)v85 + 24 * v86 > (char *)&v80)
              {
                int64_t v76 = (char *)&v80 - (unsigned char *)v85;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v72, 24);
                uint64_t v19 = (char *)v85;
                long long v18 = (unint64_t *)((char *)v85 + v76);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v85, v88, v72, 24);
                long long v18 = &v80;
                uint64_t v19 = (char *)v85;
              }
            }
            uint64_t v20 = &v19[24 * v86];
            long long v21 = *(_OWORD *)v18;
            *((void *)v20 + 2) = v18[2];
            *(_OWORD *)uint64_t v20 = v21;
            ++v86;
          }
        }
      }
    }
    char v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
    if (v83) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
    }
    if (v93)
    {
      long long v23 = (void **)__p;
      if (__p)
      {
        uint64_t v24 = v92;
        uint64_t v25 = __p;
        if (v92 != __p)
        {
          do
            uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
          while (v24 != v23);
          uint64_t v25 = __p;
        }
        BOOL v92 = v23;
        operator delete(v25);
      }
      __int16 v26 = v89;
      if (v89)
      {
        int v27 = v90;
        long long v28 = v89;
        if (v90 != v89)
        {
          do
          {
            unsigned int v30 = (void *)*--v27;
            unint64_t v29 = v30;
            *int v27 = 0;
            if (v30) {
              operator delete[](v29);
            }
          }
          while (v27 != v26);
          long long v28 = v89;
        }
        BOOL v90 = v26;
        operator delete(v28);
      }
      if (v85 != v88) {
        free(v85);
      }
    }
    if (!v22) {
      return 0;
    }
  }
  uint64_t v31 = *this;
  uint64_t v32 = *((unsigned int *)*this + 9);
  if (*((_DWORD *)*this + 9)) {
    uint64_t v33 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v33 = 0;
  }
  if (v32)
  {
    for (uint64_t i = 0; i != v32; ++i)
      mlir::detail::OpResultImpl::getNextResultAtOffset(v33, i);
    uint64_t v31 = *this;
  }
  unint64_t v80 = *(void *)(*(void *)(v31[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t Inputs = (void *)mlir::FunctionType::getInputs((mlir::FunctionType *)&v80);
  unint64_t v37 = v36;
  long long v38 = *this;
  if ((*((unsigned char *)*this + 46) & 0x80) != 0)
  {
    unsigned int v39 = *((_DWORD *)v38 + 17);
    uint64_t v40 = v38[9];
  }
  else
  {
    unsigned int v39 = 0;
    uint64_t v40 = 0;
  }
  uint64_t v77 = (const void **)(v40 + 32);
  uint64_t v78 = v39 - 1;
  mlir::OperandRange::getTypes((uint64_t *)&v77, (uint64_t *)&v83);
  if (v37 != (char *)v85 - v84)
  {
LABEL_52:
    uint64_t v77 = (const void **)"failed to verify that callee input types match argument types";
    __int16 v79 = 259;
    mlir::OpState::emitOpError(this, &v77, (uint64_t)&v83);
    uint64_t v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
    if (v83) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
    }
    if (v93)
    {
      uint64_t v52 = (void **)__p;
      if (__p)
      {
        long long v53 = v92;
        uint64_t v54 = __p;
        if (v92 != __p)
        {
          do
            long long v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
          while (v53 != v52);
          uint64_t v54 = __p;
        }
        BOOL v92 = v52;
        operator delete(v54);
      }
      uint64_t v55 = v89;
      if (!v89) {
        goto LABEL_83;
      }
      uint64_t v56 = v90;
      char v57 = v89;
      if (v90 == v89) {
        goto LABEL_82;
      }
      do
      {
        uint64_t v59 = (void *)*--v56;
        uint64_t v58 = v59;
        *uint64_t v56 = 0;
        if (v59) {
          operator delete[](v58);
        }
      }
      while (v56 != v55);
      goto LABEL_81;
    }
    return v51;
  }
  if (v37)
  {
    uint64_t v41 = 8 * (void)v37;
    __int16 v42 = (char *)v83 + 32 * v84 + 24;
    while (*Inputs == (*(void *)(*(void *)v42 + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      ++Inputs;
      v42 += 32;
      v41 -= 8;
      if (!v41) {
        goto LABEL_44;
      }
    }
    goto LABEL_52;
  }
LABEL_44:
  unint64_t v80 = *(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  uint64_t Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)&v80);
  uint64_t v45 = v44;
  uint64_t v46 = *((unsigned int *)*this + 9);
  int v47 = (const void **)(*this - 2);
  if (!v46) {
    int v47 = 0;
  }
  uint64_t v77 = v47;
  uint64_t v78 = v46;
  mlir::OperandRange::getTypes((uint64_t *)&v77, (uint64_t *)&v83);
  uint64_t v48 = v84;
  if (v45 == (char *)v85 - v84)
  {
    if (!v45) {
      return 1;
    }
    uint64_t v49 = v83;
    uint64_t v50 = 8 * (void)v45;
    while (*Results == (*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v49, v48) + 8) & 0xFFFFFFFFFFFFFFF8))
    {
      ++Results;
      ++v48;
      v50 -= 8;
      if (!v50) {
        return 1;
      }
    }
  }
  uint64_t v77 = (const void **)"failed to verify that callee result types match result types";
  __int16 v79 = 259;
  mlir::OpState::emitOpError(this, &v77, (uint64_t)&v83);
  uint64_t v51 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v83);
  if (v83) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v83);
  }
  if (v93)
  {
    uint64_t v60 = (void **)__p;
    if (__p)
    {
      uint64_t v61 = v92;
      uint64_t v62 = __p;
      if (v92 != __p)
      {
        do
          uint64_t v61 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v61 - 1);
        while (v61 != v60);
        uint64_t v62 = __p;
      }
      BOOL v92 = v60;
      operator delete(v62);
    }
    uint64_t v55 = v89;
    if (!v89) {
      goto LABEL_83;
    }
    uint64_t v63 = v90;
    char v57 = v89;
    if (v90 == v89)
    {
LABEL_82:
      BOOL v90 = v55;
      operator delete(v57);
LABEL_83:
      if (v85 != v88) {
        free(v85);
      }
      return v51;
    }
    do
    {
      unsigned int v65 = (void *)*--v63;
      BOOL v64 = v65;
      *uint64_t v63 = 0;
      if (v65) {
        operator delete[](v64);
      }
    }
    while (v63 != v55);
LABEL_81:
    char v57 = v89;
    goto LABEL_82;
  }
  return v51;
}

uint64_t mlir::func::CallIndirectOp::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  unint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"func.call_indirect", 18, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D0C88;
  v4[12] = mlir::func::CallIndirectOp::canonicalize;
  unint64_t v9 = v4;
  unint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    long long v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    unint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::func::CallIndirectOp::parse(uint64_t a1, uint64_t a2)
{
  uint64_t v24[4] = *MEMORY[0x1E4F143B8];
  memset(v24, 0, 24);
  v19[0] = (uint64_t)v24;
  v19[1] = 1;
  uint64_t v21 = 0;
  v22[0] = v23;
  v22[1] = (void *)0x400000000;
  v18[0] = &v21;
  v18[1] = 1;
  uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *, uint64_t))(*(void *)a1 + 672))(a1, v24, 1)) {
    goto LABEL_12;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 264))(a1)) {
    goto LABEL_12;
  }
  uint64_t v5 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void **, void, uint64_t, uint64_t))(*(void *)a1 + 688))(a1, v22, 0, 1, 0xFFFFFFFFLL))goto LABEL_12; {
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 280))(a1))
  }
    goto LABEL_12;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    goto LABEL_12;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)) {
    goto LABEL_12;
  }
  v20[0] = 0;
  if (!mlir::AsmParser::parseType<mlir::FunctionType>(a1, v20)) {
    goto LABEL_12;
  }
  uint64_t v21 = v20[0];
  uint64_t v17 = v20[0];
  if (*(_UNKNOWN **)(*(void *)v20[0] + 136) != &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
  {
    uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    __int16 v16 = 257;
    (*(void (**)(void *__return_ptr, uint64_t, uint64_t, void *))(*(void *)a1 + 24))(v20, a1, v6, v15);
    uint64_t v7 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v20, "'callee' must be function type, but got ");
    uint64_t v8 = mlir::InFlightDiagnostic::append<mlir::Type &>(v7, &v17);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v8);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v20);
    goto LABEL_13;
  }
  uint64_t Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)v20);
  mlir::OperationState::addTypes(a2, Results, v11);
  uint64_t v12 = a2 + 16;
  if (mlir::OpAsmParser::resolveOperands<llvm::ArrayRef<mlir::OpAsmParser::UnresolvedOperand> &,llvm::ArrayRef<mlir::Type> &>(a1, v19, v18, v4, v12))
  {
    v15[0] = *(void *)v18[0];
    v20[0] = mlir::FunctionType::getInputs((mlir::FunctionType *)v15);
    v20[1] = v13;
    uint64_t v9 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,3u> &,llvm::ArrayRef<mlir::Type>>(a1, (uint64_t *)v22, v20, v5, v12) != 0;
  }
  else
  {
LABEL_12:
    uint64_t v9 = 0;
  }
LABEL_13:
  if (v22[0] != v23) {
    free(v22[0]);
  }
  return v9;
}

void mlir::func::CallIndirectOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v29[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = (unsigned char *)*((void *)v4 + 4);
  if ((unint64_t)v5 >= *((void *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((void *)v4 + 4) = v5 + 1;
    unsigned char *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 160))(a2, *(void *)(*((void *)*this + 9) + 24));
  uint64_t v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v7 = (unsigned char *)*((void *)v6 + 4);
  if (*((unsigned char **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "(", 1uLL);
    uint64_t v8 = *this;
    if ((*((unsigned char *)*this + 46) & 0x80) != 0) {
      goto LABEL_6;
    }
  }
  else
  {
    *uint64_t v7 = 40;
    ++*((void *)v6 + 4);
    uint64_t v8 = *this;
    if ((*((unsigned char *)*this + 46) & 0x80) != 0)
    {
LABEL_6:
      uint64_t v9 = *((unsigned int *)v8 + 17);
      uint64_t v10 = *((void *)v8 + 9);
      uint64_t v11 = v9 - 1;
      goto LABEL_7;
    }
  }
  uint64_t v10 = 0;
  uint64_t v11 = -1;
LABEL_7:
  uint64_t v12 = v10 + 32;
  uint64_t v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  int v27 = ", ";
  uint64_t v28 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v12, 0, v12, v11, (uint64_t)a2, v13, (uint64_t)&v27);
  unint64_t v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v15 = (unsigned char *)*((void *)v14 + 4);
  if (*((unsigned char **)v14 + 3) == v15)
  {
    llvm::raw_ostream::write(v14, ")", 1uLL);
  }
  else
  {
    unsigned char *v15 = 41;
    ++*((void *)v14 + 4);
  }
  int v27 = v29;
  uint64_t v28 = 0x200000000;
  __int16 v16 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v16);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v16 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, void))(*(void *)a2 + 192))(a2, Value, v19, v27, v28);
  uint64_t v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v21 = (unsigned char *)*((void *)v20 + 4);
  if ((unint64_t)v21 >= *((void *)v20 + 3))
  {
    llvm::raw_ostream::write(v20, 32);
  }
  else
  {
    *((void *)v20 + 4) = v21 + 1;
    unsigned char *v21 = 32;
  }
  char v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v23 = (unsigned char *)*((void *)v22 + 4);
  if (*((unsigned char **)v22 + 3) == v23)
  {
    llvm::raw_ostream::write(v22, ":", 1uLL);
  }
  else
  {
    unsigned char *v23 = 58;
    ++*((void *)v22 + 4);
  }
  uint64_t v24 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v25 = (unsigned char *)*((void *)v24 + 4);
  if ((unint64_t)v25 >= *((void *)v24 + 3))
  {
    llvm::raw_ostream::write(v24, 32);
  }
  else
  {
    *((void *)v24 + 4) = v25 + 1;
    *uint64_t v25 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, unint64_t))(*(void *)a2 + 32))(a2, *(void *)(*(void *)(*((void *)*this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (v27 != v29) {
    free(v27);
  }
}

uint64_t mlir::func::CallOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v59 = v6;
  if (!v6)
  {
    a3(v63, a4);
    if (v63[0])
    {
      int v60 = 3;
      uint64_t v61 = "expected DictionaryAttr to set properties";
      uint64_t v62 = 41;
      unsigned int v30 = &v60;
      uint64_t v31 = (char *)v64;
      if (v65 >= v66)
      {
        unint64_t v51 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          int64_t v55 = (char *)&v60 - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          uint64_t v31 = (char *)v64;
          unsigned int v30 = (int *)((char *)v64 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          unsigned int v30 = &v60;
          uint64_t v31 = (char *)v64;
        }
      }
      uint64_t v32 = &v31[24 * v65];
      long long v33 = *(_OWORD *)v30;
      *((void *)v32 + 2) = *((void *)v30 + 2);
      *(_OWORD *)uint64_t v32 = v33;
      ++v65;
      if (v63[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
      }
    }
    if (!v72) {
      return 0;
    }
    uint64_t v34 = (void **)__p;
    if (__p)
    {
      uint64_t v35 = v71;
      uint64_t v36 = __p;
      if (v71 != __p)
      {
        do
          uint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        uint64_t v36 = __p;
      }
      BOOL v71 = v34;
      operator delete(v36);
    }
    uint64_t v25 = v68;
    if (!v68) {
      goto LABEL_64;
    }
    unint64_t v37 = v69;
    int v27 = v68;
    if (v69 == v68) {
      goto LABEL_63;
    }
    do
    {
      unsigned int v39 = (void *)*--v37;
      long long v38 = v39;
      *unint64_t v37 = 0;
      if (v39) {
        operator delete[](v38);
      }
    }
    while (v37 != v25);
    goto LABEL_62;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v59, "callee", 6uLL);
  if (!v8)
  {
    a3(v63, a4);
    if (v63[0])
    {
      int v60 = 3;
      uint64_t v61 = "expected key entry for callee in DictionaryAttr to set Properties.";
      uint64_t v62 = 66;
      uint64_t v40 = &v60;
      uint64_t v41 = (char *)v64;
      if (v65 >= v66)
      {
        unint64_t v53 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          int64_t v57 = (char *)&v60 - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          uint64_t v41 = (char *)v64;
          uint64_t v40 = (int *)((char *)v64 + v57);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          uint64_t v40 = &v60;
          uint64_t v41 = (char *)v64;
        }
      }
      __int16 v42 = &v41[24 * v65];
      long long v43 = *(_OWORD *)v40;
      *((void *)v42 + 2) = *((void *)v40 + 2);
      *(_OWORD *)__int16 v42 = v43;
      ++v65;
      if (v63[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
      }
    }
    if (!v72) {
      return 0;
    }
    uint64_t v44 = (void **)__p;
    if (__p)
    {
      uint64_t v45 = v71;
      uint64_t v46 = __p;
      if (v71 != __p)
      {
        do
          uint64_t v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        uint64_t v46 = __p;
      }
      BOOL v71 = v44;
      operator delete(v46);
    }
    uint64_t v25 = v68;
    if (!v68) {
      goto LABEL_64;
    }
    int v47 = v69;
    int v27 = v68;
    if (v69 == v68) {
      goto LABEL_63;
    }
    do
    {
      uint64_t v49 = (void *)*--v47;
      uint64_t v48 = v49;
      *int v47 = 0;
      if (v49) {
        operator delete[](v48);
      }
    }
    while (v47 != v25);
    goto LABEL_62;
  }
  uint64_t v9 = v8;
  uint64_t v10 = *(void **)(*(void *)v8 + 136);
  BOOL v11 = v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
    uint64_t v12 = v8;
  }
  else {
    uint64_t v12 = 0;
  }
  v63[0] = v12;
  if (v11)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
    if (!v13)
    {
      *a1 = v9;
      return 1;
    }
  }
  a3(v63, a4);
  if (v63[0])
  {
    int v60 = 3;
    uint64_t v62 = 51;
    unint64_t v14 = &v60;
    uint64_t v15 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v52 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        int64_t v56 = (char *)&v60 - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        uint64_t v15 = (char *)v64;
        unint64_t v14 = (int *)((char *)v64 + v56);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        unint64_t v14 = &v60;
        uint64_t v15 = (char *)v64;
      }
    }
    __int16 v16 = &v15[24 * v65];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)__int16 v16 = v17;
    ++v65;
    if (v63[0])
    {
      long long v18 = &v60;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, v9);
      uint64_t v19 = (char *)v64;
      if (v65 >= v66)
      {
        unint64_t v54 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          int64_t v58 = (char *)&v60 - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          uint64_t v19 = (char *)v64;
          long long v18 = (int *)((char *)v64 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          long long v18 = &v60;
          uint64_t v19 = (char *)v64;
        }
      }
      uint64_t v20 = &v19[24 * v65];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)uint64_t v20 = v21;
      ++v65;
      if (v63[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
      }
    }
  }
  if (v72)
  {
    char v22 = (void **)__p;
    if (__p)
    {
      long long v23 = v71;
      uint64_t v24 = __p;
      if (v71 != __p)
      {
        do
          long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        uint64_t v24 = __p;
      }
      BOOL v71 = v22;
      operator delete(v24);
    }
    uint64_t v25 = v68;
    if (!v68) {
      goto LABEL_64;
    }
    __int16 v26 = v69;
    int v27 = v68;
    if (v69 == v68)
    {
LABEL_63:
      BOOL v69 = v25;
      operator delete(v27);
LABEL_64:
      if (v64 != v67) {
        free(v64);
      }
      return 0;
    }
    do
    {
      unint64_t v29 = (void *)*--v26;
      uint64_t v28 = v29;
      void *v26 = 0;
      if (v29) {
        operator delete[](v28);
      }
    }
    while (v26 != v25);
LABEL_62:
    int v27 = v68;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::func::CallOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v15[6] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1;
  uint64_t v13 = v15;
  uint64_t v14 = 0x300000000;
  if (!*a2) {
    return 0;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"callee", 6, *a2);
  uint64_t v4 = v3;
  unsigned int v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    unsigned int v5 = v14;
  }
  uint64_t v6 = (uint64_t *)((char *)v13 + 16 * v5);
  uint64_t *v6 = NamedAttr;
  v6[1] = v4;
  uint64_t v7 = v13;
  BOOL v8 = __CFADD__(v14, 1);
  uint64_t v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v13 == v15) {
      return DictionaryAttr;
    }
    goto LABEL_10;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (uint64_t *)v13, v9);
  uint64_t v7 = v13;
  if (v13 != v15) {
LABEL_10:
  }
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  uint64_t v9 = *(void **)(*(void *)a1 + 136);
  BOOL v10 = v9 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  uint64_t v11 = v9 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id ? a1 : 0;
  uint64_t v39 = v11;
  if (v10)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v39);
    if (!v12) {
      return 1;
    }
  }
  a4(&v39, a5);
  if (v39)
  {
    LODWORD(v35) = 3;
    uint64_t v36 = "attribute '";
    uint64_t v37 = 11;
    uint64_t v13 = &v35;
    uint64_t v14 = (char *)v41;
    if (v42 >= v43)
    {
      unint64_t v31 = v42 + 1;
      if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
      {
        int64_t v33 = (char *)&v35 - (unsigned char *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        uint64_t v14 = (char *)v41;
        uint64_t v13 = (const void ***)((char *)v41 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        uint64_t v13 = &v35;
        uint64_t v14 = (char *)v41;
      }
    }
    uint64_t v15 = &v14[24 * v42];
    long long v16 = *(_OWORD *)v13;
    *((void *)v15 + 2) = v13[2];
    *(_OWORD *)uint64_t v15 = v16;
    ++v42;
    if (v39)
    {
      __int16 v38 = 261;
      uint64_t v35 = a2;
      uint64_t v36 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v40, &v35);
      if (v39)
      {
        LODWORD(v35) = 3;
        uint64_t v36 = "' failed to satisfy constraint: flat symbol reference attribute";
        uint64_t v37 = 63;
        long long v17 = &v35;
        long long v18 = (char *)v41;
        if (v42 >= v43)
        {
          unint64_t v32 = v42 + 1;
          if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
          {
            int64_t v34 = (char *)&v35 - (unsigned char *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            long long v18 = (char *)v41;
            long long v17 = (const void ***)((char *)v41 + v34);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            long long v17 = &v35;
            long long v18 = (char *)v41;
          }
        }
        uint64_t v19 = &v18[24 * v42];
        long long v20 = *(_OWORD *)v17;
        *((void *)v19 + 2) = v17[2];
        *(_OWORD *)uint64_t v19 = v20;
        ++v42;
      }
    }
  }
  uint64_t v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
  if (v39) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
  }
  if (v49)
  {
    char v22 = (void **)__p;
    if (__p)
    {
      long long v23 = v48;
      uint64_t v24 = __p;
      if (v48 != __p)
      {
        do
          long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        uint64_t v24 = __p;
      }
      uint64_t v48 = v22;
      operator delete(v24);
    }
    uint64_t v25 = v45;
    if (v45)
    {
      __int16 v26 = v46;
      int v27 = v45;
      if (v46 != v45)
      {
        do
        {
          unint64_t v29 = (void *)*--v26;
          uint64_t v28 = v29;
          void *v26 = 0;
          if (v29) {
            operator delete[](v28);
          }
        }
        while (v26 != v25);
        int v27 = v45;
      }
      uint64_t v46 = v25;
      operator delete(v27);
    }
    if (v41 != v44) {
      free(v41);
    }
  }
  return v21;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &unk_1E8EBA000;
    {
      uint64_t v4 = (void *)&unk_1E8EBA000;
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::CallOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 106;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        BOOL v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::func::detail::CallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = (void *)&unk_1E8EBA000;
      }
    }
    a1[33] = v4[97];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  uint64_t v41 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v41)) {
    return 0;
  }
  uint64_t v4 = v41;
  if (*(_UNKNOWN **)(*(void *)v41 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
    uint64_t v5 = v41;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t v46 = v5;
  if (v5)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v46);
    if (v6) {
      uint64_t v7 = 0;
    }
    else {
      uint64_t v7 = v4;
    }
    *a2 = v7;
    if (!v6) {
      return 1;
    }
  }
  else
  {
    *a2 = 0;
  }
  unsigned char v40[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v46, a1, v40);
  if (v46)
  {
    LODWORD(v42) = 3;
    unint64_t v43 = (unint64_t)"expected ";
    uint64_t v44 = 9;
    unint64_t v9 = &v42;
    uint64_t v10 = (char *)v48;
    if (v49 >= v50)
    {
      unint64_t v34 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        int64_t v37 = (char *)&v42 - (unsigned char *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
        uint64_t v10 = (char *)v48;
        unint64_t v9 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v34, 24);
        unint64_t v9 = &v42;
        uint64_t v10 = (char *)v48;
      }
    }
    unint64_t v11 = &v10[24 * v49];
    long long v12 = *(_OWORD *)v9;
    *((void *)v11 + 2) = v9[2];
    *(_OWORD *)unint64_t v11 = v12;
    ++v49;
  }
  unsigned int v42 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::FlatSymbolRefAttr]";
  unint64_t v43 = 73;
  unint64_t v13 = llvm::StringRef::find((uint64_t *)&v42, "DesiredTypeName = ", 0x12uLL, 0);
  if (v46)
  {
    if (v43 >= v13) {
      unint64_t v14 = v13;
    }
    else {
      unint64_t v14 = v43;
    }
    uint64_t v15 = 18;
    if (v43 - v14 < 0x12) {
      uint64_t v15 = v43 - v14;
    }
    unint64_t v16 = v43 - v14 - v15;
    if (v16 >= v16 - 1) {
      --v16;
    }
    __int16 v45 = 261;
    unsigned int v42 = (const void **)((char *)v42 + v14 + v15);
    unint64_t v43 = v16;
    mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
    if (v46)
    {
      LODWORD(v42) = 3;
      unint64_t v43 = (unint64_t)", but got: ";
      uint64_t v44 = 11;
      long long v17 = &v42;
      long long v18 = (char *)v48;
      if (v49 >= v50)
      {
        unint64_t v35 = v49 + 1;
        if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
        {
          int64_t v38 = (char *)&v42 - (unsigned char *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
          long long v18 = (char *)v48;
          long long v17 = (const void ***)((char *)v48 + v38);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
          long long v17 = &v42;
          long long v18 = (char *)v48;
        }
      }
      uint64_t v19 = &v18[24 * v49];
      long long v20 = *(_OWORD *)v17;
      *((void *)v19 + 2) = v17[2];
      *(_OWORD *)uint64_t v19 = v20;
      ++v49;
      if (v46)
      {
        uint64_t v21 = &v42;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v42, v41);
        char v22 = (char *)v48;
        if (v49 >= v50)
        {
          unint64_t v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            int64_t v39 = (char *)&v42 - (unsigned char *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            char v22 = (char *)v48;
            uint64_t v21 = (const void ***)((char *)v48 + v39);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            uint64_t v21 = &v42;
            char v22 = (char *)v48;
          }
        }
        long long v23 = &v22[24 * v49];
        long long v24 = *(_OWORD *)v21;
        *((void *)v23 + 2) = v21[2];
        *(_OWORD *)long long v23 = v24;
        ++v49;
      }
    }
  }
  uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  if (v56)
  {
    uint64_t v25 = (void **)__p;
    if (__p)
    {
      __int16 v26 = v55;
      int v27 = __p;
      if (v55 != __p)
      {
        do
          __int16 v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        int v27 = __p;
      }
      int64_t v55 = v25;
      operator delete(v27);
    }
    uint64_t v28 = v52;
    if (v52)
    {
      unint64_t v29 = v53;
      unsigned int v30 = v52;
      if (v53 != v52)
      {
        do
        {
          unint64_t v32 = (void *)*--v29;
          unint64_t v31 = v32;
          *unint64_t v29 = 0;
          if (v32) {
            operator delete[](v31);
          }
        }
        while (v29 != v28);
        unsigned int v30 = v52;
      }
      unint64_t v53 = v28;
      operator delete(v30);
    }
    if (v48 != v51) {
      free(v48);
    }
  }
  return v8;
}

void mlir::func::CallOp::build(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5)
{
  mlir::OperationState::addOperands(a2, a4, a5);
  uint64_t v8 = mlir::SymbolRefAttr::get((mlir::SymbolRefAttr *)a3, v7);
  uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  __int16 v19 = 261;
  v18[0] = "callee";
  v18[1] = 6;
  uint64_t v10 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v18);
  mlir::NamedAttribute::NamedAttribute(v20, v10, v8);
  mlir::NamedAttrList::push_back(a2 + 112, v20[0], v20[1]);
  if (HIBYTE(a3[11])) {
    unint64_t v11 = (unint64_t)&a3[4 * (((unint64_t)a3[11] >> 23) & 1) + 16];
  }
  else {
    unint64_t v11 = 0;
  }
  v18[0] = *(void *)(v11 + 8);
  v18[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v18);
  uint64_t Results = (const void *)mlir::FunctionType::getResults((mlir::FunctionType *)v18);
  uint64_t v14 = v13;
  size_t v15 = 8 * v13;
  uint64_t v16 = *(unsigned int *)(a2 + 72);
  unint64_t v17 = v16 + ((8 * v13) >> 3);
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if (v14)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v16), Results, v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + (v15 >> 3);
}

void mlir::func::CallOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  mlir::OperationState::addOperands(a2, a6, a7);
  uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  __int16 v17 = 261;
  v16[0] = "callee";
  v16[1] = 6;
  uint64_t v12 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v16);
  mlir::NamedAttribute::NamedAttribute(v18, v12, a3);
  mlir::NamedAttrList::push_back(a2 + 112, v18[0], v18[1]);
  uint64_t v13 = *(unsigned int *)(a2 + 72);
  if (a5 + v13 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a5 + v13, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (a5)
  {
    uint64_t v14 = 0;
    uint64_t v15 = *(void *)(a2 + 64) + 8 * v13;
    do
    {
      *(void *)(v15 + 8 * v14) = mlir::TypeRange::dereference_iterator(a4, v14);
      ++v14;
    }
    while (a5 != v14);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + a5;
}

uint64_t mlir::func::CallOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v19[0] = v2;
    if (mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v3, (const void **)"callee", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v19))
    {
      uint64_t v4 = *((unsigned int *)*this + 9);
      if (*((_DWORD *)*this + 9)) {
        uint64_t v5 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v5 = 0;
      }
      if (v4)
      {
        for (uint64_t i = 0; i != v4; ++i)
          mlir::detail::OpResultImpl::getNextResultAtOffset(v5, i);
      }
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    __int16 v17 = (const void **)"requires attribute 'callee'";
    __int16 v18 = 259;
    mlir::OpState::emitOpError(this, &v17, (uint64_t)v19);
    uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
    if (v19[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
    }
    if (v26)
    {
      uint64_t v8 = (void **)__p;
      if (__p)
      {
        unint64_t v9 = v25;
        uint64_t v10 = __p;
        if (v25 != __p)
        {
          do
            unint64_t v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
          while (v9 != v8);
          uint64_t v10 = __p;
        }
        uint64_t v25 = v8;
        operator delete(v10);
      }
      unint64_t v11 = v22;
      if (v22)
      {
        uint64_t v12 = v23;
        uint64_t v13 = v22;
        if (v23 != v22)
        {
          do
          {
            uint64_t v15 = (void *)*--v12;
            uint64_t v14 = v15;
            void *v12 = 0;
            if (v15) {
              operator delete[](v14);
            }
          }
          while (v12 != v11);
          uint64_t v13 = v22;
        }
        long long v23 = v11;
        operator delete(v13);
      }
      if (v20 != &v21) {
        free(v20);
      }
    }
  }
  return v7;
}

BOOL mlir::func::CallOp::parse(uint64_t a1, void *a2)
{
  v22[16] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = 0;
  v21[0] = v22;
  v21[1] = (void *)0x400000000;
  uint64_t Inputs = 0;
  uint64_t v19 = 0;
  uint64_t v4 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  uint64_t v6 = mlir::NoneType::get(*v4, v5);
  if (!mlir::AsmParser::parseAttribute<mlir::FlatSymbolRefAttr>(a1, &v20, v6)) {
    goto LABEL_13;
  }
  if (v20)
  {
    uint64_t v7 = (void *)mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(a2);
    *uint64_t v7 = v20;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 264))(a1)) {
    goto LABEL_13;
  }
  uint64_t v8 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void **, void, uint64_t, uint64_t))(*(void *)a1 + 688))(a1, v21, 0, 1, 0xFFFFFFFFLL))goto LABEL_13; {
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 280))(a1))
  }
    goto LABEL_13;
  uint64_t v17 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, void *))(*(void *)a1 + 456))(a1, a2 + 14)) {
    goto LABEL_13;
  }
  uint64_t v9 = a2[1];
  v16[0] = a1;
  v16[1] = &v17;
  uint64_t v16[2] = a2;
  uint64_t v10 = mlir::NamedAttrList::get((uint64_t)(a2 + 14), **(void **)(v9 + 96));
  if (v10)
  {
    if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v10, (const void **)"callee", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::CallOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v16))goto LABEL_13; {
  }
    }
  if ((*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)
    && (v16[0] = 0, mlir::AsmParser::parseType<mlir::FunctionType>(a1, v16)))
  {
    uint64_t Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)v16);
    uint64_t v19 = v11;
    uint64_t Results = (void *)mlir::FunctionType::getResults((mlir::FunctionType *)v16);
    mlir::OperationState::addTypes((uint64_t)a2, Results, v13);
    BOOL v14 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,3u> &,llvm::ArrayRef<mlir::Type>>(a1, (uint64_t *)v21, &Inputs, v8, (uint64_t)(a2 + 2)) != 0;
  }
  else
  {
LABEL_13:
    BOOL v14 = 0;
  }
  if (v21[0] != v22) {
    free(v21[0]);
  }
  return v14;
}

void mlir::func::CallOp::print(mlir::Operation **this, mlir::OpAsmPrinter *a2)
{
  v35[4] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v5 = (unsigned char *)*((void *)v4 + 4);
  if ((unint64_t)v5 >= *((void *)v4 + 3))
  {
    llvm::raw_ostream::write(v4, 32);
  }
  else
  {
    *((void *)v4 + 4) = v5 + 1;
    unsigned char *v5 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 48))(a2, *((void *)*this + 2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8));
  uint64_t v6 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v7 = (unsigned char *)*((void *)v6 + 4);
  if (*((unsigned char **)v6 + 3) == v7)
  {
    llvm::raw_ostream::write(v6, "(", 1uLL);
    uint64_t v8 = *this;
    if ((*((unsigned char *)*this + 46) & 0x80) != 0) {
      goto LABEL_6;
    }
  }
  else
  {
    *uint64_t v7 = 40;
    ++*((void *)v6 + 4);
    uint64_t v8 = *this;
    if ((*((unsigned char *)*this + 46) & 0x80) != 0)
    {
LABEL_6:
      uint64_t v9 = *((unsigned int *)v8 + 17);
      uint64_t v10 = *((void *)v8 + 9);
      goto LABEL_7;
    }
  }
  uint64_t v10 = 0;
  uint64_t v9 = 0;
LABEL_7:
  uint64_t v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  int64_t v33 = ", ";
  uint64_t v34 = 2;
  llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v10, 0, v10, v9, (uint64_t)a2, v11, (uint64_t)&v33);
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v13 = (unsigned char *)*((void *)v12 + 4);
  if (*((unsigned char **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ")", 1uLL);
  }
  else
  {
    unsigned char *v13 = 41;
    ++*((void *)v12 + 4);
  }
  int64_t v33 = (char *)v35;
  v35[0] = "callee";
  v35[1] = 6;
  uint64_t v34 = 0x200000001;
  BOOL v14 = *this;
  if (*((unsigned char *)*this + 47))
  {
    v31[0] = mlir::Operation::getAttrDictionary(v14);
    uint64_t v15 = (mlir::ArrayAttr *)v31;
  }
  else
  {
    uint64_t v15 = (mlir::Operation *)((char *)v14 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v15);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, char *, void))(*(void *)a2 + 192))(a2, Value, v17, v33, v34);
  __int16 v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v19 = (unsigned char *)*((void *)v18 + 4);
  if ((unint64_t)v19 >= *((void *)v18 + 3))
  {
    llvm::raw_ostream::write(v18, 32);
  }
  else
  {
    *((void *)v18 + 4) = v19 + 1;
    unsigned char *v19 = 32;
  }
  uint64_t v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v21 = (unsigned char *)*((void *)v20 + 4);
  if (*((unsigned char **)v20 + 3) == v21)
  {
    llvm::raw_ostream::write(v20, ":", 1uLL);
  }
  else
  {
    unsigned char *v21 = 58;
    ++*((void *)v20 + 4);
  }
  char v22 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  long long v23 = (unsigned char *)*((void *)v22 + 4);
  if ((unint64_t)v23 >= *((void *)v22 + 3))
  {
    llvm::raw_ostream::write(v22, 32);
  }
  else
  {
    *((void *)v22 + 4) = v23 + 1;
    unsigned char *v23 = 32;
  }
  long long v24 = *this;
  if ((*((unsigned char *)*this + 46) & 0x80) != 0)
  {
    uint64_t v25 = *((unsigned int *)v24 + 17);
    uint64_t v26 = *((void *)v24 + 9);
  }
  else
  {
    uint64_t v26 = 0;
    uint64_t v25 = 0;
  }
  v30[0] = v26;
  v30[1] = v25;
  mlir::OperandRange::getTypes(v30, v31);
  uint64_t v27 = *((unsigned int *)*this + 9);
  uint64_t v28 = (uint64_t)*this - 16;
  if (!v27) {
    uint64_t v28 = 0;
  }
  v32[0] = v28;
  v32[1] = v27;
  mlir::OperandRange::getTypes(v32, v29);
  mlir::AsmPrinter::printFunctionalType<mlir::ValueTypeRange<mlir::OperandRange>,mlir::ValueTypeRange<mlir::ResultRange>>((uint64_t)a2, v31, v29);
  if (v33 != (char *)v35) {
    free(v33);
  }
}

uint64_t mlir::func::ConstantOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v59 = v6;
  if (!v6)
  {
    a3(v63, a4);
    if (v63[0])
    {
      int v60 = 3;
      uint64_t v61 = "expected DictionaryAttr to set properties";
      uint64_t v62 = 41;
      unsigned int v30 = &v60;
      unint64_t v31 = (char *)v64;
      if (v65 >= v66)
      {
        unint64_t v51 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          int64_t v55 = (char *)&v60 - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          unint64_t v31 = (char *)v64;
          unsigned int v30 = (int *)((char *)v64 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
          unsigned int v30 = &v60;
          unint64_t v31 = (char *)v64;
        }
      }
      unint64_t v32 = &v31[24 * v65];
      long long v33 = *(_OWORD *)v30;
      *((void *)v32 + 2) = *((void *)v30 + 2);
      *(_OWORD *)unint64_t v32 = v33;
      ++v65;
      if (v63[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
      }
    }
    if (!v72) {
      return 0;
    }
    uint64_t v34 = (void **)__p;
    if (__p)
    {
      unint64_t v35 = v71;
      unint64_t v36 = __p;
      if (v71 != __p)
      {
        do
          unint64_t v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        unint64_t v36 = __p;
      }
      BOOL v71 = v34;
      operator delete(v36);
    }
    uint64_t v25 = v68;
    if (!v68) {
      goto LABEL_64;
    }
    int64_t v37 = v69;
    uint64_t v27 = v68;
    if (v69 == v68) {
      goto LABEL_63;
    }
    do
    {
      int64_t v39 = (void *)*--v37;
      int64_t v38 = v39;
      *int64_t v37 = 0;
      if (v39) {
        operator delete[](v38);
      }
    }
    while (v37 != v25);
    goto LABEL_62;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v59, "value", 5uLL);
  if (!v8)
  {
    a3(v63, a4);
    if (v63[0])
    {
      int v60 = 3;
      uint64_t v61 = "expected key entry for value in DictionaryAttr to set Properties.";
      uint64_t v62 = 65;
      uint64_t v40 = &v60;
      uint64_t v41 = (char *)v64;
      if (v65 >= v66)
      {
        unint64_t v53 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          int64_t v57 = (char *)&v60 - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          uint64_t v41 = (char *)v64;
          uint64_t v40 = (int *)((char *)v64 + v57);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v53, 24);
          uint64_t v40 = &v60;
          uint64_t v41 = (char *)v64;
        }
      }
      unsigned int v42 = &v41[24 * v65];
      long long v43 = *(_OWORD *)v40;
      *((void *)v42 + 2) = *((void *)v40 + 2);
      *(_OWORD *)unsigned int v42 = v43;
      ++v65;
      if (v63[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
      }
    }
    if (!v72) {
      return 0;
    }
    uint64_t v44 = (void **)__p;
    if (__p)
    {
      __int16 v45 = v71;
      uint64_t v46 = __p;
      if (v71 != __p)
      {
        do
          __int16 v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
        while (v45 != v44);
        uint64_t v46 = __p;
      }
      BOOL v71 = v44;
      operator delete(v46);
    }
    uint64_t v25 = v68;
    if (!v68) {
      goto LABEL_64;
    }
    uint64_t v47 = v69;
    uint64_t v27 = v68;
    if (v69 == v68) {
      goto LABEL_63;
    }
    do
    {
      unsigned int v49 = (void *)*--v47;
      uint64_t v48 = v49;
      *uint64_t v47 = 0;
      if (v49) {
        operator delete[](v48);
      }
    }
    while (v47 != v25);
    goto LABEL_62;
  }
  uint64_t v9 = v8;
  uint64_t v10 = *(void **)(*(void *)v8 + 136);
  BOOL v11 = v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
    uint64_t v12 = v8;
  }
  else {
    uint64_t v12 = 0;
  }
  v63[0] = v12;
  if (v11)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v63);
    if (!v13)
    {
      *a1 = v9;
      return 1;
    }
  }
  a3(v63, a4);
  if (v63[0])
  {
    int v60 = 3;
    uint64_t v62 = 50;
    BOOL v14 = &v60;
    uint64_t v15 = (char *)v64;
    if (v65 >= v66)
    {
      unint64_t v52 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        int64_t v56 = (char *)&v60 - (unsigned char *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        uint64_t v15 = (char *)v64;
        BOOL v14 = (int *)((char *)v64 + v56);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v52, 24);
        BOOL v14 = &v60;
        uint64_t v15 = (char *)v64;
      }
    }
    uint64_t v16 = &v15[24 * v65];
    long long v17 = *(_OWORD *)v14;
    *((void *)v16 + 2) = *((void *)v14 + 2);
    *(_OWORD *)uint64_t v16 = v17;
    ++v65;
    if (v63[0])
    {
      __int16 v18 = &v60;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, v9);
      uint64_t v19 = (char *)v64;
      if (v65 >= v66)
      {
        unint64_t v54 = v65 + 1;
        if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
        {
          int64_t v58 = (char *)&v60 - (unsigned char *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          uint64_t v19 = (char *)v64;
          __int16 v18 = (int *)((char *)v64 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v54, 24);
          __int16 v18 = &v60;
          uint64_t v19 = (char *)v64;
        }
      }
      uint64_t v20 = &v19[24 * v65];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)uint64_t v20 = v21;
      ++v65;
      if (v63[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
      }
    }
  }
  if (v72)
  {
    char v22 = (void **)__p;
    if (__p)
    {
      long long v23 = v71;
      long long v24 = __p;
      if (v71 != __p)
      {
        do
          long long v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        long long v24 = __p;
      }
      BOOL v71 = v22;
      operator delete(v24);
    }
    uint64_t v25 = v68;
    if (!v68) {
      goto LABEL_64;
    }
    uint64_t v26 = v69;
    uint64_t v27 = v68;
    if (v69 == v68)
    {
LABEL_63:
      BOOL v69 = v25;
      operator delete(v27);
LABEL_64:
      if (v64 != v67) {
        free(v64);
      }
      return 0;
    }
    do
    {
      unint64_t v29 = (void *)*--v26;
      uint64_t v28 = v29;
      void *v26 = 0;
      if (v29) {
        operator delete[](v28);
      }
    }
    while (v26 != v25);
LABEL_62:
    uint64_t v27 = v68;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(8uLL);
    void *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &unk_1E8EBA000;
    {
      uint64_t v4 = (void *)&unk_1E8EBA000;
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::ConstantOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 110;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = (void *)&unk_1E8EBA000;
      }
    }
    a1[33] = v4[99];
    return a1[32];
  }
  return result;
}

uint64_t mlir::func::ConstantOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  uint64_t v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v17[0] = v2;
    if (mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v3, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v17))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v4 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v4 = 0;
      }
      mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    uint64_t v15 = (const void **)"requires attribute 'value'";
    __int16 v16 = 259;
    mlir::OpState::emitOpError(this, &v15, (uint64_t)v17);
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v17);
    if (v17[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v17);
    }
    if (v24)
    {
      unint64_t v6 = (void **)__p;
      if (__p)
      {
        unint64_t v7 = v23;
        uint64_t v8 = __p;
        if (v23 != __p)
        {
          do
            unint64_t v7 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v7 - 1);
          while (v7 != v6);
          uint64_t v8 = __p;
        }
        long long v23 = v6;
        operator delete(v8);
      }
      unint64_t v9 = v20;
      if (v20)
      {
        uint64_t v10 = v21;
        unint64_t v11 = v20;
        if (v21 != v20)
        {
          do
          {
            uint64_t v13 = (void *)*--v10;
            uint64_t v12 = v13;
            void *v10 = 0;
            if (v13) {
              operator delete[](v12);
            }
          }
          while (v10 != v9);
          unint64_t v11 = v20;
        }
        long long v21 = v9;
        operator delete(v11);
      }
      if (v18 != &v19) {
        free(v18);
      }
    }
  }
  return v5;
}

uint64_t mlir::func::ConstantOp::parse(uint64_t a1, uint64_t a2)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = 0;
  uint64_t __src = v22;
  uint64_t v21 = 0x100000000;
  uint64_t v18 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)) {
    goto LABEL_15;
  }
  uint64_t v4 = *(void *)(a2 + 8);
  v17[0] = a1;
  v17[1] = &v18;
  void v17[2] = a2;
  uint64_t v5 = mlir::NamedAttrList::get(a2 + 112, **(void **)(v4 + 96));
  if (v5)
  {
    if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v5, (const void **)"value", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)v17))goto LABEL_15; {
  }
    }
  unint64_t v6 = (mlir::NoneType **)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 32))(a1);
  uint64_t v8 = mlir::NoneType::get(*v6, v7);
  if (!mlir::AsmParser::parseAttribute<mlir::FlatSymbolRefAttr>(a1, &v19, v8)) {
    goto LABEL_15;
  }
  if (v19)
  {
    unint64_t v9 = (void *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>((void *)a2);
    *unint64_t v9 = v19;
  }
  if (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)
    || !mlir::AsmParser::parseTypeList(a1, (uint64_t)&__src))
  {
LABEL_15:
    uint64_t v14 = 0;
    uint64_t v15 = __src;
    if (__src == v22) {
      return v14;
    }
LABEL_16:
    free(v15);
    return v14;
  }
  uint64_t v10 = __src;
  uint64_t v11 = v21;
  uint64_t v12 = *(unsigned int *)(a2 + 72);
  unint64_t v13 = v12 + v21;
  if (v13 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v13, 8);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  if (v11)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v12), v10, 8 * v11);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v12 + v11;
  uint64_t v14 = 1;
  uint64_t v15 = __src;
  if (__src != v22) {
    goto LABEL_16;
  }
  return v14;
}

void mlir::func::ConstantOp::print(mlir::func::ConstantOp *this, mlir::OpAsmPrinter *a2)
{
  v23[4] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = v23;
  v23[0] = "value";
  v23[1] = 5;
  uint64_t v22 = 0x200000001;
  uint64_t v4 = *(unsigned char **)this;
  if (v4[47])
  {
    v18[0] = mlir::Operation::getAttrDictionary((mlir::Operation *)v4);
    uint64_t v5 = (mlir::ArrayAttr *)v18;
  }
  else
  {
    uint64_t v5 = (mlir::ArrayAttr *)(v4 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v5);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, void))(*(void *)a2 + 192))(a2, Value, v7, v21, v22);
  uint64_t v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  unint64_t v9 = (unsigned char *)*((void *)v8 + 4);
  if ((unint64_t)v9 >= *((void *)v8 + 3))
  {
    llvm::raw_ostream::write(v8, 32);
  }
  else
  {
    *((void *)v8 + 4) = v9 + 1;
    *unint64_t v9 = 32;
  }
  (*(void (**)(mlir::OpAsmPrinter *, void))(*(void *)a2 + 48))(a2, *(void *)(*(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64));
  uint64_t v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v11 = (unsigned char *)*((void *)v10 + 4);
  if ((unint64_t)v11 >= *((void *)v10 + 3))
  {
    llvm::raw_ostream::write(v10, 32);
  }
  else
  {
    *((void *)v10 + 4) = v11 + 1;
    unsigned char *v11 = 32;
  }
  uint64_t v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  unint64_t v13 = (unsigned char *)*((void *)v12 + 4);
  if (*((unsigned char **)v12 + 3) == v13)
  {
    llvm::raw_ostream::write(v12, ":", 1uLL);
  }
  else
  {
    unsigned char *v13 = 58;
    ++*((void *)v12 + 4);
  }
  uint64_t v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
  uint64_t v15 = (unsigned char *)*((void *)v14 + 4);
  if ((unint64_t)v15 >= *((void *)v14 + 3))
  {
    llvm::raw_ostream::write(v14, 32);
  }
  else
  {
    *((void *)v14 + 4) = v15 + 1;
    unsigned char *v15 = 32;
  }
  uint64_t v16 = *(unsigned int *)(*(void *)this + 36);
  long long v17 = (const char *)(*(void *)this - 16);
  if (!v16) {
    long long v17 = 0;
  }
  uint64_t v19 = v17;
  uint64_t v20 = v16;
  mlir::OperandRange::getTypes((uint64_t *)&v19, v18);
  uint64_t v19 = ", ";
  uint64_t v20 = 2;
  llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::ResultRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::ResultRange>,mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::AsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::ResultRange> const&,mlir::AsmPrinter &,mlir::AsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>(v18[0], v18[1], v18[2], v18[3], (uint64_t)a2, (uint64_t)a2, (uint64_t)&v19);
  if (v21 != v23) {
    free(v21);
  }
}

uint64_t mlir::func::FuncOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(void *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v93 = v6;
  if (!v6)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      BOOL v95 = "expected DictionaryAttr to set properties";
      uint64_t v96 = 41;
      uint64_t v26 = &v94;
      uint64_t v27 = (char *)v98;
      if (v99 >= v100)
      {
        unint64_t v78 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          int64_t v85 = (char *)&v94 - (unsigned char *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v78, 24);
          uint64_t v27 = (char *)v98;
          uint64_t v26 = (uint64_t *)((char *)v98 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v78, 24);
          uint64_t v26 = &v94;
          uint64_t v27 = (char *)v98;
        }
      }
      uint64_t v28 = &v27[24 * v99];
      long long v29 = *(_OWORD *)v26;
      *((void *)v28 + 2) = v26[2];
      *(_OWORD *)uint64_t v28 = v29;
      ++v99;
      if (v97[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
      }
    }
    if (!v106) {
      return 0;
    }
    unsigned int v30 = (void **)__p;
    if (__p)
    {
      unint64_t v31 = v105;
      unint64_t v32 = __p;
      if (v105 != __p)
      {
        do
          unint64_t v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        unint64_t v32 = __p;
      }
      unint64_t v105 = v30;
      operator delete(v32);
    }
    uint64_t v21 = v102;
    if (!v102) {
      goto LABEL_104;
    }
    long long v33 = v103;
    long long v23 = v102;
    if (v103 == v102)
    {
LABEL_103:
      BOOL v103 = v21;
      operator delete(v23);
LABEL_104:
      if (v98 != v101) {
        free(v98);
      }
      return 0;
    }
    do
    {
      unint64_t v35 = (void *)*--v33;
      uint64_t v34 = v35;
      void *v33 = 0;
      if (v35) {
        operator delete[](v34);
      }
    }
    while (v33 != v21);
    goto LABEL_102;
  }
  uint64_t v8 = mlir::DictionaryAttr::get((uint64_t)&v93, "arg_attrs", 9uLL);
  if (v8)
  {
    uint64_t v9 = v8;
    if (*(_UNKNOWN **)(*(void *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
    {
      a3(v97, a4);
      if (v97[0])
      {
        LODWORD(v94) = 3;
        uint64_t v96 = 54;
        uint64_t v10 = &v94;
        uint64_t v11 = (char *)v98;
        if (v99 >= v100)
        {
          unint64_t v79 = v99 + 1;
          if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
          {
            int64_t v86 = (char *)&v94 - (unsigned char *)v98;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v79, 24);
            uint64_t v11 = (char *)v98;
            uint64_t v10 = (uint64_t *)((char *)v98 + v86);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v79, 24);
            uint64_t v10 = &v94;
            uint64_t v11 = (char *)v98;
          }
        }
        uint64_t v12 = &v11[24 * v99];
        long long v13 = *(_OWORD *)v10;
        *((void *)v12 + 2) = v10[2];
        *(_OWORD *)uint64_t v12 = v13;
        ++v99;
        if (v97[0])
        {
          uint64_t v14 = &v94;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v94, v9);
          uint64_t v15 = (char *)v98;
          if (v99 >= v100)
          {
            unint64_t v80 = v99 + 1;
            if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
            {
              int64_t v87 = (char *)&v94 - (unsigned char *)v98;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v80, 24);
              uint64_t v15 = (char *)v98;
              uint64_t v14 = (uint64_t *)((char *)v98 + v87);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v80, 24);
              uint64_t v14 = &v94;
              uint64_t v15 = (char *)v98;
            }
          }
          uint64_t v16 = &v15[24 * v99];
          long long v17 = *(_OWORD *)v14;
          *((void *)v16 + 2) = v14[2];
          *(_OWORD *)uint64_t v16 = v17;
          ++v99;
          if (v97[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
          }
        }
      }
      if (!v106) {
        return 0;
      }
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        uint64_t v19 = v105;
        uint64_t v20 = __p;
        if (v105 != __p)
        {
          do
            uint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          uint64_t v20 = __p;
        }
        unint64_t v105 = v18;
        operator delete(v20);
      }
      uint64_t v21 = v102;
      if (!v102) {
        goto LABEL_104;
      }
      uint64_t v22 = v103;
      long long v23 = v102;
      if (v103 == v102) {
        goto LABEL_103;
      }
      do
      {
        uint64_t v25 = (void *)*--v22;
        char v24 = v25;
        void *v22 = 0;
        if (v25) {
          operator delete[](v24);
        }
      }
      while (v22 != v21);
      goto LABEL_102;
    }
    *a1 = v8;
  }
  uint64_t v36 = mlir::DictionaryAttr::get((uint64_t)&v93, "function_type", 0xDuLL);
  if (!v36)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      BOOL v95 = "expected key entry for function_type in DictionaryAttr to set Properties.";
      uint64_t v96 = 73;
      unint64_t v52 = &v94;
      unint64_t v53 = (char *)v98;
      if (v99 >= v100)
      {
        unint64_t v82 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          int64_t v89 = (char *)&v94 - (unsigned char *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v82, 24);
          unint64_t v53 = (char *)v98;
          unint64_t v52 = (uint64_t *)((char *)v98 + v89);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v82, 24);
          unint64_t v52 = &v94;
          unint64_t v53 = (char *)v98;
        }
      }
      unint64_t v54 = &v53[24 * v99];
      long long v55 = *(_OWORD *)v52;
      *((void *)v54 + 2) = v52[2];
      *(_OWORD *)unint64_t v54 = v55;
      ++v99;
      if (v97[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
      }
    }
    if (!v106) {
      return 0;
    }
    int64_t v56 = (void **)__p;
    if (__p)
    {
      int64_t v57 = v105;
      int64_t v58 = __p;
      if (v105 != __p)
      {
        do
          int64_t v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        int64_t v58 = __p;
      }
      unint64_t v105 = v56;
      operator delete(v58);
    }
    uint64_t v21 = v102;
    if (!v102) {
      goto LABEL_104;
    }
    uint64_t v59 = v103;
    long long v23 = v102;
    if (v103 == v102) {
      goto LABEL_103;
    }
    do
    {
      uint64_t v61 = (void *)*--v59;
      int v60 = v61;
      void *v59 = 0;
      if (v61) {
        operator delete[](v60);
      }
    }
    while (v59 != v21);
    goto LABEL_102;
  }
  uint64_t v37 = v36;
  if (*(_UNKNOWN **)(*(void *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      uint64_t v96 = 58;
      int64_t v38 = &v94;
      int64_t v39 = (char *)v98;
      if (v99 >= v100)
      {
        unint64_t v81 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          int64_t v88 = (char *)&v94 - (unsigned char *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v81, 24);
          int64_t v39 = (char *)v98;
          int64_t v38 = (uint64_t *)((char *)v98 + v88);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v81, 24);
          int64_t v38 = &v94;
          int64_t v39 = (char *)v98;
        }
      }
      uint64_t v40 = &v39[24 * v99];
      long long v41 = *(_OWORD *)v38;
      *((void *)v40 + 2) = v38[2];
      *(_OWORD *)uint64_t v40 = v41;
      ++v99;
      if (v97[0])
      {
        unsigned int v42 = &v94;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v94, v37);
        long long v43 = (char *)v98;
        if (v99 >= v100)
        {
          unint64_t v83 = v99 + 1;
          if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
          {
            int64_t v90 = (char *)&v94 - (unsigned char *)v98;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v83, 24);
            long long v43 = (char *)v98;
            unsigned int v42 = (uint64_t *)((char *)v98 + v90);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v83, 24);
            unsigned int v42 = &v94;
            long long v43 = (char *)v98;
          }
        }
        uint64_t v44 = &v43[24 * v99];
        long long v45 = *(_OWORD *)v42;
        *((void *)v44 + 2) = v42[2];
        *(_OWORD *)uint64_t v44 = v45;
        ++v99;
        if (v97[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
        }
      }
    }
    if (!v106) {
      return 0;
    }
    uint64_t v46 = (void **)__p;
    if (__p)
    {
      uint64_t v47 = v105;
      uint64_t v48 = __p;
      if (v105 != __p)
      {
        do
          uint64_t v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        uint64_t v48 = __p;
      }
      unint64_t v105 = v46;
      operator delete(v48);
    }
    uint64_t v21 = v102;
    if (!v102) {
      goto LABEL_104;
    }
    unsigned int v49 = v103;
    long long v23 = v102;
    if (v103 == v102) {
      goto LABEL_103;
    }
    do
    {
      unint64_t v51 = (void *)*--v49;
      unsigned int v50 = v51;
      *unsigned int v49 = 0;
      if (v51) {
        operator delete[](v50);
      }
    }
    while (v49 != v21);
    goto LABEL_102;
  }
  a1[1] = v36;
  uint64_t v62 = mlir::DictionaryAttr::get((uint64_t)&v93, "res_attrs", 9uLL);
  uint64_t v94 = v62;
  if (!v62)
  {
LABEL_83:
    uint64_t v64 = mlir::DictionaryAttr::get((uint64_t)&v93, "sym_name", 8uLL);
    uint64_t v92 = v64;
    if (v64)
    {
      if (*(_UNKNOWN **)(*(void *)v64 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
      {
        a3(v97, a4);
        mlir::InFlightDiagnostic::append<mlir::Attribute>(v65, &v92);
        mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v97);
        return 0;
      }
      a1[3] = v64;
      uint64_t v77 = mlir::DictionaryAttr::get((uint64_t)&v93, "sym_visibility", 0xEuLL);
      uint64_t v94 = v77;
      if (v77)
      {
        if (*(_UNKNOWN **)(*(void *)v77 + 136) != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
        {
          a3(v97, a4);
          goto LABEL_81;
        }
        a1[4] = v77;
      }
      return 1;
    }
    a3(v97, a4);
    if (v97[0])
    {
      LODWORD(v94) = 3;
      BOOL v95 = "expected key entry for sym_name in DictionaryAttr to set Properties.";
      uint64_t v96 = 68;
      unsigned int v66 = &v94;
      unint64_t v67 = (char *)v98;
      if (v99 >= v100)
      {
        unint64_t v84 = v99 + 1;
        if (v98 <= &v94 && (char *)v98 + 24 * v99 > (char *)&v94)
        {
          int64_t v91 = (char *)&v94 - (unsigned char *)v98;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v84, 24);
          unint64_t v67 = (char *)v98;
          unsigned int v66 = (uint64_t *)((char *)v98 + v91);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v98, v101, v84, 24);
          unsigned int v66 = &v94;
          unint64_t v67 = (char *)v98;
        }
      }
      unint64_t v68 = &v67[24 * v99];
      long long v69 = *(_OWORD *)v66;
      *((void *)v68 + 2) = v66[2];
      *(_OWORD *)unint64_t v68 = v69;
      ++v99;
      if (v97[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v97);
      }
    }
    if (!v106) {
      return 0;
    }
    unint64_t v70 = (void **)__p;
    if (__p)
    {
      BOOL v71 = v105;
      char v72 = __p;
      if (v105 != __p)
      {
        do
          BOOL v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        char v72 = __p;
      }
      unint64_t v105 = v70;
      operator delete(v72);
    }
    uint64_t v21 = v102;
    if (!v102) {
      goto LABEL_104;
    }
    uint64_t v73 = v103;
    long long v23 = v102;
    if (v103 == v102) {
      goto LABEL_103;
    }
    do
    {
      int64_t v75 = (void *)*--v73;
      int64_t v74 = v75;
      *uint64_t v73 = 0;
      if (v75) {
        operator delete[](v74);
      }
    }
    while (v73 != v21);
LABEL_102:
    long long v23 = v102;
    goto LABEL_103;
  }
  if (*(_UNKNOWN **)(*(void *)v62 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    a1[2] = v62;
    goto LABEL_83;
  }
  a3(v97, a4);
LABEL_81:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v63, &v94);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v97);
  return 0;
}

uint64_t mlir::func::FuncOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  v39[6] = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a1;
  uint64_t v37 = v39;
  uint64_t v38 = 0x300000000;
  if (!*a2)
  {
    unsigned int v8 = 0;
    uint64_t v9 = a2[1];
    if (!v9) {
      goto LABEL_10;
    }
    goto LABEL_7;
  }
  uint64_t NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"arg_attrs", 9, *a2);
  uint64_t v5 = v4;
  unsigned int v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    unsigned int v6 = v38;
  }
  uint64_t v7 = (uint64_t *)((char *)v37 + 16 * v6);
  *uint64_t v7 = NamedAttr;
  v7[1] = v5;
  unsigned int v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  uint64_t v9 = a2[1];
  if (v9)
  {
LABEL_7:
    uint64_t v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"function_type", 13, v9);
    uint64_t v12 = v11;
    unsigned int v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v13 = v38;
    }
    uint64_t v14 = (uint64_t *)((char *)v37 + 16 * v13);
    uint64_t *v14 = v10;
    v14[1] = v12;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  uint64_t v15 = a2[2];
  if (v15)
  {
    uint64_t v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"res_attrs", 9, v15);
    uint64_t v18 = v17;
    unsigned int v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v19 = v38;
    }
    uint64_t v20 = (uint64_t *)((char *)v37 + 16 * v19);
    *uint64_t v20 = v16;
    v20[1] = v18;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v21 = a2[3];
  if (v21)
  {
    uint64_t v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"sym_name", 8, v21);
    uint64_t v24 = v23;
    unsigned int v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v25 = v38;
    }
    uint64_t v26 = (uint64_t *)((char *)v37 + 16 * v25);
    uint64_t *v26 = v22;
    v26[1] = v24;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  uint64_t v27 = a2[4];
  if (v27)
  {
    uint64_t v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"sym_visibility", 14, v27);
    uint64_t v30 = v29;
    unsigned int v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      unsigned int v31 = v38;
    }
    unint64_t v32 = (uint64_t *)((char *)v37 + 16 * v31);
    uint64_t *v32 = v28;
    v32[1] = v30;
    unsigned int v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  long long v33 = v37;
  if (!v8)
  {
    uint64_t DictionaryAttr = 0;
    if (v37 == v39) {
      return DictionaryAttr;
    }
    goto LABEL_24;
  }
  uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (uint64_t *)v37, v8);
  long long v33 = v37;
  if (v37 != v39) {
LABEL_24:
  }
    free(v33);
  return DictionaryAttr;
}

unint64_t mlir::func::FuncOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1 = *a1;
  unint64_t v2 = 0x1E8EB8000uLL;
  {
    unint64_t v32 = v1;
    uint64_t v36 = a1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v19 = v18;
    unint64_t v1 = v32;
    a1 = v36;
    if (v19)
    {
      unint64_t v20 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v20 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v20;
      unint64_t v1 = v32;
      a1 = v36;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v3 = HIDWORD(v1);
  unint64_t v4 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v1) ^ HIDWORD(v1));
  unint64_t v45 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) ^ ((0x9DDFEA08EB382D69 * (v3 ^ (v4 >> 47) ^ v4)) >> 47));
  unint64_t v5 = a1[1];
  {
    unint64_t v33 = v5;
    uint64_t v37 = a1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v22 = v21;
    unint64_t v5 = v33;
    a1 = v37;
    if (v22)
    {
      unint64_t v23 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v23 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v23;
      unint64_t v5 = v33;
      a1 = v37;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v6 = HIDWORD(v5);
  unint64_t v7 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v5) ^ HIDWORD(v5));
  unint64_t v44 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) ^ ((0x9DDFEA08EB382D69 * (v6 ^ (v7 >> 47) ^ v7)) >> 47));
  unint64_t v8 = a1[2];
  {
    unint64_t v34 = v8;
    uint64_t v38 = a1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v25 = v24;
    unint64_t v8 = v34;
    a1 = v38;
    if (v25)
    {
      unint64_t v26 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v26 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v26;
      unint64_t v8 = v34;
      a1 = v38;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v9 = HIDWORD(v8);
  unint64_t v10 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v8) ^ HIDWORD(v8));
  unint64_t v43 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) ^ ((0x9DDFEA08EB382D69 * (v9 ^ (v10 >> 47) ^ v10)) >> 47));
  unint64_t v11 = a1[3];
  {
    unint64_t v35 = v11;
    int64_t v39 = a1;
    unint64_t v2 = 0x1E8EB8000uLL;
    int v28 = v27;
    unint64_t v11 = v35;
    a1 = v39;
    if (v28)
    {
      unint64_t v29 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v29 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v29;
      unint64_t v11 = v35;
      a1 = v39;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v12 = HIDWORD(v11);
  unint64_t v13 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v11) ^ HIDWORD(v11));
  unint64_t v42 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v12 ^ (v13 >> 47) ^ v13)) ^ ((0x9DDFEA08EB382D69 * (v12 ^ (v13 >> 47) ^ v13)) >> 47));
  unint64_t v14 = a1[4];
  {
    unint64_t v40 = v14;
    unint64_t v14 = v40;
    unint64_t v2 = 0x1E8EB8000uLL;
    if (v30)
    {
      unint64_t v31 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v31 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v31;
      unint64_t v14 = v40;
      unint64_t v2 = 0x1E8EB8000;
    }
  }
  unint64_t v15 = HIDWORD(v14);
  unint64_t v16 = 0x9DDFEA08EB382D69 * ((*(void *)(v2 + 3024) + 8 * v14) ^ HIDWORD(v14));
  unint64_t v41 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v15 ^ (v16 >> 47) ^ v16)) ^ ((0x9DDFEA08EB382D69 * (v15 ^ (v16 >> 47) ^ v16)) >> 47));
  return llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v45, (uint64_t *)&v44, (uint64_t *)&v43, (uint64_t *)&v42, (uint64_t *)&v41);
}

unint64_t llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>(void *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v24 = 0;
  memset(v23, 0, sizeof(v23));
  memset(v22, 0, sizeof(v22));
  {
    unint64_t v16 = a2;
    uint64_t v17 = a1;
    a2 = v16;
    a1 = v17;
    if (v14)
    {
      unint64_t v15 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override) {
        unint64_t v15 = 0xFF51AFD7ED558CCDLL;
      }
      llvm::hashing::detail::get_execution_seed(void)::seed = v15;
      a2 = v16;
      a1 = v17;
    }
  }
  uint64_t v8 = *a1;
  uint64_t v25 = llvm::hashing::detail::get_execution_seed(void)::seed;
  *(void *)&v22[0] = v8;
  unint64_t v18 = 0;
  unint64_t v9 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v22, (uint64_t *)&v18, (void *)v22 + 1, (unint64_t)v23, *a2);
  unint64_t v19 = v18;
  unint64_t v10 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v22, (uint64_t *)&v19, v9, (unint64_t)v23, *a3);
  unint64_t v20 = v19;
  unint64_t v11 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v22, (uint64_t *)&v20, v10, (unint64_t)v23, *a4);
  unint64_t v21 = v20;
  unint64_t v12 = llvm::hashing::detail::hash_combine_recursive_helper::combine_data<unsigned long>(v22, (uint64_t *)&v21, v11, (unint64_t)v23, *a5);
  return llvm::hashing::detail::hash_combine_recursive_helper::combine((llvm::hashing::detail::hash_combine_recursive_helper *)v22, v21, v12, (char *)v23);
}

uint64_t mlir::func::FuncOp::getInherentAttr(int a1, void *a2, void *__s1, size_t __n)
{
  switch(__n)
  {
    case 8uLL:
      if (memcmp(__s1, "sym_name", __n)) {
        return 0;
      }
      return a2[3];
    case 9uLL:
      if (*__s1 == 0x727474615F677261 && *((unsigned char *)__s1 + 8) == 115) {
        return *a2;
      }
      if (memcmp(__s1, "res_attrs", __n)) {
        return 0;
      }
      return a2[2];
    case 0xAuLL:
    case 0xBuLL:
    case 0xCuLL:
      return 0;
    case 0xDuLL:
      if (memcmp(__s1, "function_type", __n)) {
        return 0;
      }
      return a2[1];
    case 0xEuLL:
      if (memcmp(__s1, "sym_visibility", __n)) {
        return 0;
      }
      return a2[4];
    default:
      return 0;
  }
}

uint64_t mlir::func::FuncOp::setInherentAttr(uint64_t result, void *__s1, size_t a3, uint64_t a4)
{
  unint64_t v5 = (void *)result;
  switch(a3)
  {
    case 8uLL:
      uint64_t result = memcmp(__s1, "sym_name", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
            uint64_t v10 = a4;
          }
          else {
            uint64_t v10 = 0;
          }
          v5[3] = v10;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 9uLL:
      if (*__s1 == 0x727474615F677261 && *((unsigned char *)__s1 + 8) == 115)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id) {
            uint64_t v11 = a4;
          }
          else {
            uint64_t v11 = 0;
          }
          *(void *)uint64_t result = v11;
        }
        else
        {
          *(void *)uint64_t result = 0;
        }
      }
      else
      {
        uint64_t result = memcmp(__s1, "res_attrs", a3);
        if (!result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id) {
              uint64_t v7 = a4;
            }
            else {
              uint64_t v7 = 0;
            }
            uint64_t v5[2] = v7;
          }
          else
          {
            uint64_t v5[2] = 0;
          }
        }
      }
      break;
    case 0xDuLL:
      uint64_t result = memcmp(__s1, "function_type", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
            uint64_t v8 = a4;
          }
          else {
            uint64_t v8 = 0;
          }
          v5[1] = v8;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xEuLL:
      uint64_t result = memcmp(__s1, "sym_visibility", a3);
      if (!result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
            uint64_t v9 = a4;
          }
          else {
            uint64_t v9 = 0;
          }
          v5[4] = v9;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::func::FuncOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  if (*a2) {
    mlir::NamedAttrList::append(a3, (uint64_t)"arg_attrs", 9, *a2);
  }
  uint64_t v5 = a2[1];
  if (v5) {
    mlir::NamedAttrList::append(a3, (uint64_t)"function_type", 13, v5);
  }
  uint64_t v6 = a2[2];
  if (v6) {
    mlir::NamedAttrList::append(a3, (uint64_t)"res_attrs", 9, v6);
  }
  uint64_t v7 = a2[3];
  if (v7) {
    mlir::NamedAttrList::append(a3, (uint64_t)"sym_name", 8, v7);
  }
  uint64_t v8 = a2[4];
  if (v8)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"sym_visibility", 14, v8);
  }
}

BOOL mlir::func::FuncOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8 = mlir::NamedAttrList::get(a2, **(void **)(a1 + 96));
  BOOL result = 0;
  if (!v8
    || mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v8, (const void **)"arg_attrs", (const char *)9, a3, a4))
  {
    uint64_t v9 = (const void **)mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 8));
    if (!v9
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(v9, (const void **)"function_type", (const char *)0xD, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
    {
      uint64_t v10 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 16));
      if (!v10
        || mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v10, (const void **)"res_attrs", (const char *)9, a3, a4))
      {
        uint64_t v11 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 24));
        if (!v11
          || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v11, (const void **)"sym_name", (const char *)8, a3, a4))
        {
          uint64_t v12 = mlir::NamedAttrList::get(a2, *(void *)(*(void *)(a1 + 96) + 32));
          if (!v12
            || mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v12, (const void **)"sym_visibility", (const char *)0xE, a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    uint64_t v39 = a1;
    uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    uint64_t v27 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    uint64_t v29 = v27 + 8 * v28;
    if (v29 != Value)
    {
      while (*(void *)Value
           && *(_UNKNOWN **)(**(void **)Value + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
      {
        Value += 8;
        if (Value == v29) {
          return 1;
        }
      }
      goto LABEL_3;
    }
    return 1;
  }
LABEL_3:
  a4(&v39, a5);
  if (v39)
  {
    LODWORD(v35) = 3;
    uint64_t v36 = "attribute '";
    uint64_t v37 = 11;
    uint64_t v9 = &v35;
    uint64_t v10 = (char *)v41;
    if (v42 >= v43)
    {
      unint64_t v31 = v42 + 1;
      if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
      {
        int64_t v33 = (char *)&v35 - (unsigned char *)v41;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        uint64_t v10 = (char *)v41;
        uint64_t v9 = (const void ***)((char *)v41 + v33);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v31, 24);
        uint64_t v9 = &v35;
        uint64_t v10 = (char *)v41;
      }
    }
    uint64_t v11 = &v10[24 * v42];
    long long v12 = *(_OWORD *)v9;
    *((void *)v11 + 2) = v9[2];
    *(_OWORD *)uint64_t v11 = v12;
    ++v42;
    if (v39)
    {
      __int16 v38 = 261;
      unint64_t v35 = a2;
      uint64_t v36 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v40, &v35);
      if (v39)
      {
        LODWORD(v35) = 3;
        uint64_t v36 = "' failed to satisfy constraint: Array of dictionary attributes";
        uint64_t v37 = 62;
        unint64_t v13 = &v35;
        int v14 = (char *)v41;
        if (v42 >= v43)
        {
          unint64_t v32 = v42 + 1;
          if (v41 <= &v35 && (char *)v41 + 24 * v42 > (char *)&v35)
          {
            int64_t v34 = (char *)&v35 - (unsigned char *)v41;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            int v14 = (char *)v41;
            unint64_t v13 = (const void ***)((char *)v41 + v34);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v44, v32, 24);
            unint64_t v13 = &v35;
            int v14 = (char *)v41;
          }
        }
        unint64_t v15 = &v14[24 * v42];
        long long v16 = *(_OWORD *)v13;
        *((void *)v15 + 2) = v13[2];
        *(_OWORD *)unint64_t v15 = v16;
        ++v42;
      }
    }
  }
  uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
  if (v39) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
  }
  if (v49)
  {
    unint64_t v18 = (void **)__p;
    if (__p)
    {
      unint64_t v19 = v48;
      unint64_t v20 = __p;
      if (v48 != __p)
      {
        do
          unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        unint64_t v20 = __p;
      }
      uint64_t v48 = v18;
      operator delete(v20);
    }
    unint64_t v21 = v45;
    if (v45)
    {
      int v22 = v46;
      unint64_t v23 = v45;
      if (v46 != v45)
      {
        do
        {
          uint64_t v25 = (void *)*--v22;
          uint64_t v24 = v25;
          void *v22 = 0;
          if (v25) {
            operator delete[](v24);
          }
        }
        while (v22 != v21);
        unint64_t v23 = v45;
      }
      uint64_t v46 = v21;
      operator delete(v23);
    }
    if (v41 != v44) {
      free(v41);
    }
  }
  return v17;
}

uint64_t mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(const void **a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (!a1) {
    return 1;
  }
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    uint64_t v36 = a1;
    if (*(_UNKNOWN **)(*(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
    {
      unint64_t v32 = a1;
      if (*(_UNKNOWN **)(*(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v32) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id) {
        return 1;
      }
    }
  }
  a4(&v36, a5);
  if (v36)
  {
    LODWORD(v32) = 3;
    int64_t v33 = "attribute '";
    uint64_t v34 = 11;
    uint64_t v10 = &v32;
    uint64_t v11 = (char *)v38;
    if (v39 >= v40)
    {
      unint64_t v28 = v39 + 1;
      if (v38 <= &v32 && (char *)v38 + 24 * v39 > (char *)&v32)
      {
        int64_t v30 = (char *)&v32 - (unsigned char *)v38;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v28, 24);
        uint64_t v11 = (char *)v38;
        uint64_t v10 = (const void ***)((char *)v38 + v30);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v28, 24);
        uint64_t v10 = &v32;
        uint64_t v11 = (char *)v38;
      }
    }
    long long v12 = &v11[24 * v39];
    long long v13 = *(_OWORD *)v10;
    *((void *)v12 + 2) = v10[2];
    *(_OWORD *)long long v12 = v13;
    ++v39;
    if (v36)
    {
      __int16 v35 = 261;
      unint64_t v32 = a2;
      int64_t v33 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v37, &v32);
      if (v36)
      {
        LODWORD(v32) = 3;
        int64_t v33 = "' failed to satisfy constraint: type attribute of function type";
        uint64_t v34 = 63;
        int v14 = &v32;
        unint64_t v15 = (char *)v38;
        if (v39 >= v40)
        {
          unint64_t v29 = v39 + 1;
          if (v38 <= &v32 && (char *)v38 + 24 * v39 > (char *)&v32)
          {
            int64_t v31 = (char *)&v32 - (unsigned char *)v38;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v29, 24);
            unint64_t v15 = (char *)v38;
            int v14 = (const void ***)((char *)v38 + v31);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v38, v41, v29, 24);
            int v14 = &v32;
            unint64_t v15 = (char *)v38;
          }
        }
        long long v16 = &v15[24 * v39];
        long long v17 = *(_OWORD *)v14;
        *((void *)v16 + 2) = v14[2];
        *(_OWORD *)long long v16 = v17;
        ++v39;
      }
    }
  }
  uint64_t v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v36);
  if (v36) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v36);
  }
  if (v46)
  {
    unint64_t v19 = (void **)__p;
    if (__p)
    {
      unint64_t v20 = v45;
      unint64_t v21 = __p;
      if (v45 != __p)
      {
        do
          unint64_t v20 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v20 - 1);
        while (v20 != v19);
        unint64_t v21 = __p;
      }
      unint64_t v45 = v19;
      operator delete(v21);
    }
    int v22 = v42;
    if (v42)
    {
      unint64_t v23 = v43;
      uint64_t v24 = v42;
      if (v43 != v42)
      {
        do
        {
          uint64_t v26 = (void *)*--v23;
          uint64_t v25 = v26;
          void *v23 = 0;
          if (v26) {
            operator delete[](v25);
          }
        }
        while (v23 != v22);
        uint64_t v24 = v42;
      }
      unsigned int v43 = v22;
      operator delete(v24);
    }
    if (v38 != v41) {
      free(v38);
    }
  }
  return v18;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    unint64_t v3 = operator new(0x28uLL);
    _OWORD *v3 = 0u;
    v3[1] = 0u;
    *((void *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    unint64_t v4 = &unk_1E8EBA000;
    {
      unint64_t v4 = (void *)&unk_1E8EBA000;
      if (v5)
      {
        long long v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::func::detail::FuncOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 106;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        uint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::func::detail::FuncOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        unint64_t v4 = (void *)&unk_1E8EBA000;
      }
    }
    a1[33] = v4[101];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  unsigned int v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::ArrayAttr]";
  unint64_t v41 = 65;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    unsigned int v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      unint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          unint64_t v15 = (char *)v46;
        }
      }
      long long v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)long long v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    unint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      uint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        uint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    uint64_t v26 = v50;
    if (v50)
    {
      uint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int64_t v30 = (void *)*--v27;
          unint64_t v29 = v30;
          *uint64_t v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 48))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  unsigned int v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::TypeAttr]";
  unint64_t v41 = 64;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    unsigned int v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      unint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          unint64_t v15 = (char *)v46;
        }
      }
      long long v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)long long v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    unint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      uint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        uint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    uint64_t v26 = v50;
    if (v50)
    {
      uint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int64_t v30 = (void *)*--v27;
          unint64_t v29 = v30;
          *uint64_t v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::StringAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(void *)a1 + 56))(a1, &v39)) {
    return 0;
  }
  uint64_t v4 = v39;
  if (!v39) {
    return 1;
  }
  int v5 = *(void **)(*(void *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
    uint64_t v4 = 0;
  }
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
    return 1;
  }
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(void *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    unint64_t v41 = (unint64_t)"expected ";
    uint64_t v42 = 9;
    unint64_t v6 = &v40;
    unint64_t v7 = (char *)v46;
    if (v47 >= v48)
    {
      unint64_t v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        int64_t v35 = (char *)&v40 - (unsigned char *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v7 = (char *)v46;
        unint64_t v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        unint64_t v6 = &v40;
        unint64_t v7 = (char *)v46;
      }
    }
    uint64_t v8 = &v7[24 * v47];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = v6[2];
    *(_OWORD *)uint64_t v8 = v9;
    ++v47;
  }
  unsigned int v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::StringAttr]";
  unint64_t v41 = 66;
  unint64_t v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10) {
      unint64_t v11 = v10;
    }
    else {
      unint64_t v11 = v41;
    }
    uint64_t v12 = 18;
    if (v41 - v11 < 0x12) {
      uint64_t v12 = v41 - v11;
    }
    unint64_t v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1) {
      --v13;
    }
    __int16 v43 = 261;
    unsigned int v40 = (const void **)((char *)v40 + v11 + v12);
    unint64_t v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      unint64_t v41 = (unint64_t)", but got: ";
      uint64_t v42 = 11;
      unint64_t v14 = &v40;
      unint64_t v15 = (char *)v46;
      if (v47 >= v48)
      {
        unint64_t v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          int64_t v36 = (char *)&v40 - (unsigned char *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v15 = (char *)v46;
          unint64_t v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          unint64_t v14 = &v40;
          unint64_t v15 = (char *)v46;
        }
      }
      long long v16 = &v15[24 * v47];
      long long v17 = *(_OWORD *)v14;
      *((void *)v16 + 2) = v14[2];
      *(_OWORD *)long long v16 = v17;
      ++v47;
      if (v44)
      {
        uint64_t v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        unint64_t v19 = (char *)v46;
        if (v47 >= v48)
        {
          unint64_t v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            int64_t v37 = (char *)&v40 - (unsigned char *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            unint64_t v19 = (char *)v46;
            uint64_t v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            uint64_t v18 = &v40;
            unint64_t v19 = (char *)v46;
          }
        }
        unint64_t v20 = &v19[24 * v47];
        long long v21 = *(_OWORD *)v18;
        *((void *)v20 + 2) = v18[2];
        *(_OWORD *)unint64_t v20 = v21;
        ++v47;
      }
    }
  }
  uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  if (v54)
  {
    unint64_t v23 = (void **)__p;
    if (__p)
    {
      uint64_t v24 = v53;
      uint64_t v25 = __p;
      if (v53 != __p)
      {
        do
          uint64_t v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        uint64_t v25 = __p;
      }
      unint64_t v53 = v23;
      operator delete(v25);
    }
    uint64_t v26 = v50;
    if (v50)
    {
      uint64_t v27 = v51;
      unint64_t v28 = v50;
      if (v51 != v50)
      {
        do
        {
          int64_t v30 = (void *)*--v27;
          unint64_t v29 = v30;
          *uint64_t v27 = 0;
          if (v30) {
            operator delete[](v29);
          }
        }
        while (v27 != v26);
        unint64_t v28 = v50;
      }
      unint64_t v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49) {
      free(v46);
    }
  }
  return v22;
}

uint64_t mlir::func::FuncOp::getSymName(mlir::func::FuncOp *this)
{
  unint64_t v1 = *(void *)this + 16 * (((unint64_t)*(unsigned int *)(*(void *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(void *)this + 44))) {
    unint64_t v1 = 0;
  }
  uint64_t v3 = *(void *)(v1 + 24);
  return mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v3);
}

BOOL mlir::func::FuncOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11))) {
    uint64_t v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  }
  else {
    uint64_t v3 = 0;
  }
  uint64_t v4 = (const void **)v3[1];
  if (v4)
  {
    uint64_t v5 = v3[3];
    if (v5)
    {
      uint64_t v6 = *v3;
      uint64_t v7 = v3[2];
      uint64_t v8 = v3[4];
      v30[0] = v2;
      if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v5, (const void **)"sym_name", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
      v30[0] = *this;
      }
      if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(v4, (const void **)"function_type", (const char *)0xD, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
      v30[0] = *this;
      }
      if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v8, (const void **)"sym_visibility", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
      v30[0] = *this;
      }
      if (!mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v6, (const void **)"arg_attrs", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30))return 0; {
      v30[0] = *this;
      }
      return mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(v7, (const void **)"res_attrs", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v30) != 0;
    }
    v28[0] = (const void **)"requires attribute 'sym_name'";
    __int16 v29 = 259;
    mlir::OpState::emitOpError(this, v28, (uint64_t)v30);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
    if (v30[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
    }
    if (v37)
    {
      uint64_t v18 = (void **)__p;
      if (__p)
      {
        unint64_t v19 = v36;
        unint64_t v20 = __p;
        if (v36 != __p)
        {
          do
            unint64_t v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          unint64_t v20 = __p;
        }
        int64_t v36 = v18;
        operator delete(v20);
      }
      long long v21 = v33;
      if (v33)
      {
        uint64_t v22 = v34;
        unint64_t v23 = v33;
        if (v34 != v33)
        {
          do
          {
            uint64_t v25 = (void *)*--v22;
            uint64_t v24 = v25;
            void *v22 = 0;
            if (v25) {
              operator delete[](v24);
            }
          }
          while (v22 != v21);
          unint64_t v23 = v33;
        }
        unint64_t v34 = v21;
        operator delete(v23);
      }
      uint64_t v26 = v31;
      if (v31 != v32) {
LABEL_47:
      }
        free(v26);
    }
  }
  else
  {
    v28[0] = (const void **)"requires attribute 'function_type'";
    __int16 v29 = 259;
    mlir::OpState::emitOpError(this, v28, (uint64_t)v30);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v30);
    if (v30[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v30);
    }
    if (v37)
    {
      unint64_t v10 = (void **)__p;
      if (__p)
      {
        unint64_t v11 = v36;
        uint64_t v12 = __p;
        if (v36 != __p)
        {
          do
            unint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          uint64_t v12 = __p;
        }
        int64_t v36 = v10;
        operator delete(v12);
      }
      unint64_t v13 = v33;
      if (v33)
      {
        unint64_t v14 = v34;
        unint64_t v15 = v33;
        if (v34 != v33)
        {
          do
          {
            long long v17 = (void *)*--v14;
            long long v16 = v17;
            void *v14 = 0;
            if (v17) {
              operator delete[](v16);
            }
          }
          while (v14 != v13);
          unint64_t v15 = v33;
        }
        unint64_t v34 = v13;
        operator delete(v15);
      }
      uint64_t v26 = v31;
      if (v31 != v32) {
        goto LABEL_47;
      }
    }
  }
  return v9;
}

void mlir::func::ReturnOp::build(mlir::func::ReturnOp *this, mlir::OpBuilder *a2, mlir::OperationState *a3)
{
  void v4[2] = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v4, 0, 0);
  mlir::OperationState::addOperands((uint64_t)a2, v4[0], v4[1]);
}

BOOL mlir::func::ReturnOp::parse(uint64_t a1, uint64_t a2)
{
  v12[16] = *MEMORY[0x1E4F143B8];
  unint64_t v10 = v12;
  uint64_t v11 = 0x400000000;
  v8[0] = &v9;
  v8[1] = (void *)0x100000000;
  (*(void (**)(uint64_t))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)a1 + 456))(a1, a2 + 112)
    || (uint64_t v4 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1),
        !(*(unsigned __int8 (**)(uint64_t, void **, void, uint64_t, uint64_t))(*(void *)a1 + 688))(a1, &v10, 0, 1, 0xFFFFFFFFLL))|| v11&& (!(*(unsigned __int8 (**)(uint64_t))(*(void *)a1 + 104))(a1)|| !mlir::AsmParser::parseTypeList(a1, (uint64_t)v8)))
  {
    BOOL v5 = 0;
    uint64_t v6 = v8[0];
    if (v8[0] == &v9) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  BOOL v5 = mlir::OpAsmParser::resolveOperands<llvm::SmallVector<mlir::OpAsmParser::UnresolvedOperand,4u> &,llvm::SmallVector<mlir::Type,1u> &>(a1, (uint64_t *)&v10, (uint64_t)v8, v4, a2 + 16) != 0;
  uint64_t v6 = v8[0];
  if (v8[0] != &v9) {
LABEL_9:
  }
    free(v6);
LABEL_10:
  if (v10 != v12) {
    free(v10);
  }
  return v5;
}

void mlir::func::ReturnOp::print(mlir::func::ReturnOp *this, mlir::OpAsmPrinter *a2)
{
  uint64_t v31[4] = *MEMORY[0x1E4F143B8];
  __int16 v29 = v31;
  uint64_t v30 = 0x200000000;
  uint64_t v4 = *(unsigned char **)this;
  if (v4[47])
  {
    unint64_t AttrDictionary = (const char *)mlir::Operation::getAttrDictionary((mlir::Operation *)v4);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v4 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(mlir::OpAsmPrinter *, uint64_t, uint64_t, void *, void))(*(void *)a2 + 192))(a2, Value, v7, v29, v30);
  if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0 && *(_DWORD *)(*(void *)this + 68))
  {
    uint64_t v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    uint64_t v9 = (unsigned char *)*((void *)v8 + 4);
    if ((unint64_t)v9 >= *((void *)v8 + 3))
    {
      llvm::raw_ostream::write(v8, 32);
    }
    else
    {
      *((void *)v8 + 4) = v9 + 1;
      *uint64_t v9 = 32;
    }
    unint64_t v10 = *(unsigned char **)this;
    if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0)
    {
      uint64_t v11 = *((unsigned int *)v10 + 17);
      uint64_t v12 = *((void *)v10 + 9);
    }
    else
    {
      uint64_t v12 = 0;
      uint64_t v11 = 0;
    }
    unint64_t v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    unint64_t AttrDictionary = ", ";
    uint64_t v25 = 2;
    llvm::interleave<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},void llvm::interleave<llvm::iterator_range<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::raw_ostream,mlir::Value>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator const&,llvm::raw_ostream &,void mlir::OpAsmPrinter::printOperands<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>(llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator,llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator)::{lambda(mlir::Value)#1},llvm::StringRef const&)::{lambda(void)#1},void>(v12, 0, v12, v11, (uint64_t)a2, v13, (uint64_t)&AttrDictionary);
    unint64_t v14 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    unint64_t v15 = (unsigned char *)*((void *)v14 + 4);
    if ((unint64_t)v15 >= *((void *)v14 + 3))
    {
      llvm::raw_ostream::write(v14, 32);
    }
    else
    {
      *((void *)v14 + 4) = v15 + 1;
      unsigned char *v15 = 32;
    }
    long long v16 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    long long v17 = (unsigned char *)*((void *)v16 + 4);
    if (*((unsigned char **)v16 + 3) == v17)
    {
      llvm::raw_ostream::write(v16, ":", 1uLL);
    }
    else
    {
      unsigned char *v17 = 58;
      ++*((void *)v16 + 4);
    }
    uint64_t v18 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::OpAsmPrinter *))(*(void *)a2 + 16))(a2);
    unint64_t v19 = (unsigned char *)*((void *)v18 + 4);
    if ((unint64_t)v19 >= *((void *)v18 + 3))
    {
      llvm::raw_ostream::write(v18, 32);
    }
    else
    {
      *((void *)v18 + 4) = v19 + 1;
      unsigned char *v19 = 32;
    }
    uint64_t v20 = *(void *)this;
    if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0)
    {
      uint64_t v21 = *(unsigned int *)(v20 + 68);
      uint64_t v22 = *(void *)(v20 + 72);
    }
    else
    {
      uint64_t v22 = 0;
      uint64_t v21 = 0;
    }
    v23[0] = v22;
    v23[1] = v21;
    mlir::OperandRange::getTypes(v23, (uint64_t *)&AttrDictionary);
    v28[0] = ", ";
    v28[1] = 2;
    llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::OperandRange,mlir::OpOperand *,mlir::Value,mlir::Value,mlir::Value>::iterator>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},void llvm::interleave<mlir::ValueTypeRange<mlir::OperandRange>,void llvm::interleaveComma<mlir::ValueTypeRange<mlir::OperandRange>,mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &)::{lambda(mlir::Type const&)#1},mlir::OpAsmPrinter,mlir::Type>(mlir::ValueTypeRange<mlir::OperandRange> const&,mlir::OpAsmPrinter &,mlir::OpAsmPrinter,llvm::StringRef const&)::{lambda(void)#1},void>((uint64_t)AttrDictionary, v25, v26, v27, (uint64_t)a2, (uint64_t)a2, (uint64_t)v28);
  }
  if (v29 != v31) {
    free(v29);
  }
}

uint64_t mlir::Dialect::getRegisteredInterfaceForOp<mlir::FunctionOpInterface>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v15 = a1;
    unint64_t v3 = 0x1E8EB8000;
    int v6 = v5;
    uint64_t v2 = a2;
    a1 = v15;
    if (v6)
    {
      long long v16 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::FunctionOpInterface]";
      unint64_t v17 = 75;
      unint64_t v7 = llvm::StringRef::find((uint64_t *)&v16, "DesiredTypeName = ", 0x12uLL, 0);
      if (v17 >= v7) {
        unint64_t v8 = v7;
      }
      else {
        unint64_t v8 = v17;
      }
      uint64_t v9 = &v16[v8];
      unint64_t v10 = v17 - v8;
      if (v17 - v8 >= 0x12) {
        uint64_t v11 = 18;
      }
      else {
        uint64_t v11 = v17 - v8;
      }
      unint64_t v12 = v10 - v11;
      if (v12 >= v12 - 1) {
        uint64_t v13 = v12 - 1;
      }
      else {
        uint64_t v13 = v12;
      }
      mlir::detail::TypeIDResolver<mlir::FunctionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = a2;
      a1 = v15;
    }
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, *(void *)(v3 + 3816), v2);
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::FunctionOpInterface>(uint64_t a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    uint64_t v20 = a1;
    unint64_t v1 = 0x1E8EB8000;
    int v12 = v11;
    a1 = v20;
    if (v12)
    {
      uint64_t v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::FunctionOpInterface]";
      unint64_t v22 = 75;
      unint64_t v13 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
      if (v22 >= v13) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = v22;
      }
      uint64_t v15 = &v21[v14];
      unint64_t v16 = v22 - v14;
      if (v22 - v14 >= 0x12) {
        uint64_t v17 = 18;
      }
      else {
        uint64_t v17 = v22 - v14;
      }
      unint64_t v18 = v16 - v17;
      if (v18 >= v18 - 1) {
        uint64_t v19 = v18 - 1;
      }
      else {
        uint64_t v19 = v18;
      }
      mlir::detail::TypeIDResolver<mlir::FunctionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v15[v17], v19);
      unint64_t v1 = 0x1E8EB8000;
      a1 = v20;
    }
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *(void *)(v1 + 3816);
  uint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)a1 + 16 * v2;
  do
  {
    unint64_t v6 = v2 >> 1;
    unint64_t v7 = &v4[2 * (v2 >> 1)];
    unint64_t v9 = *v7;
    unint64_t v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3) {
      uint64_t v4 = v8;
    }
    else {
      unint64_t v2 = v6;
    }
  }
  while (v2);
  if (v4 != (void *)v5 && *v4 == v3) {
    return v4[1];
  }
  else {
    return 0;
  }
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::__mlir_ods_local_attr_constraint_FuncOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>(uint64_t **a1@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2 = *a1;
  __int16 v4 = 257;
  mlir::Operation::emitOpError(v2, &v3, a2);
}

uint64_t mlir::RegisteredOperationName::insert<mlir::func::CallIndirectOp>(uint64_t a1)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v2 = operator new(0x70uLL);
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(v2, (uint64_t)"func.call_indirect", 18, a1, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::CallIndirectOp,void>::id, (uint64_t)&v9);
  unint64_t v3 = v9;
  if (v10)
  {
    uint64_t v4 = 16 * v10;
    uint64_t v5 = (void **)((char *)v9 + 8);
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    unint64_t v3 = v9;
  }
  if (v3 != v11) {
    free(v3);
  }
  *unint64_t v2 = &unk_1EC9BE278;
  unint64_t v8 = v2;
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  uint64_t result = (uint64_t)v8;
  unint64_t v8 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  unint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    unint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  unint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    unint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  return mlir::func::CallIndirectOp::getCanonicalizationPatterns(a2);
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::CallIndirectOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x1E4F143B8];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    unint64_t v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      int v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          int v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      unint64_t v14 = v30;
      uint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          uint64_t v17 = (void *)*--v14;
          unint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v29;
      }
      uint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallIndirectOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  *uint64_t v2 = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getCallableForCallee;
  v2[1] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::setCalleeFromCallable;
  v2[2] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperands;
  v2[3] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperandsMutable;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface]";
      unint64_t v14 = 71;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3736), v2);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getCallableForCallee(uint64_t a1, uint64_t a2)
{
  return *(void *)(*(void *)(a2 + 72) + 24) | 4;
}

void mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::setCalleeFromCallable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3 = (uint64_t *)(a3 & 0xFFFFFFFFFFFFFFF8);
  int v4 = *(uint64_t **)(a2 + 72);
  unint64_t v5 = (uint64_t *)v4[1];
  if (v5)
  {
    uint64_t *v5 = *v4;
    if (*v4) {
      *(void *)(*v4 + 8) = v4[1];
    }
  }
  unint64_t v4[3] = (uint64_t)v3;
  uint64_t v6 = *v3;
  uint64_t *v4 = *v3;
  v4[1] = (uint64_t)v3;
  if (v6) {
    *(void *)(v6 + 8) = v4;
  }
  uint64_t *v3 = (uint64_t)v4;
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 46) & 0x80) != 0) {
    return *(void *)(a2 + 72) + 32;
  }
  else {
    return 32;
  }
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallIndirectOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0) {
    int v2 = *(_DWORD *)(a1 + 68) - 1;
  }
  else {
    int v2 = -1;
  }
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 1, v2, 0, 0);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>(uint64_t a1)
{
  unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v87 = a1;
    unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v19 = v18;
    a1 = v87;
    if (v19)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v94 = 83;
      unint64_t v20 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v20) {
        unint64_t v21 = v20;
      }
      else {
        unint64_t v21 = v94;
      }
      unint64_t v22 = &v93[v21];
      unint64_t v23 = v94 - v21;
      if (v94 - v21 >= 0x12) {
        uint64_t v24 = 18;
      }
      else {
        uint64_t v24 = v94 - v21;
      }
      unint64_t v25 = v23 - v24;
      if (v25 >= v25 - 1) {
        uint64_t v26 = v25 - 1;
      }
      else {
        uint64_t v26 = v25;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v22[v24], v26);
      unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v87;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v82 = v2;
    uint64_t v88 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v28 = v27;
    uint64_t v2 = v82;
    a1 = v88;
    if (v28)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      unint64_t v94 = 87;
      unint64_t v29 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v29) {
        unint64_t v30 = v29;
      }
      else {
        unint64_t v30 = v94;
      }
      int64_t v31 = &v93[v30];
      unint64_t v32 = v94 - v30;
      if (v94 - v30 >= 0x12) {
        uint64_t v33 = 18;
      }
      else {
        uint64_t v33 = v94 - v30;
      }
      unint64_t v34 = v32 - v33;
      if (v34 >= v34 - 1) {
        uint64_t v35 = v34 - 1;
      }
      else {
        uint64_t v35 = v34;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v31[v33], v35);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v82;
      a1 = v88;
    }
  }
  uint64_t v4 = v3[449];
  unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v83 = v2;
    uint64_t v89 = a1;
    uint64_t v78 = v4;
    unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v4 = v78;
    uint64_t v2 = v83;
    int v37 = v36;
    a1 = v89;
    if (v37)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v94 = 86;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v94;
      }
      unsigned int v40 = &v93[v39];
      unint64_t v41 = v94 - v39;
      if (v94 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v94 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v4 = v78;
      uint64_t v2 = v83;
      a1 = v89;
    }
  }
  uint64_t v6 = v5[12];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v84 = v2;
    uint64_t v90 = a1;
    uint64_t v75 = v6;
    uint64_t v79 = v4;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v75;
    uint64_t v4 = v79;
    int v46 = v45;
    uint64_t v2 = v84;
    a1 = v90;
    if (v46)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      unint64_t v94 = 97;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v94;
      }
      char v49 = &v93[v48];
      unint64_t v50 = v94 - v48;
      if (v94 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v94 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v75;
      uint64_t v4 = v79;
      uint64_t v2 = v84;
      a1 = v90;
    }
  }
  uint64_t v8 = v7[13];
  uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v85 = v2;
    uint64_t v91 = a1;
    uint64_t v76 = v6;
    uint64_t v80 = v4;
    uint64_t v73 = v8;
    uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v73;
    uint64_t v6 = v76;
    uint64_t v4 = v80;
    uint64_t v2 = v85;
    int v55 = v54;
    a1 = v91;
    if (v55)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v94 = 84;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v94;
      }
      int64_t v58 = &v93[v57];
      unint64_t v59 = v94 - v57;
      if (v94 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v94 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v73;
      uint64_t v6 = v76;
      uint64_t v4 = v80;
      uint64_t v2 = v85;
      a1 = v91;
    }
  }
  uint64_t v10 = v9[9];
  uint64_t v11 = &unk_1E8EBA000;
  {
    uint64_t v86 = v2;
    uint64_t v92 = a1;
    uint64_t v77 = v6;
    uint64_t v81 = v4;
    uint64_t v72 = v10;
    uint64_t v74 = v8;
    uint64_t v11 = (void *)&unk_1E8EBA000;
    uint64_t v10 = v72;
    uint64_t v8 = v74;
    uint64_t v6 = v77;
    uint64_t v4 = v81;
    int v64 = v63;
    uint64_t v2 = v86;
    a1 = v92;
    if (v64)
    {
      uint64_t v93 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface::Trait<Empty>]";
      unint64_t v94 = 85;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v93, "DesiredTypeName = ", 0x12uLL, 0);
      if (v94 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v94;
      }
      unint64_t v67 = &v93[v66];
      unint64_t v68 = v94 - v66;
      if (v94 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v94 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v11 = (void *)&unk_1E8EBA000;
      uint64_t v10 = v72;
      uint64_t v8 = v74;
      uint64_t v6 = v77;
      uint64_t v4 = v81;
      uint64_t v2 = v86;
      a1 = v92;
    }
  }
  return v2 == a1 || v4 == a1 || v6 == a1 || v8 == a1 || v10 == a1 || v11[79] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::func::CallIndirectOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1))
  {
    return 0;
  }
  unint64_t v5 = a1;
  return mlir::func::CallIndirectOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

uint64_t mlir::Op<mlir::func::CallIndirectOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::CallOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::func::CallOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.call", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::CallOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9BE340;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getParseAssemblyFn(void *a1@<X8>)
{
  *a1 = mlir::func::CallOp::parse;
  a1[3] = (char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
        + 2;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::printAssembly(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                              + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                       + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 6 && (*(_DWORD *)a3 == 1819042147 ? (BOOL v7 = *(unsigned __int16 *)(a3 + 4) == 25957) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 6 && *(_DWORD *)result == 1819042147 && *(_WORD *)(result + 4) == 25957)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      uint64_t v12 = v9;
      if (v9)
      {
        uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
        if (v10) {
          uint64_t v9 = 0;
        }
        else {
          uint64_t v9 = a4;
        }
      }
      void *v5 = v9;
    }
    else
    {
      void *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"callee", 6, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v7, (const void **)"callee", (const char *)6, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::CallOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::func::CallOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::func::CallOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::CallOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::CallOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::readProperties(uint64_t a1, void *a2)
{
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  *uint64_t v2 = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getCallableForCallee;
  v2[1] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::setCalleeFromCallable;
  v2[2] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperands;
  v2[3] = mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperandsMutable;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface]";
      unint64_t v14 = 71;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3736), v2);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getCallableForCallee(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 47) || (uint64_t result = mlir::Operation::getInherentAttr(a2, (uint64_t)"callee", 6), !v4)) {
    uint64_t result = mlir::DictionaryAttr::get(a2 + 56, "callee", 6uLL);
  }
  if (result)
  {
    if (*(_UNKNOWN **)(*(void *)result + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
      return result & 0xFFFFFFFFFFFFFFFBLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

void mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::setCalleeFromCallable(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v4 = a3 & 0xFFFFFFFFFFFFFFF8;
  uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  __int16 v8 = 261;
  v7[0] = "callee";
  v7[1] = 6;
  uint64_t v6 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v7);
  mlir::Operation::setAttr(a2, v6, v4);
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperands(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a2 + 46) & 0x80) != 0) {
    return *(void *)(a2 + 72);
  }
  else {
    return 0;
  }
}

uint64_t mlir::detail::CallOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::getArgOperandsMutable@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0) {
    int v2 = *(_DWORD *)(a1 + 68);
  }
  else {
    int v2 = 0;
  }
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1, 0, v2, 0, 0);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>>(uint64_t a1)
{
  int v2 = malloc(8uLL);
  *int v2 = mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::verifySymbolUses;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    int v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolUserOpInterface]";
      unint64_t v14 = 77;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      int v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3880), v2);
}

uint64_t mlir::detail::SymbolUserOpInterfaceInterfaceTraits::Model<mlir::func::CallOp>::verifySymbolUses(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a2;
  return mlir::func::CallOp::verifySymbolUses(&v4, a3);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>(uint64_t a1)
{
  unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v144 = a1;
    unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v28 = v27;
    a1 = v144;
    if (v28)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v154 = 83;
      unint64_t v29 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v29) {
        unint64_t v30 = v29;
      }
      else {
        unint64_t v30 = v154;
      }
      int64_t v31 = &v153[v30];
      unint64_t v32 = v154 - v30;
      if (v154 - v30 >= 0x12) {
        uint64_t v33 = 18;
      }
      else {
        uint64_t v33 = v154 - v30;
      }
      unint64_t v34 = v32 - v33;
      if (v34 >= v34 - 1) {
        uint64_t v35 = v34 - 1;
      }
      else {
        uint64_t v35 = v34;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v31[v33], v35);
      unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v144;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v136 = v2;
    uint64_t v145 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v37 = v36;
    uint64_t v2 = v136;
    a1 = v145;
    if (v37)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicResults<Empty>]";
      unint64_t v154 = 87;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v154;
      }
      unsigned int v40 = &v153[v39];
      unint64_t v41 = v154 - v39;
      if (v154 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v154 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v136;
      a1 = v145;
    }
  }
  uint64_t v4 = v3[449];
  unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v137 = v2;
    uint64_t v146 = a1;
    uint64_t v129 = v4;
    unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v4 = v129;
    int v46 = v45;
    uint64_t v2 = v137;
    a1 = v146;
    if (v46)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v154 = 86;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v154;
      }
      char v49 = &v153[v48];
      unint64_t v50 = v154 - v48;
      if (v154 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v154 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v4 = v129;
      uint64_t v2 = v137;
      a1 = v146;
    }
  }
  uint64_t v6 = v5[12];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v138 = v2;
    uint64_t v147 = a1;
    uint64_t v123 = v6;
    uint64_t v130 = v4;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v123;
    uint64_t v4 = v130;
    int v55 = v54;
    uint64_t v2 = v138;
    a1 = v147;
    if (v55)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      unint64_t v154 = 88;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v154;
      }
      int64_t v58 = &v153[v57];
      unint64_t v59 = v154 - v57;
      if (v154 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v154 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v123;
      uint64_t v4 = v130;
      uint64_t v2 = v138;
      a1 = v147;
    }
  }
  uint64_t v8 = v7[14];
  uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v139 = v2;
    uint64_t v148 = a1;
    uint64_t v124 = v6;
    uint64_t v131 = v4;
    uint64_t v118 = v8;
    uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v118;
    uint64_t v6 = v124;
    uint64_t v4 = v131;
    int v64 = v63;
    uint64_t v2 = v139;
    a1 = v148;
    if (v64)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v154 = 84;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v154;
      }
      unint64_t v67 = &v153[v66];
      unint64_t v68 = v154 - v66;
      if (v154 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v154 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v118;
      uint64_t v6 = v124;
      uint64_t v4 = v131;
      uint64_t v2 = v139;
      a1 = v148;
    }
  }
  uint64_t v10 = v9[9];
  unint64_t v11 = 0x1E8EB8000uLL;
  {
    uint64_t v140 = v2;
    uint64_t v149 = a1;
    uint64_t v125 = v6;
    uint64_t v132 = v4;
    uint64_t v114 = v10;
    uint64_t v119 = v8;
    unint64_t v11 = 0x1E8EB8000;
    uint64_t v10 = v114;
    uint64_t v8 = v119;
    uint64_t v6 = v125;
    uint64_t v4 = v132;
    int v73 = v72;
    uint64_t v2 = v140;
    a1 = v149;
    if (v73)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v154 = 89;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v154;
      }
      uint64_t v76 = &v153[v75];
      unint64_t v77 = v154 - v75;
      if (v154 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v154 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      unint64_t v11 = 0x1E8EB8000;
      uint64_t v10 = v114;
      uint64_t v8 = v119;
      uint64_t v6 = v125;
      uint64_t v4 = v132;
      uint64_t v2 = v140;
      a1 = v149;
    }
  }
  uint64_t v12 = *(void *)(v11 + 2744);
  uint64_t v13 = &unk_1E8EBA000;
  {
    uint64_t v141 = v2;
    uint64_t v150 = a1;
    uint64_t v126 = v6;
    uint64_t v133 = v4;
    uint64_t v115 = v10;
    uint64_t v120 = v8;
    uint64_t v111 = v12;
    uint64_t v13 = (void *)&unk_1E8EBA000;
    uint64_t v12 = v111;
    uint64_t v10 = v115;
    uint64_t v8 = v120;
    uint64_t v6 = v126;
    uint64_t v4 = v133;
    int v82 = v81;
    uint64_t v2 = v141;
    a1 = v150;
    if (v82)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface::Trait<Empty>]";
      unint64_t v154 = 85;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v154;
      }
      uint64_t v85 = &v153[v84];
      unint64_t v86 = v154 - v84;
      if (v154 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v154 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::CallOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      uint64_t v13 = (void *)&unk_1E8EBA000;
      uint64_t v12 = v111;
      uint64_t v10 = v115;
      uint64_t v8 = v120;
      uint64_t v6 = v126;
      uint64_t v4 = v133;
      uint64_t v2 = v141;
      a1 = v150;
    }
  }
  uint64_t v14 = v13[79];
  uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v142 = v2;
    uint64_t v151 = a1;
    uint64_t v127 = v6;
    uint64_t v134 = v4;
    uint64_t v116 = v10;
    uint64_t v121 = v8;
    uint64_t v109 = v14;
    uint64_t v112 = v12;
    uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v14 = v109;
    uint64_t v12 = v112;
    uint64_t v10 = v116;
    uint64_t v8 = v121;
    uint64_t v6 = v127;
    uint64_t v4 = v134;
    int v91 = v90;
    uint64_t v2 = v142;
    a1 = v151;
    if (v91)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::MemRefsNormalizable<Empty>]";
      unint64_t v154 = 91;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v154;
      }
      unint64_t v94 = &v153[v93];
      unint64_t v95 = v154 - v93;
      if (v154 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v154 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      uint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v14 = v109;
      uint64_t v12 = v112;
      uint64_t v10 = v116;
      uint64_t v8 = v121;
      uint64_t v6 = v127;
      uint64_t v4 = v134;
      uint64_t v2 = v142;
      a1 = v151;
    }
  }
  uint64_t v16 = v15[18];
  uint64_t v17 = &unk_1E8EBA000;
  {
    uint64_t v143 = v2;
    uint64_t v152 = a1;
    uint64_t v128 = v6;
    uint64_t v135 = v4;
    uint64_t v117 = v10;
    uint64_t v122 = v8;
    uint64_t v110 = v14;
    uint64_t v113 = v12;
    uint64_t v108 = v16;
    uint64_t v17 = (void *)&unk_1E8EBA000;
    uint64_t v16 = v108;
    uint64_t v14 = v110;
    uint64_t v12 = v113;
    uint64_t v10 = v117;
    uint64_t v8 = v122;
    uint64_t v6 = v128;
    uint64_t v4 = v135;
    int v100 = v99;
    uint64_t v2 = v143;
    a1 = v152;
    if (v100)
    {
      uint64_t v153 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolUserOpInterface::Trait<Empty>]";
      unint64_t v154 = 91;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v153, "DesiredTypeName = ", 0x12uLL, 0);
      if (v154 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v154;
      }
      BOOL v103 = &v153[v102];
      unint64_t v104 = v154 - v102;
      if (v154 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v154 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::SymbolUserOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolUserOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      uint64_t v17 = (void *)&unk_1E8EBA000;
      uint64_t v16 = v108;
      uint64_t v14 = v110;
      uint64_t v12 = v113;
      uint64_t v10 = v117;
      uint64_t v8 = v122;
      uint64_t v6 = v128;
      uint64_t v4 = v135;
      uint64_t v2 = v143;
      a1 = v152;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v17[81] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, mlir::Operation *a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName((uint64_t)a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::func::CallOp::print(&v7, a3);
}

BOOL mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3))
  {
    return 0;
  }
  unint64_t v5 = a1;
  return mlir::func::CallOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

uint64_t mlir::Op<mlir::func::CallOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::VariadicResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::CallOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::SymbolUserOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.constant", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::ConstantOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9BE1B0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2;
  uint64_t v5 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  char v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0) {
      (*(void (__cdecl **)())((v9 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v6 & 2) == 0) {
      llvm::deallocate_buffer(v8[0], v8[1]);
    }
  }
  return v5;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::ConstantOp::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, mlir::Operation *, mlir::OpAsmPrinter *, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8)
                                                                                                 + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 5 && (*(_DWORD *)a3 == 1970037110 ? (BOOL v7 = *(unsigned char *)(a3 + 4) == 101) : (BOOL v7 = 0), v7)) {
    return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 5 && *(_DWORD *)result == 1970037110 && *(unsigned char *)(result + 4) == 101)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(void *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
        uint64_t v9 = a4;
      }
      else {
        uint64_t v9 = 0;
      }
      uint64_t v12 = v9;
      if (v9)
      {
        uint64_t result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
        if (v10) {
          uint64_t v9 = 0;
        }
        else {
          uint64_t v9 = a4;
        }
      }
      void *v5 = v9;
    }
    else
    {
      void *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  uint64_t v5 = *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
  {
    mlir::NamedAttrList::append(a3, (uint64_t)"value", 5, v5);
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7 = mlir::NamedAttrList::get(a3, **(void **)(a2 + 96));
  return !v7
      || mlir::func::__mlir_ods_local_attr_constraint_FuncOps0(v7, (const void **)"value", (const char *)5, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::initProperties(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  if (a4) {
    *a3 = *a4;
  }
  else {
    *a3 = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::ConstantOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    char v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    char v4 = 0;
  }

  return mlir::arith::ConstantOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::copyProperties(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::ConstantOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::readProperties(uint64_t a1, void *a2)
{
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::FlatSymbolRefAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, void))(*(void *)a3 + 16))(a3, *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ConstantOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x20uLL);
  *uint64_t v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getDefaultDialect;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      unint64_t v14 = 72;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3760), v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getAsmResultNames(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  return a3(a4, a2 - 16, "f", 1);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::ConstantOp>::getDefaultDialect()
{
  return "";
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldSingleResultHook<mlir::func::ConstantOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldSingleResultHook<mlir::func::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 56);
  unint64_t v9 = *(unsigned int *)(a1 + 44);
  uint64_t v10 = a1 + 64;
  uint64_t v11 = (uint64_t *)(a1 + 64 + 16 * ((v9 >> 23) & 1));
  unint64_t v12 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    uint64_t v13 = (((unint64_t)v11 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    uint64_t v13 = 0;
    unint64_t v12 = 0;
  }
  mlir::ValueRange::ValueRange(v25, v13, v12);
  uint64_t v18 = v8;
  v19[0] = 0;
  char v20 = 0;
  uint64_t v21 = *v11;
  long long v22 = *(_OWORD *)v25;
  if (v8)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v18);
    if (v20) {
      char v20 = 0;
    }
    mlir::OperationName::OperationName(v19, "func.constant", 13, Context);
    char v20 = 1;
  }
  uint64_t v23 = a2;
  uint64_t v24 = a3;
  unint64_t v15 = *(void *)(v10 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1)) & 0xFFFFFFFFFFFFFFFBLL;
  if (v15 < 8) {
    return 0;
  }
  uint64_t v16 = *(unsigned int *)(a4 + 8);
  if (v16 >= *(_DWORD *)(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v16 + 1, 8);
    LODWORD(v16) = *(_DWORD *)(a4 + 8);
  }
  *(void *)(*(void *)a4 + 8 * v16) = v15;
  ++*(_DWORD *)(a4 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v210 = a1;
    unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v37 = v36;
    a1 = v210;
    if (v37)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v223 = 83;
      unint64_t v38 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v38) {
        unint64_t v39 = v38;
      }
      else {
        unint64_t v39 = v223;
      }
      unsigned int v40 = &v222[v39];
      unint64_t v41 = v223 - v39;
      if (v223 - v39 >= 0x12) {
        uint64_t v42 = 18;
      }
      else {
        uint64_t v42 = v223 - v39;
      }
      unint64_t v43 = v41 - v42;
      if (v43 >= v43 - 1) {
        uint64_t v44 = v43 - 1;
      }
      else {
        uint64_t v44 = v43;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v210;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v199 = v2;
    uint64_t v211 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v46 = v45;
    uint64_t v2 = v199;
    a1 = v211;
    if (v46)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      unint64_t v223 = 81;
      unint64_t v47 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v47) {
        unint64_t v48 = v47;
      }
      else {
        unint64_t v48 = v223;
      }
      char v49 = &v222[v48];
      unint64_t v50 = v223 - v48;
      if (v223 - v48 >= 0x12) {
        uint64_t v51 = 18;
      }
      else {
        uint64_t v51 = v223 - v48;
      }
      unint64_t v52 = v50 - v51;
      if (v52 >= v52 - 1) {
        uint64_t v53 = v52 - 1;
      }
      else {
        uint64_t v53 = v52;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v199;
      a1 = v211;
    }
  }
  uint64_t v4 = v3[27];
  unint64_t v5 = 0x1E8EB8000uLL;
  {
    uint64_t v200 = v2;
    uint64_t v212 = a1;
    uint64_t v189 = v4;
    unint64_t v5 = 0x1E8EB8000;
    uint64_t v4 = v189;
    uint64_t v2 = v200;
    int v55 = v54;
    a1 = v212;
    if (v55)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      unint64_t v223 = 104;
      unint64_t v56 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v56) {
        unint64_t v57 = v56;
      }
      else {
        unint64_t v57 = v223;
      }
      int64_t v58 = &v222[v57];
      unint64_t v59 = v223 - v57;
      if (v223 - v57 >= 0x12) {
        uint64_t v60 = 18;
      }
      else {
        uint64_t v60 = v223 - v57;
      }
      unint64_t v61 = v59 - v60;
      if (v61 >= v61 - 1) {
        uint64_t v62 = v61 - 1;
      }
      else {
        uint64_t v62 = v61;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      unint64_t v5 = 0x1E8EB8000;
      uint64_t v4 = v189;
      uint64_t v2 = v200;
      a1 = v212;
    }
  }
  uint64_t v6 = *(void *)(v5 + 2896);
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v201 = v2;
    uint64_t v213 = a1;
    uint64_t v190 = v4;
    uint64_t v180 = v6;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v180;
    uint64_t v4 = v190;
    uint64_t v2 = v201;
    int v64 = v63;
    a1 = v213;
    if (v64)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v223 = 86;
      unint64_t v65 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v65) {
        unint64_t v66 = v65;
      }
      else {
        unint64_t v66 = v223;
      }
      unint64_t v67 = &v222[v66];
      unint64_t v68 = v223 - v66;
      if (v223 - v66 >= 0x12) {
        uint64_t v69 = 18;
      }
      else {
        uint64_t v69 = v223 - v66;
      }
      unint64_t v70 = v68 - v69;
      if (v70 >= v70 - 1) {
        uint64_t v71 = v70 - 1;
      }
      else {
        uint64_t v71 = v70;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v180;
      uint64_t v4 = v190;
      uint64_t v2 = v201;
      a1 = v213;
    }
  }
  uint64_t v8 = v7[12];
  unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v202 = v2;
    uint64_t v214 = a1;
    uint64_t v191 = v4;
    uint64_t v172 = v8;
    uint64_t v181 = v6;
    unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v172;
    uint64_t v6 = v181;
    uint64_t v4 = v191;
    uint64_t v2 = v202;
    int v73 = v72;
    a1 = v214;
    if (v73)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      unint64_t v223 = 84;
      unint64_t v74 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v74) {
        unint64_t v75 = v74;
      }
      else {
        unint64_t v75 = v223;
      }
      uint64_t v76 = &v222[v75];
      unint64_t v77 = v223 - v75;
      if (v223 - v75 >= 0x12) {
        uint64_t v78 = 18;
      }
      else {
        uint64_t v78 = v223 - v75;
      }
      unint64_t v79 = v77 - v78;
      if (v79 >= v79 - 1) {
        uint64_t v80 = v79 - 1;
      }
      else {
        uint64_t v80 = v79;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      unint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v172;
      uint64_t v6 = v181;
      uint64_t v4 = v191;
      uint64_t v2 = v202;
      a1 = v214;
    }
  }
  uint64_t v10 = v9[10];
  uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v203 = v2;
    uint64_t v215 = a1;
    uint64_t v192 = v4;
    uint64_t v173 = v8;
    uint64_t v182 = v6;
    uint64_t v165 = v10;
    uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v165;
    uint64_t v8 = v173;
    uint64_t v6 = v182;
    uint64_t v4 = v192;
    uint64_t v2 = v203;
    int v82 = v81;
    a1 = v215;
    if (v82)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v223 = 84;
      unint64_t v83 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v83) {
        unint64_t v84 = v83;
      }
      else {
        unint64_t v84 = v223;
      }
      uint64_t v85 = &v222[v84];
      unint64_t v86 = v223 - v84;
      if (v223 - v84 >= 0x12) {
        uint64_t v87 = 18;
      }
      else {
        uint64_t v87 = v223 - v84;
      }
      unint64_t v88 = v86 - v87;
      if (v88 >= v88 - 1) {
        uint64_t v89 = v88 - 1;
      }
      else {
        uint64_t v89 = v88;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v165;
      uint64_t v8 = v173;
      uint64_t v6 = v182;
      uint64_t v4 = v192;
      uint64_t v2 = v203;
      a1 = v215;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v204 = v2;
    uint64_t v216 = a1;
    uint64_t v193 = v4;
    uint64_t v174 = v8;
    uint64_t v183 = v6;
    uint64_t v159 = v12;
    uint64_t v166 = v10;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v159;
    uint64_t v10 = v166;
    uint64_t v8 = v174;
    uint64_t v6 = v183;
    uint64_t v4 = v193;
    uint64_t v2 = v204;
    int v91 = v90;
    a1 = v216;
    if (v91)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v223 = 89;
      unint64_t v92 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v92) {
        unint64_t v93 = v92;
      }
      else {
        unint64_t v93 = v223;
      }
      unint64_t v94 = &v222[v93];
      unint64_t v95 = v223 - v93;
      if (v223 - v93 >= 0x12) {
        uint64_t v96 = 18;
      }
      else {
        uint64_t v96 = v223 - v93;
      }
      unint64_t v97 = v95 - v96;
      if (v97 >= v97 - 1) {
        uint64_t v98 = v97 - 1;
      }
      else {
        uint64_t v98 = v97;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v159;
      uint64_t v10 = v166;
      uint64_t v8 = v174;
      uint64_t v6 = v183;
      uint64_t v4 = v193;
      uint64_t v2 = v204;
      a1 = v216;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2744);
  unint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v205 = v2;
    uint64_t v217 = a1;
    uint64_t v194 = v4;
    uint64_t v175 = v8;
    uint64_t v184 = v6;
    uint64_t v160 = v12;
    uint64_t v167 = v10;
    uint64_t v154 = v14;
    unint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v14 = v154;
    uint64_t v12 = v160;
    uint64_t v10 = v167;
    uint64_t v8 = v175;
    uint64_t v6 = v184;
    uint64_t v4 = v194;
    uint64_t v2 = v205;
    int v100 = v99;
    a1 = v217;
    if (v100)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
      unint64_t v223 = 84;
      unint64_t v101 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v101) {
        unint64_t v102 = v101;
      }
      else {
        unint64_t v102 = v223;
      }
      BOOL v103 = &v222[v102];
      unint64_t v104 = v223 - v102;
      if (v223 - v102 >= 0x12) {
        uint64_t v105 = 18;
      }
      else {
        uint64_t v105 = v223 - v102;
      }
      unint64_t v106 = v104 - v105;
      if (v106 >= v106 - 1) {
        uint64_t v107 = v106 - 1;
      }
      else {
        uint64_t v107 = v106;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      unint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v14 = v154;
      uint64_t v12 = v160;
      uint64_t v10 = v167;
      uint64_t v8 = v175;
      uint64_t v6 = v184;
      uint64_t v4 = v194;
      uint64_t v2 = v205;
      a1 = v217;
    }
  }
  uint64_t v16 = v15[6];
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v206 = v2;
    uint64_t v218 = a1;
    uint64_t v195 = v4;
    uint64_t v176 = v8;
    uint64_t v185 = v6;
    uint64_t v161 = v12;
    uint64_t v168 = v10;
    uint64_t v150 = v16;
    uint64_t v155 = v14;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v150;
    uint64_t v14 = v155;
    uint64_t v12 = v161;
    uint64_t v10 = v168;
    uint64_t v8 = v176;
    uint64_t v6 = v185;
    uint64_t v4 = v195;
    uint64_t v2 = v206;
    int v109 = v108;
    a1 = v218;
    if (v109)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v223 = 95;
      unint64_t v110 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v110) {
        unint64_t v111 = v110;
      }
      else {
        unint64_t v111 = v223;
      }
      uint64_t v112 = &v222[v111];
      unint64_t v113 = v223 - v111;
      if (v223 - v111 >= 0x12) {
        uint64_t v114 = 18;
      }
      else {
        uint64_t v114 = v223 - v111;
      }
      unint64_t v115 = v113 - v114;
      if (v115 >= v115 - 1) {
        uint64_t v116 = v115 - 1;
      }
      else {
        uint64_t v116 = v115;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v150;
      uint64_t v14 = v155;
      uint64_t v12 = v161;
      uint64_t v10 = v168;
      uint64_t v8 = v176;
      uint64_t v6 = v185;
      uint64_t v4 = v195;
      uint64_t v2 = v206;
      a1 = v218;
    }
  }
  uint64_t v18 = *(void *)(v17 + 2776);
  unint64_t v19 = 0x1E8EB8000uLL;
  {
    uint64_t v207 = v2;
    uint64_t v219 = a1;
    uint64_t v196 = v4;
    uint64_t v177 = v8;
    uint64_t v186 = v6;
    uint64_t v162 = v12;
    uint64_t v169 = v10;
    uint64_t v151 = v16;
    uint64_t v156 = v14;
    uint64_t v147 = v18;
    unint64_t v19 = 0x1E8EB8000;
    uint64_t v18 = v147;
    uint64_t v16 = v151;
    uint64_t v14 = v156;
    uint64_t v12 = v162;
    uint64_t v10 = v169;
    uint64_t v8 = v177;
    uint64_t v6 = v186;
    uint64_t v4 = v196;
    uint64_t v2 = v207;
    int v118 = v117;
    a1 = v219;
    if (v118)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v223 = 99;
      unint64_t v119 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v119) {
        unint64_t v120 = v119;
      }
      else {
        unint64_t v120 = v223;
      }
      uint64_t v121 = &v222[v120];
      unint64_t v122 = v223 - v120;
      if (v223 - v120 >= 0x12) {
        uint64_t v123 = 18;
      }
      else {
        uint64_t v123 = v223 - v120;
      }
      unint64_t v124 = v122 - v123;
      if (v124 >= v124 - 1) {
        uint64_t v125 = v124 - 1;
      }
      else {
        uint64_t v125 = v124;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v121[v123], v125);
      unint64_t v19 = 0x1E8EB8000;
      uint64_t v18 = v147;
      uint64_t v16 = v151;
      uint64_t v14 = v156;
      uint64_t v12 = v162;
      uint64_t v10 = v169;
      uint64_t v8 = v177;
      uint64_t v6 = v186;
      uint64_t v4 = v196;
      uint64_t v2 = v207;
      a1 = v219;
    }
  }
  uint64_t v20 = *(void *)(v19 + 2912);
  unint64_t v21 = 0x1E8EB8000uLL;
  {
    uint64_t v208 = v2;
    uint64_t v220 = a1;
    uint64_t v197 = v4;
    uint64_t v178 = v8;
    uint64_t v187 = v6;
    uint64_t v163 = v12;
    uint64_t v170 = v10;
    uint64_t v152 = v16;
    uint64_t v157 = v14;
    uint64_t v145 = v20;
    uint64_t v148 = v18;
    unint64_t v21 = 0x1E8EB8000;
    uint64_t v20 = v145;
    uint64_t v18 = v148;
    uint64_t v16 = v152;
    uint64_t v14 = v157;
    uint64_t v12 = v163;
    uint64_t v10 = v170;
    uint64_t v8 = v178;
    uint64_t v6 = v187;
    uint64_t v4 = v197;
    uint64_t v2 = v208;
    int v127 = v126;
    a1 = v220;
    if (v127)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v223 = 93;
      unint64_t v128 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v128) {
        unint64_t v129 = v128;
      }
      else {
        unint64_t v129 = v223;
      }
      uint64_t v130 = &v222[v129];
      unint64_t v131 = v223 - v129;
      if (v223 - v129 >= 0x12) {
        uint64_t v132 = 18;
      }
      else {
        uint64_t v132 = v223 - v129;
      }
      unint64_t v133 = v131 - v132;
      if (v133 >= v133 - 1) {
        uint64_t v134 = v133 - 1;
      }
      else {
        uint64_t v134 = v133;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v130[v132], v134);
      unint64_t v21 = 0x1E8EB8000;
      uint64_t v20 = v145;
      uint64_t v18 = v148;
      uint64_t v16 = v152;
      uint64_t v14 = v157;
      uint64_t v12 = v163;
      uint64_t v10 = v170;
      uint64_t v8 = v178;
      uint64_t v6 = v187;
      uint64_t v4 = v197;
      uint64_t v2 = v208;
      a1 = v220;
    }
  }
  uint64_t v22 = *(void *)(v21 + 3904);
  unint64_t v23 = 0x1E8EB8000uLL;
  {
    uint64_t v209 = v2;
    uint64_t v221 = a1;
    uint64_t v198 = v4;
    uint64_t v179 = v8;
    uint64_t v188 = v6;
    uint64_t v164 = v12;
    uint64_t v171 = v10;
    uint64_t v153 = v16;
    uint64_t v158 = v14;
    uint64_t v146 = v20;
    uint64_t v149 = v18;
    uint64_t v144 = v22;
    unint64_t v23 = 0x1E8EB8000;
    uint64_t v22 = v144;
    uint64_t v20 = v146;
    uint64_t v18 = v149;
    uint64_t v16 = v153;
    uint64_t v14 = v158;
    uint64_t v12 = v164;
    uint64_t v10 = v171;
    uint64_t v8 = v179;
    uint64_t v6 = v188;
    uint64_t v4 = v198;
    uint64_t v2 = v209;
    int v136 = v135;
    a1 = v221;
    if (v136)
    {
      uint64_t v222 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      unint64_t v223 = 86;
      unint64_t v137 = llvm::StringRef::find((uint64_t *)&v222, "DesiredTypeName = ", 0x12uLL, 0);
      if (v223 >= v137) {
        unint64_t v138 = v137;
      }
      else {
        unint64_t v138 = v223;
      }
      uint64_t v139 = &v222[v138];
      unint64_t v140 = v223 - v138;
      if (v223 - v138 >= 0x12) {
        uint64_t v141 = 18;
      }
      else {
        uint64_t v141 = v223 - v138;
      }
      unint64_t v142 = v140 - v141;
      if (v142 >= v142 - 1) {
        uint64_t v143 = v142 - 1;
      }
      else {
        uint64_t v143 = v142;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v139[v141], v143);
      unint64_t v23 = 0x1E8EB8000;
      uint64_t v22 = v144;
      uint64_t v20 = v146;
      uint64_t v18 = v149;
      uint64_t v16 = v153;
      uint64_t v14 = v158;
      uint64_t v12 = v164;
      uint64_t v10 = v171;
      uint64_t v8 = v179;
      uint64_t v6 = v188;
      uint64_t v4 = v198;
      uint64_t v2 = v209;
      a1 = v221;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || *(void *)(v23 + 3752) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::func::ConstantOp::print((mlir::func::ConstantOp *)&v7, a3);
}

BOOL mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)) {
    return 0;
  }
  if (!mlir::OpTrait::impl::verifyZeroOperands(a1, v5)) {
    return 0;
  }
  uint64_t v7 = a1;
  if (!mlir::func::ConstantOp::verifyInvariantsImpl((uint64_t **)&v7)) {
    return 0;
  }
  uint64_t v7 = a1;
  return mlir::func::ConstantOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::func::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants()
{
  return 1;
}

void *mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  unint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.func", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    uint64_t v6 = (void **)((char *)v9 + 8);
    do
    {
      uint64_t v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9BE408;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      uint64_t v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getParseAssemblyFn(uint64_t (**a1)(mlir::AsmParser *a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::FuncOp::parse;
  a1[3] = (uint64_t (*)(mlir::AsmParser *, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                             + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getInherentAttr(uint64_t a1, uint64_t a2, void *a3, size_t a4)
{
  int Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v8 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    uint64_t v8 = 0;
  }

  return mlir::func::FuncOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    uint64_t v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::func::FuncOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v6 = 0;
  }

  mlir::func::FuncOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::func::FuncOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, long long *a4)
{
  if (a4)
  {
    long long v4 = *a4;
    long long v5 = a4[1];
    *(void *)(a3 + 32) = *((void *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(void *)(a3 + 32) = 0;
    *(void *)&long long v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::func::FuncOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    long long v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    long long v4 = 0;
  }

  return mlir::func::FuncOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(void *)(a2 + 32) = *(void *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::compareProperties(uint64_t a1, void *a2, void *a3)
{
  if (*a3 != *a2) {
    return 0;
  }
  if (a3[1] != a2[1]) {
    return 0;
  }
  if (a3[2] != a2[2]) {
    return 0;
  }
  if (a3[3] == a2[3]) {
    return a3[4] == a2[4];
  }
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::func::FuncOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::func::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::writeProperties;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2752), v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::readProperties(uint64_t a1, void *a2)
{
  unint64_t v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::ArrayAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::StringAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::StringAttr>(a1, v3 + 4) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    int v4 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    int v4 = 0;
  }
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, void))(*(void *)a3 + 16))(a3, v4[3]);
  uint64_t v5 = v4[4];
  unint64_t v6 = *(uint64_t (**)(uint64_t, uint64_t))(*(void *)a3 + 24);

  return v6(a3, v5);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x80uLL);
  *uint64_t v2 = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getNameAttr;
  v2[1] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setName;
  v2[2] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getVisibility;
  v2[3] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isNested;
  v2[4] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPrivate;
  v2[5] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPublic;
  v2[6] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setVisibility;
  v2[7] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setNested;
  v2[8] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPrivate;
  v2[9] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPublic;
  v2[10] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getSymbolUses;
  v2[11] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::symbolKnownUseEmpty;
  v2[12] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::replaceAllSymbolUses;
  v2[13] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isOptionalSymbol;
  v2[14] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::canDiscardOnUseEmpty;
  v2[15] = mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isDeclaration;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolOpInterface]";
      unint64_t v14 = 73;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3784), v2);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getNameAttr(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolName(this, this);
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setName(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  __int16 v8 = 261;
  v7[0] = "sym_name";
  v7[1] = 8;
  uint64_t v6 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)v7);
  mlir::Operation::setAttr(a2, v6, a3);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getVisibility(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this);
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isNested(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 2;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPrivate(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 1;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isPublic(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) == 0;
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setVisibility(uint64_t a1, uint64_t a2, int a3)
{
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setNested(uint64_t a1, uint64_t a2)
{
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPrivate(uint64_t a1, uint64_t a2)
{
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setPublic(uint64_t a1, uint64_t a2)
{
}

void mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getSymbolUses(mlir::SymbolTable *a1@<X1>, mlir::Operation *a2@<X2>, uint64_t a3@<X8>)
{
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::symbolKnownUseEmpty(uint64_t a1, mlir::SymbolTable *a2, mlir::Operation *a3)
{
  return mlir::SymbolTable::symbolKnownUseEmpty(a2, a3, a3);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::replaceAllSymbolUses(uint64_t a1, mlir::Operation *a2, uint64_t a3, unint64_t a4)
{
  return mlir::SymbolTable::replaceAllSymbolUses(a2, a3, a4);
}

uint64_t mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isOptionalSymbol()
{
  return 0;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::canDiscardOnUseEmpty(int a1, mlir::SymbolTable *this)
{
  return mlir::SymbolTable::getSymbolVisibility(this, this) != 0;
}

BOOL mlir::detail::SymbolOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::isDeclaration(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a2 + 44);
  if ((v2 & 0x7FFFFF) == 0) {
    return MEMORY[0] == 0;
  }
  unint64_t v3 = (void *)(((a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(a2 + 40));
  return *v3 == (void)v3;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  unint64_t v2 = malloc(0x48uLL);
  *unint64_t v2 = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getCallableRegion;
  v2[1] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgumentTypes;
  v2[2] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResultTypes;
  v2[3] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgAttrsAttr;
  v2[4] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResAttrsAttr;
  v2[5] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setArgAttrsAttr;
  v2[6] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setResAttrsAttr;
  v2[7] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeArgAttrsAttr;
  v2[8] = mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeResAttrsAttr;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    unint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallableOpInterface]";
      unint64_t v14 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::CallableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      unint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3800), v2);
}

void *mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getCallableRegion(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = *(unsigned int *)(a2 + 44);
  if ((v2 & 0x7FFFFF) == 0) {
    return 0;
  }
  unint64_t v3 = (void *)(((a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                + 32 * *(unsigned int *)(a2 + 40));
  if ((void *)*v3 == v3) {
    return 0;
  }
  else {
    return v3;
  }
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgumentTypes(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v2 = 0;
  }
  uint64_t Value = *(void *)(v2 + 8);
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResultTypes(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v2 = 0;
  }
  uint64_t Value = *(void *)(v2 + 8);
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::getResults((mlir::FunctionType *)&Value);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getArgAttrsAttr(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getResAttrsAttr(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v2 = 0;
  }
  return *(void *)(v2 + 16);
}

void mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setArgAttrsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

void mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setResAttrsAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeArgAttrsAttr(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v2 = (void *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else {
    unint64_t v2 = 0;
  }
  *unint64_t v2 = 0;
  return 0;
}

uint64_t mlir::detail::CallableOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::removeResAttrsAttr(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v2 = 0;
  }
  *(void *)(v2 + 16) = 0;
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  unint64_t v2 = malloc(0x38uLL);
  *unint64_t v2 = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getFunctionType;
  v2[1] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setFunctionTypeAttr;
  v2[2] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::cloneTypeWith;
  v2[3] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyBody;
  v2[4] = mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyType;
  v2[5] = mlir::detail::InterfaceMap::lookup<mlir::SymbolOpInterface>(a1);
  v2[6] = mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(a1);
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v3 = 0x1E8EB8000;
    if (v4)
    {
      unint64_t v12 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::FunctionOpInterface]";
      unint64_t v13 = 75;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v12, "DesiredTypeName = ", 0x12uLL, 0);
      if (v13 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v13;
      }
      size_t v7 = &v12[v6];
      unint64_t v8 = v13 - v6;
      if (v13 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v13 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::FunctionOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3816), v2);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getFunctionType(uint64_t a1, uint64_t a2)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v2 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v2 = 0;
  }
  uint64_t v4 = *(void *)(v2 + 8);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v4);
}

void mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::setFunctionTypeAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::cloneTypeWith(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if (HIBYTE(*(_DWORD *)(a2 + 44))) {
    unint64_t v10 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  }
  else {
    unint64_t v10 = 0;
  }
  uint64_t Value = *(void *)(v10 + 8);
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  return mlir::FunctionType::clone((mlir::Attribute *)&Value, a3, a4, a5, a6);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyBody(uint64_t a1, uint64_t *a2)
{
  unint64_t v3 = a2;
  return mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(&v3);
}

uint64_t mlir::detail::FunctionOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::verifyType()
{
  return 1;
}

uint64_t mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(uint64_t **a1)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = *a1;
  unint64_t v3 = *((unsigned int *)*a1 + 11);
  if ((v3 & 0x7FFFFF) != 0)
  {
    uint64_t v4 = (void *)((((unint64_t)&v2[2 * ((v3 >> 23) & 1) + 8] + ((v3 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)v2 + 10));
    if ((void *)*v4 == v4) {
      return 1;
    }
  }
  else if (!MEMORY[0])
  {
    return 1;
  }
  uint64_t v5 = (uint64_t)&v2[2 * ((v3 >> 23) & 1) + 8];
  if (HIBYTE(*((_DWORD *)*a1 + 11))) {
    uint64_t v6 = v5;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t Value = *(void *)(v6 + 8);
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&Value);
  uint64_t Inputs = mlir::FunctionType::getInputs((mlir::FunctionType *)&Value);
  unsigned int v9 = v8;
  uint64_t v10 = *(void *)((((unint64_t)&(*a1)[2 * (((unint64_t)*((unsigned int *)*a1 + 11) >> 23) & 1) + 8]
                    + (((unint64_t)*((unsigned int *)*a1 + 11) >> 21) & 0x7F8)
                    + 7) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)*a1 + 10)
                  + 8);
  if (v10) {
    uint64_t v11 = v10 - 8;
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t v13 = v11 + 48;
  uint64_t v12 = *(void *)(v11 + 48);
  if (((unint64_t)(*(void *)(v13 + 8) - v12) >> 3) != v8)
  {
    v85[0] = (const void **)"entry block must have ";
    __int16 v86 = 259;
    mlir::OpState::emitOpError(a1, v85, (uint64_t)&Value);
    if (Value)
    {
      int v87 = 5;
      unint64_t v88 = (const char *)v9;
      uint64_t v18 = &v87;
      unint64_t v19 = (char *)v92;
      if (v93 >= v94)
      {
        unint64_t v68 = v93 + 1;
        if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
        {
          int64_t v78 = (char *)&v87 - (unsigned char *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v68, 24);
          unint64_t v19 = (char *)v92;
          uint64_t v18 = (int *)((char *)v92 + v78);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v68, 24);
          uint64_t v18 = &v87;
          unint64_t v19 = (char *)v92;
        }
      }
      uint64_t v20 = &v19[24 * v93];
      long long v21 = *(_OWORD *)v18;
      *((void *)v20 + 2) = *((void *)v18 + 2);
      *(_OWORD *)uint64_t v20 = v21;
      uint64_t v22 = ++v93;
      if (Value)
      {
        int v87 = 3;
        unint64_t v88 = " arguments to match function signature";
        uint64_t v89 = 38;
        unint64_t v23 = &v87;
        uint64_t v24 = (char *)v92;
        if (v22 >= v94)
        {
          unint64_t v69 = v22 + 1;
          BOOL v70 = (char *)v92 + 24 * v22 > (char *)&v87;
          if (v92 <= &v87 && v70)
          {
            int64_t v79 = (char *)&v87 - (unsigned char *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v69, 24);
            uint64_t v24 = (char *)v92;
            unint64_t v23 = (int *)((char *)v92 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v69, 24);
            unint64_t v23 = &v87;
            uint64_t v24 = (char *)v92;
          }
        }
        unint64_t v25 = &v24[24 * v93];
        long long v26 = *(_OWORD *)v23;
        *((void *)v25 + 2) = *((void *)v23 + 2);
        *(_OWORD *)unint64_t v25 = v26;
        ++v93;
      }
    }
    uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
    if (Value) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
    }
    if (!v100) {
      return v17;
    }
    int v27 = (void **)__p;
    if (__p)
    {
      int v28 = v99;
      unint64_t v29 = __p;
      if (v99 != __p)
      {
        do
          int v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        unint64_t v29 = __p;
      }
      int v99 = v27;
      operator delete(v29);
    }
    unint64_t v30 = v96;
    if (v96)
    {
      int64_t v31 = v97;
      unint64_t v32 = v96;
      if (v97 != v96)
      {
        do
        {
          unint64_t v34 = (void *)*--v31;
          uint64_t v33 = v34;
          void *v31 = 0;
          if (v34) {
            operator delete[](v33);
          }
        }
        while (v31 != v30);
        unint64_t v32 = v96;
      }
      unint64_t v97 = v30;
      operator delete(v32);
    }
    unint64_t v66 = v92;
    if (v92 == v95) {
      return v17;
    }
LABEL_66:
    free(v66);
    return v17;
  }
  if (!v8) {
    return 1;
  }
  uint64_t v14 = Inputs;
  unint64_t v15 = 0;
  while (1)
  {
    unint64_t v16 = *(void *)(*(void *)(v12 + 8 * (void)v15) + 8) & 0xFFFFFFFFFFFFFFF8;
    if (*(void *)(Inputs + 8 * (void)v15) != v16) {
      break;
    }
    if ((const char *)v8 == ++v15) {
      return 1;
    }
  }
  v85[0] = (const void **)"type of entry block argument #";
  __int16 v86 = 259;
  mlir::OpState::emitOpError(a1, v85, (uint64_t)&Value);
  if (Value)
  {
    int v87 = 5;
    unint64_t v88 = v15;
    uint64_t v35 = &v87;
    int v36 = (char *)v92;
    if (v93 >= v94)
    {
      unint64_t v71 = v93 + 1;
      if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
      {
        int64_t v80 = (char *)&v87 - (unsigned char *)v92;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v71, 24);
        int v36 = (char *)v92;
        uint64_t v35 = (int *)((char *)v92 + v80);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v71, 24);
        uint64_t v35 = &v87;
        int v36 = (char *)v92;
      }
    }
    int v37 = &v36[24 * v93];
    long long v38 = *(_OWORD *)v35;
    *((void *)v37 + 2) = *((void *)v35 + 2);
    *(_OWORD *)int v37 = v38;
    ++v93;
    if (Value)
    {
      mlir::Diagnostic::operator<<((uint64_t)v91, 40);
      if (Value)
      {
        unint64_t v39 = &v87;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v87, v16);
        unsigned int v40 = (char *)v92;
        if (v93 >= v94)
        {
          unint64_t v72 = v93 + 1;
          if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
          {
            int64_t v81 = (char *)&v87 - (unsigned char *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v72, 24);
            unsigned int v40 = (char *)v92;
            unint64_t v39 = (int *)((char *)v92 + v81);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v72, 24);
            unint64_t v39 = &v87;
            unsigned int v40 = (char *)v92;
          }
        }
        unint64_t v41 = &v40[24 * v93];
        long long v42 = *(_OWORD *)v39;
        *((void *)v41 + 2) = *((void *)v39 + 2);
        *(_OWORD *)unint64_t v41 = v42;
        uint64_t v43 = ++v93;
        if (Value)
        {
          int v87 = 3;
          unint64_t v88 = ") must match the type of the corresponding argument in ";
          uint64_t v89 = 55;
          uint64_t v44 = &v87;
          int v45 = (char *)v92;
          if (v43 >= v94)
          {
            unint64_t v73 = v43 + 1;
            BOOL v74 = (char *)v92 + 24 * v43 > (char *)&v87;
            if (v92 <= &v87 && v74)
            {
              int64_t v82 = (char *)&v87 - (unsigned char *)v92;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
              int v45 = (char *)v92;
              uint64_t v44 = (int *)((char *)v92 + v82);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
              uint64_t v44 = &v87;
              int v45 = (char *)v92;
            }
          }
          int v46 = &v45[24 * v93];
          long long v47 = *(_OWORD *)v44;
          *((void *)v46 + 2) = *((void *)v44 + 2);
          *(_OWORD *)int v46 = v47;
          uint64_t v48 = ++v93;
          if (Value)
          {
            int v87 = 3;
            unint64_t v88 = "function signature(";
            uint64_t v89 = 19;
            char v49 = &v87;
            unint64_t v50 = (char *)v92;
            if (v48 >= v94)
            {
              unint64_t v75 = v48 + 1;
              BOOL v76 = (char *)v92 + 24 * v48 > (char *)&v87;
              if (v92 <= &v87 && v76)
              {
                int64_t v83 = (char *)&v87 - (unsigned char *)v92;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
                unint64_t v50 = (char *)v92;
                char v49 = (int *)((char *)v92 + v83);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
                char v49 = &v87;
                unint64_t v50 = (char *)v92;
              }
            }
            uint64_t v51 = &v50[24 * v93];
            long long v52 = *(_OWORD *)v49;
            *((void *)v51 + 2) = *((void *)v49 + 2);
            *(_OWORD *)uint64_t v51 = v52;
            ++v93;
            if (Value)
            {
              uint64_t v53 = *(void *)(v14 + 8 * (void)v15);
              int v54 = &v87;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v87, v53);
              int v55 = (char *)v92;
              if (v93 >= v94)
              {
                unint64_t v77 = v93 + 1;
                if (v92 <= &v87 && (char *)v92 + 24 * v93 > (char *)&v87)
                {
                  int64_t v84 = (char *)&v87 - (unsigned char *)v92;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
                  int v55 = (char *)v92;
                  int v54 = (int *)((char *)v92 + v84);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
                  int v54 = &v87;
                  int v55 = (char *)v92;
                }
              }
              unint64_t v56 = &v55[24 * v93];
              long long v57 = *(_OWORD *)v54;
              *((void *)v56 + 2) = *((void *)v54 + 2);
              *(_OWORD *)unint64_t v56 = v57;
              ++v93;
              if (Value) {
                mlir::Diagnostic::operator<<((uint64_t)v91, 41);
              }
            }
          }
        }
      }
    }
  }
  uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  if (v100)
  {
    int64_t v58 = (void **)__p;
    if (__p)
    {
      unint64_t v59 = v99;
      uint64_t v60 = __p;
      if (v99 != __p)
      {
        do
          unint64_t v59 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v59 - 1);
        while (v59 != v58);
        uint64_t v60 = __p;
      }
      int v99 = v58;
      operator delete(v60);
    }
    unint64_t v61 = v96;
    if (v96)
    {
      uint64_t v62 = v97;
      int v63 = v96;
      if (v97 != v96)
      {
        do
        {
          unint64_t v65 = (void *)*--v62;
          int v64 = v65;
          *uint64_t v62 = 0;
          if (v65) {
            operator delete[](v64);
          }
        }
        while (v62 != v61);
        int v63 = v96;
      }
      unint64_t v97 = v61;
      operator delete(v63);
    }
    unint64_t v66 = v92;
    if (v92 != v95) {
      goto LABEL_66;
    }
  }
  return v17;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>>(uint64_t a1)
{
  unint64_t v2 = malloc(0x20uLL);
  *unint64_t v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getDefaultDialect;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    unint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      unint64_t v14 = 72;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      size_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      unint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3760), v2);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::func::FuncOp>::getDefaultDialect()
{
  return "func";
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>(uint64_t a1)
{
  unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v234 = a1;
    unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v40 = v39;
    a1 = v234;
    if (v40)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneRegion<Empty>]";
      unint64_t v248 = 81;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v248;
      }
      uint64_t v43 = &v247[v42];
      unint64_t v44 = v248 - v42;
      if (v248 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v248 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneRegion<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneRegion>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v234;
    }
  }
  uint64_t v2 = v1[26];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v222 = v2;
    uint64_t v235 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v49 = v48;
    uint64_t v2 = v222;
    a1 = v235;
    if (v49)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      unint64_t v248 = 83;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v248;
      }
      long long v52 = &v247[v51];
      unint64_t v53 = v248 - v51;
      if (v248 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v248 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v222;
      a1 = v235;
    }
  }
  uint64_t v4 = v3[5];
  unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v223 = v2;
    uint64_t v236 = a1;
    uint64_t v211 = v4;
    unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v4 = v211;
    uint64_t v2 = v223;
    int v58 = v57;
    a1 = v236;
    if (v58)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v248 = 86;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v248;
      }
      unint64_t v61 = &v247[v60];
      unint64_t v62 = v248 - v60;
      if (v248 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v248 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      unint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v4 = v211;
      uint64_t v2 = v223;
      a1 = v236;
    }
  }
  uint64_t v6 = v5[12];
  size_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v224 = v2;
    uint64_t v237 = a1;
    uint64_t v201 = v6;
    uint64_t v212 = v4;
    size_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v201;
    uint64_t v4 = v212;
    int v67 = v66;
    uint64_t v2 = v224;
    a1 = v237;
    if (v67)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      unint64_t v248 = 84;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v248;
      }
      BOOL v70 = &v247[v69];
      unint64_t v71 = v248 - v69;
      if (v248 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v248 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      size_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v201;
      uint64_t v4 = v212;
      uint64_t v2 = v224;
      a1 = v237;
    }
  }
  uint64_t v8 = v7[10];
  uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v225 = v2;
    uint64_t v238 = a1;
    uint64_t v202 = v6;
    uint64_t v213 = v4;
    uint64_t v192 = v8;
    uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v192;
    uint64_t v6 = v202;
    uint64_t v4 = v213;
    int v76 = v75;
    uint64_t v2 = v225;
    a1 = v238;
    if (v76)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v248 = 84;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v248;
      }
      int64_t v79 = &v247[v78];
      unint64_t v80 = v248 - v78;
      if (v248 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v248 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v192;
      uint64_t v6 = v202;
      uint64_t v4 = v213;
      uint64_t v2 = v225;
      a1 = v238;
    }
  }
  uint64_t v10 = v9[9];
  unint64_t v11 = 0x1E8EB8000uLL;
  {
    uint64_t v226 = v2;
    uint64_t v239 = a1;
    uint64_t v203 = v6;
    uint64_t v214 = v4;
    uint64_t v184 = v10;
    uint64_t v193 = v8;
    unint64_t v11 = 0x1E8EB8000;
    uint64_t v10 = v184;
    uint64_t v8 = v193;
    uint64_t v6 = v203;
    uint64_t v4 = v214;
    int v85 = v84;
    uint64_t v2 = v226;
    a1 = v239;
    if (v85)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      unint64_t v248 = 89;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v248;
      }
      unint64_t v88 = &v247[v87];
      unint64_t v89 = v248 - v87;
      if (v248 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v248 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      unint64_t v11 = 0x1E8EB8000;
      uint64_t v10 = v184;
      uint64_t v8 = v193;
      uint64_t v6 = v203;
      uint64_t v4 = v214;
      uint64_t v2 = v226;
      a1 = v239;
    }
  }
  uint64_t v12 = *(void *)(v11 + 2744);
  uint64_t v13 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v227 = v2;
    uint64_t v240 = a1;
    uint64_t v204 = v6;
    uint64_t v215 = v4;
    uint64_t v185 = v10;
    uint64_t v194 = v8;
    uint64_t v177 = v12;
    uint64_t v13 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v12 = v177;
    uint64_t v10 = v185;
    uint64_t v8 = v194;
    uint64_t v6 = v204;
    uint64_t v4 = v215;
    int v94 = v93;
    uint64_t v2 = v227;
    a1 = v240;
    if (v94)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AffineScope<Empty>]";
      unint64_t v248 = 83;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v248;
      }
      unint64_t v97 = &v247[v96];
      unint64_t v98 = v248 - v96;
      if (v248 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v248 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      uint64_t v13 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v12 = v177;
      uint64_t v10 = v185;
      uint64_t v8 = v194;
      uint64_t v6 = v204;
      uint64_t v4 = v215;
      uint64_t v2 = v227;
      a1 = v240;
    }
  }
  uint64_t v14 = *v13;
  unint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v228 = v2;
    uint64_t v241 = a1;
    uint64_t v205 = v6;
    uint64_t v216 = v4;
    uint64_t v186 = v10;
    uint64_t v195 = v8;
    uint64_t v171 = v14;
    uint64_t v178 = v12;
    unint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v14 = v171;
    uint64_t v12 = v178;
    uint64_t v10 = v186;
    uint64_t v8 = v195;
    uint64_t v6 = v205;
    uint64_t v4 = v216;
    int v103 = v102;
    uint64_t v2 = v228;
    a1 = v241;
    if (v103)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AutomaticAllocationScope<Empty>]";
      unint64_t v248 = 96;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v248;
      }
      unint64_t v106 = &v247[v105];
      unint64_t v107 = v248 - v105;
      if (v248 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v248 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AutomaticAllocationScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AutomaticAllocationScope>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      unint64_t v15 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v14 = v171;
      uint64_t v12 = v178;
      uint64_t v10 = v186;
      uint64_t v8 = v195;
      uint64_t v6 = v205;
      uint64_t v4 = v216;
      uint64_t v2 = v228;
      a1 = v241;
    }
  }
  uint64_t v16 = v15[19];
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v229 = v2;
    uint64_t v242 = a1;
    uint64_t v206 = v6;
    uint64_t v217 = v4;
    uint64_t v187 = v10;
    uint64_t v196 = v8;
    uint64_t v172 = v14;
    uint64_t v179 = v12;
    uint64_t v166 = v16;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v166;
    uint64_t v14 = v172;
    uint64_t v12 = v179;
    uint64_t v10 = v187;
    uint64_t v8 = v196;
    uint64_t v6 = v206;
    uint64_t v4 = v217;
    int v112 = v111;
    uint64_t v2 = v229;
    a1 = v242;
    if (v112)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolOpInterface::Trait<Empty>]";
      unint64_t v248 = 87;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v248;
      }
      unint64_t v115 = &v247[v114];
      unint64_t v116 = v248 - v114;
      if (v248 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v248 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::SymbolOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::SymbolOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v166;
      uint64_t v14 = v172;
      uint64_t v12 = v179;
      uint64_t v10 = v187;
      uint64_t v8 = v196;
      uint64_t v6 = v206;
      uint64_t v4 = v217;
      uint64_t v2 = v229;
      a1 = v242;
    }
  }
  uint64_t v18 = *(void *)(v17 + 3776);
  unint64_t v19 = 0x1E8EB8000uLL;
  {
    uint64_t v230 = v2;
    uint64_t v243 = a1;
    uint64_t v207 = v6;
    uint64_t v218 = v4;
    uint64_t v188 = v10;
    uint64_t v197 = v8;
    uint64_t v173 = v14;
    uint64_t v180 = v12;
    uint64_t v162 = v18;
    uint64_t v167 = v16;
    unint64_t v19 = 0x1E8EB8000;
    uint64_t v18 = v162;
    uint64_t v16 = v167;
    uint64_t v14 = v173;
    uint64_t v12 = v180;
    uint64_t v10 = v188;
    uint64_t v8 = v197;
    uint64_t v6 = v207;
    uint64_t v4 = v218;
    int v121 = v120;
    uint64_t v2 = v230;
    a1 = v243;
    if (v121)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallableOpInterface::Trait<Empty>]";
      unint64_t v248 = 89;
      unint64_t v122 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v122) {
        unint64_t v123 = v122;
      }
      else {
        unint64_t v123 = v248;
      }
      unint64_t v124 = &v247[v123];
      unint64_t v125 = v248 - v123;
      if (v248 - v123 >= 0x12) {
        uint64_t v126 = 18;
      }
      else {
        uint64_t v126 = v248 - v123;
      }
      unint64_t v127 = v125 - v126;
      if (v127 >= v127 - 1) {
        uint64_t v128 = v127 - 1;
      }
      else {
        uint64_t v128 = v127;
      }
      mlir::detail::TypeIDResolver<mlir::CallableOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CallableOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      unint64_t v19 = 0x1E8EB8000;
      uint64_t v18 = v162;
      uint64_t v16 = v167;
      uint64_t v14 = v173;
      uint64_t v12 = v180;
      uint64_t v10 = v188;
      uint64_t v8 = v197;
      uint64_t v6 = v207;
      uint64_t v4 = v218;
      uint64_t v2 = v230;
      a1 = v243;
    }
  }
  uint64_t v20 = *(void *)(v19 + 3792);
  unint64_t v21 = 0x1E8EB8000uLL;
  {
    uint64_t v231 = v2;
    uint64_t v244 = a1;
    uint64_t v208 = v6;
    uint64_t v219 = v4;
    uint64_t v189 = v10;
    uint64_t v198 = v8;
    uint64_t v174 = v14;
    uint64_t v181 = v12;
    uint64_t v163 = v18;
    uint64_t v168 = v16;
    uint64_t v159 = v20;
    unint64_t v21 = 0x1E8EB8000;
    uint64_t v20 = v159;
    uint64_t v18 = v163;
    uint64_t v16 = v168;
    uint64_t v14 = v174;
    uint64_t v12 = v181;
    uint64_t v10 = v189;
    uint64_t v8 = v198;
    uint64_t v6 = v208;
    uint64_t v4 = v219;
    int v130 = v129;
    uint64_t v2 = v231;
    a1 = v244;
    if (v130)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::FunctionOpInterface::Trait<Empty>]";
      unint64_t v248 = 89;
      unint64_t v131 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v131) {
        unint64_t v132 = v131;
      }
      else {
        unint64_t v132 = v248;
      }
      unint64_t v133 = &v247[v132];
      unint64_t v134 = v248 - v132;
      if (v248 - v132 >= 0x12) {
        uint64_t v135 = 18;
      }
      else {
        uint64_t v135 = v248 - v132;
      }
      unint64_t v136 = v134 - v135;
      if (v136 >= v136 - 1) {
        uint64_t v137 = v136 - 1;
      }
      else {
        uint64_t v137 = v136;
      }
      mlir::detail::TypeIDResolver<mlir::FunctionOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::FunctionOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      unint64_t v21 = 0x1E8EB8000;
      uint64_t v20 = v159;
      uint64_t v18 = v163;
      uint64_t v16 = v168;
      uint64_t v14 = v174;
      uint64_t v12 = v181;
      uint64_t v10 = v189;
      uint64_t v8 = v198;
      uint64_t v6 = v208;
      uint64_t v4 = v219;
      uint64_t v2 = v231;
      a1 = v244;
    }
  }
  uint64_t v22 = *(void *)(v21 + 3808);
  unint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v232 = v2;
    uint64_t v245 = a1;
    uint64_t v209 = v6;
    uint64_t v220 = v4;
    uint64_t v190 = v10;
    uint64_t v199 = v8;
    uint64_t v175 = v14;
    uint64_t v182 = v12;
    uint64_t v164 = v18;
    uint64_t v169 = v16;
    uint64_t v157 = v22;
    uint64_t v160 = v20;
    unint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v22 = v157;
    uint64_t v20 = v160;
    uint64_t v18 = v164;
    uint64_t v16 = v169;
    uint64_t v14 = v175;
    uint64_t v12 = v182;
    uint64_t v10 = v190;
    uint64_t v8 = v199;
    uint64_t v6 = v209;
    uint64_t v4 = v220;
    int v139 = v138;
    uint64_t v2 = v232;
    a1 = v245;
    if (v139)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsIsolatedFromAbove<Empty>]";
      unint64_t v248 = 91;
      unint64_t v140 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v140) {
        unint64_t v141 = v140;
      }
      else {
        unint64_t v141 = v248;
      }
      unint64_t v142 = &v247[v141];
      unint64_t v143 = v248 - v141;
      if (v248 - v141 >= 0x12) {
        uint64_t v144 = 18;
      }
      else {
        uint64_t v144 = v248 - v141;
      }
      unint64_t v145 = v143 - v144;
      if (v145 >= v145 - 1) {
        uint64_t v146 = v145 - 1;
      }
      else {
        uint64_t v146 = v145;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsIsolatedFromAbove<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsIsolatedFromAbove>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      unint64_t v23 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v22 = v157;
      uint64_t v20 = v160;
      uint64_t v18 = v164;
      uint64_t v16 = v169;
      uint64_t v14 = v175;
      uint64_t v12 = v182;
      uint64_t v10 = v190;
      uint64_t v8 = v199;
      uint64_t v6 = v209;
      uint64_t v4 = v220;
      uint64_t v2 = v232;
      a1 = v245;
    }
  }
  uint64_t v24 = v23[17];
  unint64_t v25 = 0x1E8EB8000uLL;
  {
    uint64_t v233 = v2;
    uint64_t v246 = a1;
    uint64_t v210 = v6;
    uint64_t v221 = v4;
    uint64_t v191 = v10;
    uint64_t v200 = v8;
    uint64_t v176 = v14;
    uint64_t v183 = v12;
    uint64_t v165 = v18;
    uint64_t v170 = v16;
    uint64_t v158 = v22;
    uint64_t v161 = v20;
    uint64_t v156 = v24;
    unint64_t v25 = 0x1E8EB8000;
    uint64_t v24 = v156;
    uint64_t v22 = v158;
    uint64_t v20 = v161;
    uint64_t v18 = v165;
    uint64_t v16 = v170;
    uint64_t v14 = v176;
    uint64_t v12 = v183;
    uint64_t v10 = v191;
    uint64_t v8 = v200;
    uint64_t v6 = v210;
    uint64_t v4 = v221;
    int v148 = v147;
    uint64_t v2 = v233;
    a1 = v246;
    if (v148)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      unint64_t v248 = 86;
      unint64_t v149 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v149) {
        unint64_t v150 = v149;
      }
      else {
        unint64_t v150 = v248;
      }
      uint64_t v151 = &v247[v150];
      unint64_t v152 = v248 - v150;
      if (v248 - v150 >= 0x12) {
        uint64_t v153 = 18;
      }
      else {
        uint64_t v153 = v248 - v150;
      }
      unint64_t v154 = v152 - v153;
      if (v154 >= v154 - 1) {
        uint64_t v155 = v154 - 1;
      }
      else {
        uint64_t v155 = v154;
      }
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      unint64_t v25 = 0x1E8EB8000;
      uint64_t v24 = v156;
      uint64_t v22 = v158;
      uint64_t v20 = v161;
      uint64_t v18 = v165;
      uint64_t v16 = v170;
      uint64_t v14 = v176;
      uint64_t v12 = v183;
      uint64_t v10 = v191;
      uint64_t v8 = v200;
      uint64_t v6 = v210;
      uint64_t v4 = v221;
      uint64_t v2 = v233;
      a1 = v246;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v24 == a1
      || *(void *)(v25 + 3752) == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::func::FuncOp::print((mlir::func::FuncOp *)&v7, a3);
}

BOOL mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::func::FuncOp>,mlir::OpTrait::ZeroResults<mlir::func::FuncOp>,mlir::OpTrait::ZeroSuccessors<mlir::func::FuncOp>,mlir::OpTrait::ZeroOperands<mlir::func::FuncOp>,mlir::OpTrait::OpInvariants<mlir::func::FuncOp>,mlir::BytecodeOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::AffineScope<mlir::func::FuncOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::func::FuncOp>,mlir::SymbolOpInterface::Trait<mlir::func::FuncOp>,mlir::CallableOpInterface::Trait<mlir::func::FuncOp>,mlir::FunctionOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::func::FuncOp>,mlir::OpAsmOpInterface::Trait<mlir::func::FuncOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::OneRegion<mlir::func::FuncOp>,mlir::OpTrait::ZeroResults<mlir::func::FuncOp>,mlir::OpTrait::ZeroSuccessors<mlir::func::FuncOp>,mlir::OpTrait::ZeroOperands<mlir::func::FuncOp>,mlir::OpTrait::OpInvariants<mlir::func::FuncOp>,mlir::BytecodeOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::AffineScope<mlir::func::FuncOp>,mlir::OpTrait::AutomaticAllocationScope<mlir::func::FuncOp>,mlir::SymbolOpInterface::Trait<mlir::func::FuncOp>,mlir::CallableOpInterface::Trait<mlir::func::FuncOp>,mlir::FunctionOpInterface::Trait<mlir::func::FuncOp>,mlir::OpTrait::IsIsolatedFromAbove<mlir::func::FuncOp>,mlir::OpAsmOpInterface::Trait<mlir::func::FuncOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (mlir::OpTrait::impl::verifyOneRegion(a1, a2)
    && mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyZeroOperands(a1, v5)
    && (uint64_t v8 = a1, mlir::func::FuncOp::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::detail::SymbolOpInterfaceTrait<mlir::func::FuncOp>::verifyTrait((uint64_t)a1, v6))
  {
    return mlir::function_interface_impl::verifyTrait<mlir::func::FuncOp>((uint64_t)a1) != 0;
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::detail::SymbolOpInterfaceTrait<mlir::func::FuncOp>::verifyTrait(uint64_t a1, mlir::Operation *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = (uint64_t *)a1;
  if (!mlir::detail::verifySymbol((mlir::detail *)a1, a2)) {
    return 0;
  }
  unint64_t v4 = *(unsigned int *)(a1 + 44);
  if ((v4 & 0x7FFFFF) != 0)
  {
    unint64_t v5 = (void *)(((a1 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *(unsigned int *)(a1 + 40));
    if ((void *)*v5 == v5) {
      goto LABEL_7;
    }
    return 1;
  }
  if (MEMORY[0]) {
    return 1;
  }
LABEL_7:
  if (mlir::SymbolTable::getSymbolVisibility((mlir::SymbolTable *)a1, v3)) {
    return 1;
  }
  uint64_t v16 = (const void **)"symbol declaration cannot have public visibility";
  __int16 v17 = 259;
  mlir::OpState::emitOpError(&v18, &v16, (uint64_t)v19);
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v19);
  if (v19[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v19);
  }
  if (v26)
  {
    uint64_t v8 = (void **)__p;
    if (__p)
    {
      uint64_t v9 = v25;
      uint64_t v10 = __p;
      if (v25 != __p)
      {
        do
          uint64_t v9 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v9 - 1);
        while (v9 != v8);
        uint64_t v10 = __p;
      }
      unint64_t v25 = v8;
      operator delete(v10);
    }
    unint64_t v11 = v22;
    if (v22)
    {
      uint64_t v12 = v23;
      uint64_t v13 = v22;
      if (v23 != v22)
      {
        do
        {
          unint64_t v15 = (void *)*--v12;
          uint64_t v14 = v15;
          void *v12 = 0;
          if (v15) {
            operator delete[](v14);
          }
        }
        while (v12 != v11);
        uint64_t v13 = v22;
      }
      unint64_t v23 = v11;
      operator delete(v13);
    }
    if (v20 != &v21) {
      free(v20);
    }
  }
  return v6;
}

uint64_t mlir::function_interface_impl::verifyTrait<mlir::func::FuncOp>(uint64_t a1)
{
  uint64_t v198 = *MEMORY[0x1E4F143B8];
  uint64_t v185 = (uint64_t *)a1;
  unint64_t v1 = *(unsigned int *)(a1 + 44);
  uint64_t v2 = a1 + 16 * ((v1 >> 23) & 1);
  uint64_t v4 = *(void *)(v2 + 64);
  uint64_t v3 = v2 + 64;
  uint64_t v184 = v4;
  if (v4)
  {
    if (BYTE3(v1)) {
      uint64_t v5 = v3;
    }
    else {
      uint64_t v5 = 0;
    }
    v188[0] = *(void *)(v5 + 8);
    v188[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v188);
    mlir::FunctionType::getInputs((mlir::FunctionType *)v188);
    unsigned int v7 = v6;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
    uint64_t v8 = v7;
    if (v9 != v7)
    {
      __int16 v183 = 257;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      if (v188[0])
      {
        LODWORD(v186) = 3;
        *((void *)&v186 + 1) = "expects argument attribute array to have the same number of elements as the number of f"
                                 "unction arguments, got ";
        uint64_t v187 = 110;
        int v36 = (char *)&v186;
        int v37 = (char *)v189;
        if (v190 >= v191)
        {
          unint64_t v147 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            int64_t v167 = (char *)&v186 - (unsigned char *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v147, 24);
            int v37 = (char *)v189;
            int v36 = (char *)v189 + v167;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v147, 24);
            int v36 = (char *)&v186;
            int v37 = (char *)v189;
          }
        }
        long long v38 = &v37[24 * v190];
        long long v39 = *(_OWORD *)v36;
        *((void *)v38 + 2) = *((void *)v36 + 2);
        *(_OWORD *)long long v38 = v39;
        ++v190;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
      if (v188[0])
      {
        LODWORD(v186) = 5;
        *((void *)&v186 + 1) = v40;
        unint64_t v41 = (char *)&v186;
        unint64_t v42 = (char *)v189;
        if (v190 >= v191)
        {
          unint64_t v148 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            int64_t v168 = (char *)&v186 - (unsigned char *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v148, 24);
            unint64_t v42 = (char *)v189;
            unint64_t v41 = (char *)v189 + v168;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v148, 24);
            unint64_t v41 = (char *)&v186;
            unint64_t v42 = (char *)v189;
          }
        }
        uint64_t v43 = &v42[24 * v190];
        long long v44 = *(_OWORD *)v41;
        *((void *)v43 + 2) = *((void *)v41 + 2);
        *(_OWORD *)uint64_t v43 = v44;
        uint64_t v45 = ++v190;
        if (v188[0])
        {
          LODWORD(v186) = 3;
          *((void *)&v186 + 1) = ", but expected ";
          uint64_t v187 = 15;
          unint64_t v46 = (char *)&v186;
          uint64_t v47 = (char *)v189;
          if (v45 >= v191)
          {
            unint64_t v149 = v45 + 1;
            BOOL v150 = (char *)v189 + 24 * v45 > (char *)&v186;
            if (v189 <= &v186 && v150)
            {
              int64_t v169 = (char *)&v186 - (unsigned char *)v189;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v149, 24);
              uint64_t v47 = (char *)v189;
              unint64_t v46 = (char *)v189 + v169;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v149, 24);
              unint64_t v46 = (char *)&v186;
              uint64_t v47 = (char *)v189;
            }
          }
          int v48 = &v47[24 * v190];
          long long v49 = *(_OWORD *)v46;
          *((void *)v48 + 2) = *((void *)v46 + 2);
          *(_OWORD *)int v48 = v49;
          uint64_t v50 = ++v190;
          if (v188[0])
          {
            LODWORD(v186) = 5;
            *((void *)&v186 + 1) = v8;
            unint64_t v51 = (char *)&v186;
            long long v52 = (char *)v189;
            if (v50 >= v191)
            {
              unint64_t v153 = v50 + 1;
              BOOL v154 = (char *)v189 + 24 * v50 > (char *)&v186;
              if (v189 <= &v186 && v154)
              {
                int64_t v172 = (char *)&v186 - (unsigned char *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v153, 24);
                long long v52 = (char *)v189;
                unint64_t v51 = (char *)v189 + v172;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v153, 24);
                unint64_t v51 = (char *)&v186;
                long long v52 = (char *)v189;
              }
            }
            unint64_t v53 = &v52[24 * v190];
            long long v54 = *(_OWORD *)v51;
            *((void *)v53 + 2) = *((void *)v51 + 2);
            *(_OWORD *)unint64_t v53 = v54;
            ++v190;
          }
        }
      }
      uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      }
      if (v197)
      {
        unint64_t v55 = (void **)__p;
        if (__p)
        {
          uint64_t v56 = v196;
          int v57 = __p;
          if (v196 != __p)
          {
            do
              uint64_t v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            int v57 = __p;
          }
          uint64_t v196 = v55;
          operator delete(v57);
        }
        int v58 = v193;
        if (!v193) {
          goto LABEL_183;
        }
        unint64_t v59 = v194;
        unint64_t v60 = v193;
        if (v194 == v193) {
          goto LABEL_182;
        }
        do
        {
          unint64_t v62 = (void *)*--v59;
          unint64_t v61 = v62;
          void *v59 = 0;
          if (v62) {
            operator delete[](v61);
          }
        }
        while (v59 != v58);
        goto LABEL_181;
      }
      return v35;
    }
    if (v7)
    {
      unsigned int v10 = 0;
      while (1)
      {
        uint64_t v11 = *(void *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184) + 8 * v10);
        if (!v11)
        {
          uint64_t v181 = 0;
LABEL_136:
          __int16 v183 = 257;
          mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
          if (v188[0])
          {
            LODWORD(v186) = 3;
            uint64_t v187 = 71;
            unint64_t v106 = (char *)&v186;
            unint64_t v107 = (char *)v189;
            if (v190 >= v191)
            {
              unint64_t v159 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                int64_t v175 = (char *)&v186 - (unsigned char *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v159, 24);
                unint64_t v107 = (char *)v189;
                unint64_t v106 = (char *)v189 + v175;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v159, 24);
                unint64_t v106 = (char *)&v186;
                unint64_t v107 = (char *)v189;
              }
            }
            uint64_t v108 = &v107[24 * v190];
            long long v109 = *(_OWORD *)v106;
            *((void *)v108 + 2) = *((void *)v106 + 2);
            *(_OWORD *)uint64_t v108 = v109;
            ++v190;
          }
          uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
          if (v188[0])
          {
            int v111 = (char *)&v186;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v186, *(void *)(Value + 8 * v10));
            int v112 = (char *)v189;
            if (v190 >= v191)
            {
              unint64_t v160 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                int64_t v176 = (char *)&v186 - (unsigned char *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v160, 24);
                int v112 = (char *)v189;
                int v111 = (char *)v189 + v176;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v160, 24);
                int v111 = (char *)&v186;
                int v112 = (char *)v189;
              }
            }
            unint64_t v113 = &v112[24 * v190];
            long long v114 = *(_OWORD *)v111;
            *((void *)v113 + 2) = *((void *)v111 + 2);
            *(_OWORD *)unint64_t v113 = v114;
            uint64_t v115 = ++v190;
            if (v188[0])
            {
              LODWORD(v186) = 3;
              uint64_t v187 = 1;
              unint64_t v116 = (char *)&v186;
              uint64_t v117 = (char *)v189;
              if (v115 >= v191)
              {
                unint64_t v161 = v115 + 1;
                BOOL v162 = (char *)v189 + 24 * v115 > (char *)&v186;
                if (v189 <= &v186 && v162)
                {
                  int64_t v177 = (char *)&v186 - (unsigned char *)v189;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v161, 24);
                  uint64_t v117 = (char *)v189;
                  unint64_t v116 = (char *)v189 + v177;
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v161, 24);
                  unint64_t v116 = (char *)&v186;
                  uint64_t v117 = (char *)v189;
                }
              }
              unint64_t v118 = &v117[24 * v190];
              long long v119 = *(_OWORD *)v116;
              *((void *)v118 + 2) = *((void *)v116 + 2);
              *(_OWORD *)unint64_t v118 = v119;
              ++v190;
            }
          }
          uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
          if (v188[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
          }
          if (!v197) {
            return v35;
          }
          int v120 = (void **)__p;
          if (__p)
          {
            int v121 = v196;
            unint64_t v122 = __p;
            if (v196 != __p)
            {
              do
                int v121 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v121 - 1);
              while (v121 != v120);
              unint64_t v122 = __p;
            }
            uint64_t v196 = v120;
            operator delete(v122);
          }
          int v58 = v193;
          if (!v193) {
            goto LABEL_183;
          }
          unint64_t v123 = v194;
          unint64_t v60 = v193;
          if (v194 == v193) {
            goto LABEL_182;
          }
          do
          {
            unint64_t v125 = (void *)*--v123;
            unint64_t v124 = v125;
            *unint64_t v123 = 0;
            if (v125) {
              operator delete[](v124);
            }
          }
          while (v123 != v58);
          goto LABEL_181;
        }
        if (*(_UNKNOWN **)(*(void *)v11 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
          uint64_t v11 = 0;
        }
        uint64_t v181 = v11;
        if (!v11) {
          goto LABEL_136;
        }
        uint64_t v12 = (long long *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v181);
        uint64_t v13 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v181);
        if (v12 != (long long *)v13) {
          break;
        }
LABEL_21:
        if (++v10 == v7) {
          goto LABEL_22;
        }
      }
      uint64_t v14 = (long long *)v13;
      while (1)
      {
        long long v186 = *v12;
        v188[0] = mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v186);
        uint64_t AttrData = (unsigned char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v188);
        if (!v16) {
          break;
        }
        __int16 v17 = AttrData;
        uint64_t v18 = (char *)memchr(AttrData, 46, v16);
        if (!v18 || v18 - v17 == -1) {
          break;
        }
        uint64_t NameDialect = mlir::NamedAttribute::getNameDialect((mlir::NamedAttribute *)&v186);
        if (NameDialect
          && !(*(unsigned __int8 (**)(uint64_t, uint64_t *, void, void, void, void))(*(void *)NameDialect + 80))(NameDialect, v185, 0, v10, v186, *((void *)&v186 + 1)))
        {
          return 0;
        }
        if (++v12 == v14) {
          goto LABEL_21;
        }
      }
      v182[0] = (const void **)"arguments may only have dialect attributes";
      __int16 v183 = 259;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      }
      if (!v197) {
        return v35;
      }
      unint64_t v88 = (void **)__p;
      if (__p)
      {
        unint64_t v89 = v196;
        uint64_t v90 = __p;
        if (v196 != __p)
        {
          do
            unint64_t v89 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v89 - 1);
          while (v89 != v88);
          uint64_t v90 = __p;
        }
        uint64_t v196 = v88;
        operator delete(v90);
      }
      int v58 = v193;
      if (!v193) {
        goto LABEL_183;
      }
      unint64_t v91 = v194;
      unint64_t v60 = v193;
      if (v194 == v193) {
        goto LABEL_182;
      }
      do
      {
        int v93 = (void *)*--v91;
        uint64_t v92 = v93;
        *unint64_t v91 = 0;
        if (v93) {
          operator delete[](v92);
        }
      }
      while (v91 != v58);
      goto LABEL_181;
    }
  }
LABEL_22:
  uint64_t v20 = &v185[2 * (((unint64_t)*((unsigned int *)v185 + 11) >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)v185 + 11))) {
    uint64_t v20 = 0;
  }
  uint64_t v184 = v20[2];
  if (v184)
  {
    v188[0] = v20[1];
    v188[0] = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v188);
    mlir::FunctionType::getResults((mlir::FunctionType *)v188);
    unsigned int v22 = v21;
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
    uint64_t v23 = v22;
    if (v24 != v22)
    {
      __int16 v183 = 257;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      if (v188[0])
      {
        LODWORD(v186) = 3;
        *((void *)&v186 + 1) = "expects result attribute array to have the same number of elements as the number of fun"
                                 "ction results, got ";
        uint64_t v187 = 106;
        uint64_t v63 = (char *)&v186;
        unint64_t v64 = (char *)v189;
        if (v190 >= v191)
        {
          unint64_t v151 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            int64_t v170 = (char *)&v186 - (unsigned char *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v151, 24);
            unint64_t v64 = (char *)v189;
            uint64_t v63 = (char *)v189 + v170;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v151, 24);
            uint64_t v63 = (char *)&v186;
            unint64_t v64 = (char *)v189;
          }
        }
        uint64_t v65 = &v64[24 * v190];
        long long v66 = *(_OWORD *)v63;
        *((void *)v65 + 2) = *((void *)v63 + 2);
        *(_OWORD *)uint64_t v65 = v66;
        ++v190;
      }
      mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
      if (v188[0])
      {
        LODWORD(v186) = 5;
        *((void *)&v186 + 1) = v67;
        unint64_t v68 = (char *)&v186;
        unint64_t v69 = (char *)v189;
        if (v190 >= v191)
        {
          unint64_t v152 = v190 + 1;
          if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
          {
            int64_t v171 = (char *)&v186 - (unsigned char *)v189;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v152, 24);
            unint64_t v69 = (char *)v189;
            unint64_t v68 = (char *)v189 + v171;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v152, 24);
            unint64_t v68 = (char *)&v186;
            unint64_t v69 = (char *)v189;
          }
        }
        BOOL v70 = &v69[24 * v190];
        long long v71 = *(_OWORD *)v68;
        *((void *)v70 + 2) = *((void *)v68 + 2);
        *(_OWORD *)BOOL v70 = v71;
        uint64_t v72 = ++v190;
        if (v188[0])
        {
          LODWORD(v186) = 3;
          *((void *)&v186 + 1) = ", but expected ";
          uint64_t v187 = 15;
          unint64_t v73 = (char *)&v186;
          uint64_t v74 = (char *)v189;
          if (v72 >= v191)
          {
            unint64_t v155 = v72 + 1;
            BOOL v156 = (char *)v189 + 24 * v72 > (char *)&v186;
            if (v189 <= &v186 && v156)
            {
              int64_t v173 = (char *)&v186 - (unsigned char *)v189;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v155, 24);
              uint64_t v74 = (char *)v189;
              unint64_t v73 = (char *)v189 + v173;
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v155, 24);
              unint64_t v73 = (char *)&v186;
              uint64_t v74 = (char *)v189;
            }
          }
          int v75 = &v74[24 * v190];
          long long v76 = *(_OWORD *)v73;
          *((void *)v75 + 2) = *((void *)v73 + 2);
          *(_OWORD *)int v75 = v76;
          uint64_t v77 = ++v190;
          if (v188[0])
          {
            LODWORD(v186) = 5;
            *((void *)&v186 + 1) = v23;
            unint64_t v78 = (char *)&v186;
            int64_t v79 = (char *)v189;
            if (v77 >= v191)
            {
              unint64_t v157 = v77 + 1;
              BOOL v158 = (char *)v189 + 24 * v77 > (char *)&v186;
              if (v189 <= &v186 && v158)
              {
                int64_t v174 = (char *)&v186 - (unsigned char *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v157, 24);
                int64_t v79 = (char *)v189;
                unint64_t v78 = (char *)v189 + v174;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v157, 24);
                unint64_t v78 = (char *)&v186;
                int64_t v79 = (char *)v189;
              }
            }
            unint64_t v80 = &v79[24 * v190];
            long long v81 = *(_OWORD *)v78;
            *((void *)v80 + 2) = *((void *)v78 + 2);
            *(_OWORD *)unint64_t v80 = v81;
            ++v190;
          }
        }
      }
      uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      }
      if (v197)
      {
        unint64_t v82 = (void **)__p;
        if (__p)
        {
          uint64_t v83 = v196;
          int v84 = __p;
          if (v196 != __p)
          {
            do
              uint64_t v83 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v83 - 1);
            while (v83 != v82);
            int v84 = __p;
          }
          uint64_t v196 = v82;
          operator delete(v84);
        }
        int v58 = v193;
        if (!v193) {
          goto LABEL_183;
        }
        int v85 = v194;
        unint64_t v60 = v193;
        if (v194 == v193) {
          goto LABEL_182;
        }
        do
        {
          unint64_t v87 = (void *)*--v85;
          unint64_t v86 = v87;
          *int v85 = 0;
          if (v87) {
            operator delete[](v86);
          }
        }
        while (v85 != v58);
        goto LABEL_181;
      }
      return v35;
    }
    if (v22)
    {
      unsigned int v25 = 0;
      while (1)
      {
        uint64_t v26 = *(void *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184) + 8 * v25);
        if (!v26)
        {
          uint64_t v181 = 0;
LABEL_159:
          __int16 v183 = 257;
          mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
          if (v188[0])
          {
            LODWORD(v186) = 3;
            uint64_t v187 = 69;
            uint64_t v126 = (char *)&v186;
            unint64_t v127 = (char *)v189;
            if (v190 >= v191)
            {
              unint64_t v163 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                int64_t v178 = (char *)&v186 - (unsigned char *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v163, 24);
                unint64_t v127 = (char *)v189;
                uint64_t v126 = (char *)v189 + v178;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v163, 24);
                uint64_t v126 = (char *)&v186;
                unint64_t v127 = (char *)v189;
              }
            }
            uint64_t v128 = &v127[24 * v190];
            long long v129 = *(_OWORD *)v126;
            *((void *)v128 + 2) = *((void *)v126 + 2);
            *(_OWORD *)uint64_t v128 = v129;
            ++v190;
          }
          uint64_t v130 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v184);
          if (v188[0])
          {
            unint64_t v131 = (char *)&v186;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v186, *(void *)(v130 + 8 * v25));
            unint64_t v132 = (char *)v189;
            if (v190 >= v191)
            {
              unint64_t v164 = v190 + 1;
              if (v189 <= &v186 && (char *)v189 + 24 * v190 > (char *)&v186)
              {
                int64_t v179 = (char *)&v186 - (unsigned char *)v189;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v164, 24);
                unint64_t v132 = (char *)v189;
                unint64_t v131 = (char *)v189 + v179;
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v164, 24);
                unint64_t v131 = (char *)&v186;
                unint64_t v132 = (char *)v189;
              }
            }
            unint64_t v133 = &v132[24 * v190];
            long long v134 = *(_OWORD *)v131;
            *((void *)v133 + 2) = *((void *)v131 + 2);
            *(_OWORD *)unint64_t v133 = v134;
            uint64_t v135 = ++v190;
            if (v188[0])
            {
              LODWORD(v186) = 3;
              uint64_t v187 = 1;
              unint64_t v136 = (char *)&v186;
              uint64_t v137 = (char *)v189;
              if (v135 >= v191)
              {
                unint64_t v165 = v135 + 1;
                BOOL v166 = (char *)v189 + 24 * v135 > (char *)&v186;
                if (v189 <= &v186 && v166)
                {
                  int64_t v180 = (char *)&v186 - (unsigned char *)v189;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v165, 24);
                  uint64_t v137 = (char *)v189;
                  unint64_t v136 = (char *)v189 + v180;
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v189, v192, v165, 24);
                  unint64_t v136 = (char *)&v186;
                  uint64_t v137 = (char *)v189;
                }
              }
              int v138 = &v137[24 * v190];
              long long v139 = *(_OWORD *)v136;
              *((void *)v138 + 2) = *((void *)v136 + 2);
              *(_OWORD *)int v138 = v139;
              ++v190;
            }
          }
          uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
          if (v188[0]) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
          }
          if (!v197) {
            return v35;
          }
          unint64_t v140 = (void **)__p;
          if (__p)
          {
            unint64_t v141 = v196;
            unint64_t v142 = __p;
            if (v196 != __p)
            {
              do
                unint64_t v141 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v141 - 1);
              while (v141 != v140);
              unint64_t v142 = __p;
            }
            uint64_t v196 = v140;
            operator delete(v142);
          }
          int v58 = v193;
          if (!v193) {
            goto LABEL_183;
          }
          unint64_t v143 = v194;
          unint64_t v60 = v193;
          if (v194 == v193) {
            goto LABEL_182;
          }
          do
          {
            unint64_t v145 = (void *)*--v143;
            uint64_t v144 = v145;
            *unint64_t v143 = 0;
            if (v145) {
              operator delete[](v144);
            }
          }
          while (v143 != v58);
          goto LABEL_181;
        }
        if (*(_UNKNOWN **)(*(void *)v26 + 136) != &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id) {
          uint64_t v26 = 0;
        }
        uint64_t v181 = v26;
        if (!v26) {
          goto LABEL_159;
        }
        uint64_t v27 = (long long *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v181);
        uint64_t v28 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v181);
        if (v27 != (long long *)v28) {
          break;
        }
LABEL_41:
        if (++v25 == v22) {
          goto LABEL_42;
        }
      }
      unint64_t v29 = (long long *)v28;
      while (1)
      {
        long long v186 = *v27;
        v188[0] = mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v186);
        unint64_t v30 = (unsigned char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v188);
        if (!v31) {
          break;
        }
        unint64_t v32 = v30;
        uint64_t v33 = (char *)memchr(v30, 46, v31);
        if (!v33 || v33 - v32 == -1) {
          break;
        }
        uint64_t v34 = mlir::NamedAttribute::getNameDialect((mlir::NamedAttribute *)&v186);
        if (v34
          && !(*(unsigned __int8 (**)(uint64_t, uint64_t *, void, void, void, void))(*(void *)v34 + 88))(v34, v185, 0, v25, v186, *((void *)&v186 + 1)))
        {
          return 0;
        }
        if (++v27 == v29) {
          goto LABEL_41;
        }
      }
      v182[0] = (const void **)"results may only have dialect attributes";
      __int16 v183 = 259;
      mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
      uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
      if (v188[0]) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
      }
      if (!v197) {
        return v35;
      }
      unint64_t v100 = (void **)__p;
      if (__p)
      {
        uint64_t v101 = v196;
        int v102 = __p;
        if (v196 != __p)
        {
          do
            uint64_t v101 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v101 - 1);
          while (v101 != v100);
          int v102 = __p;
        }
        uint64_t v196 = v100;
        operator delete(v102);
      }
      int v58 = v193;
      if (!v193) {
        goto LABEL_183;
      }
      int v103 = v194;
      unint64_t v60 = v193;
      if (v194 == v193) {
        goto LABEL_182;
      }
      do
      {
        unint64_t v105 = (void *)*--v103;
        unint64_t v104 = v105;
        *int v103 = 0;
        if (v105) {
          operator delete[](v104);
        }
      }
      while (v103 != v58);
      goto LABEL_181;
    }
  }
LABEL_42:
  if ((*((_DWORD *)v185 + 11) & 0x7FFFFF) == 1) {
    return mlir::detail::FunctionOpInterfaceTrait<mlir::func::FuncOp>::verifyBody(&v185);
  }
  v182[0] = (const void **)"expects one region";
  __int16 v183 = 259;
  mlir::OpState::emitOpError(&v185, v182, (uint64_t)v188);
  uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v188);
  if (v188[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v188);
  }
  if (v197)
  {
    int v94 = (void **)__p;
    if (__p)
    {
      unint64_t v95 = v196;
      unint64_t v96 = __p;
      if (v196 != __p)
      {
        do
          unint64_t v95 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v95 - 1);
        while (v95 != v94);
        unint64_t v96 = __p;
      }
      uint64_t v196 = v94;
      operator delete(v96);
    }
    int v58 = v193;
    if (!v193) {
      goto LABEL_183;
    }
    unint64_t v97 = v194;
    unint64_t v60 = v193;
    if (v194 == v193)
    {
LABEL_182:
      uint64_t v194 = v58;
      operator delete(v60);
LABEL_183:
      if (v189 != v192) {
        free(v189);
      }
      return v35;
    }
    do
    {
      uint64_t v99 = (void *)*--v97;
      unint64_t v98 = v99;
      void *v97 = 0;
      if (v99) {
        operator delete[](v98);
      }
    }
    while (v97 != v58);
LABEL_181:
    unint64_t v60 = v193;
    goto LABEL_182;
  }
  return v35;
}

BOOL mlir::Op<mlir::func::FuncOp,mlir::OpTrait::OneRegion,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::OpTrait::AffineScope,mlir::OpTrait::AutomaticAllocationScope,mlir::SymbolOpInterface::Trait,mlir::CallableOpInterface::Trait,mlir::FunctionOpInterface::Trait,mlir::OpTrait::IsIsolatedFromAbove,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::OpTrait::impl::verifyIsIsolatedFromAbove(a1, a2) != 0;
}

void *mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::Model(void *a1, uint64_t a2)
{
  v11[6] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = v11;
  uint64_t v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"func.return", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::func::ReturnOp,void>::id, (uint64_t)&v9);
  uint64_t v4 = v9;
  if (v10)
  {
    uint64_t v5 = 16 * v10;
    unsigned int v6 = (void **)((char *)v9 + 8);
    do
    {
      unsigned int v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    uint64_t v4 = v9;
  }
  if (v4 != v11) {
    free(v4);
  }
  *a1 = &unk_1EC9BE4D0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::~Model(uint64_t a1)
{
  *(void *)a1 = &unk_1EC9AA560;
  uint64_t v2 = *(void ***)(a1 + 32);
  uint64_t v3 = *(unsigned int *)(a1 + 40);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unsigned int v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48)) {
    free(v2);
  }
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::~Model(void *__p)
{
  void *__p = &unk_1EC9AA560;
  uint64_t v2 = (void **)__p[4];
  uint64_t v3 = *((unsigned int *)__p + 10);
  if (v3)
  {
    uint64_t v4 = 16 * v3;
    uint64_t v5 = v2 + 1;
    do
    {
      unsigned int v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    uint64_t v2 = (void **)__p[4];
  }
  if (v2 != __p + 6) {
    free(v2);
  }

  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::foldHook()
{
  uint64_t v0 = (*(uint64_t (__cdecl **)())(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                 + 2) & 0xFFFFFFFFFFFFFFF8))();
  if ((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
     + 2 >= 8)
  {
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 4) != 0)
      (*(void (__cdecl **)())((((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                              + 2) & 0xFFFFFFFFFFFFFFF8)
                            + 16))();
    if (((llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
         + 2) & 2) == 0)
      llvm::deallocate_buffer(v2, v3);
  }
  return v0;
}

BOOL mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unint64_t v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  BOOL v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  char v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0) {
        uint64_t v5 = v7;
      }
      else {
        uint64_t v5 = (llvm **)v7[0];
      }
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0) {
      llvm::deallocate_buffer(v7[0], v7[1]);
    }
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getParseAssemblyFn(BOOL (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::func::ReturnOp::parse;
  a1[3] = (BOOL (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                + 2);
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::printAssembly(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  unint64_t v12 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  (*(void (**)(uint64_t, uint64_t, mlir::OpAsmPrinter *, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                    + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v11, a2, a3, a4, a5);
  char v9 = v12;
  if (v12 >= 8)
  {
    if ((v12 & 4) != 0)
    {
      if ((v12 & 2) != 0) {
        uint64_t v10 = v11;
      }
      else {
        uint64_t v10 = (llvm **)v11[0];
      }
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v12 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v10, v5, v6, v7, v8);
    }
    if ((v9 & 2) == 0) {
      llvm::deallocate_buffer(v11[0], v11[1]);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants;
  unint64_t v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  uint64_t v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  char v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0) {
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    }
    if ((v3 & 2) == 0) {
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
    }
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v9[9] = *MEMORY[0x1E4F143B8];
  mlir::NamedAttrList::NamedAttrList(v8, *(void *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(void *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9) {
    free(v8[0]);
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(void *__return_ptr, uint64_t), uint64_t a6)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  a5(v24, a6);
  if (v24[0])
  {
    int v21 = 3;
    unsigned int v22 = "this operation does not support properties";
    uint64_t v23 = 42;
    unint64_t v6 = &v21;
    uint64_t v7 = (char *)v25;
    if (v26 >= v27)
    {
      unint64_t v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        int64_t v20 = (char *)&v21 - (unsigned char *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        uint64_t v7 = (char *)v25;
        unint64_t v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        unint64_t v6 = &v21;
        uint64_t v7 = (char *)v25;
      }
    }
    uint64_t v8 = &v7[24 * v26];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)uint64_t v8 = v9;
    ++v26;
    if (v24[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
    }
  }
  if (v33)
  {
    uint64_t v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = v32;
      unint64_t v12 = __p;
      if (v32 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        unint64_t v12 = __p;
      }
      unint64_t v32 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v29;
    if (v29)
    {
      uint64_t v14 = v30;
      unint64_t v15 = v29;
      if (v30 != v29)
      {
        do
        {
          __int16 v17 = (void *)*--v14;
          size_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        unint64_t v15 = v29;
      }
      unint64_t v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28) {
      free(v25);
    }
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::func::ReturnOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>::getSpeculatability;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable]";
      unint64_t v14 = 81;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 2784), v2);
}

uint64_t mlir::detail::ConditionallySpeculatableInterfaceTraits::Model<mlir::func::ReturnOp>::getSpeculatability()
{
  return 1;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(8uLL);
  *uint64_t v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getEffects;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      unint64_t v14 = 79;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 3912), v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>>(uint64_t a1)
{
  uint64_t v2 = malloc(0x10uLL);
  *uint64_t v2 = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getMutableSuccessorOperands;
  v2[1] = mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getSuccessorRegions;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    unint64_t v12 = v2;
    unint64_t v3 = 0x1E8EB8000;
    uint64_t v2 = v12;
    if (v4)
    {
      uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
      unint64_t v14 = 89;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      uint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = v12;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, *(void *)(v3 + 4016), v2);
}

double mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getMutableSuccessorOperands@<D0>(mlir::Operation *a1@<X1>, mlir::MutableOperandRange *a2@<X8>)
{
  return mlir::MutableOperandRange::MutableOperandRange(a2, a1);
}

uint64_t mlir::detail::RegionBranchTerminatorOpInterfaceInterfaceTraits::Model<mlir::func::ReturnOp>::getSuccessorRegions(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a2;
  return mlir::detail::RegionBranchTerminatorOpInterfaceTrait<mlir::func::ReturnOp>::getSuccessorRegions(&v6, a3, a4, a5);
}

uint64_t mlir::detail::RegionBranchTerminatorOpInterfaceTrait<mlir::func::ReturnOp>::getSuccessorRegions(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = *a1;
  uint64_t ParentOp = *(mlir::Block **)(*a1 + 16);
  if (!ParentOp)
  {
    uint64_t v7 = 0;
    goto LABEL_13;
  }
  uint64_t ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
  uint64_t v7 = ParentOp;
  if (!ParentOp) {
    goto LABEL_13;
  }
  uint64_t v8 = *((void *)ParentOp + 6);
  uint64_t v9 = *(void **)(v8 + 16);
  BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *((void *)ParentOp + 6);
  }
  if (v10)
  {
    v17[0] = *(void *)(v8 + 8);
    uint64_t ParentOp = (mlir::Block *)mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v17);
    if (!ParentOp) {
      goto LABEL_13;
    }
    uint64_t v13 = v8;
  }
  else
  {
    unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
    uint64_t ParentOp = (mlir::Block *)mlir::detail::InterfaceMap::lookup<mlir::RegionBranchOpInterface>(v12 + 32);
    if (ParentOp) {
      goto LABEL_13;
    }
    uint64_t ParentOp = *(mlir::Block **)(v12 + 24);
    uint64_t v13 = *((void *)v7 + 6);
  }
  uint64_t ParentOp = (mlir::Block *)mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>((uint64_t)ParentOp, v13);
LABEL_13:
  v17[0] = v7;
  v17[1] = ParentOp;
  unint64_t v14 = *(mlir::Block **)(v5 + 16);
  if (v14) {
    unint64_t Parent = mlir::Block::getParent(v14);
  }
  else {
    unint64_t Parent = 0;
  }
  return mlir::BranchOpInterface::getSuccessorForOperands(v17, Parent, a4);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>()
{
  return 0;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>(uint64_t a1)
{
  unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v234 = a1;
    unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v40 = v39;
    a1 = v234;
    if (v40)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      unint64_t v248 = 83;
      unint64_t v41 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v41) {
        unint64_t v42 = v41;
      }
      else {
        unint64_t v42 = v248;
      }
      uint64_t v43 = &v247[v42];
      unint64_t v44 = v248 - v42;
      if (v248 - v42 >= 0x12) {
        uint64_t v45 = 18;
      }
      else {
        uint64_t v45 = v248 - v42;
      }
      unint64_t v46 = v44 - v45;
      if (v46 >= v46 - 1) {
        uint64_t v47 = v46 - 1;
      }
      else {
        uint64_t v47 = v46;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
      unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v234;
    }
  }
  uint64_t v2 = v1[4];
  unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v222 = v2;
    uint64_t v235 = a1;
    unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v49 = v48;
    uint64_t v2 = v222;
    a1 = v235;
    if (v49)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroResults<Empty>]";
      unint64_t v248 = 83;
      unint64_t v50 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v50) {
        unint64_t v51 = v50;
      }
      else {
        unint64_t v51 = v248;
      }
      long long v52 = &v247[v51];
      unint64_t v53 = v248 - v51;
      if (v248 - v51 >= 0x12) {
        uint64_t v54 = 18;
      }
      else {
        uint64_t v54 = v248 - v51;
      }
      unint64_t v55 = v53 - v54;
      if (v55 >= v55 - 1) {
        uint64_t v56 = v55 - 1;
      }
      else {
        uint64_t v56 = v55;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroResults<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroResults>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      unint64_t v3 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v2 = v222;
      a1 = v235;
    }
  }
  uint64_t v4 = v3[5];
  uint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v223 = v2;
    uint64_t v236 = a1;
    uint64_t v211 = v4;
    uint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v4 = v211;
    uint64_t v2 = v223;
    int v58 = v57;
    a1 = v236;
    if (v58)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      unint64_t v248 = 86;
      unint64_t v59 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v59) {
        unint64_t v60 = v59;
      }
      else {
        unint64_t v60 = v248;
      }
      unint64_t v61 = &v247[v60];
      unint64_t v62 = v248 - v60;
      if (v248 - v60 >= 0x12) {
        uint64_t v63 = 18;
      }
      else {
        uint64_t v63 = v248 - v60;
      }
      unint64_t v64 = v62 - v63;
      if (v64 >= v64 - 1) {
        uint64_t v65 = v64 - 1;
      }
      else {
        uint64_t v65 = v64;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      uint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v4 = v211;
      uint64_t v2 = v223;
      a1 = v236;
    }
  }
  uint64_t v6 = v5[12];
  uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v224 = v2;
    uint64_t v237 = a1;
    uint64_t v201 = v6;
    uint64_t v212 = v4;
    uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v6 = v201;
    uint64_t v4 = v212;
    int v67 = v66;
    uint64_t v2 = v224;
    a1 = v237;
    if (v67)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::VariadicOperands<Empty>]";
      unint64_t v248 = 88;
      unint64_t v68 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v68) {
        unint64_t v69 = v68;
      }
      else {
        unint64_t v69 = v248;
      }
      BOOL v70 = &v247[v69];
      unint64_t v71 = v248 - v69;
      if (v248 - v69 >= 0x12) {
        uint64_t v72 = 18;
      }
      else {
        uint64_t v72 = v248 - v69;
      }
      unint64_t v73 = v71 - v72;
      if (v73 >= v73 - 1) {
        uint64_t v74 = v73 - 1;
      }
      else {
        uint64_t v74 = v73;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::VariadicOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::VariadicOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      uint64_t v7 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v6 = v201;
      uint64_t v4 = v212;
      uint64_t v2 = v224;
      a1 = v237;
    }
  }
  uint64_t v8 = v7[14];
  uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v225 = v2;
    uint64_t v238 = a1;
    uint64_t v202 = v6;
    uint64_t v213 = v4;
    uint64_t v192 = v8;
    uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v8 = v192;
    uint64_t v6 = v202;
    uint64_t v4 = v213;
    int v76 = v75;
    uint64_t v2 = v225;
    a1 = v238;
    if (v76)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<Empty>]";
      unint64_t v248 = 107;
      unint64_t v77 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v77) {
        unint64_t v78 = v77;
      }
      else {
        unint64_t v78 = v248;
      }
      int64_t v79 = &v247[v78];
      unint64_t v80 = v248 - v78;
      if (v248 - v78 >= 0x12) {
        uint64_t v81 = 18;
      }
      else {
        uint64_t v81 = v248 - v78;
      }
      unint64_t v82 = v80 - v81;
      if (v82 >= v82 - 1) {
        uint64_t v83 = v82 - 1;
      }
      else {
        uint64_t v83 = v82;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      uint64_t v9 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v8 = v192;
      uint64_t v6 = v202;
      uint64_t v4 = v213;
      uint64_t v2 = v225;
      a1 = v238;
    }
  }
  uint64_t v10 = v9[23];
  uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v226 = v2;
    uint64_t v239 = a1;
    uint64_t v203 = v6;
    uint64_t v214 = v4;
    uint64_t v184 = v10;
    uint64_t v193 = v8;
    uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v10 = v184;
    uint64_t v8 = v193;
    uint64_t v6 = v203;
    uint64_t v4 = v214;
    int v85 = v84;
    uint64_t v2 = v226;
    a1 = v239;
    if (v85)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      unint64_t v248 = 84;
      unint64_t v86 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v86) {
        unint64_t v87 = v86;
      }
      else {
        unint64_t v87 = v248;
      }
      unint64_t v88 = &v247[v87];
      unint64_t v89 = v248 - v87;
      if (v248 - v87 >= 0x12) {
        uint64_t v90 = 18;
      }
      else {
        uint64_t v90 = v248 - v87;
      }
      unint64_t v91 = v89 - v90;
      if (v91 >= v91 - 1) {
        uint64_t v92 = v91 - 1;
      }
      else {
        uint64_t v92 = v91;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      uint64_t v11 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v10 = v184;
      uint64_t v8 = v193;
      uint64_t v6 = v203;
      uint64_t v4 = v214;
      uint64_t v2 = v226;
      a1 = v239;
    }
  }
  uint64_t v12 = v11[9];
  unint64_t v13 = 0x1E8EB8000uLL;
  {
    uint64_t v227 = v2;
    uint64_t v240 = a1;
    uint64_t v204 = v6;
    uint64_t v215 = v4;
    uint64_t v185 = v10;
    uint64_t v194 = v8;
    uint64_t v177 = v12;
    unint64_t v13 = 0x1E8EB8000;
    uint64_t v12 = v177;
    uint64_t v10 = v185;
    uint64_t v8 = v194;
    uint64_t v6 = v204;
    uint64_t v4 = v215;
    int v94 = v93;
    uint64_t v2 = v227;
    a1 = v240;
    if (v94)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ConditionallySpeculatable::Trait<Empty>]";
      unint64_t v248 = 95;
      unint64_t v95 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v95) {
        unint64_t v96 = v95;
      }
      else {
        unint64_t v96 = v248;
      }
      unint64_t v97 = &v247[v96];
      unint64_t v98 = v248 - v96;
      if (v248 - v96 >= 0x12) {
        uint64_t v99 = 18;
      }
      else {
        uint64_t v99 = v248 - v96;
      }
      unint64_t v100 = v98 - v99;
      if (v100 >= v100 - 1) {
        uint64_t v101 = v100 - 1;
      }
      else {
        uint64_t v101 = v100;
      }
      mlir::detail::TypeIDResolver<mlir::ConditionallySpeculatable::Trait<mlir::TypeID mlir::TypeID::get<mlir::ConditionallySpeculatable::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      unint64_t v13 = 0x1E8EB8000;
      uint64_t v12 = v177;
      uint64_t v10 = v185;
      uint64_t v8 = v194;
      uint64_t v6 = v204;
      uint64_t v4 = v215;
      uint64_t v2 = v227;
      a1 = v240;
    }
  }
  uint64_t v14 = *(void *)(v13 + 2776);
  unint64_t v15 = 0x1E8EB8000uLL;
  {
    uint64_t v228 = v2;
    uint64_t v241 = a1;
    uint64_t v205 = v6;
    uint64_t v216 = v4;
    uint64_t v186 = v10;
    uint64_t v195 = v8;
    uint64_t v171 = v14;
    uint64_t v178 = v12;
    unint64_t v15 = 0x1E8EB8000;
    uint64_t v14 = v171;
    uint64_t v12 = v178;
    uint64_t v10 = v186;
    uint64_t v8 = v195;
    uint64_t v6 = v205;
    uint64_t v4 = v216;
    int v103 = v102;
    uint64_t v2 = v228;
    a1 = v241;
    if (v103)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AlwaysSpeculatableImplTrait<Empty>]";
      unint64_t v248 = 99;
      unint64_t v104 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v104) {
        unint64_t v105 = v104;
      }
      else {
        unint64_t v105 = v248;
      }
      unint64_t v106 = &v247[v105];
      unint64_t v107 = v248 - v105;
      if (v248 - v105 >= 0x12) {
        uint64_t v108 = 18;
      }
      else {
        uint64_t v108 = v248 - v105;
      }
      unint64_t v109 = v107 - v108;
      if (v109 >= v109 - 1) {
        uint64_t v110 = v109 - 1;
      }
      else {
        uint64_t v110 = v109;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::AlwaysSpeculatableImplTrait<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AlwaysSpeculatableImplTrait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      unint64_t v15 = 0x1E8EB8000;
      uint64_t v14 = v171;
      uint64_t v12 = v178;
      uint64_t v10 = v186;
      uint64_t v8 = v195;
      uint64_t v6 = v205;
      uint64_t v4 = v216;
      uint64_t v2 = v228;
      a1 = v241;
    }
  }
  uint64_t v16 = *(void *)(v15 + 2912);
  unint64_t v17 = 0x1E8EB8000uLL;
  {
    uint64_t v229 = v2;
    uint64_t v242 = a1;
    uint64_t v206 = v6;
    uint64_t v217 = v4;
    uint64_t v187 = v10;
    uint64_t v196 = v8;
    uint64_t v172 = v14;
    uint64_t v179 = v12;
    uint64_t v166 = v16;
    unint64_t v17 = 0x1E8EB8000;
    uint64_t v16 = v166;
    uint64_t v14 = v172;
    uint64_t v12 = v179;
    uint64_t v10 = v187;
    uint64_t v8 = v196;
    uint64_t v6 = v206;
    uint64_t v4 = v217;
    int v112 = v111;
    uint64_t v2 = v229;
    a1 = v242;
    if (v112)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      unint64_t v248 = 93;
      unint64_t v113 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v113) {
        unint64_t v114 = v113;
      }
      else {
        unint64_t v114 = v248;
      }
      uint64_t v115 = &v247[v114];
      unint64_t v116 = v248 - v114;
      if (v248 - v114 >= 0x12) {
        uint64_t v117 = 18;
      }
      else {
        uint64_t v117 = v248 - v114;
      }
      unint64_t v118 = v116 - v117;
      if (v118 >= v118 - 1) {
        uint64_t v119 = v118 - 1;
      }
      else {
        uint64_t v119 = v118;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      unint64_t v17 = 0x1E8EB8000;
      uint64_t v16 = v166;
      uint64_t v14 = v172;
      uint64_t v12 = v179;
      uint64_t v10 = v187;
      uint64_t v8 = v196;
      uint64_t v6 = v206;
      uint64_t v4 = v217;
      uint64_t v2 = v229;
      a1 = v242;
    }
  }
  uint64_t v18 = *(void *)(v17 + 3904);
  unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v230 = v2;
    uint64_t v243 = a1;
    uint64_t v207 = v6;
    uint64_t v218 = v4;
    uint64_t v188 = v10;
    uint64_t v197 = v8;
    uint64_t v173 = v14;
    uint64_t v180 = v12;
    uint64_t v162 = v18;
    uint64_t v167 = v16;
    unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v18 = v162;
    uint64_t v16 = v167;
    uint64_t v14 = v173;
    uint64_t v12 = v180;
    uint64_t v10 = v188;
    uint64_t v8 = v197;
    uint64_t v6 = v207;
    uint64_t v4 = v218;
    int v121 = v120;
    uint64_t v2 = v230;
    a1 = v243;
    if (v121)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::MemRefsNormalizable<Empty>]";
      unint64_t v248 = 91;
      unint64_t v122 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v122) {
        unint64_t v123 = v122;
      }
      else {
        unint64_t v123 = v248;
      }
      unint64_t v124 = &v247[v123];
      unint64_t v125 = v248 - v123;
      if (v248 - v123 >= 0x12) {
        uint64_t v126 = 18;
      }
      else {
        uint64_t v126 = v248 - v123;
      }
      unint64_t v127 = v125 - v126;
      if (v127 >= v127 - 1) {
        uint64_t v128 = v127 - 1;
      }
      else {
        uint64_t v128 = v127;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::MemRefsNormalizable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::MemRefsNormalizable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      unint64_t v19 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v18 = v162;
      uint64_t v16 = v167;
      uint64_t v14 = v173;
      uint64_t v12 = v180;
      uint64_t v10 = v188;
      uint64_t v8 = v197;
      uint64_t v6 = v207;
      uint64_t v4 = v218;
      uint64_t v2 = v230;
      a1 = v243;
    }
  }
  uint64_t v20 = v19[18];
  unint64_t v21 = 0x1E8EB8000uLL;
  {
    uint64_t v231 = v2;
    uint64_t v244 = a1;
    uint64_t v208 = v6;
    uint64_t v219 = v4;
    uint64_t v189 = v10;
    uint64_t v198 = v8;
    uint64_t v174 = v14;
    uint64_t v181 = v12;
    uint64_t v163 = v18;
    uint64_t v168 = v16;
    uint64_t v159 = v20;
    unint64_t v21 = 0x1E8EB8000;
    uint64_t v20 = v159;
    uint64_t v18 = v163;
    uint64_t v16 = v168;
    uint64_t v14 = v174;
    uint64_t v12 = v181;
    uint64_t v10 = v189;
    uint64_t v8 = v198;
    uint64_t v6 = v208;
    uint64_t v4 = v219;
    int v130 = v129;
    uint64_t v2 = v231;
    a1 = v244;
    if (v130)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface::Trait<Empty>]";
      unint64_t v248 = 103;
      unint64_t v131 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v131) {
        unint64_t v132 = v131;
      }
      else {
        unint64_t v132 = v248;
      }
      unint64_t v133 = &v247[v132];
      unint64_t v134 = v248 - v132;
      if (v248 - v132 >= 0x12) {
        uint64_t v135 = 18;
      }
      else {
        uint64_t v135 = v248 - v132;
      }
      unint64_t v136 = v134 - v135;
      if (v136 >= v136 - 1) {
        uint64_t v137 = v136 - 1;
      }
      else {
        uint64_t v137 = v136;
      }
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::RegionBranchTerminatorOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      unint64_t v21 = 0x1E8EB8000;
      uint64_t v20 = v159;
      uint64_t v18 = v163;
      uint64_t v16 = v168;
      uint64_t v14 = v174;
      uint64_t v12 = v181;
      uint64_t v10 = v189;
      uint64_t v8 = v198;
      uint64_t v6 = v208;
      uint64_t v4 = v219;
      uint64_t v2 = v231;
      a1 = v244;
    }
  }
  uint64_t v22 = *(void *)(v21 + 1936);
  unint64_t v23 = 0x1E8EB8000uLL;
  {
    uint64_t v232 = v2;
    uint64_t v245 = a1;
    uint64_t v209 = v6;
    uint64_t v220 = v4;
    uint64_t v190 = v10;
    uint64_t v199 = v8;
    uint64_t v175 = v14;
    uint64_t v182 = v12;
    uint64_t v164 = v18;
    uint64_t v169 = v16;
    uint64_t v157 = v22;
    uint64_t v160 = v20;
    unint64_t v23 = 0x1E8EB8000;
    uint64_t v22 = v157;
    uint64_t v20 = v160;
    uint64_t v18 = v164;
    uint64_t v16 = v169;
    uint64_t v14 = v175;
    uint64_t v12 = v182;
    uint64_t v10 = v190;
    uint64_t v8 = v199;
    uint64_t v6 = v209;
    uint64_t v4 = v220;
    int v139 = v138;
    uint64_t v2 = v232;
    a1 = v245;
    if (v139)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ReturnLike<Empty>]";
      unint64_t v248 = 82;
      unint64_t v140 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v140) {
        unint64_t v141 = v140;
      }
      else {
        unint64_t v141 = v248;
      }
      unint64_t v142 = &v247[v141];
      unint64_t v143 = v248 - v141;
      if (v248 - v141 >= 0x12) {
        uint64_t v144 = 18;
      }
      else {
        uint64_t v144 = v248 - v141;
      }
      unint64_t v145 = v143 - v144;
      if (v145 >= v145 - 1) {
        uint64_t v146 = v145 - 1;
      }
      else {
        uint64_t v146 = v145;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ReturnLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ReturnLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      unint64_t v23 = 0x1E8EB8000;
      uint64_t v22 = v157;
      uint64_t v20 = v160;
      uint64_t v18 = v164;
      uint64_t v16 = v169;
      uint64_t v14 = v175;
      uint64_t v12 = v182;
      uint64_t v10 = v190;
      uint64_t v8 = v199;
      uint64_t v6 = v209;
      uint64_t v4 = v220;
      uint64_t v2 = v232;
      a1 = v245;
    }
  }
  uint64_t v24 = *(void *)(v23 + 4088);
  unsigned int v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v233 = v2;
    uint64_t v246 = a1;
    uint64_t v210 = v6;
    uint64_t v221 = v4;
    uint64_t v191 = v10;
    uint64_t v200 = v8;
    uint64_t v176 = v14;
    uint64_t v183 = v12;
    uint64_t v165 = v18;
    uint64_t v170 = v16;
    uint64_t v158 = v22;
    uint64_t v161 = v20;
    uint64_t v156 = v24;
    unsigned int v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    uint64_t v24 = v156;
    uint64_t v22 = v158;
    uint64_t v20 = v161;
    uint64_t v18 = v165;
    uint64_t v16 = v170;
    uint64_t v14 = v176;
    uint64_t v12 = v183;
    uint64_t v10 = v191;
    uint64_t v8 = v200;
    uint64_t v6 = v210;
    uint64_t v4 = v221;
    int v148 = v147;
    uint64_t v2 = v233;
    a1 = v246;
    if (v148)
    {
      uint64_t v247 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsTerminator<Empty>]";
      unint64_t v248 = 84;
      unint64_t v149 = llvm::StringRef::find((uint64_t *)&v247, "DesiredTypeName = ", 0x12uLL, 0);
      if (v248 >= v149) {
        unint64_t v150 = v149;
      }
      else {
        unint64_t v150 = v248;
      }
      unint64_t v151 = &v247[v150];
      unint64_t v152 = v248 - v150;
      if (v248 - v150 >= 0x12) {
        uint64_t v153 = 18;
      }
      else {
        uint64_t v153 = v248 - v150;
      }
      unint64_t v154 = v152 - v153;
      if (v154 >= v154 - 1) {
        uint64_t v155 = v154 - 1;
      }
      else {
        uint64_t v155 = v154;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsTerminator<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsTerminator>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      unsigned int v25 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      uint64_t v24 = v156;
      uint64_t v22 = v158;
      uint64_t v20 = v161;
      uint64_t v18 = v165;
      uint64_t v16 = v170;
      uint64_t v14 = v176;
      uint64_t v12 = v183;
      uint64_t v10 = v191;
      uint64_t v8 = v200;
      uint64_t v6 = v210;
      uint64_t v4 = v221;
      uint64_t v2 = v233;
      a1 = v246;
    }
  }
  return v2 == a1
      || v4 == a1
      || v6 == a1
      || v8 == a1
      || v10 == a1
      || v12 == a1
      || v14 == a1
      || v16 == a1
      || v18 == a1
      || v20 == a1
      || v22 == a1
      || v24 == a1
      || v25[7] == a1;
}

void llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, mlir::OpAsmPrinter *a3, uint64_t a4, uint64_t a5)
{
  mlir::OpState::printOpName(a2, (uint64_t)a3, a4, a5);
  uint64_t v7 = a2;
  mlir::func::ReturnOp::print((mlir::func::ReturnOp *)&v7, a3);
}

BOOL mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyZeroResults(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::func::ReturnOp>::verifyTrait((uint64_t *)a1)
    || !mlir::OpTrait::impl::verifyIsTerminator(a1, v5))
  {
    return 0;
  }
  uint64_t v7 = a1;
  return mlir::func::ReturnOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl<mlir::func::ReturnOp>::verifyTrait(uint64_t *a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (mlir::Block *)a1[2];
  if (v2)
  {
    uint64_t ParentOp = mlir::Block::getParentOp(v2);
    if (ParentOp)
    {
      if (*(_UNKNOWN **)(*(void *)(ParentOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::func::FuncOp,void>::id) {
        return 1;
      }
    }
  }
  __int16 v33 = 257;
  mlir::Operation::emitOpError(a1, &v32, (uint64_t)v38);
  if (v38[0])
  {
    LODWORD(v34) = 3;
    uint64_t v35 = "expects parent op ";
    uint64_t v36 = 18;
    uint64_t v4 = &v34;
    uint64_t v5 = (char *)v39;
    if (v40 >= v41)
    {
      unint64_t v26 = v40 + 1;
      if (v39 <= &v34 && (char *)v39 + 24 * v40 > (char *)&v34)
      {
        int64_t v29 = (char *)&v34 - (unsigned char *)v39;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        uint64_t v5 = (char *)v39;
        uint64_t v4 = (const char **)((char *)v39 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v39, v42, v26, 24);
        uint64_t v4 = &v34;
        uint64_t v5 = (char *)v39;
      }
    }
    uint64_t v6 = &v5[24 * v40];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v40;
  }
  size_t v31 = "'";
  uint64_t v8 = (void *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)v38, &v31);
  uint64_t v9 = (uint64_t)v8;
  v37[0] = "func.func";
  v37[1] = 9;
  if (*v8)
  {
    uint64_t v34 = ", ";
    llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>((uint64_t)v37, (uint64_t)v38, (uint64_t)(v8 + 1), (uint64_t)(v8 + 1), &v34);
    if (*(void *)v9)
    {
      uint64_t v10 = v9 + 24;
      unint64_t v11 = *(void *)(v9 + 24);
      LODWORD(v34) = 3;
      uint64_t v35 = "'";
      uint64_t v36 = 1;
      uint64_t v12 = *(unsigned int *)(v9 + 32);
      unint64_t v13 = &v34;
      if (v12 >= *(_DWORD *)(v9 + 36))
      {
        unint64_t v27 = v12 + 1;
        BOOL v28 = v11 + 24 * v12 > (unint64_t)&v34;
        if (v11 <= (unint64_t)&v34 && v28)
        {
          unint64_t v30 = (char *)&v34 - v11;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          unint64_t v11 = *(void *)(v9 + 24);
          unint64_t v13 = (const char **)&v30[v11];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v10, (void *)(v9 + 40), v27, 24);
          unint64_t v11 = *(void *)(v9 + 24);
          unint64_t v13 = &v34;
        }
      }
      uint64_t v14 = v11 + 24 * *(unsigned int *)(v9 + 32);
      long long v15 = *(_OWORD *)v13;
      *(void *)(v14 + 16) = v13[2];
      *(_OWORD *)uint64_t v14 = v15;
      ++*(_DWORD *)(v9 + 32);
    }
  }
  uint64_t v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v9);
  if (v38[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v38);
  }
  if (v47)
  {
    unint64_t v17 = (void **)__p;
    if (__p)
    {
      uint64_t v18 = v46;
      unint64_t v19 = __p;
      if (v46 != __p)
      {
        do
          uint64_t v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        unint64_t v19 = __p;
      }
      unint64_t v46 = v17;
      operator delete(v19);
    }
    uint64_t v20 = v43;
    if (v43)
    {
      unint64_t v21 = v44;
      uint64_t v22 = v43;
      if (v44 != v43)
      {
        do
        {
          uint64_t v24 = (void *)*--v21;
          unint64_t v23 = v24;
          void *v21 = 0;
          if (v24) {
            operator delete[](v23);
          }
        }
        while (v21 != v20);
        uint64_t v22 = v43;
      }
      unint64_t v44 = v20;
      operator delete(v22);
    }
    if (v39 != v42) {
      free(v39);
    }
  }
  return v16;
}

uint64_t llvm::interleave<llvm::StringLiteral const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(llvm::ArrayRef<llvm::StringLiteral> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<llvm::StringLiteral>>(llvm::ArrayRef<llvm::StringLiteral> const&,char const*)::{lambda(void)#1},void>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, const char **a5)
{
  if (result != a2)
  {
    uint64_t v32 = v5;
    uint64_t v33 = v6;
    uint64_t v11 = result;
    __int16 v31 = 262;
    uint64_t v12 = *(const char **)(result + 8);
    BOOL v28 = *(const void ***)result;
    int64_t v29 = v12;
    __n128 result = mlir::Diagnostic::operator<<(a3, &v28);
    uint64_t v13 = v11 + 16;
    if (v11 + 16 != a2)
    {
      uint64_t v14 = (unint64_t *)(a4 + 16);
      unint64_t v27 = (void *)(a4 + 32);
      do
      {
        long long v15 = *a5;
        if (*a5)
        {
          size_t v16 = strlen(*a5);
          LODWORD(v28) = 3;
          int64_t v29 = v15;
          size_t v30 = v16;
          uint64_t v17 = *(unsigned int *)(a4 + 24);
          unint64_t v18 = *(void *)(a4 + 16);
          if (v17 < *(_DWORD *)(a4 + 28)) {
            goto LABEL_8;
          }
        }
        else
        {
          LODWORD(v28) = 3;
          int64_t v29 = 0;
          size_t v30 = 0;
          uint64_t v17 = *(unsigned int *)(a4 + 24);
          unint64_t v18 = *(void *)(a4 + 16);
          if (v17 < *(_DWORD *)(a4 + 28)) {
            goto LABEL_8;
          }
        }
        unint64_t v24 = v17 + 1;
        BOOL v25 = v18 + 24 * v17 > (unint64_t)&v28;
        if (v18 <= (unint64_t)&v28 && v25)
        {
          unint64_t v26 = (char *)&v28 - v18;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4 + 16, v27, v24, 24);
          unint64_t v18 = *v14;
          unint64_t v19 = (const void ***)&v26[*v14];
          goto LABEL_9;
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4 + 16, v27, v24, 24);
        unint64_t v18 = *v14;
LABEL_8:
        unint64_t v19 = &v28;
LABEL_9:
        uint64_t v20 = v18 + 24 * *(unsigned int *)(a4 + 24);
        long long v21 = *(_OWORD *)v19;
        *(void *)(v20 + 16) = v19[2];
        *(_OWORD *)uint64_t v20 = v21;
        ++*(_DWORD *)(a4 + 24);
        __int16 v31 = 262;
        uint64_t v22 = *(const void ***)v13;
        unint64_t v23 = *(const char **)(v13 + 8);
        v13 += 16;
        BOOL v28 = v22;
        int64_t v29 = v23;
        __n128 result = mlir::Diagnostic::operator<<(a3, &v28);
      }
      while (v13 != a2);
    }
  }
  return result;
}

uint64_t mlir::Op<mlir::func::ReturnOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::ZeroResults,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::VariadicOperands,mlir::OpTrait::HasParent<mlir::func::FuncOp>::Impl,mlir::OpTrait::OpInvariants,mlir::ConditionallySpeculatable::Trait,mlir::OpTrait::AlwaysSpeculatableImplTrait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::MemRefsNormalizable,mlir::RegionBranchTerminatorOpInterface::Trait,mlir::OpTrait::ReturnLike,mlir::OpTrait::IsTerminator>::verifyRegionInvariants()
{
  return 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    unint64_t v7 = ((v6 >> 4) ^ (v6 >> 9) | ((unint64_t)((*a2 >> 4) ^ (*a2 >> 9)) << 32))
       + ~((unint64_t)((v6 >> 4) ^ (v6 >> 9)) << 32);
    unint64_t v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
    unint64_t v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
    int v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~(v9 << 27));
    int v11 = v3 - 1;
    unsigned int v12 = (v3 - 1) & v10;
    uint64_t v13 = (void *)(*a1 + 16 * v12);
    uint64_t v14 = *v13;
    uint64_t v15 = v13[1];
    if (*a2 == *v13 && v6 == v15)
    {
      uint64_t result = 1;
      *a3 = v13;
    }
    else
    {
      uint64_t v17 = 0;
      int v18 = 1;
      uint64_t result = 1;
      while (v14 != -4096 || v15 != -4096)
      {
        if (v17) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v15 == -8192;
        }
        if (v20 && v14 == -8192) {
          uint64_t v17 = v13;
        }
        unsigned int v22 = v12 + v18++;
        unsigned int v12 = v22 & v11;
        uint64_t v13 = (void *)(v4 + 16 * (v22 & v11));
        uint64_t v14 = *v13;
        uint64_t v15 = v13[1];
        if (v5 == *v13 && v6 == v15)
        {
          *a3 = v13;
          return result;
        }
      }
      uint64_t result = 0;
      if (v17) {
        uint64_t v13 = v17;
      }
      *a3 = v13;
    }
  }
  else
  {
    uint64_t result = 0;
    *a3 = 0;
  }
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::InsertIntoBucketImpl<std::pair<mlir::TypeID,mlir::TypeID>>(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    ++*(_DWORD *)(a1 + 8);
    if (*a4 != -4096) {
      goto LABEL_8;
    }
    goto LABEL_4;
  }
  llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::grow(a1, v7);
  unint64_t v9 = 0;
  llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>((uint64_t *)a1, a3, &v9);
  a4 = v9;
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    goto LABEL_8;
  }
LABEL_4:
  if (a4[1] == -4096) {
    return a4;
  }
LABEL_8:
  --*(_DWORD *)(a1 + 12);
  return a4;
}

void llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  buffer = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = buffer;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v10 = *(unsigned int *)(a1 + 16);
    if (v10) {
      memset_pattern16(buffer, &unk_1810FE110, 16 * v10);
    }
    int v11 = (void *)(16 * v3);
    if (v3)
    {
      uint64_t v12 = 16 * v3;
      uint64_t v13 = (uint64_t *)v4;
      do
      {
        uint64_t v15 = v13[1];
        if ((*v13 != -4096 || v15 != -4096) && (*v13 != -8192 || v15 != -8192))
        {
          uint64_t v17 = 0;
          llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>,std::pair<mlir::TypeID,mlir::TypeID>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::TypeID,mlir::TypeID>,void>,llvm::detail::DenseSetPair<std::pair<mlir::TypeID,mlir::TypeID>>>::LookupBucketFor<std::pair<mlir::TypeID,mlir::TypeID>>((uint64_t *)a1, v13, &v17);
          uint64_t v14 = v17;
          uint64_t *v17 = *v13;
          v14[1] = v13[1];
          ++*(_DWORD *)(a1 + 8);
        }
        v13 += 2;
        v12 -= 16;
      }
      while (v12);
    }
    llvm::deallocate_buffer(v4, v11);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v16 = *(unsigned int *)(a1 + 16);
  if (v16)
  {
    memset_pattern16(buffer, &unk_1810FE110, 16 * v16);
  }
}

__n128 llvm::interleave<mlir::ValueTypeIterator<llvm::detail::indexed_accessor_range_base<mlir::ResultRange,mlir::detail::OpResultImpl *,mlir::OpResult,mlir::OpResult,mlir::OpResult>::iterator>,mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(mlir::ValueTypeRange<mlir::ResultRange> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<mlir::ValueTypeRange<mlir::ResultRange>>(mlir::ValueTypeRange<mlir::ResultRange> const&,char const*)::{lambda(void)#1},void>(mlir::detail::OpResultImpl *this, uint64_t a2, mlir::detail::OpResultImpl *a3, uint64_t a4, uint64_t a5, uint64_t a6, const char **a7)
{
  if (this != a3 || a2 != a4)
  {
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, a2);
    uint64_t v15 = (__n128 *)&v47;
    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v47, *(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
    unint64_t v16 = *(void *)(a5 + 16);
    unint64_t v46 = (unint64_t *)(a5 + 16);
    uint64_t v17 = *(unsigned int *)(a5 + 24);
    if (v17 >= *(_DWORD *)(a5 + 28))
    {
      unint64_t v38 = v17 + 1;
      BOOL v39 = v16 + 24 * v17 > (unint64_t)&v47;
      if (v16 <= (unint64_t)&v47 && v39)
      {
        unsigned int v40 = (char *)&v47 - v16;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, (void *)(a5 + 32), v38, 24);
        unint64_t v16 = *(void *)(a5 + 16);
        uint64_t v15 = (__n128 *)&v40[v16];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, (void *)(a5 + 32), v38, 24);
        unint64_t v16 = *(void *)(a5 + 16);
        uint64_t v15 = (__n128 *)&v47;
      }
    }
    int v18 = (__n128 *)(v16 + 24 * *(unsigned int *)(a5 + 24));
    __n128 result = *v15;
    v18[1].n128_u64[0] = v15[1].n128_u64[0];
    __n128 *v18 = result;
    ++*(_DWORD *)(a5 + 24);
    if (this != a3 || a2 + 1 != a4)
    {
      unint64_t v44 = (void *)(a6 + 32);
      uint64_t v45 = (unint64_t *)(a6 + 16);
      uint64_t v43 = (void *)(a5 + 32);
      uint64_t v20 = a2 + 2;
      do
      {
        uint64_t v21 = v20;
        unsigned int v22 = *a7;
        if (*a7)
        {
          size_t v23 = strlen(*a7);
          int v47 = 3;
          uint64_t v48 = v22;
          size_t v49 = v23;
          uint64_t v24 = *(unsigned int *)(a6 + 24);
          unint64_t v25 = *(void *)(a6 + 16);
          if (v24 < *(_DWORD *)(a6 + 28)) {
            goto LABEL_12;
          }
        }
        else
        {
          int v47 = 3;
          uint64_t v48 = 0;
          size_t v49 = 0;
          uint64_t v24 = *(unsigned int *)(a6 + 24);
          unint64_t v25 = *(void *)(a6 + 16);
          if (v24 < *(_DWORD *)(a6 + 28)) {
            goto LABEL_12;
          }
        }
        unint64_t v34 = v24 + 1;
        BOOL v35 = v25 + 24 * v24 > (unint64_t)&v47;
        if (v25 <= (unint64_t)&v47 && v35)
        {
          unsigned int v41 = (char *)&v47 - v25;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v45, v44, v34, 24);
          unint64_t v25 = *v45;
          unint64_t v26 = (int *)&v41[*v45];
          goto LABEL_13;
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v45, v44, v34, 24);
        unint64_t v25 = *v45;
LABEL_12:
        unint64_t v26 = &v47;
LABEL_13:
        uint64_t v27 = v25 + 24 * *(unsigned int *)(a6 + 24);
        long long v28 = *(_OWORD *)v26;
        *(void *)(v27 + 16) = *((void *)v26 + 2);
        *(_OWORD *)uint64_t v27 = v28;
        ++*(_DWORD *)(a6 + 24);
        uint64_t v29 = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)this, v21 - 1);
        size_t v30 = (__n128 *)&v47;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v47, *(void *)(v29 + 8) & 0xFFFFFFFFFFFFFFF8);
        uint64_t v31 = *(unsigned int *)(a5 + 24);
        unint64_t v32 = *(void *)(a5 + 16);
        if (v31 >= *(_DWORD *)(a5 + 28))
        {
          unint64_t v36 = v31 + 1;
          BOOL v37 = v32 + 24 * v31 > (unint64_t)&v47;
          if (v32 <= (unint64_t)&v47 && v37)
          {
            unint64_t v42 = (char *)&v47 - v32;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, v43, v36, 24);
            unint64_t v32 = *v46;
            size_t v30 = (__n128 *)&v42[*v46];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v46, v43, v36, 24);
            unint64_t v32 = *v46;
            size_t v30 = (__n128 *)&v47;
          }
        }
        uint64_t v33 = (__n128 *)(v32 + 24 * *(unsigned int *)(a5 + 24));
        __n128 result = *v30;
        v33[1].n128_u64[0] = v30[1].n128_u64[0];
        __n128 *v33 = result;
        ++*(_DWORD *)(a5 + 24);
        uint64_t v20 = v21 + 1;
      }
      while (this != a3 || a4 != v21);
    }
  }
  return result;
}

__n128 llvm::interleave<mlir::Type const*,mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(llvm::ArrayRef<mlir::Type> const&)#1},mlir::Diagnostic& mlir::Diagnostic::appendRange<llvm::ArrayRef<mlir::Type>>(llvm::ArrayRef<mlir::Type> const&,char const*)::{lambda(void)#1},void>(uint64_t *a1, uint64_t *a2, uint64_t a3, uint64_t a4, const char **a5)
{
  if (a1 != a2)
  {
    uint64_t v44 = v5;
    uint64_t v45 = v6;
    uint64_t v12 = (__n128 *)&v41;
    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v41, *a1);
    uint64_t v14 = (unint64_t *)(a3 + 16);
    unint64_t v13 = *(void *)(a3 + 16);
    uint64_t v15 = *(unsigned int *)(a3 + 24);
    if (v15 >= *(_DWORD *)(a3 + 28))
    {
      unint64_t v35 = v15 + 1;
      BOOL v36 = v13 + 24 * v15 > (unint64_t)&v41;
      if (v13 <= (unint64_t)&v41 && v36)
      {
        BOOL v37 = (char *)&v41 - v13;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 16, (void *)(a3 + 32), v35, 24);
        unint64_t v13 = *(void *)(a3 + 16);
        uint64_t v12 = (__n128 *)&v37[v13];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 16, (void *)(a3 + 32), v35, 24);
        unint64_t v13 = *(void *)(a3 + 16);
        uint64_t v12 = (__n128 *)&v41;
      }
    }
    unint64_t v16 = (__n128 *)(v13 + 24 * *(unsigned int *)(a3 + 24));
    __n128 result = *v12;
    v16[1].n128_u64[0] = v12[1].n128_u64[0];
    *unint64_t v16 = result;
    ++*(_DWORD *)(a3 + 24);
    int v18 = a1 + 1;
    if (a1 + 1 != a2)
    {
      BOOL v39 = (void *)(a4 + 32);
      unsigned int v40 = (unint64_t *)(a4 + 16);
      do
      {
        unint64_t v19 = *a5;
        if (*a5)
        {
          size_t v20 = strlen(*a5);
          int v41 = 3;
          unint64_t v42 = v19;
          size_t v43 = v20;
          uint64_t v21 = *(unsigned int *)(a4 + 24);
          unint64_t v22 = *(void *)(a4 + 16);
          if (v21 < *(_DWORD *)(a4 + 28)) {
            goto LABEL_9;
          }
        }
        else
        {
          int v41 = 3;
          unint64_t v42 = 0;
          size_t v43 = 0;
          uint64_t v21 = *(unsigned int *)(a4 + 24);
          unint64_t v22 = *(void *)(a4 + 16);
          if (v21 < *(_DWORD *)(a4 + 28)) {
            goto LABEL_9;
          }
        }
        unint64_t v30 = v21 + 1;
        BOOL v31 = v22 + 24 * v21 > (unint64_t)&v41;
        if (v22 <= (unint64_t)&v41 && v31)
        {
          unint64_t v38 = (char *)&v41 - v22;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v40, v39, v30, 24);
          unint64_t v22 = *v40;
          size_t v23 = (int *)&v38[*v40];
          goto LABEL_10;
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v40, v39, v30, 24);
        unint64_t v22 = *v40;
LABEL_9:
        size_t v23 = &v41;
LABEL_10:
        uint64_t v24 = v22 + 24 * *(unsigned int *)(a4 + 24);
        long long v25 = *(_OWORD *)v23;
        *(void *)(v24 + 16) = *((void *)v23 + 2);
        *(_OWORD *)uint64_t v24 = v25;
        ++*(_DWORD *)(a4 + 24);
        unint64_t v26 = (__n128 *)&v41;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v41, *v18);
        uint64_t v27 = *(unsigned int *)(a3 + 24);
        unint64_t v28 = *(void *)(a3 + 16);
        if (v27 >= *(_DWORD *)(a3 + 28))
        {
          unint64_t v32 = v27 + 1;
          BOOL v33 = v28 + 24 * v27 > (unint64_t)&v41;
          if (v28 <= (unint64_t)&v41 && v33)
          {
            unint64_t v34 = (char *)&v41 - v28;
            llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 16, (void *)(a3 + 32), v32, 24);
            unint64_t v28 = *v14;
            unint64_t v26 = (__n128 *)&v34[*v14];
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod(a3 + 16, (void *)(a3 + 32), v32, 24);
            unint64_t v28 = *v14;
            unint64_t v26 = (__n128 *)&v41;
          }
        }
        uint64_t v29 = (__n128 *)(v28 + 24 * *(unsigned int *)(a3 + 24));
        __n128 result = *v26;
        v29[1].n128_u64[0] = v26[1].n128_u64[0];
        *uint64_t v29 = result;
        ++*(_DWORD *)(a3 + 24);
        ++v18;
      }
      while (v18 != a2);
    }
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::func::CallOp,mlir::SymbolRefAttr &,mlir::ValueTypeRange<mlir::ResultRange>,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v21);
  uint64_t v11 = mlir::RegisteredOperationName::lookup((int8x16_t *)"func.call", (const unsigned __int8 *)9, Context);
  if (!v12)
  {
    __int16 v28 = 1283;
    uint64_t v27[2] = (uint64_t)"func.call";
    v27[3] = 9;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v23 = 259;
    llvm::operator+(v27, (uint64_t *)&v22, (uint64_t)v26);
    llvm::report_fatal_error((llvm::Twine *)v26, 1);
  }
  mlir::OperationState::OperationState(v26, a2, v11);
  uint64_t v13 = *a3;
  uint64_t NextResultAtOffset = *a4;
  uint64_t v15 = a4[1];
  uint64_t v16 = a4[3];
  if (v15) {
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, v15);
  }
  mlir::ValueRange::ValueRange((unint64_t *)v27, NextResultAtOffset, v16 - v15);
  mlir::TypeRange::TypeRange(v25, v27[0], v27[1]);
  uint64_t v17 = mlir::ValueRange::ValueRange(v24, *(void *)a5, *(void *)(a5 + 8));
  mlir::func::CallOp::build((uint64_t)v17, (uint64_t)v26, v13, v25[0], v25[1], v24[0], v24[1]);
  int v18 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v26);
  if (*(_UNKNOWN **)(*((void *)v18 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::func::CallOp,void>::id) {
    unint64_t v19 = v18;
  }
  else {
    unint64_t v19 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v26);
  return v19;
}

uint64_t llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::func::FuncOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(uint64_t a1, mlir::MLIRContext **a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6)
{
  v11[2] = *MEMORY[0x1E4F143B8];
  mlir::ValueRange::ValueRange(v11, a3, a4);
  mlir::ValueRange::ValueRange(v10, a5, a6);
  return mlir::Builder::getFunctionType(a2, v11[0], v11[1], v10[0], v10[1]);
}

void *mlir::RewritePatternSet::add<mlir::func::CallIndirectOp>(mlir::LogicalResult (*)(mlir::func::CallIndirectOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(void *a1)
{
  uint64_t v2 = (void *)a1[10];
  if (v2 != a1 + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)a1[4];
  if (v3 != a1 + 6) {
    free(v3);
  }
  return a1;
}

void mlir::RewritePatternSet::add<mlir::func::CallIndirectOp>(mlir::LogicalResult (*)(mlir::func::CallIndirectOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::~FnPattern(void *__p)
{
  uint64_t v2 = (void *)__p[10];
  if (v2 != __p + 12) {
    free(v2);
  }
  uint64_t v3 = (void *)__p[4];
  if (v3 != __p + 6) {
    free(v3);
  }

  operator delete(__p);
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::CallIndirectOp>::rewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 48))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::CallIndirectOp>::match(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 56))();
}

uint64_t mlir::detail::OpOrInterfaceRewritePatternBase<mlir::func::CallIndirectOp>::matchAndRewrite(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::RewritePatternSet::add<mlir::func::CallIndirectOp>(mlir::LogicalResult (*)(mlir::func::CallIndirectOp,mlir::PatternRewriter &),mlir::PatternBenefit,llvm::ArrayRef<llvm::StringRef>)::FnPattern::matchAndRewrite(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1 + 96))(a2, a3);
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

uint64_t mlir::AsmParser::parseAttribute<mlir::FlatSymbolRefAttr>(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (*(uint64_t (**)(uint64_t))(*(void *)a1 + 40))(a1);
  uint64_t v23 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *, uint64_t))(*(void *)a1 + 408))(a1, &v23, a3)) {
    return 0;
  }
  uint64_t v7 = v23;
  if (*(_UNKNOWN **)(*(void *)v23 + 136) == &mlir::detail::TypeIDResolver<mlir::SymbolRefAttr,void>::id) {
    uint64_t v8 = v23;
  }
  else {
    uint64_t v8 = 0;
  }
  v24[0] = v8;
  if (v8)
  {
    mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v24);
    if (v9) {
      uint64_t v10 = 0;
    }
    else {
      uint64_t v10 = v7;
    }
    *a2 = v10;
    if (!v9) {
      return 1;
    }
  }
  else
  {
    *a2 = 0;
  }
  uint64_t v21 = "invalid kind of attribute specified";
  __int16 v22 = 259;
  (*(void (**)(void *__return_ptr, uint64_t, uint64_t, const char **))(*(void *)a1 + 24))(v24, a1, v6, &v21);
  uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v24);
  if (v24[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v31)
  {
    char v12 = (void **)__p;
    if (__p)
    {
      uint64_t v13 = v30;
      uint64_t v14 = __p;
      if (v30 != __p)
      {
        do
          uint64_t v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
        while (v13 != v12);
        uint64_t v14 = __p;
      }
      unint64_t v30 = v12;
      operator delete(v14);
    }
    uint64_t v15 = v27;
    if (v27)
    {
      uint64_t v16 = v28;
      uint64_t v17 = v27;
      if (v28 != v27)
      {
        do
        {
          unint64_t v19 = (void *)*--v16;
          int v18 = v19;
          *uint64_t v16 = 0;
          if (v19) {
            operator delete[](v18);
          }
        }
        while (v16 != v15);
        uint64_t v17 = v27;
      }
      __int16 v28 = v15;
      operator delete(v17);
    }
    if (v25 != &v26) {
      free(v25);
    }
  }
  return v11;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::CallOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    unint64_t v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  BOOL v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  uint64_t AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    BOOL v33 = AttrData;
    unint64_t v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      unint64_t v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      char v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          char v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          char v12 = (char *)v40;
        }
      }
      uint64_t v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)uint64_t v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    uint64_t v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    uint64_t v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unsigned int v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      uint64_t v17 = v40;
      uint64_t v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      __int16 v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          __int16 v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    uint64_t v24 = v44[0];
    if (v44[0])
    {
      long long v25 = v44[1];
      uint64_t v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          __int16 v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *long long v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        uint64_t v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, void *a2, void *a3)
{
  *a2 = *a3;
}

void llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::func::ConstantOp::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>(void *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  (*(void (**)(uint64_t *__return_ptr))(*(void *)*a1 + 24))(&v37);
  if (v37)
  {
    LODWORD(v33) = 3;
    unint64_t v34 = "'";
    uint64_t v35 = 1;
    uint64_t v4 = &v33;
    uint64_t v5 = (char *)v40;
    if (v41 >= v42)
    {
      unint64_t v29 = v41 + 1;
      if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
      {
        int64_t v31 = (char *)&v33 - (unsigned char *)v40;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v5 = (char *)v40;
        uint64_t v4 = (const void ***)((char *)v40 + v31);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v29, 24);
        uint64_t v4 = &v33;
        uint64_t v5 = (char *)v40;
      }
    }
    uint64_t v6 = &v5[24 * v41];
    long long v7 = *(_OWORD *)v4;
    *((void *)v6 + 2) = v4[2];
    *(_OWORD *)uint64_t v6 = v7;
    ++v41;
  }
  BOOL v33 = *(const void ***)(*(void *)(a1[2] + 8) + 8);
  uint64_t AttrData = (const void **)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v33);
  uint64_t v10 = v37;
  if (v37)
  {
    __int16 v36 = 261;
    BOOL v33 = AttrData;
    unint64_t v34 = v9;
    mlir::Diagnostic::operator<<((uint64_t)&v38, &v33);
    uint64_t v10 = v37;
    if (v37)
    {
      LODWORD(v33) = 3;
      unint64_t v34 = "' op ";
      uint64_t v35 = 5;
      uint64_t v11 = &v33;
      char v12 = (char *)v40;
      if (v41 >= v42)
      {
        unint64_t v30 = v41 + 1;
        if (v40 <= &v33 && (char *)v40 + 24 * v41 > (char *)&v33)
        {
          int64_t v32 = (char *)&v33 - (unsigned char *)v40;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          char v12 = (char *)v40;
          uint64_t v11 = (const void ***)((char *)v40 + v32);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v40, v43, v30, 24);
          uint64_t v11 = &v33;
          char v12 = (char *)v40;
        }
      }
      uint64_t v13 = &v12[24 * v41];
      long long v14 = *(_OWORD *)v11;
      *((void *)v13 + 2) = v11[2];
      *(_OWORD *)uint64_t v13 = v14;
      ++v41;
      uint64_t v10 = v37;
    }
  }
  *(void *)a2 = v10;
  *(unsigned char *)(a2 + 8) = 0;
  *(unsigned char *)(a2 + 184) = 0;
  if (v48)
  {
    *(void *)(a2 + 8) = v38;
    unint64_t v15 = v41;
    *(_DWORD *)(a2 + 16) = v39;
    uint64_t v16 = (void *)(a2 + 40);
    *(void *)(a2 + 24) = a2 + 40;
    *(void *)(a2 + 32) = 0x400000000;
    if (!v15 || &v37 == (uint64_t *)a2)
    {
      int v19 = 1;
      goto LABEL_21;
    }
    uint64_t v17 = v43;
    if (v40 != v43)
    {
      *(void *)(a2 + 24) = v40;
      unsigned int v18 = v42;
      *(_DWORD *)(a2 + 32) = v15;
      *(_DWORD *)(a2 + 36) = v18;
      unsigned int v40 = v43;
      unsigned int v42 = 0;
      int v19 = 1;
LABEL_20:
      unsigned int v41 = 0;
LABEL_21:
      *(_OWORD *)(a2 + 136) = *(_OWORD *)v44;
      *(void *)(a2 + 152) = v45;
      v44[0] = 0;
      v44[1] = 0;
      *(_OWORD *)(a2 + 160) = *(_OWORD *)__p;
      *(void *)(a2 + 176) = v47;
      uint64_t v45 = 0;
      __p[0] = 0;
      __p[1] = 0;
      uint64_t v47 = 0;
      *(unsigned char *)(a2 + 184) = 1;
      if (v19)
      {
        if (v40 != v43) {
          free(v40);
        }
        unsigned __int8 v48 = 0;
      }
      goto LABEL_25;
    }
    if (v15 < 5)
    {
      unint64_t v20 = v15;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 24, (void *)(a2 + 40), v15, 24);
      unint64_t v20 = v41;
      if (!v41)
      {
LABEL_19:
        *(_DWORD *)(a2 + 32) = v15;
        int v19 = v48;
        goto LABEL_20;
      }
      uint64_t v17 = v40;
      uint64_t v16 = *(void **)(a2 + 24);
    }
    memcpy(v16, v17, 24 * v20);
    goto LABEL_19;
  }
LABEL_25:
  mlir::InFlightDiagnostic::abandon(&v37);
  if (v37) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
  }
  if (v48)
  {
    uint64_t v21 = (void **)__p[0];
    if (__p[0])
    {
      __int16 v22 = (void **)__p[1];
      uint64_t v23 = __p[0];
      if (__p[1] != __p[0])
      {
        do
          __int16 v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
        while (v22 != v21);
        uint64_t v23 = __p[0];
      }
      __p[1] = v21;
      operator delete(v23);
    }
    uint64_t v24 = v44[0];
    if (v44[0])
    {
      long long v25 = v44[1];
      uint64_t v26 = v44[0];
      if (v44[1] != v44[0])
      {
        do
        {
          __int16 v28 = (void *)*--v25;
          uint64_t v27 = v28;
          *long long v25 = 0;
          if (v28) {
            operator delete[](v27);
          }
        }
        while (v25 != v24);
        uint64_t v26 = v44[0];
      }
      v44[1] = v24;
      operator delete(v26);
    }
    if (v40 != v43) {
      free(v40);
    }
  }
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::func::detail::FuncOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::func::detail::FuncOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result = *(__n128 *)a3;
  long long v4 = *(_OWORD *)(a3 + 16);
  *(void *)(a2 + 32) = *(void *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

void *mlir::func::registerInlinerExtension(mlir::func *this, mlir::DialectRegistry *a2)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  v3[0] = &unk_1EC9CE9D8;
  v3[1] = mlir::func::registerInlinerExtension(mlir::DialectRegistry &)::$_0::__invoke;
  long long v4 = v3;
  mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(this, v3);
  __n128 result = v4;
  if (v4 == v3) {
    return (void *)(*(uint64_t (**)(void *))(v3[0] + 32))(v3);
  }
  if (v4) {
    return (void *)(*(uint64_t (**)(void))(*v4 + 40))();
  }
  return result;
}

mlir::Dialect *mlir::func::registerInlinerExtension(mlir::DialectRegistry &)::$_0::__invoke(char *a1, uint64_t a2)
{
  long long v4 = (char *)operator new(0x18uLL);
  unint64_t v5 = 0x1E8EB8000uLL;
  {
    unsigned int v18 = v4;
    unint64_t v5 = 0x1E8EB8000;
    int v10 = v9;
    long long v4 = v18;
    if (v10)
    {
      int v19 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DialectInlinerInterface]";
      unint64_t v20 = 79;
      unint64_t v11 = llvm::StringRef::find((uint64_t *)&v19, "DesiredTypeName = ", 0x12uLL, 0);
      if (v20 >= v11) {
        unint64_t v12 = v11;
      }
      else {
        unint64_t v12 = v20;
      }
      uint64_t v13 = &v19[v12];
      unint64_t v14 = v20 - v12;
      if (v20 - v12 >= 0x12) {
        uint64_t v15 = 18;
      }
      else {
        uint64_t v15 = v20 - v12;
      }
      unint64_t v16 = v14 - v15;
      if (v16 >= v16 - 1) {
        uint64_t v17 = v16 - 1;
      }
      else {
        uint64_t v17 = v16;
      }
      mlir::detail::TypeIDResolver<mlir::DialectInlinerInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v13[v15], v17);
      unint64_t v5 = 0x1E8EB8000;
      long long v4 = v18;
    }
  }
  uint64_t v6 = *(void *)(v5 + 3896);
  *((void *)v4 + 1) = a2;
  *((void *)v4 + 2) = v6;
  *(void *)long long v4 = &unk_1EC99A638;
  int v19 = v4;
  mlir::Dialect::addInterface(a2, (uint64_t *)&v19);
  long long v7 = v19;
  int v19 = 0;
  if (v7) {
    (*(void (**)(const char *))(*(void *)v7 + 8))(v7);
  }
  int v19 = a1;
  return mlir::MLIRContext::getOrLoadDialect(a1, (uint64_t)"cf", 2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::cf::ControlFlowDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::cf::ControlFlowDialect * mlir::MLIRContext::getOrLoadDialect<mlir::cf::ControlFlowDialect>(void)::{lambda(void)#1}>, (uint64_t)&v19);
}

void anonymous namespace'::FuncInlinerInterface::~FuncInlinerInterface(_anonymous_namespace_::FuncInlinerInterface *this)
{
  mlir::GenericProgramPoint::~GenericProgramPoint(this);

  operator delete(v1);
}

uint64_t anonymous namespace'::FuncInlinerInterface::isLegalToInline(_anonymous_namespace_::FuncInlinerInterface *this, Operation *a2, Operation *a3)
{
  return 1;
}

uint64_t anonymous namespace'::FuncInlinerInterface::isLegalToInline()
{
  return 1;
}

{
  return 1;
}

void anonymous namespace'::FuncInlinerInterface::handleTerminator(_anonymous_namespace_::FuncInlinerInterface *this, mlir::Operation *a2, mlir::Block *a3)
{
  unint64_t v12 = a3;
  if (*(_UNKNOWN **)(*((void *)a2 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::func::ReturnOp,void>::id) {
    uint64_t v3 = a2;
  }
  else {
    uint64_t v3 = 0;
  }
  unint64_t v11 = v3;
  if (v3)
  {
    v10[0] = mlir::Attribute::getContext((mlir::Operation *)((char *)a2 + 24));
    v10[1] = 0;
    uint64_t v5 = *((void *)a2 + 2);
    mlir::GenericProgramPoint::~GenericProgramPoint(a2);
    unint64_t v10[2] = v5;
    unint64_t v10[3] = v6;
    uint64_t v7 = *((void *)a2 + 3);
    v9[0] = mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v11);
    v9[1] = v8;
    mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::OperandRange>((mlir::OpBuilder *)v10, v7, (uint64_t *)&v12, (uint64_t)v9);
    mlir::Operation::erase(a2);
  }
}

void **anonymous namespace'::FuncInlinerInterface::handleTerminator(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v14[2] = *MEMORY[0x1E4F143B8];
  v14[0] = a3;
  v14[1] = a4;
  uint64_t v13 = a2;
  __n128 result = (void **)mlir::anec::Concat::getInputs((mlir::anec::Concat *)&v13);
  if (v5)
  {
    uint64_t v6 = result;
    uint64_t v7 = v5;
    for (uint64_t i = 0; i != v7; ++i)
    {
      int v9 = v6[4 * i + 3];
      __n128 result = (void **)mlir::ValueRange::dereference_iterator(v14, i);
      while (1)
      {
        int v10 = *result;
        if (!*result) {
          break;
        }
        unint64_t v11 = (void *)v10[1];
        if (v11)
        {
          void *v11 = *v10;
          if (*v10) {
            *(void *)(*v10 + 8) = v10[1];
          }
        }
        unint64_t v10[3] = v9;
        v10[1] = v9;
        uint64_t v12 = *v9;
        void *v10 = *v9;
        if (v12) {
          *(void *)(v12 + 8) = v10;
        }
        *int v9 = (uint64_t)v10;
      }
    }
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::cf::BranchOp,mlir::Block *&,mlir::OperandRange>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t a4)
{
  v21[38] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"cf.br", (const unsigned __int8 *)5, Context);
  if (!v10)
  {
    __int16 v19 = 1283;
    uint64_t v18[2] = (uint64_t)"cf.br";
    void v18[3] = 5;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v17 = 259;
    llvm::operator+(v18, (uint64_t *)&v16, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  uint64_t v11 = *a3;
  mlir::ValueRange::ValueRange(v20, *(void *)a4, *(void *)(a4 + 8));
  mlir::cf::BranchOp::build((uint64_t)a1, (uint64_t)v21, v11, v20[0], v20[1]);
  uint64_t v12 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v12 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::cf::BranchOp,void>::id) {
    uint64_t v13 = v12;
  }
  else {
    uint64_t v13 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v13;
}

mlir::cf::ControlFlowDialect *llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::cf::ControlFlowDialect * mlir::MLIRContext::getOrLoadDialect<mlir::cf::ControlFlowDialect>(void)::{lambda(void)#1}>@<X0>(mlir::MLIRContext **a1@<X0>, mlir::cf::ControlFlowDialect **a2@<X8>)
{
  uint64_t v3 = *a1;
  long long v4 = (mlir::cf::ControlFlowDialect *)operator new(0x60uLL);
  __n128 result = mlir::cf::ControlFlowDialect::ControlFlowDialect(v4, v3);
  *a2 = result;
  return result;
}

void *mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(void *a1, void *a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  __n128 result = operator new(0x68uLL);
  uint64_t v5 = result;
  uint64_t v6 = (void *)a2[3];
  if (v6)
  {
    if (v6 == a2)
    {
      uint64_t v11 = v10;
      __n128 result = (void *)(*(uint64_t (**)(void *, void *))(*a2 + 24))(a2, v10);
      uint64_t v6 = v11;
    }
    else
    {
      uint64_t v11 = (void *)a2[3];
      a2[3] = 0;
    }
  }
  else
  {
    uint64_t v11 = 0;
  }
  v5[3] = "func";
  v5[4] = 4;
  uint64_t v5[2] = 0x300000001;
  void *v5 = &unk_1EC9D0590;
  v5[1] = v5 + 3;
  if (v6)
  {
    if (v6 == v10)
    {
      v5[12] = v5 + 9;
      (*(void (**)(void *))(v10[0] + 24))(v10);
      __n128 result = v11;
      if (v11 == v10)
      {
        __n128 result = (void *)(*(uint64_t (**)(void *))(v10[0] + 32))(v10);
      }
      else if (v11)
      {
        __n128 result = (void *)(*(uint64_t (**)(void))(*v11 + 40))();
      }
    }
    else
    {
      v5[12] = v6;
    }
  }
  else
  {
    v5[12] = 0;
  }
  uint64_t v9 = v5;
  uint64_t v7 = (void *)a1[4];
  if ((unint64_t)v7 >= a1[5])
  {
    uint64_t v8 = std::vector<std::unique_ptr<mlir::DialectExtensionBase>>::__push_back_slow_path<std::unique_ptr<mlir::DialectExtensionBase>>(a1 + 3, (uint64_t *)&v9);
    __n128 result = v9;
    a1[4] = v8;
    uint64_t v9 = 0;
    if (result) {
      return (void *)(*(uint64_t (**)(void *))(*result + 8))(result);
    }
  }
  else
  {
    *uint64_t v7 = v5;
    a1[4] = v7 + 1;
  }
  return result;
}

void *std::vector<std::unique_ptr<mlir::DialectExtensionBase>>::__push_back_slow_path<std::unique_ptr<mlir::DialectExtensionBase>>(void *a1, uint64_t *a2)
{
  uint64_t v2 = a1[1] - *a1;
  uint64_t v3 = v2 >> 3;
  unint64_t v4 = (v2 >> 3) + 1;
  if (v4 >> 61) {
    abort();
  }
  uint64_t v7 = a1[2] - *a1;
  if (v7 >> 2 > v4) {
    unint64_t v4 = v7 >> 2;
  }
  if ((unint64_t)v7 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v8 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v8 = v4;
  }
  if (v8)
  {
    if (v8 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    uint64_t v9 = (char *)operator new(8 * v8);
  }
  else
  {
    uint64_t v9 = 0;
  }
  char v10 = &v9[8 * v3];
  uint64_t v11 = &v9[8 * v8];
  uint64_t v12 = *a2;
  *a2 = 0;
  *(void *)char v10 = v12;
  uint64_t v13 = v10 + 8;
  unint64_t v14 = (char *)*a1;
  uint64_t v15 = (char *)a1[1];
  if (v15 == (char *)*a1)
  {
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
  }
  else
  {
    unint64_t v16 = (unint64_t)&v15[-*a1 - 8];
    if (v16 < 0x78 || &v15[-(v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v10 && &v9[v2 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v15) {
      goto LABEL_31;
    }
    uint64_t v17 = (v16 >> 3) + 1;
    uint64_t v18 = 8 * (v17 & 0x3FFFFFFFFFFFFFFCLL);
    __int16 v19 = &v15[-v18];
    v10 -= v18;
    unint64_t v20 = &v9[8 * v3 - 16];
    uint64_t v21 = v15 - 16;
    uint64_t v22 = v17 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v24 = *((_OWORD *)v21 - 1);
      long long v23 = *(_OWORD *)v21;
      *((_OWORD *)v21 - 1) = 0uLL;
      *(_OWORD *)uint64_t v21 = 0uLL;
      *((_OWORD *)v20 - 1) = v24;
      *(_OWORD *)unint64_t v20 = v23;
      v20 -= 32;
      v21 -= 32;
      v22 -= 4;
    }
    while (v22);
    uint64_t v15 = v19;
    if (v17 != (v17 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_31:
      do
      {
        uint64_t v25 = *((void *)v15 - 1);
        v15 -= 8;
        *(void *)uint64_t v15 = 0;
        *((void *)v10 - 1) = v25;
        v10 -= 8;
      }
      while (v15 != v14);
    }
    uint64_t v15 = (char *)*a1;
    uint64_t v26 = (char *)a1[1];
    *a1 = v10;
    a1[1] = v13;
    a1[2] = v11;
    while (v26 != v15)
    {
      uint64_t v28 = *((void *)v26 - 1);
      v26 -= 8;
      uint64_t v27 = v28;
      *(void *)uint64_t v26 = 0;
      if (v28) {
        (*(void (**)(uint64_t))(*(void *)v27 + 8))(v27);
      }
    }
  }
  if (v15) {
    operator delete(v15);
  }
  return v13;
}

void mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(std::function<void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>)::Extension::~Extension(mlir::DialectExtensionBase *this)
{
  *(void *)this = &unk_1EC9D0590;
  uint64_t v2 = (char *)this + 72;
  uint64_t v3 = (char *)*((void *)this + 12);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    unint64_t v4 = this;
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    unint64_t v4 = this;
  }
  mlir::DialectExtensionBase::~DialectExtensionBase(v4);
}

{
  char *v2;
  char *v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EC9D0590;
  uint64_t v2 = (char *)this + 72;
  uint64_t v3 = (char *)*((void *)this + 12);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
    mlir::DialectExtensionBase::~DialectExtensionBase(this);
  }
  else
  {
    if (v3) {
      (*(void (**)(char *))(*(void *)v3 + 40))(v3);
    }
    mlir::DialectExtensionBase::~DialectExtensionBase(this);
  }
  operator delete(v4);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(std::function<void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>)::Extension,mlir::func::FuncDialect>::apply(uint64_t a1, uint64_t a2, void *a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, void))(*(void *)a1 + 32))(a1, a2, *a3);
}

uint64_t mlir::DialectExtension<void mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(std::function<void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>)::Extension,mlir::func::FuncDialect>::clone@<X0>(uint64_t a1@<X0>, void *a2@<X8>)
{
  unint64_t v4 = operator new(0x68uLL);
  uint64_t v5 = v4;
  void *v4 = &unk_1EC9AAD88;
  uint64_t v6 = v4 + 3;
  v4[1] = v4 + 3;
  uint64_t v7 = (void **)(v4 + 1);
  void v4[2] = 0x300000000;
  if (v4 != (void *)a1)
  {
    unsigned int v8 = *(_DWORD *)(a1 + 16);
    if (v8)
    {
      if (v8 < 4)
      {
        unsigned int v9 = *(_DWORD *)(a1 + 16);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v4 + 1), v6, *(unsigned int *)(a1 + 16), 16);
        unsigned int v9 = *(_DWORD *)(a1 + 16);
        if (!v9)
        {
LABEL_8:
          *((_DWORD *)v5 + 4) = v8;
          goto LABEL_9;
        }
        uint64_t v6 = *v7;
      }
      memcpy(v6, *(const void **)(a1 + 8), 16 * v9);
      goto LABEL_8;
    }
  }
LABEL_9:
  void *v5 = &unk_1EC9D0590;
  char v10 = v5 + 9;
  uint64_t result = *(void *)(a1 + 96);
  if (result)
  {
    if (result == a1 + 72)
    {
      v5[12] = v10;
      uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 24))(result);
    }
    else
    {
      uint64_t result = (*(uint64_t (**)(uint64_t, void *))(*(void *)result + 16))(result, v10);
      v5[12] = result;
    }
    *a2 = v5;
  }
  else
  {
    v5[12] = 0;
    *a2 = v5;
  }
  return result;
}

uint64_t mlir::DialectRegistry::addExtension<mlir::func::FuncDialect>(std::function<void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>)::Extension::apply(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = a2;
  uint64_t v3 = *(void *)(a1 + 96);
  if (!v3)
  {
    std::__throw_bad_function_call[abi:nn180100]();
    JUMPOUT(0x1803FDAFCLL);
  }
  return (*(uint64_t (**)(uint64_t, uint64_t *, uint64_t *))(*(void *)v3 + 48))(v3, &v6, &v5);
}

void *std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::__clone(uint64_t a1)
{
  uint64_t result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *uint64_t result = &unk_1EC9CE9D8;
  result[1] = v3;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::__clone(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CE9D8;
  a2[1] = v2;
  return result;
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::operator()(uint64_t a1, void *a2, void *a3)
{
  return (*(uint64_t (**)(void, void))(a1 + 8))(*a2, *a3);
}

uint64_t std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::target(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  if (v3 == 0x8000000181101741) {
    return a1 + 8;
  }
  if (((v3 & 0x8000000181101741 & 0x8000000000000000) != 0) == __OFSUB__(v3, 0x8000000181101741)) {
    return 0;
  }
  if (!strcmp((const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(0x8000000181101741 & 0x7FFFFFFFFFFFFFFFLL))) {
    return a1 + 8;
  }
  return 0;
}

void *std::__function::__func<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *),std::allocator<void (*)(mlir::MLIRContext *,mlir::func::FuncDialect *)>,void ()(mlir::MLIRContext *,mlir::func::FuncDialect *)>::target_type()
{
}

uint64_t mlir::FunctionOpInterface::getArgumentTypes(mlir::FunctionOpInterface *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 1) + 48) + 8))();
}

uint64_t mlir::FunctionOpInterface::getResultTypes(mlir::FunctionOpInterface *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 1) + 48) + 16))();
}

uint64_t mlir::FunctionOpInterface::getArgAttrsAttr(mlir::FunctionOpInterface *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 1) + 48) + 24))();
}

uint64_t mlir::FunctionOpInterface::getResAttrsAttr(mlir::FunctionOpInterface *this)
{
  return (*(uint64_t (**)(void))(*(void *)(*((void *)this + 1) + 48) + 32))();
}

void mlir::function_interface_impl::setFunctionType(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v73[6] = *MEMORY[0x1E4F143B8];
  (*(void (**)(void))(*(void *)(a2 + 48) + 8))();
  unsigned int v7 = v6;
  (*(void (**)(void))(*(void *)(a2 + 48) + 16))();
  unsigned int v9 = v8;
  uint64_t v10 = mlir::TypeAttr::get(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(a2 + 8))(a2, a1, v10);
  (*(void (**)(void))(*(void *)(a2 + 48) + 8))();
  LODWORD(v12) = v11;
  (*(void (**)(void))(*(void *)(a2 + 48) + 16))();
  LODWORD(v14) = v13;
  uint64_t Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  unint64_t v16 = mlir::DictionaryAttr::get(Context, 0, 0);
  if (v7 == v12) {
    goto LABEL_13;
  }
  if (!v12) {
    goto LABEL_12;
  }
  uint64_t v69 = (*(uint64_t (**)(void))(*(void *)(a2 + 48) + 24))();
  if (!v69) {
    goto LABEL_13;
  }
  if (v12 < v7)
  {
    uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
    if (v18 >= v12) {
      uint64_t v12 = v12;
    }
    else {
      uint64_t v12 = v18;
    }
    if (v12)
    {
      uint64_t v19 = Value;
      uint64_t v20 = 8 * v12;
      uint64_t v21 = (void **)Value;
      while (1)
      {
        unint64_t v71 = *v21;
        if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v71)) {
          break;
        }
        ++v21;
        v20 -= 8;
        if (!v20) {
          goto LABEL_12;
        }
      }
      unint64_t v53 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
      mlir::ArrayAttr::get(v53, v19, v12);
      (*(void (**)(void))(*(void *)(a2 + 48) + 40))();
      goto LABEL_13;
    }
LABEL_12:
    (*(void (**)(void))(*(void *)(a2 + 48) + 56))();
    goto LABEL_13;
  }
  uint64_t v27 = (unsigned char *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
  uint64_t v28 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
  unint64_t v30 = (unsigned char *)(v28 + 8 * v29);
  unint64_t v71 = v73;
  uint64_t v72 = 0x600000000;
  uint64_t v31 = v30 - v27;
  if ((unint64_t)(v30 - v27) < 0x31)
  {
    unsigned int v32 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v31 >> 3, 8);
    unsigned int v32 = v72;
  }
  if (v30 != v27)
  {
    memcpy((char *)v71 + 8 * v32, v27, v30 - v27);
    unsigned int v32 = v72;
  }
  uint64_t v39 = v32 + ((unint64_t)v31 >> 3);
  LODWORD(v72) = v39;
  uint64_t v40 = v12;
  if (v39 == v12)
  {
LABEL_36:
    unsigned int v41 = v71;
    unsigned int v42 = (char *)v71 + 8 * v40;
    size_t v43 = (uint64_t *)v71;
    goto LABEL_37;
  }
  if (v39 > v12)
  {
    LODWORD(v72) = v12;
    goto LABEL_36;
  }
  unint64_t v55 = v12 - v39;
  if (HIDWORD(v72) < v12)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v12, 8);
    uint64_t v39 = v72;
    if (!v55) {
      goto LABEL_65;
    }
  }
  else if (!v55)
  {
    goto LABEL_65;
  }
  uint64_t v56 = (int64x2_t *)((char *)v71 + 8 * v39);
  int v57 = (unint64_t *)v56;
  unint64_t v58 = v55;
  if (v55 < 4) {
    goto LABEL_82;
  }
  int v57 = (unint64_t *)v56 + (v55 & 0xFFFFFFFFFFFFFFFCLL);
  unint64_t v58 = v55 & 3;
  int64x2_t v59 = vdupq_n_s64(v16);
  unint64_t v60 = v56 + 1;
  unint64_t v61 = v55 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v60[-1] = v59;
    *unint64_t v60 = v59;
    v60 += 2;
    v61 -= 4;
  }
  while (v61);
  if (v55 != (v55 & 0xFFFFFFFFFFFFFFFCLL))
  {
LABEL_82:
    do
    {
      *v57++ = v16;
      --v58;
    }
    while (v58);
  }
LABEL_65:
  uint64_t v40 = (v39 + v55);
  LODWORD(v72) = v39 + v55;
  if (!(v39 + v55))
  {
LABEL_39:
    (*(void (**)(void))(*(void *)(a2 + 48) + 56))();
    uint64_t v44 = v71;
    if (v71 == v73) {
      goto LABEL_13;
    }
LABEL_53:
    free(v44);
    goto LABEL_13;
  }
  unsigned int v41 = v71;
  unsigned int v42 = (char *)v71 + 8 * v40;
  size_t v43 = (uint64_t *)v71;
LABEL_37:
  while (1)
  {
    uint64_t v70 = *v43;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v70)) {
      break;
    }
    if (++v43 == (uint64_t *)v42) {
      goto LABEL_39;
    }
  }
  unint64_t v51 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  mlir::ArrayAttr::get(v51, (uint64_t)v41, v40);
  (*(void (**)(void))(*(void *)(a2 + 48) + 40))();
  uint64_t v44 = v71;
  if (v71 != v73) {
    goto LABEL_53;
  }
LABEL_13:
  if (v9 == v14) {
    return;
  }
  if (!v14) {
    goto LABEL_24;
  }
  uint64_t v69 = (*(uint64_t (**)(void))(*(void *)(a2 + 48) + 32))();
  if (!v69) {
    return;
  }
  if (v14 < v9)
  {
    uint64_t v22 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
    if (v23 >= v14) {
      uint64_t v14 = v14;
    }
    else {
      uint64_t v14 = v23;
    }
    if (v14)
    {
      uint64_t v24 = v22;
      uint64_t v25 = 8 * v14;
      uint64_t v26 = (void **)v22;
      while (1)
      {
        unint64_t v71 = *v26;
        if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v71)) {
          break;
        }
        ++v26;
        v25 -= 8;
        if (!v25) {
          goto LABEL_24;
        }
      }
      uint64_t v54 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
      mlir::ArrayAttr::get(v54, v24, v14);
      (*(void (**)(void))(*(void *)(a2 + 48) + 48))();
      return;
    }
LABEL_24:
    (*(void (**)(void))(*(void *)(a2 + 48) + 64))();
    return;
  }
  BOOL v33 = (unsigned char *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
  uint64_t v34 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v69);
  __int16 v36 = (unsigned char *)(v34 + 8 * v35);
  unint64_t v71 = v73;
  uint64_t v72 = 0x600000000;
  uint64_t v37 = v36 - v33;
  if ((unint64_t)(v36 - v33) < 0x31)
  {
    unsigned int v38 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v37 >> 3, 8);
    unsigned int v38 = v72;
  }
  if (v36 != v33)
  {
    memcpy((char *)v71 + 8 * v38, v33, v36 - v33);
    unsigned int v38 = v72;
  }
  uint64_t v45 = v38 + ((unint64_t)v37 >> 3);
  LODWORD(v72) = v45;
  uint64_t v46 = v14;
  if (v45 == v14)
  {
LABEL_47:
    uint64_t v47 = v71;
    unsigned __int8 v48 = (char *)v71 + 8 * v14;
    uint64_t v49 = (uint64_t *)v71;
    goto LABEL_48;
  }
  if (v45 > v14)
  {
    LODWORD(v72) = v14;
    goto LABEL_47;
  }
  unint64_t v62 = v14 - v45;
  if (HIDWORD(v72) < v14)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v14, 8);
    uint64_t v45 = v72;
    if (!v62) {
      goto LABEL_74;
    }
  }
  else if (!v62)
  {
    goto LABEL_74;
  }
  uint64_t v63 = (int64x2_t *)((char *)v71 + 8 * v45);
  unint64_t v64 = (unint64_t *)v63;
  unint64_t v65 = v62;
  if (v62 < 4) {
    goto LABEL_83;
  }
  unint64_t v64 = (unint64_t *)v63 + (v62 & 0xFFFFFFFFFFFFFFFCLL);
  unint64_t v65 = v62 & 3;
  int64x2_t v66 = vdupq_n_s64(v16);
  int v67 = v63 + 1;
  unint64_t v68 = v62 & 0xFFFFFFFFFFFFFFFCLL;
  do
  {
    v67[-1] = v66;
    *int v67 = v66;
    v67 += 2;
    v68 -= 4;
  }
  while (v68);
  if (v62 != (v62 & 0xFFFFFFFFFFFFFFFCLL))
  {
LABEL_83:
    do
    {
      *v64++ = v16;
      --v65;
    }
    while (v65);
  }
LABEL_74:
  uint64_t v46 = (v45 + v62);
  LODWORD(v72) = v45 + v62;
  if (!(v45 + v62))
  {
LABEL_50:
    (*(void (**)(void))(*(void *)(a2 + 48) + 64))();
    unint64_t v50 = v71;
    if (v71 == v73) {
      return;
    }
LABEL_55:
    free(v50);
    return;
  }
  uint64_t v47 = v71;
  unsigned __int8 v48 = (char *)v71 + 8 * v46;
  uint64_t v49 = (uint64_t *)v71;
LABEL_48:
  while (1)
  {
    uint64_t v70 = *v49;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v70)) {
      break;
    }
    if (++v49 == (uint64_t *)v48) {
      goto LABEL_50;
    }
  }
  long long v52 = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  mlir::ArrayAttr::get(v52, (uint64_t)v47, v46);
  (*(void (**)(void))(*(void *)(a2 + 48) + 48))();
  unint64_t v50 = v71;
  if (v71 != v73) {
    goto LABEL_55;
  }
}

uint64_t mlir::function_interface_impl::parseFunctionSignature(char *a1, char a2, uint64_t a3, unsigned char *a4, uint64_t a5, uint64_t a6)
{
  char v17 = a2;
  *a4 = 0;
  int v13 = a4;
  uint64_t v14 = (uint64_t)a1;
  uint64_t v15 = &v17;
  uint64_t v16 = a3;
  if (!(*(unsigned __int8 (**)(char *, uint64_t, uint64_t (*)(uint64_t), unsigned char **, void, void))(*(void *)a1 + 360))(a1, 1, llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<parseFunctionArgumentList(mlir::OpAsmParser &,BOOL,llvm::SmallVectorImpl<mlir::OpAsmParser::Argument> &,BOOL &)::$_0>, &v13, 0, 0))return 0; {
  if (!(*(unsigned __int8 (**)(char *))(*(void *)a1 + 64))(a1))
  }
    return 1;
  if ((*(unsigned __int8 (**)(char *))(*(void *)a1 + 272))(a1))
  {
    if ((*(unsigned __int8 (**)(char *))(*(void *)a1 + 288))(a1)) {
      return 1;
    }
    int v13 = (unsigned char *)a5;
    uint64_t v14 = a6;
    uint64_t v15 = a1;
    if ((*(unsigned __int8 (**)(char *, void, uint64_t (*)(uint64_t *), unsigned char **, void, void))(*(void *)a1 + 360))(a1, 0, llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<parseFunctionResultList(mlir::OpAsmParser &,llvm::SmallVectorImpl<mlir::Type> &,llvm::SmallVectorImpl<mlir::DictionaryAttr> &)::$_0>, &v13, 0, 0))
    {
      return (*(uint64_t (**)(char *))(*(void *)a1 + 280))(a1);
    }
    return 0;
  }
  int v13 = 0;
  if (!(*(unsigned __int8 (**)(char *, unsigned char **))(*(void *)a1 + 504))(a1, &v13)) {
    return 0;
  }
  uint64_t v10 = v13;
  uint64_t v11 = *(unsigned int *)(a5 + 8);
  if (v11 >= *(_DWORD *)(a5 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a5, (void *)(a5 + 16), v11 + 1, 8);
    LODWORD(v11) = *(_DWORD *)(a5 + 8);
  }
  *(void *)(*(void *)a5 + 8 * v11) = v10;
  ++*(_DWORD *)(a5 + 8);
  uint64_t v12 = *(unsigned int *)(a6 + 8);
  if (v12 >= *(_DWORD *)(a6 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a6, (void *)(a6 + 16), v12 + 1, 8);
    *(void *)(*(void *)a6 + 8 * *(unsigned int *)(a6 + 8)) = 0;
    LODWORD(v12) = *(_DWORD *)(a6 + 8);
  }
  else
  {
    *(void *)(*(void *)a6 + 8 * v12) = 0;
  }
  *(_DWORD *)(a6 + 8) = v12 + 1;
  return 1;
}

void mlir::function_interface_impl::addArgAndResultAttrs(mlir::DictionaryAttr **a1, uint64_t a2, uint64_t *a3, uint64_t a4, void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v29[6] = *MEMORY[0x1E4F143B8];
  if (a4)
  {
    uint64_t v14 = a3;
    uint64_t v15 = 8 * a4;
    uint64_t v16 = 8 * a4;
    char v17 = (void **)a3;
    while (1)
    {
      uint64_t v27 = *v17;
      if (v27)
      {
        if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v27)) {
          break;
        }
      }
      ++v17;
      v16 -= 8;
      if (!v16) {
        goto LABEL_15;
      }
    }
    LODWORD(v18) = 0;
    uint64_t v27 = v29;
    uint64_t v28 = 0x600000000;
    do
    {
      uint64_t DictionaryAttr = *v14;
      if (!*v14)
      {
        uint64_t DictionaryAttr = mlir::Builder::getDictionaryAttr(a1, 0, 0);
        LODWORD(v18) = v28;
      }
      if (v18 >= HIDWORD(v28))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v18 + 1, 8);
        LODWORD(v18) = v28;
      }
      *((void *)v27 + v18) = DictionaryAttr;
      uint64_t v18 = (v28 + 1);
      LODWORD(v28) = v28 + 1;
      ++v14;
      v15 -= 8;
    }
    while (v15);
    uint64_t ArrayAttr = mlir::Builder::getArrayAttr(a1, (uint64_t)v27, v18);
    if (v27 != v29) {
      free(v27);
    }
    mlir::NamedAttribute::NamedAttribute(&v27, a7, ArrayAttr);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v27, v28);
  }
LABEL_15:
  if (a6)
  {
    uint64_t v21 = 8 * a6;
    uint64_t v22 = 8 * a6;
    for (uint64_t i = a5; ; ++i)
    {
      uint64_t v27 = *i;
      if (v27)
      {
        if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v27)) {
          break;
        }
      }
      v22 -= 8;
      if (!v22) {
        return;
      }
    }
    LODWORD(v24) = 0;
    uint64_t v27 = v29;
    uint64_t v28 = 0x600000000;
    do
    {
      uint64_t v25 = (uint64_t)*a5;
      if (!*a5)
      {
        uint64_t v25 = mlir::Builder::getDictionaryAttr(a1, 0, 0);
        LODWORD(v24) = v28;
      }
      if (v24 >= HIDWORD(v28))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v24 + 1, 8);
        LODWORD(v24) = v28;
      }
      *((void *)v27 + v24) = v25;
      uint64_t v24 = (v28 + 1);
      LODWORD(v28) = v28 + 1;
      ++a5;
      v21 -= 8;
    }
    while (v21);
    uint64_t v26 = mlir::Builder::getArrayAttr(a1, (uint64_t)v27, v24);
    if (v27 != v29) {
      free(v27);
    }
    mlir::NamedAttribute::NamedAttribute(&v27, a8, v26);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v27, v28);
  }
}

uint64_t mlir::function_interface_impl::parseFunctionOp(mlir::AsmParser *a1, uint64_t a2, char a3, uint64_t a4, uint64_t (*a5)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **), uint64_t a6, uint64_t a7, uint64_t a8)
{
  v119[8] = *MEMORY[0x1E4F143B8];
  uint64_t v86 = a4;
  uint64_t v117 = (char *)v119;
  uint64_t v118 = 0x100000000;
  unint64_t v114 = (void **)v116;
  uint64_t v115 = 0x600000000;
  int v111 = v113;
  uint64_t v112 = 0x600000000;
  int v13 = (mlir::DictionaryAttr **)(*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 32))(a1);
  mlir::impl::parseOptionalVisibilityKeyword((uint64_t)a1, a2 + 112);
  uint64_t v85 = 0;
  if (!mlir::AsmParser::parseSymbolName(a1, (mlir::StringAttr *)&v85))
  {
    uint64_t v17 = 0;
    goto LABEL_77;
  }
  mlir::NamedAttrList::append(a2 + 112, (uint64_t)"sym_name", 8, v85);
  uint64_t v14 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  unsigned __int8 v84 = 0;
  if (!mlir::function_interface_impl::parseFunctionSignature((char *)a1, a3, (uint64_t)&v117, &v84, (uint64_t)&v111, (uint64_t)&v114))
  {
    uint64_t v17 = 0;
    goto LABEL_77;
  }
  uint64_t v81 = 0;
  uint64_t v82 = 0;
  uint64_t v83 = 0;
  uint64_t v108 = v110;
  uint64_t v109 = 0x600000000;
  unsigned int v15 = v118;
  if (v118 < 7)
  {
    unsigned int v16 = 0;
    if (!v118) {
      goto LABEL_13;
    }
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v110, v118, 8);
    unsigned int v15 = v118;
    unsigned int v16 = v109;
    if (!v118) {
      goto LABEL_13;
    }
  }
  unint64_t v18 = (unint64_t)v15 << 6;
  uint64_t v19 = (uint64_t *)(v117 + 32);
  do
  {
    uint64_t v20 = *v19;
    if (v16 >= HIDWORD(v109))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v110, v16 + 1, 8);
      unsigned int v16 = v109;
    }
    *((void *)v108 + v16) = v20;
    unsigned int v16 = v109 + 1;
    LODWORD(v109) = v109 + 1;
    v19 += 8;
    v18 -= 64;
  }
  while (v18);
LABEL_13:
  uint64_t v21 = a5(a6, v13, v108, v16, v111, v112, v84, &v81);
  if (!v21)
  {
    __int16 v90 = 257;
    (*(void (**)(void **__return_ptr, mlir::AsmParser *, uint64_t, const void ***))(*(void *)a1 + 24))(&v96, a1, v14, &v87);
    if (v96)
    {
      LODWORD(__src) = 3;
      uint64_t v92 = (uint64_t)"failed to construct function type";
      v93[0] = 33;
      p_src = &__src;
      unsigned int v42 = (char *)v99;
      if (v100 >= v101)
      {
        unint64_t v72 = v100 + 1;
        if (v99 <= &__src && (char *)v99 + 24 * v100 > (char *)&__src)
        {
          int64_t v74 = (char *)&__src - (unsigned char *)v99;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v72, 24);
          unsigned int v42 = (char *)v99;
          p_src = (void **)((char *)v99 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v72, 24);
          p_src = &__src;
          unsigned int v42 = (char *)v99;
        }
      }
      size_t v43 = &v42[24 * v100];
      long long v44 = *(_OWORD *)p_src;
      *((void *)v43 + 2) = p_src[2];
      *(_OWORD *)size_t v43 = v44;
      ++v100;
    }
    uint64_t v45 = HIBYTE(v83);
    if (v83 < 0) {
      uint64_t v45 = v82;
    }
    if (v45) {
      uint64_t v46 = ": ";
    }
    else {
      uint64_t v46 = "";
    }
    v79[0] = v46;
    uint64_t v47 = (void *)mlir::InFlightDiagnostic::append<char const*&>((uint64_t)&v96, v79);
    uint64_t v48 = (uint64_t)v47;
    if (*v47)
    {
      __int16 v94 = 260;
      uint64_t __src = &v81;
      mlir::Diagnostic::operator<<((uint64_t)(v47 + 1), (const void ***)&__src);
    }
    uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v48);
    if (v96) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v96);
    }
    if (!v107) {
      goto LABEL_73;
    }
    uint64_t v49 = (void **)__p;
    if (__p)
    {
      unint64_t v50 = v106;
      unint64_t v51 = __p;
      if (v106 != __p)
      {
        do
          unint64_t v50 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v50 - 1);
        while (v50 != v49);
        unint64_t v51 = __p;
      }
      unint64_t v106 = v49;
      operator delete(v51);
    }
    long long v52 = v103;
    if (v103)
    {
      unint64_t v53 = v104;
      uint64_t v54 = v103;
      if (v104 != v103)
      {
        do
        {
          uint64_t v56 = (void *)*--v53;
          unint64_t v55 = v56;
          void *v53 = 0;
          if (v56) {
            operator delete[](v55);
          }
        }
        while (v53 != v52);
        uint64_t v54 = v103;
      }
      unint64_t v104 = v52;
      operator delete(v54);
    }
    int v57 = v99;
    if (v99 == v102) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }
  uint64_t v22 = v86;
  uint64_t v23 = mlir::TypeAttr::get(v21);
  mlir::NamedAttribute::NamedAttribute(&v96, v22, v23);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)v96, v97);
  uint64_t __src = v93;
  uint64_t v92 = 0x400000000;
  uint64_t v95 = 4;
  uint64_t v24 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *, void **))(*(void *)a1 + 464))(a1, &__src))
  {
    uint64_t v17 = 0;
    int v57 = __src;
    if (__src == v93) {
      goto LABEL_73;
    }
    goto LABEL_72;
  }
  uint64_t AttrData = (const char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v86);
  size_t v26 = v25;
  uint64_t v27 = "sym_visibility";
  uint64_t v28 = 14;
  if (mlir::NamedAttrList::get((uint64_t)&__src, "sym_visibility", 0xEuLL)) {
    goto LABEL_19;
  }
  uint64_t v27 = "sym_name";
  uint64_t v28 = 8;
  if (mlir::NamedAttrList::get((uint64_t)&__src, "sym_name", 8uLL)) {
    goto LABEL_19;
  }
  uint64_t v27 = AttrData;
  if (mlir::NamedAttrList::get((uint64_t)&__src, AttrData, v26))
  {
    uint64_t v28 = v26;
LABEL_19:
    v79[0] = "'";
    __int16 v80 = 259;
    (*(void (**)(void **__return_ptr, mlir::AsmParser *, uint64_t, const char **))(*(void *)a1 + 24))(&v96, a1, v24, v79);
    if (v96)
    {
      __int16 v90 = 261;
      unint64_t v87 = (const void **)v27;
      unint64_t v88 = (const char *)v28;
      mlir::Diagnostic::operator<<((uint64_t)&v97, &v87);
      if (v96)
      {
        LODWORD(v87) = 3;
        unint64_t v88 = "' is an inferred attribute and should not be specified in the explicit attribute dictionary";
        uint64_t v89 = 91;
        uint64_t v29 = &v87;
        unint64_t v30 = (char *)v99;
        if (v100 >= v101)
        {
          unint64_t v73 = v100 + 1;
          if (v99 <= &v87 && (char *)v99 + 24 * v100 > (char *)&v87)
          {
            int64_t v75 = (char *)&v87 - (unsigned char *)v99;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v73, 24);
            unint64_t v30 = (char *)v99;
            uint64_t v29 = (const void ***)((char *)v99 + v75);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v99, v102, v73, 24);
            uint64_t v29 = &v87;
            unint64_t v30 = (char *)v99;
          }
        }
        uint64_t v31 = &v30[24 * v100];
        long long v32 = *(_OWORD *)v29;
        *((void *)v31 + 2) = v29[2];
        *(_OWORD *)uint64_t v31 = v32;
        ++v100;
      }
    }
    uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v96);
    if (v96) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v96);
    }
    if (v107)
    {
      BOOL v33 = (void **)__p;
      if (__p)
      {
        uint64_t v34 = v106;
        uint64_t v35 = __p;
        if (v106 != __p)
        {
          do
            uint64_t v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
          while (v34 != v33);
          uint64_t v35 = __p;
        }
        unint64_t v106 = v33;
        operator delete(v35);
      }
      __int16 v36 = v103;
      if (v103)
      {
        uint64_t v37 = v104;
        unsigned int v38 = v103;
        if (v104 != v103)
        {
          do
          {
            uint64_t v40 = (void *)*--v37;
            uint64_t v39 = v40;
            *uint64_t v37 = 0;
            if (v40) {
              operator delete[](v39);
            }
          }
          while (v37 != v36);
          unsigned int v38 = v103;
        }
        unint64_t v104 = v36;
        operator delete(v38);
      }
      if (v99 != v102) {
        free(v99);
      }
    }
    goto LABEL_71;
  }
  int64x2_t v59 = __src;
  uint64_t v60 = v92;
  *(void *)(a2 + 192) = 0;
  uint64_t v61 = *(unsigned int *)(a2 + 120);
  if (v61 + v60 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), v61 + v60, 16);
    LODWORD(v61) = *(_DWORD *)(a2 + 120);
  }
  if (v60)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v61), v59, 16 * v60);
    LODWORD(v61) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v61 + v60;
  unint64_t v62 = v114;
  uint64_t v63 = v115;
  unint64_t v96 = &v98;
  uint64_t v97 = 0x600000000;
  if (v118)
  {
    LODWORD(v64) = 0;
    unint64_t v65 = (unint64_t)v118 << 6;
    int64x2_t v66 = (uint64_t *)(v117 + 40);
    do
    {
      uint64_t v67 = *v66;
      if (v64 >= HIDWORD(v97))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v96, &v98, v64 + 1, 8);
        LODWORD(v64) = v97;
      }
      *((void *)v96 + v64) = v67;
      uint64_t v64 = (v97 + 1);
      LODWORD(v97) = v97 + 1;
      v66 += 8;
      v65 -= 64;
    }
    while (v65);
    unint64_t v68 = (uint64_t *)v96;
  }
  else
  {
    uint64_t v64 = 0;
    unint64_t v68 = &v98;
  }
  mlir::function_interface_impl::addArgAndResultAttrs(v13, a2, v68, v64, v62, v63, a7, a8);
  if (v96 != &v98) {
    free(v96);
  }
  uint64_t v69 = (void *)mlir::OperationState::addRegion((mlir::OperationState *)a2);
  uint64_t v70 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)a1 + 40))(a1);
  unsigned __int16 v71 = (*(uint64_t (**)(mlir::AsmParser *, void *, char *, void, void))(*(void *)a1 + 752))(a1, v69, v117, v118, 0);
  if (v71 < 0x100u) {
    goto LABEL_100;
  }
  if (!(_BYTE)v71)
  {
    uint64_t v17 = 0;
    goto LABEL_71;
  }
  if ((void *)*v69 != v69)
  {
LABEL_100:
    uint64_t v17 = 1;
    goto LABEL_71;
  }
  unint64_t v87 = (const void **)"expected non-empty function body";
  __int16 v90 = 259;
  (*(void (**)(void **__return_ptr, mlir::AsmParser *, uint64_t, const void ***))(*(void *)a1 + 24))(&v96, a1, v70, &v87);
  uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v96);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v96);
LABEL_71:
  int v57 = __src;
  if (__src != v93) {
LABEL_72:
  }
    free(v57);
LABEL_73:
  if (v108 != v110) {
    free(v108);
  }
  if (SHIBYTE(v83) < 0) {
    operator delete(v81);
  }
LABEL_77:
  if (v111 != v113) {
    free(v111);
  }
  if (v114 != (void **)v116) {
    free(v114);
  }
  if (v117 != (char *)v119) {
    free(v117);
  }
  return v17;
}

llvm::raw_ostream *mlir::function_interface_impl::printFunctionSignature(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, char a6, void *a7, unint64_t a8)
{
  v61[0] = a2;
  v61[1] = a3;
  unint64_t v14 = *(unsigned int *)(a2 + 44);
  if ((v14 & 0x7FFFFF) != 0) {
    unsigned int v15 = (void *)(((a2 + 16 * ((v14 >> 23) & 1) + ((v14 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
  }
                   + 32 * *(unsigned int *)(a2 + 40));
  else {
    unsigned int v15 = 0;
  }
  unsigned int v16 = (void *)*v15;
  uint64_t v17 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  unint64_t v18 = (unsigned char *)*((void *)v17 + 4);
  if ((unint64_t)v18 >= *((void *)v17 + 3))
  {
    llvm::raw_ostream::write(v17, 40);
    uint64_t ArgAttrsAttr = mlir::FunctionOpInterface::getArgAttrsAttr((mlir::FunctionOpInterface *)v61);
    uint64_t v60 = ArgAttrsAttr;
    uint64_t v20 = a5;
    if (!a5) {
      goto LABEL_26;
    }
  }
  else
  {
    *((void *)v17 + 4) = v18 + 1;
    unsigned char *v18 = 40;
    uint64_t ArgAttrsAttr = mlir::FunctionOpInterface::getArgAttrsAttr((mlir::FunctionOpInterface *)v61);
    uint64_t v60 = ArgAttrsAttr;
    uint64_t v20 = a5;
    if (!a5) {
      goto LABEL_26;
    }
  }
  if (v16 != v15)
  {
    if (ArgAttrsAttr)
    {
      uint64_t v63 = *(void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
      uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
      uint64_t v23 = v22;
    }
    else
    {
      uint64_t v23 = 0;
      uint64_t Value = 0;
    }
    uint64_t v31 = v15[1];
    if (v31) {
      uint64_t v32 = v31 - 8;
    }
    else {
      uint64_t v32 = 0;
    }
    (*(void (**)(uint64_t, void, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, **(void **)(v32 + 48), Value, v23, 0);
    if (v20 == 1) {
      goto LABEL_26;
    }
    uint64_t v35 = 1;
    while (1)
    {
      unsigned int v41 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      unsigned int v42 = (_WORD *)*((void *)v41 + 4);
      if (*((void *)v41 + 3) - (void)v42 > 1uLL)
      {
        *unsigned int v42 = 8236;
        *((void *)v41 + 4) += 2;
        if (!v60) {
          goto LABEL_39;
        }
      }
      else
      {
        llvm::raw_ostream::write(v41, ", ", 2uLL);
        if (!v60)
        {
LABEL_39:
          uint64_t v38 = 0;
          uint64_t v36 = 0;
          goto LABEL_33;
        }
      }
      uint64_t v63 = *(void *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60) + 8 * v35);
      uint64_t v36 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
      uint64_t v38 = v37;
LABEL_33:
      uint64_t v39 = v15[1];
      if (v39) {
        uint64_t v40 = v39 - 8;
      }
      else {
        uint64_t v40 = 0;
      }
      (*(void (**)(uint64_t, void, uint64_t, uint64_t, void))(*(void *)a1 + 152))(a1, *(void *)(*(void *)(v40 + 48) + 8 * v35++), v36, v38, 0);
      if (v20 == v35) {
        goto LABEL_26;
      }
    }
  }
  (*(void (**)(uint64_t, void))(*(void *)a1 + 32))(a1, *a4);
  if (v60)
  {
    uint64_t v63 = *(void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60);
    uint64_t v24 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
    (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)a1 + 192))(a1, v24, v25, 0, 0);
  }
  if (v20 != 1)
  {
    for (uint64_t i = 1; i != v20; ++i)
    {
      uint64_t v27 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      uint64_t v28 = (_WORD *)*((void *)v27 + 4);
      if (*((void *)v27 + 3) - (void)v28 >= 2uLL)
      {
        _WORD *v28 = 8236;
        *((void *)v27 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v27, ", ", 2uLL);
      }
      (*(void (**)(uint64_t, void))(*(void *)a1 + 32))(a1, a4[i]);
      if (v60)
      {
        uint64_t v63 = *(void *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v60) + 8 * i);
        uint64_t v29 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
        (*(void (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)a1 + 192))(a1, v29, v30, 0, 0);
      }
    }
  }
LABEL_26:
  if (a6)
  {
    if (a5)
    {
      BOOL v33 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      uint64_t v34 = (_WORD *)*((void *)v33 + 4);
      if (*((void *)v33 + 3) - (void)v34 > 1uLL)
      {
        _WORD *v34 = 8236;
        *((void *)v33 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v33, ", ", 2uLL);
      }
    }
    size_t v43 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
    uint64_t v44 = *((void *)v43 + 4);
    if ((unint64_t)(*((void *)v43 + 3) - v44) > 2)
    {
      *(unsigned char *)(v44 + 2) = 46;
      *(_WORD *)uint64_t v44 = 11822;
      *((void *)v43 + 4) += 3;
    }
    else
    {
      llvm::raw_ostream::write(v43, "...", 3uLL);
    }
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v46 = (unsigned char *)*((void *)result + 4);
  if ((unint64_t)v46 >= *((void *)result + 3))
  {
    uint64_t result = llvm::raw_ostream::write(result, 41);
    if (!a8) {
      return result;
    }
  }
  else
  {
    *((void *)result + 4) = v46 + 1;
    *uint64_t v46 = 41;
    if (!a8) {
      return result;
    }
  }
  uint64_t v47 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v48 = (_DWORD *)*((void *)v47 + 4);
  if (*((void *)v47 + 3) - (void)v48 > 3uLL)
  {
    *uint64_t v48 = 540945696;
    *((void *)v47 + 4) += 4;
  }
  else
  {
    llvm::raw_ostream::write(v47, " -> ", 4uLL);
  }
  uint64_t ResAttrsAttr = mlir::FunctionOpInterface::getResAttrsAttr((mlir::FunctionOpInterface *)v61);
  uint64_t v62 = ResAttrsAttr;
  unint64_t v50 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  if (a8 > 1
    || *(_UNKNOWN **)(*(void *)*a7 + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id
    || ResAttrsAttr
    && (uint64_t v63 = *(void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62),
        mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v63)))
  {
    unint64_t v51 = (unsigned char *)*((void *)v50 + 4);
    if ((unint64_t)v51 >= *((void *)v50 + 3))
    {
      llvm::raw_ostream::write(v50, 40);
    }
    else
    {
      *((void *)v50 + 4) = v51 + 1;
      unsigned char *v51 = 40;
    }
    int v52 = 1;
  }
  else
  {
    int v52 = 0;
  }
  uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 32))(a1, *a7);
  if (v62)
  {
    uint64_t v63 = *(void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62);
    uint64_t v53 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
    uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)a1 + 192))(a1, v53, v54, 0, 0);
  }
  if (a8 != 1)
  {
    uint64_t v56 = 1;
    do
    {
      int v57 = (_WORD *)*((void *)v50 + 4);
      if (*((void *)v50 + 3) - (void)v57 > 1uLL)
      {
        *int v57 = 8236;
        *((void *)v50 + 4) += 2;
      }
      else
      {
        llvm::raw_ostream::write(v50, ", ", 2uLL);
      }
      uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, void))(*(void *)a1 + 32))(a1, a7[v56]);
      if (v62)
      {
        uint64_t v63 = *(void *)(mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v62) + 8 * v56);
        uint64_t v58 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v63);
        uint64_t result = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, void))(*(void *)a1 + 192))(a1, v58, v59, 0, 0);
      }
      ++v56;
    }
    while (a8 != v56);
  }
  if (v52)
  {
    unint64_t v55 = (unsigned char *)*((void *)v50 + 4);
    if ((unint64_t)v55 >= *((void *)v50 + 3))
    {
      return llvm::raw_ostream::write(v50, 41);
    }
    else
    {
      *((void *)v50 + 4) = v55 + 1;
      *unint64_t v55 = 41;
    }
  }
  return result;
}

void mlir::function_interface_impl::printFunctionAttributes(uint64_t a1, unsigned char *a2, const void *a3, uint64_t a4)
{
  v17[16] = *MEMORY[0x1E4F143B8];
  unsigned int v15 = v17;
  v17[0] = "sym_name";
  v17[1] = 8;
  uint64_t v16 = 0x800000001;
  unint64_t v8 = ((16 * a4) >> 4) + 1;
  if (v8 < 9)
  {
    unsigned int v9 = 1;
    size_t v10 = 16 * a4;
    if (!a4) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v15, v17, v8, 16);
  unsigned int v9 = v16;
  size_t v10 = 16 * a4;
  if (a4)
  {
LABEL_5:
    memcpy((char *)v15 + 16 * v9, a3, v10);
    unsigned int v9 = v16;
  }
LABEL_6:
  LODWORD(v16) = v9 + (v10 >> 4);
  if (a2[47])
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(a2 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  (*(void (**)(uint64_t, uint64_t, uint64_t, void *, void))(*(void *)a1 + 200))(a1, Value, v13, v15, v16);
  if (v15 != v17) {
    free(v15);
  }
}

void mlir::function_interface_impl::printFunctionOp(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  v49[8] = *MEMORY[0x1E4F143B8];
  uint64_t v47 = a2;
  uint64_t v48 = a3;
  uint64_t v45 = a8;
  uint64_t v46 = a7;
  if (*(unsigned char *)(a2 + 47))
  {
    uint64_t InherentAttr = mlir::Operation::getInherentAttr(a2, (uint64_t)"sym_name", 8);
    if (v14)
    {
      if (InherentAttr) {
        goto LABEL_4;
      }
LABEL_8:
      uint64_t v15 = 0;
      goto LABEL_9;
    }
  }
  uint64_t InherentAttr = mlir::DictionaryAttr::get(a2 + 56, "sym_name", 8uLL);
  if (!InherentAttr) {
    goto LABEL_8;
  }
LABEL_4:
  if (*(_UNKNOWN **)(*(void *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
    uint64_t v15 = InherentAttr;
  }
  else {
    uint64_t v15 = 0;
  }
LABEL_9:
  v49[0] = v15;
  uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
  uint64_t v18 = v17;
  uint64_t v19 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v20 = (unsigned char *)*((void *)v19 + 4);
  if ((unint64_t)v20 >= *((void *)v19 + 3))
  {
    llvm::raw_ostream::write(v19, 32);
    if (!*(unsigned char *)(a2 + 47))
    {
LABEL_14:
      uint64_t v21 = mlir::DictionaryAttr::get(a2 + 56, "sym_visibility", 0xEuLL);
      goto LABEL_15;
    }
  }
  else
  {
    *((void *)v19 + 4) = v20 + 1;
    *uint64_t v20 = 32;
    if (!*(unsigned char *)(a2 + 47)) {
      goto LABEL_14;
    }
  }
  uint64_t v21 = mlir::Operation::getInherentAttr(a2, (uint64_t)"sym_visibility", 14);
  if (!v22) {
    goto LABEL_14;
  }
LABEL_15:
  if (v21)
  {
    uint64_t v23 = *(void **)(*(void *)v21 + 136);
    BOOL v24 = v23 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id;
    uint64_t v25 = v23 == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id ? v21 : 0;
    v49[0] = v25;
    if (v24)
    {
      size_t v26 = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v49);
      size_t v28 = v27;
      uint64_t v29 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      uint64_t v30 = (void *)*((void *)v29 + 4);
      if (v28 <= *((void *)v29 + 3) - (void)v30)
      {
        if (v28)
        {
          memcpy(v30, v26, v28);
          *((void *)v29 + 4) += v28;
        }
      }
      else
      {
        llvm::raw_ostream::write(v29, (const char *)v26, v28);
      }
      uint64_t v31 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
      uint64_t v32 = (unsigned char *)*((void *)v31 + 4);
      if ((unint64_t)v32 >= *((void *)v31 + 3))
      {
        llvm::raw_ostream::write(v31, 32);
      }
      else
      {
        *((void *)v31 + 4) = v32 + 1;
        unsigned char *v32 = 32;
      }
    }
  }
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)a1 + 72))(a1, AttrData, v18);
  Argument__n128 Types = (void *)mlir::FunctionOpInterface::getArgumentTypes((mlir::FunctionOpInterface *)&v47);
  uint64_t v35 = v34;
  Result__n128 Types = (void *)mlir::FunctionOpInterface::getResultTypes((mlir::FunctionOpInterface *)&v47);
  mlir::function_interface_impl::printFunctionSignature(a1, v47, v48, ArgumentTypes, v35, a4, ResultTypes, v37);
  uint64_t v38 = (unsigned char *)v47;
  v49[0] = "sym_visibility";
  v49[1] = 14;
  v49[2] = a5;
  v49[3] = a6;
  v49[4] = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v46);
  v49[5] = v39;
  v49[6] = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v45);
  v49[7] = v40;
  mlir::function_interface_impl::printFunctionAttributes(a1, v38, v49, 4);
  unint64_t v41 = *(unsigned int *)(v47 + 44);
  if ((v41 & 0x7FFFFF) != 0)
  {
    unsigned int v42 = (void *)(((v47 + 16 * ((v41 >> 23) & 1) + ((v41 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                   + 32 * *(unsigned int *)(v47 + 40));
    if ((void *)*v42 == v42) {
      return;
    }
  }
  else
  {
    unsigned int v42 = 0;
    if (!MEMORY[0]) {
      return;
    }
  }
  size_t v43 = (llvm::raw_ostream *)(*(uint64_t (**)(uint64_t))(*(void *)a1 + 16))(a1);
  uint64_t v44 = (unsigned char *)*((void *)v43 + 4);
  if ((unint64_t)v44 >= *((void *)v43 + 3))
  {
    llvm::raw_ostream::write(v43, 32);
  }
  else
  {
    *((void *)v43 + 4) = v44 + 1;
    *uint64_t v44 = 32;
  }
  (*(void (**)(uint64_t, void *, void, uint64_t, void))(*(void *)a1 + 224))(a1, v42, 0, 1, 0);
}

uint64_t llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<parseFunctionArgumentList(mlir::OpAsmParser &,BOOL,llvm::SmallVectorImpl<mlir::OpAsmParser::Argument> &,BOOL &)::$_0>(uint64_t a1)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (**(unsigned char **)a1)
  {
    uint64_t v2 = *(void *)(a1 + 8);
    uint64_t v3 = (*(uint64_t (**)(uint64_t))(*(void *)v2 + 40))(v2);
    v43[0] = "variadic arguments must be in the end of the argument list";
    LOWORD(v44) = 259;
    (*(void (**)(void **__return_ptr, uint64_t, uint64_t, void *))(*(void *)v2 + 24))(v47, v2, v3, v43);
    uint64_t v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
    if (v47[0]) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (v55)
    {
      uint64_t v5 = (void **)__p;
      if (__p)
      {
        unsigned int v6 = v54;
        unsigned int v7 = __p;
        if (v54 != __p)
        {
          do
            unsigned int v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
          while (v6 != v5);
          unsigned int v7 = __p;
        }
        uint64_t v54 = v5;
        operator delete(v7);
      }
      unint64_t v8 = v51;
      if (!v51) {
        goto LABEL_55;
      }
      unsigned int v9 = v52;
      size_t v10 = v51;
      if (v52 == v51)
      {
LABEL_54:
        int v52 = v8;
        operator delete(v10);
LABEL_55:
        if (v49 != v50) {
          free(v49);
        }
        return v4;
      }
      do
      {
        uint64_t v12 = (void *)*--v9;
        uint64_t v11 = v12;
        *unsigned int v9 = 0;
        if (v12) {
          operator delete[](v11);
        }
      }
      while (v9 != v8);
LABEL_53:
      size_t v10 = v51;
      goto LABEL_54;
    }
    return v4;
  }
  if (**(unsigned char **)(a1 + 16)
    && (*(unsigned __int8 (**)(void))(**(void **)(a1 + 8) + 336))(*(void *)(a1 + 8)))
  {
    uint64_t v13 = *(unsigned char **)a1;
    uint64_t v4 = 1;
    unsigned char *v13 = 1;
    return v4;
  }
  memset(v43, 0, 24);
  v46[8] = 0;
  uint64_t v44 = 0;
  unint64_t Dictionary = 0;
  v46[0] = 0;
  unsigned __int16 v14 = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 728))();
  if (v14 >= 0x100u)
  {
    if ((_BYTE)v14)
    {
      uint64_t v23 = *(void *)(a1 + 24);
      uint64_t v24 = *(unsigned int *)(v23 + 8);
      if (v24 && !*(void *)(*(void *)v23 + (v24 << 6) - 48))
      {
        (*(void (**)(void **__return_ptr))(**(void **)(a1 + 8) + 24))(v47);
        uint64_t v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0]) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        }
        if (v55)
        {
          uint64_t v25 = (void **)__p;
          if (__p)
          {
            size_t v26 = v54;
            size_t v27 = __p;
            if (v54 != __p)
            {
              do
                size_t v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
              while (v26 != v25);
              size_t v27 = __p;
            }
            uint64_t v54 = v25;
            operator delete(v27);
          }
          unint64_t v8 = v51;
          if (!v51) {
            goto LABEL_55;
          }
          size_t v28 = v52;
          size_t v10 = v51;
          if (v52 == v51) {
            goto LABEL_54;
          }
          do
          {
            uint64_t v30 = (void *)*--v28;
            uint64_t v29 = v30;
            void *v28 = 0;
            if (v30) {
              operator delete[](v29);
            }
          }
          while (v28 != v8);
          goto LABEL_53;
        }
        return v4;
      }
LABEL_63:
      unint64_t v32 = *(void *)v23;
      BOOL v33 = (char *)v43;
      if (v24 >= *(_DWORD *)(v23 + 12))
      {
        uint64_t v39 = (unint64_t *)v23;
        unint64_t v40 = v24 + 1;
        BOOL v41 = v32 + ((unint64_t)v24 << 6) > (unint64_t)v43;
        if (v32 <= (unint64_t)v43 && v41)
        {
          unsigned int v42 = (char *)v43 - v32;
          llvm::SmallVectorBase<unsigned int>::grow_pod(v23, (void *)(v23 + 16), v40, 64);
          uint64_t v23 = (uint64_t)v39;
          unint64_t v32 = *v39;
          BOOL v33 = &v42[*v39];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(v23, (void *)(v23 + 16), v40, 64);
          uint64_t v23 = (uint64_t)v39;
          unint64_t v32 = *v39;
          BOOL v33 = (char *)v43;
        }
      }
      uint64_t v34 = (_OWORD *)(v32 + ((unint64_t)*(unsigned int *)(v23 + 8) << 6));
      long long v35 = *(_OWORD *)v33;
      long long v36 = *((_OWORD *)v33 + 1);
      long long v37 = *((_OWORD *)v33 + 3);
      v34[2] = *((_OWORD *)v33 + 2);
      v34[3] = v37;
      _OWORD *v34 = v35;
      v34[1] = v36;
      ++*(_DWORD *)(v23 + 8);
      return 1;
    }
    return 0;
  }
  v43[0] = (*(uint64_t (**)(void))(**(void **)(a1 + 8) + 40))(*(void *)(a1 + 8));
  uint64_t v15 = *(void *)(a1 + 24);
  uint64_t v16 = *(unsigned int *)(v15 + 8);
  if (!v16 || !*(void *)(*(void *)v15 + (v16 << 6) - 48))
  {
    v47[0] = &v48;
    v47[1] = (void *)0x400000000;
    v50[5] = 4;
    if ((*(unsigned __int8 (**)(void, uint64_t *))(**(void **)(a1 + 8) + 504))(*(void *)(a1 + 8), &v44)&& (*(unsigned __int8 (**)(void, void **))(**(void **)(a1 + 8) + 456))(*(void *)(a1 + 8), v47)&& (*(unsigned __int8 (**)(void, unsigned char *))(**(void **)(a1 + 8) + 624))(*(void *)(a1 + 8), v46))
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(*(mlir::AsmParser **)(a1 + 8));
      unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v47, Context);
      if (v47[0] != &v48) {
        free(v47[0]);
      }
      uint64_t v23 = *(void *)(a1 + 24);
      LODWORD(v24) = *(_DWORD *)(v23 + 8);
      goto LABEL_63;
    }
    if (v47[0] != &v48) {
      free(v47[0]);
    }
    return 0;
  }
  (*(void (**)(void **__return_ptr))(**(void **)(a1 + 8) + 24))(v47);
  uint64_t v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
  if (v47[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
  }
  if (v55)
  {
    uint64_t v17 = (void **)__p;
    if (__p)
    {
      uint64_t v18 = v54;
      uint64_t v19 = __p;
      if (v54 != __p)
      {
        do
          uint64_t v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        uint64_t v19 = __p;
      }
      uint64_t v54 = v17;
      operator delete(v19);
    }
    unint64_t v8 = v51;
    if (!v51) {
      goto LABEL_55;
    }
    uint64_t v20 = v52;
    size_t v10 = v51;
    if (v52 == v51) {
      goto LABEL_54;
    }
    do
    {
      char v22 = (void *)*--v20;
      uint64_t v21 = v22;
      *uint64_t v20 = 0;
      if (v22) {
        operator delete[](v21);
      }
    }
    while (v20 != v8);
    goto LABEL_53;
  }
  return v4;
}

uint64_t llvm::function_ref<mlir::ParseResult ()(void)>::callback_fn<parseFunctionResultList(mlir::OpAsmParser &,llvm::SmallVectorImpl<mlir::Type> &,llvm::SmallVectorImpl<mlir::DictionaryAttr> &)::$_0>(uint64_t *a1)
{
  v11[9] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *a1;
  uint64_t v3 = *(unsigned int *)(*a1 + 8);
  if (v3 >= *(_DWORD *)(*a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(*a1, (void *)(v2 + 16), v3 + 1, 8);
    *(void *)(*(void *)v2 + 8 * (*(_DWORD *)(v2 + 8))++) = 0;
    uint64_t v4 = a1[1];
    uint64_t v5 = *(unsigned int *)(v4 + 8);
    if (v5 < *(_DWORD *)(v4 + 12)) {
      goto LABEL_3;
    }
LABEL_12:
    llvm::SmallVectorBase<unsigned int>::grow_pod(v4, (void *)(v4 + 16), v5 + 1, 8);
    *(void *)(*(void *)v4 + 8 * *(unsigned int *)(v4 + 8)) = 0;
    LODWORD(v5) = *(_DWORD *)(v4 + 8);
    goto LABEL_4;
  }
  *(void *)(*(void *)v2 + 8 * v3) = 0;
  *(_DWORD *)(v2 + 8) = v3 + 1;
  uint64_t v4 = a1[1];
  uint64_t v5 = *(unsigned int *)(v4 + 8);
  if (v5 >= *(_DWORD *)(v4 + 12)) {
    goto LABEL_12;
  }
LABEL_3:
  *(void *)(*(void *)v4 + 8 * v5) = 0;
LABEL_4:
  *(_DWORD *)(v4 + 8) = v5 + 1;
  v10[0] = v11;
  v10[1] = (void *)0x400000000;
  v11[8] = 4;
  if ((*(unsigned __int8 (**)(void))(*(void *)a1[2] + 504))()
    && (*(unsigned __int8 (**)(uint64_t, void **))(*(void *)a1[2] + 456))(a1[2], v10))
  {
    uint64_t Context = (mlir::MLIRContext *)mlir::AsmParser::getContext((mlir::AsmParser *)a1[2]);
    *(void *)(*(void *)a1[1] + 8 * *(unsigned int *)(a1[1] + 8) - 8) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v10, Context);
    uint64_t v7 = 1;
    unint64_t v8 = v10[0];
    if (v10[0] == v11) {
      return v7;
    }
    goto LABEL_9;
  }
  uint64_t v7 = 0;
  unint64_t v8 = v10[0];
  if (v10[0] != v11) {
LABEL_9:
  }
    free(v8);
  return v7;
}

uint64_t mlir::AsmParser::parseSymbolName(mlir::AsmParser *this, mlir::StringAttr *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned __int8 (**)(mlir::AsmParser *, mlir::StringAttr *))(*(void *)this + 496))(this, a2)) {
    return 1;
  }
  uint64_t v5 = (*(uint64_t (**)(mlir::AsmParser *))(*(void *)this + 40))(this);
  __int16 v21 = 257;
  (*(void (**)(void *__return_ptr, mlir::AsmParser *, uint64_t, char *))(*(void *)this + 24))(v25, this, v5, v20);
  if (v25[0])
  {
    int v22 = 3;
    uint64_t v23 = "expected valid '@'-identifier for symbol name";
    uint64_t v24 = 45;
    unsigned int v6 = &v22;
    uint64_t v7 = (char *)v26;
    if (v27 >= v28)
    {
      unint64_t v18 = v27 + 1;
      if (v26 <= &v22 && (char *)v26 + 24 * v27 > (char *)&v22)
      {
        int64_t v19 = (char *)&v22 - (unsigned char *)v26;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v29, v18, 24);
        uint64_t v7 = (char *)v26;
        unsigned int v6 = (int *)((char *)v26 + v19);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v29, v18, 24);
        unsigned int v6 = &v22;
        uint64_t v7 = (char *)v26;
      }
    }
    unint64_t v8 = &v7[24 * v27];
    long long v9 = *(_OWORD *)v6;
    *((void *)v8 + 2) = *((void *)v6 + 2);
    *(_OWORD *)unint64_t v8 = v9;
    ++v27;
  }
  uint64_t v3 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v25);
  if (v25[0]) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v25);
  }
  if (v34)
  {
    size_t v10 = (void **)__p;
    if (__p)
    {
      uint64_t v11 = v33;
      uint64_t v12 = __p;
      if (v33 != __p)
      {
        do
          uint64_t v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        uint64_t v12 = __p;
      }
      BOOL v33 = v10;
      operator delete(v12);
    }
    uint64_t v13 = v30;
    if (v30)
    {
      unsigned __int16 v14 = v31;
      uint64_t v15 = v30;
      if (v31 != v30)
      {
        do
        {
          uint64_t v17 = (void *)*--v14;
          uint64_t v16 = v17;
          void *v14 = 0;
          if (v17) {
            operator delete[](v16);
          }
        }
        while (v14 != v13);
        uint64_t v15 = v30;
      }
      uint64_t v31 = v13;
      operator delete(v15);
    }
    if (v26 != v29) {
      free(v26);
    }
  }
  return v3;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void *a1)
{
  uint64_t result = a1[32];
  if (!result)
  {
    uint64_t v3 = operator new(0x10uLL);
    void *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v13;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v13;
    uint64_t v4 = &unk_1E8EBA000;
    {
      uint64_t v4 = (void *)&unk_1E8EBA000;
      if (v5)
      {
        uint64_t v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties]";
        unint64_t v14 = 106;
        unint64_t v6 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
        if (v14 >= v6) {
          unint64_t v7 = v6;
        }
        else {
          unint64_t v7 = v14;
        }
        unint64_t v8 = &v13[v7];
        unint64_t v9 = v14 - v7;
        if (v14 - v7 >= 0x12) {
          uint64_t v10 = 18;
        }
        else {
          uint64_t v10 = v14 - v7;
        }
        unint64_t v11 = v9 - v10;
        if (v11 >= v11 - 1) {
          uint64_t v12 = v11 - 1;
        }
        else {
          uint64_t v12 = v11;
        }
        mlir::detail::TypeIDResolver<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
        uint64_t v4 = (void *)&unk_1E8EBA000;
      }
    }
    a1[33] = v4[103];
    return a1[32];
  }
  return result;
}

void mlir::ub::PoisonOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    unint64_t v9 = (void *)mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>((void *)a2);
    *unint64_t v9 = a4;
    v9[1] = a5;
  }
  uint64_t v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v10) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void *llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<void mlir::StorageUniquer::registerSingletonStorageType<mlir::AttributeStorage>(mlir::TypeID,llvm::function_ref<void ()(mlir::AttributeStorage *)>)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(void (***a1)(void, void *), uint64_t *a2)
{
  a2[10] += 8;
  uint64_t v4 = *a2;
  unint64_t v5 = ((*a2 + 7) & 0xFFFFFFFFFFFFFFF8) - *a2;
  if (*a2) {
    BOOL v6 = v5 + 8 > a2[1] - *a2;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    unsigned int v7 = *((_DWORD *)a2 + 6) >> 7;
    if (v7 >= 0x1E) {
      LOBYTE(v7) = 30;
    }
    uint64_t v8 = 4096 << v7;
    buffer = (char *)llvm::allocate_buffer(4096 << v7, (std::align_val_t)8uLL);
    uint64_t v10 = *((unsigned int *)a2 + 6);
    if (v10 >= *((_DWORD *)a2 + 7))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(a2 + 2), a2 + 4, v10 + 1, 8);
      LODWORD(v10) = *((_DWORD *)a2 + 6);
    }
    *(void *)(a2[2] + 8 * v10) = buffer;
    ++*((_DWORD *)a2 + 6);
    a2[1] = (uint64_t)&buffer[v8];
    unint64_t v11 = (void *)((unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8);
    void *v11 = 0;
    *a2 = (uint64_t)(v11 + 1);
    uint64_t v12 = *a1;
    uint64_t v13 = **a1;
    if (v13) {
      goto LABEL_13;
    }
  }
  else
  {
    unint64_t v11 = (void *)(v4 + v5);
    unint64_t v14 = (void *)(v4 + v5);
    void *v14 = 0;
    *a2 = (uint64_t)(v14 + 1);
    uint64_t v12 = *a1;
    uint64_t v13 = **a1;
    if (v13) {
LABEL_13:
    }
      v13(v12[1], v11);
  }
  return v11;
}

void llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>(int a1, void *__p)
{
  if (__p) {
    operator delete(__p);
  }
}

__n128 llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::ub::detail::PoisonOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result = *a3;
  *a2 = *a3;
  return result;
}

uint64_t mlir::AffineExpr::getKind(mlir::AffineExpr *this)
{
  return *(unsigned int *)(*(void *)this + 8);
}

uint64_t mlir::AffineExpr::walk(void *a1, void *a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void *)a2[3];
  if (!v3)
  {
    BOOL v6 = 0;
    goto LABEL_5;
  }
  if (v3 != a2)
  {
    BOOL v6 = (void *)a2[3];
    a2[3] = 0;
    goto LABEL_7;
  }
  BOOL v6 = v5;
  (*(void (**)(void *, void *))(*a2 + 24))(a2, v5);
  uint64_t v3 = v6;
  if (!v6)
  {
LABEL_5:
    uint64_t v8 = 0;
    goto LABEL_10;
  }
LABEL_7:
  if (v3 == v5)
  {
    uint64_t v8 = v7;
    (*(void (**)(void *, void *))(v5[0] + 24))(v5, v7);
  }
  else
  {
    uint64_t v8 = v3;
    BOOL v6 = 0;
  }
LABEL_10:
  ((void (*)(void *, void))mlir::AffineExprVisitor<mlir::AffineExpr::walk(std::function<void ()(mlir::AffineExpr)>)::AffineExprWalker,void>::walkPostOrder)(v7, *a1);
  if (v8 != v7)
  {
    if (v8) {
      (*(void (**)(void))(*v8 + 40))();
    }
    uint64_t result = (uint64_t)v6;
    if (v6 != v5) {
      goto LABEL_14;
    }
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
  (*(void (**)(void *))(v7[0] + 32))(v7);
  uint64_t result = (uint64_t)v6;
  if (v6 == v5) {
    return (*(uint64_t (**)(void *))(v5[0] + 32))(v5);
  }
LABEL_14:
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 40))(result);
  }
  return result;
}

uint64_t mlir::getAffineBinaryOpExpr(int a1, mlir::MLIRContext **a2, uint64_t a3)
{
  uint64_t v4 = a2;
  switch(a1)
  {
    case 0:
      uint64_t result = mlir::AffineExpr::operator+((unint64_t *)&v4, a3);
      break;
    case 1:
      uint64_t result = mlir::AffineExpr::operator*((unint64_t *)&v4, a3);
      break;
    case 3:
      uint64_t result = mlir::AffineExpr::floorDiv(&v4, a3);
      break;
    case 4:
      uint64_t result = mlir::AffineExpr::ceilDiv((unint64_t *)&v4, a3);
      break;
    default:
      uint64_t result = mlir::AffineExpr::operator%((unint64_t *)&v4, a3);
      break;
  }
  return result;
}

uint64_t mlir::AffineExpr::operator+(unint64_t *a1, uint64_t a2)
{
  uint64_t v38 = a2;
  uint64_t v39 = a2;
  uint64_t v3 = *a1;
  uint64_t v40 = v3;
  int v4 = *(_DWORD *)(v3 + 8);
  if (v4 == 5) {
    uint64_t v5 = v3;
  }
  else {
    uint64_t v5 = 0;
  }
  int v6 = *(_DWORD *)(a2 + 8);
  if (v6 == 5) {
    uint64_t v7 = a2;
  }
  else {
    uint64_t v7 = 0;
  }
  if (v5) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    if (v4 == 5
      || mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v40)
      && (mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v39) & 1) == 0)
    {
      uint64_t v3 = mlir::AffineExpr::operator+(&v39, v3);
      if (v3) {
        return v3;
      }
      goto LABEL_29;
    }
    if (v7)
    {
      uint64_t v10 = *(void *)(v7 + 16);
      if (!v10) {
        return v3;
      }
      if (v4 <= 4 && v3 != 0)
      {
        int v12 = *(_DWORD *)(v3 + 8);
        if (!v12)
        {
          uint64_t v13 = *(void *)(v3 + 24);
          uint64_t v14 = 1;
          int v15 = 1;
          if (v13)
          {
            uint64_t v16 = v3;
            uint64_t v17 = (mlir::MLIRContext **)v3;
            if (*(_DWORD *)(v13 + 8) == 5)
            {
              unsigned int v42 = *(mlir::MLIRContext ***)(v3 + 16);
              uint64_t v3 = mlir::AffineExpr::operator+(&v42, v10 + *(void *)(v13 + 16));
              if (v3) {
                return v3;
              }
LABEL_29:
              uint64_t v3 = *a1;
LABEL_30:
              AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(*(mlir::MLIRContext **)v3);
              LODWORD(v42) = 0;
              return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(AffineUniquer, 0, 0, &v42, a1, &v38);
            }
LABEL_48:
            if (v6 >= 5) {
              uint64_t v25 = 0;
            }
            else {
              uint64_t v25 = a2;
            }
            if (!v25) {
              goto LABEL_57;
            }
LABEL_52:
            if (*(_DWORD *)(v25 + 8) == 1)
            {
              uint64_t v26 = *(void *)(v25 + 24);
              if (v26 && *(_DWORD *)(v26 + 8) == 5)
              {
                uint64_t v28 = *(void *)(v26 + 16);
                if (v17 != *(mlir::MLIRContext ***)(v25 + 16)) {
                  goto LABEL_58;
                }
                goto LABEL_74;
              }
            }
LABEL_57:
            uint64_t v28 = 1;
            if (v17 != (mlir::MLIRContext **)a2)
            {
LABEL_58:
              if (v15)
              {
                if (!*(_DWORD *)(v16 + 8))
                {
                  uint64_t v35 = *(void *)(v16 + 24);
                  if (v35)
                  {
                    if (*(_DWORD *)(v35 + 8) == 5)
                    {
                      BOOL v41 = *(mlir::MLIRContext **)(v16 + 16);
                      unsigned int v42 = (mlir::MLIRContext **)mlir::AffineExpr::operator+(&v41, a2);
                      uint64_t v3 = mlir::AffineExpr::operator+(&v42, v35);
                      if (v3) {
                        return v3;
                      }
                      goto LABEL_29;
                    }
                  }
                }
              }
              if (!v25) {
                goto LABEL_30;
              }
              uint64_t v29 = *(void *)(v25 + 16);
              uint64_t v30 = *(void *)(v25 + 24);
              unsigned int v42 = (mlir::MLIRContext **)v30;
              if (*(int *)(v29 + 8) >= 5) {
                uint64_t v29 = 0;
              }
              if (v30 && *(_DWORD *)(v30 + 8) == 5 && *(void *)(v30 + 16) == -1)
              {
                if (!v29) {
                  goto LABEL_29;
                }
                int v31 = *(_DWORD *)(v29 + 8);
                if (v31 == 1)
                {
                  uint64_t v36 = *(void *)(v29 + 16);
                  if (v36) {
                    BOOL v37 = *(_DWORD *)(v36 + 8) == 3;
                  }
                  else {
                    BOOL v37 = 0;
                  }
                  if (!v37) {
                    goto LABEL_29;
                  }
                  uint64_t v32 = *(void *)(v29 + 24);
                  if (*(void *)(v36 + 24) != v32 || v3 != *(void *)(v36 + 16)) {
                    goto LABEL_29;
                  }
                  goto LABEL_71;
                }
              }
              else
              {
                if (!v29) {
                  goto LABEL_29;
                }
                int v31 = *(_DWORD *)(v29 + 8);
              }
              if (v31 != 3) {
                goto LABEL_29;
              }
              if (v3 != *(void *)(v29 + 16)) {
                goto LABEL_29;
              }
              uint64_t v32 = *(void *)(v29 + 24);
              if (v32 != mlir::AffineExpr::operator-((unint64_t *)&v42)) {
                goto LABEL_29;
              }
LABEL_71:
              uint64_t v3 = mlir::AffineExpr::operator%((unint64_t *)&v40, v32);
              if (v3) {
                return v3;
              }
              goto LABEL_29;
            }
LABEL_74:
            BOOL v41 = *(mlir::MLIRContext **)v3;
            unsigned int v42 = (mlir::MLIRContext **)(v28 + v14);
            BOOL v33 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v41);
            uint64_t v34 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v33, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v41, &v42);
            unsigned int v42 = v17;
            uint64_t v3 = mlir::AffineExpr::operator*((unint64_t *)&v42, v34);
            if (v3) {
              return v3;
            }
            goto LABEL_29;
          }
LABEL_80:
          uint64_t v16 = v3;
          uint64_t v17 = (mlir::MLIRContext **)v3;
          if (v6 >= 5) {
            uint64_t v25 = 0;
          }
          else {
            uint64_t v25 = a2;
          }
          if (!v25) {
            goto LABEL_57;
          }
          goto LABEL_52;
        }
        goto LABEL_38;
      }
    }
    else if (v4 <= 4 && v3 != 0)
    {
      int v12 = *(_DWORD *)(v3 + 8);
LABEL_38:
      if (v12 == 1)
      {
        uint64_t v24 = *(void *)(v3 + 24);
        uint64_t v14 = 1;
        int v15 = 1;
        if (v24)
        {
          uint64_t v16 = v3;
          uint64_t v17 = (mlir::MLIRContext **)v3;
          if (*(_DWORD *)(v24 + 8) == 5)
          {
            uint64_t v14 = *(void *)(v24 + 16);
            uint64_t v17 = *(mlir::MLIRContext ***)(v3 + 16);
            int v15 = 1;
            uint64_t v16 = v3;
            if (v6 >= 5) {
              uint64_t v25 = 0;
            }
            else {
              uint64_t v25 = a2;
            }
            if (!v25) {
              goto LABEL_57;
            }
            goto LABEL_52;
          }
          goto LABEL_48;
        }
        goto LABEL_80;
      }
      int v15 = 1;
      uint64_t v16 = v3;
LABEL_47:
      uint64_t v14 = 1;
      uint64_t v17 = (mlir::MLIRContext **)v3;
      goto LABEL_48;
    }
    uint64_t v16 = 0;
    int v15 = 0;
    goto LABEL_47;
  }
  unint64_t v18 = (mlir::MLIRContext **)(*(void *)(v7 + 16) + *(void *)(v5 + 16));
  BOOL v41 = *(mlir::MLIRContext **)v3;
  unsigned int v42 = v18;
  int64_t v19 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v41);
  uint64_t v20 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v19, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v41, &v42);
  uint64_t v3 = v20;
  if (!v20) {
    goto LABEL_29;
  }
  return v3;
}

uint64_t mlir::AffineExpr::operator*(unint64_t *a1, uint64_t a2)
{
  uint64_t v21 = a2;
  uint64_t v22 = a2;
  uint64_t v3 = *a1;
  int v4 = *(_DWORD *)(*a1 + 8);
  if (v4 == 5) {
    unint64_t v5 = *a1;
  }
  else {
    unint64_t v5 = 0;
  }
  if (*(_DWORD *)(a2 + 8) == 5) {
    uint64_t v6 = a2;
  }
  else {
    uint64_t v6 = 0;
  }
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    char isSymbolicOrConstant = mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v22);
    if (v4 != 5 && (isSymbolicOrConstant & 1) != 0)
    {
      if (v6)
      {
        uint64_t v10 = *(void *)(v6 + 16);
        if (!v10) {
          return a2;
        }
        if (v10 == 1) {
          return v3;
        }
        if (v4 != 1 || v3 == 0) {
          goto LABEL_29;
        }
        uint64_t v12 = *(void *)(v3 + 24);
        if (v12 && *(_DWORD *)(v12 + 8) == 5)
        {
          uint64_t v24 = *(mlir::MLIRContext ***)(v3 + 16);
          uint64_t v3 = mlir::AffineExpr::operator*(&v24, v10 * *(void *)(v12 + 16));
          if (v3) {
            return v3;
          }
LABEL_28:
          uint64_t v3 = *a1;
LABEL_29:
          AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(*(mlir::MLIRContext **)v3);
          LODWORD(v24) = 1;
          return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(AffineUniquer, 0, 0, &v24, a1, &v21);
        }
      }
      else if (v4 != 1 || v3 == 0)
      {
        goto LABEL_29;
      }
      uint64_t v19 = *(void *)(v3 + 24);
      if (v19) {
        BOOL v20 = *(_DWORD *)(v19 + 8) == 5;
      }
      else {
        BOOL v20 = 0;
      }
      if (!v20) {
        goto LABEL_29;
      }
      uint64_t v23 = *(mlir::MLIRContext **)(v3 + 16);
      uint64_t v24 = (mlir::MLIRContext **)mlir::AffineExpr::operator*(&v23, a2);
      uint64_t v3 = mlir::AffineExpr::operator*(&v24, v19);
      if (v3) {
        return v3;
      }
      goto LABEL_28;
    }
    uint64_t v3 = mlir::AffineExpr::operator*(&v22, v3);
    if (v3) {
      return v3;
    }
    goto LABEL_28;
  }
  uint64_t v13 = (mlir::MLIRContext **)(*(void *)(v6 + 16) * *(void *)(v5 + 16));
  uint64_t v23 = *(mlir::MLIRContext **)v3;
  uint64_t v24 = v13;
  uint64_t v14 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v23);
  uint64_t v15 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v14, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v24);
  uint64_t v3 = v15;
  if (!v15) {
    goto LABEL_28;
  }
  return v3;
}

uint64_t mlir::AffineExpr::floorDiv(mlir::MLIRContext ***a1, uint64_t a2)
{
  uint64_t v27 = a2;
  uint64_t v3 = (uint64_t)*a1;
  if (*((_DWORD *)*a1 + 2) == 5) {
    int v4 = *a1;
  }
  else {
    int v4 = 0;
  }
  if (!a2) {
    goto LABEL_27;
  }
  if (*(_DWORD *)(a2 + 8) != 5) {
    goto LABEL_27;
  }
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6 < 1) {
    goto LABEL_27;
  }
  if (v4)
  {
    BOOL v7 = v4[2];
    if (v7) {
      BOOL v8 = (unint64_t)v7 >> 63 == (unint64_t)v6 >> 63;
    }
    else {
      BOOL v8 = 1;
    }
    uint64_t v9 = (uint64_t)v7 / v6;
    uint64_t v10 = *(mlir::MLIRContext ***)v3;
    uint64_t v11 = (uint64_t)~(unint64_t)v7 / v6;
    if (v8) {
      uint64_t v12 = v9;
    }
    else {
      uint64_t v12 = ~v11;
    }
    uint64_t v29 = *(mlir::MLIRContext ***)v3;
    uint64_t v30 = v12;
    AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer((mlir::MLIRContext *)v10);
    uint64_t v14 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v29, &v30);
  }
  else
  {
    uint64_t v29 = *(mlir::MLIRContext ***)a2;
    uint64_t v30 = 1;
    uint64_t v15 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer((mlir::MLIRContext *)v29);
    if (mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v15, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v29, &v30) == a2)return v3; {
    int v16 = *(_DWORD *)(v3 + 8);
    }
    if (v16 > 4)
    {
LABEL_27:
      uint64_t v24 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(**a1);
      LODWORD(v30) = 3;
      return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(v24, 0, 0, &v30, (unint64_t *)a1, &v27);
    }
    if (v16)
    {
      if (v16 != 1) {
        goto LABEL_27;
      }
      uint64_t v17 = *(void *)(v3 + 24);
      if (!v17) {
        goto LABEL_27;
      }
      if (*(_DWORD *)(v17 + 8) != 5) {
        goto LABEL_27;
      }
      uint64_t v18 = *(void *)(v17 + 16);
      uint64_t v19 = *(void *)(a2 + 16);
      if (v18 % v19) {
        goto LABEL_27;
      }
      uint64_t v30 = *(void *)(v3 + 16);
      uint64_t v14 = mlir::AffineExpr::operator*((mlir::MLIRContext ***)&v30, v18 / v19);
    }
    else
    {
      BOOL v20 = *(mlir::MLIRContext ***)(v3 + 16);
      uint64_t v30 = (uint64_t)v20;
      uint64_t LargestKnownDivisor = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v30);
      uint64_t v30 = *(void *)(v3 + 24);
      uint64_t v22 = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v30);
      uint64_t v23 = *(void *)(a2 + 16);
      if (LargestKnownDivisor % v23 && v22 % v23) {
        goto LABEL_27;
      }
      uint64_t v29 = v20;
      uint64_t v30 = mlir::AffineExpr::floorDiv(&v29, v23);
      uint64_t v28 = *(mlir::MLIRContext ***)(v3 + 24);
      uint64_t v26 = mlir::AffineExpr::floorDiv(&v28, *(void *)(a2 + 16));
      uint64_t v14 = mlir::AffineExpr::operator+((unint64_t *)&v30, v26);
    }
  }
  uint64_t v3 = v14;
  if (!v14) {
    goto LABEL_27;
  }
  return v3;
}

uint64_t mlir::AffineExpr::ceilDiv(unint64_t *a1, uint64_t a2)
{
  uint64_t v21 = a2;
  uint64_t result = *a1;
  int v4 = *(_DWORD *)(result + 8);
  if (v4 == 5) {
    uint64_t v5 = result;
  }
  else {
    uint64_t v5 = 0;
  }
  if (!a2) {
    goto LABEL_23;
  }
  if (*(_DWORD *)(a2 + 8) != 5) {
    goto LABEL_23;
  }
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6 < 1) {
    goto LABEL_23;
  }
  if (!v5)
  {
    if (v6 == 1) {
      return result;
    }
    if (v4 != 1
      || ((v15 = *(void *)(result + 24)) != 0 ? (BOOL v16 = *(_DWORD *)(v15 + 8) == 5) : (BOOL v16 = 0),
          !v16 || (uint64_t v17 = *(void *)(v15 + 16), v17 % v6)))
    {
LABEL_23:
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(*(mlir::MLIRContext **)result);
      LODWORD(v24) = 4;
      return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(AffineUniquer, 0, 0, &v24, a1, &v21);
    }
    uint64_t v22 = *(mlir::MLIRContext ***)(result + 16);
    uint64_t v23 = *v22;
    uint64_t v24 = v17 / v6;
    uint64_t v18 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v23);
    uint64_t v19 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v18, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v24);
    uint64_t result = mlir::AffineExpr::operator*((unint64_t *)&v22, v19);
    if (result) {
      return result;
    }
LABEL_22:
    uint64_t result = *a1;
    goto LABEL_23;
  }
  uint64_t v7 = *(void *)(v5 + 16);
  unint64_t v8 = -v7;
  BOOL v9 = v7 < 1;
  unint64_t v10 = (v7 - 1) / (unint64_t)v6 + 1;
  uint64_t v11 = *(mlir::MLIRContext **)result;
  unint64_t v12 = v8 / v6;
  if (v9) {
    unint64_t v13 = -(uint64_t)v12;
  }
  else {
    unint64_t v13 = v10;
  }
  uint64_t v23 = v11;
  uint64_t v24 = v13;
  uint64_t v14 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v11);
  uint64_t result = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v14, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v24);
  if (!result) {
    goto LABEL_22;
  }
  return result;
}

uint64_t mlir::AffineExpr::operator%(unint64_t *a1, uint64_t a2)
{
  unint64_t v3 = *a1;
  uint64_t v17 = a2;
  unint64_t v18 = v3;
  int v4 = *(_DWORD *)(v3 + 8);
  if (v4 == 5) {
    unint64_t v5 = v3;
  }
  else {
    unint64_t v5 = 0;
  }
  if (!a2) {
    goto LABEL_27;
  }
  if (*(_DWORD *)(a2 + 8) != 5) {
    goto LABEL_27;
  }
  uint64_t v6 = *(void *)(a2 + 16);
  if (v6 < 1) {
    goto LABEL_27;
  }
  if (v5)
  {
    uint64_t v7 = *(mlir::MLIRContext **)v3;
    BOOL v20 = (mlir::MLIRContext **)((v6 & ((*(void *)(v5 + 16) % v6) >> 63)) + *(void *)(v5 + 16) % v6);
    goto LABEL_9;
  }
  if (!(mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v18) % v6))
  {
    uint64_t v7 = *(mlir::MLIRContext **)v3;
    BOOL v20 = 0;
LABEL_9:
    uint64_t v19 = v7;
    AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v7);
    uint64_t result = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v19, &v20);
    if (result) {
      return result;
    }
    goto LABEL_26;
  }
  if (v4 > 4) {
    goto LABEL_27;
  }
  if (v4 == 2)
  {
    uint64_t v14 = *(void *)(v3 + 24);
    if (!v14) {
      goto LABEL_27;
    }
    if (*(_DWORD *)(v14 + 8) != 5) {
      goto LABEL_27;
    }
    uint64_t v15 = *(void *)(v14 + 16);
    if (v15 < 1 || v15 % (unint64_t)v6) {
      goto LABEL_27;
    }
    BOOL v20 = *(mlir::MLIRContext ***)(v3 + 16);
  }
  else
  {
    if (v4) {
      goto LABEL_27;
    }
    unint64_t v10 = *(mlir::MLIRContext ***)(v3 + 16);
    BOOL v20 = v10;
    uint64_t LargestKnownDivisor = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v20);
    unint64_t v12 = *(mlir::MLIRContext ***)(v3 + 24);
    BOOL v20 = v12;
    uint64_t v13 = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v20);
    if (LargestKnownDivisor % v6)
    {
      if (!(v13 % v6))
      {
        BOOL v20 = v10;
        goto LABEL_25;
      }
LABEL_27:
      BOOL v16 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(*(mlir::MLIRContext **)v3);
      LODWORD(v20) = 2;
      return mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(v16, 0, 0, &v20, a1, &v17);
    }
    BOOL v20 = v12;
  }
LABEL_25:
  uint64_t result = mlir::AffineExpr::operator%(&v20, v6);
  if (!result)
  {
LABEL_26:
    unint64_t v3 = *a1;
    goto LABEL_27;
  }
  return result;
}

uint64_t mlir::AffineExpr::replaceDimsAndSymbols(uint64_t *a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t result = *a1;
  switch(*(_DWORD *)(result + 8))
  {
    case 5:
      return result;
    case 6:
      unint64_t v17 = *(unsigned int *)(result + 16);
      unint64_t v18 = (uint64_t *)(a2 + 8 * v17);
      BOOL v19 = a3 > v17;
      goto LABEL_10;
    case 7:
      unint64_t v20 = *(unsigned int *)(result + 16);
      unint64_t v18 = (uint64_t *)(a4 + 8 * v20);
      BOOL v19 = a5 > v20;
LABEL_10:
      if (v19) {
        uint64_t v21 = v18;
      }
      else {
        uint64_t v21 = a1;
      }
      uint64_t result = *v21;
      break;
    default:
      uint64_t v11 = *(mlir::MLIRContext ***)(result + 16);
      uint64_t v12 = *(void *)(result + 24);
      uint64_t v22 = v12;
      uint64_t v23 = v11;
      uint64_t v13 = (mlir::MLIRContext **)mlir::AffineExpr::replaceDimsAndSymbols(&v23, a2, a3, a4, a5);
      uint64_t v14 = mlir::AffineExpr::replaceDimsAndSymbols(&v22, a2, a3, a4, a5);
      uint64_t result = *a1;
      if (v11 != v13 || v12 != v14)
      {
        int v16 = *(_DWORD *)(result + 8);
        uint64_t v24 = v13;
        switch(v16)
        {
          case 0:
            uint64_t result = mlir::AffineExpr::operator+((unint64_t *)&v24, v14);
            break;
          case 1:
            uint64_t result = mlir::AffineExpr::operator*((unint64_t *)&v24, v14);
            break;
          case 3:
            uint64_t result = mlir::AffineExpr::floorDiv(&v24, v14);
            break;
          case 4:
            uint64_t result = mlir::AffineExpr::ceilDiv((unint64_t *)&v24, v14);
            break;
          default:
            uint64_t result = mlir::AffineExpr::operator%((unint64_t *)&v24, v14);
            break;
        }
      }
      break;
  }
  return result;
}

uint64_t mlir::AffineDimExpr::getPosition(mlir::AffineDimExpr *this)
{
  return *(unsigned int *)(*(void *)this + 16);
}

uint64_t mlir::AffineBinaryOpExpr::getLHS(mlir::AffineBinaryOpExpr *this)
{
  return *(void *)(*(void *)this + 16);
}

uint64_t mlir::AffineBinaryOpExpr::getRHS(mlir::AffineBinaryOpExpr *this)
{
  return *(void *)(*(void *)this + 24);
}

uint64_t mlir::AffineExpr::shiftDims(mlir::MLIRContext ***this, unsigned int a2, int a3, unsigned int a4)
{
  uint64_t v27[4] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = v27;
  uint64_t v26 = 0x400000000;
  if (a4)
  {
    for (unsigned int i = 0; i != a4; ++i)
    {
      BOOL v9 = **this;
      unsigned int v24 = i;
      uint64_t v23 = v9;
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v9);
      unsigned int v22 = 6;
      uint64_t v11 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v22, &v24);
      uint64_t v12 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 8);
        uint64_t v12 = v26;
      }
      *((void *)v25 + v12) = v11;
      unsigned int v13 = v26 + 1;
      LODWORD(v26) = v26 + 1;
    }
  }
  else
  {
    unsigned int v13 = 0;
  }
  unsigned int v14 = a2 - a4;
  if (a2 > a4)
  {
    unsigned int v15 = a4 + a3;
    do
    {
      int v16 = **this;
      unsigned int v24 = v15;
      uint64_t v23 = v16;
      unint64_t v17 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v16);
      unsigned int v22 = 6;
      uint64_t v18 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(v17, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v22, &v24);
      uint64_t v19 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 8);
        uint64_t v19 = v26;
      }
      *((void *)v25 + v19) = v18;
      unsigned int v13 = v26 + 1;
      LODWORD(v26) = v26 + 1;
      ++v15;
      --v14;
    }
    while (v14);
  }
  uint64_t v20 = mlir::AffineExpr::replaceDimsAndSymbols((uint64_t *)this, (uint64_t)v25, v13, 0, 0);
  if (v25 != v27) {
    free(v25);
  }
  return v20;
}

uint64_t mlir::getAffineDimExpr(mlir *this, mlir::MLIRContext *a2, mlir::MLIRContext *a3)
{
  unsigned int v7 = this;
  uint64_t v6 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(a2);
  unsigned int v5 = 6;
  return mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v5, &v7);
}

uint64_t mlir::AffineExpr::shiftSymbols(mlir::MLIRContext ***this, unsigned int a2, int a3, unsigned int a4)
{
  uint64_t v27[4] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = v27;
  uint64_t v26 = 0x400000000;
  if (a4)
  {
    for (unsigned int i = 0; i != a4; ++i)
    {
      BOOL v9 = **this;
      unsigned int v24 = i;
      uint64_t v23 = v9;
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v9);
      unsigned int v22 = 7;
      uint64_t v11 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v22, &v24);
      uint64_t v12 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 8);
        uint64_t v12 = v26;
      }
      *((void *)v25 + v12) = v11;
      unsigned int v13 = v26 + 1;
      LODWORD(v26) = v26 + 1;
    }
  }
  else
  {
    unsigned int v13 = 0;
  }
  unsigned int v14 = a2 - a4;
  if (a2 > a4)
  {
    unsigned int v15 = a4 + a3;
    do
    {
      int v16 = **this;
      unsigned int v24 = v15;
      uint64_t v23 = v16;
      unint64_t v17 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v16);
      unsigned int v22 = 7;
      uint64_t v18 = mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(v17, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v23, &v22, &v24);
      uint64_t v19 = v26;
      if (v26 >= (unint64_t)HIDWORD(v26))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 8);
        uint64_t v19 = v26;
      }
      *((void *)v25 + v19) = v18;
      unsigned int v13 = v26 + 1;
      LODWORD(v26) = v26 + 1;
      ++v15;
      --v14;
    }
    while (v14);
  }
  uint64_t v20 = mlir::AffineExpr::replaceDimsAndSymbols((uint64_t *)this, 0, 0, (uint64_t)v25, v13);
  if (v25 != v27) {
    free(v25);
  }
  return v20;
}

uint64_t mlir::getAffineSymbolExpr(mlir *this, mlir::MLIRContext *a2, mlir::MLIRContext *a3)
{
  unsigned int v7 = this;
  uint64_t v6 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(a2);
  unsigned int v5 = 7;
  return mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v5, &v7);
}

mlir::MLIRContext *mlir::AffineExpr::replace(unint64_t *a1, uint64_t a2)
{
  uint64_t v11 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>((uint64_t *)a2, a1, &v11)&& v11 != (mlir::MLIRContext **)(*(void *)a2 + 16 * *(unsigned int *)(a2 + 16)))
  {
    return v11[1];
  }
  uint64_t result = (mlir::MLIRContext *)*a1;
  if (*(_DWORD *)(*a1 + 8) <= 4u)
  {
    unsigned int v5 = (mlir::MLIRContext **)*((void *)result + 2);
    uint64_t v9 = *((void *)result + 3);
    unint64_t v10 = v5;
    uint64_t v6 = (mlir::MLIRContext **)mlir::AffineExpr::replace(&v10, a2);
    uint64_t v7 = mlir::AffineExpr::replace(&v9, a2);
    uint64_t result = (mlir::MLIRContext *)*a1;
    if (v10 != v6 || v9 != v7)
    {
      int v8 = *((_DWORD *)result + 2);
      uint64_t v11 = v6;
      switch(v8)
      {
        case 0:
          uint64_t result = (mlir::MLIRContext *)mlir::AffineExpr::operator+((unint64_t *)&v11, v7);
          break;
        case 1:
          uint64_t result = (mlir::MLIRContext *)mlir::AffineExpr::operator*((unint64_t *)&v11, v7);
          break;
        case 3:
          uint64_t result = (mlir::MLIRContext *)mlir::AffineExpr::floorDiv(&v11, v7);
          break;
        case 4:
          uint64_t result = (mlir::MLIRContext *)mlir::AffineExpr::ceilDiv((unint64_t *)&v11, v7);
          break;
        default:
          uint64_t result = (mlir::MLIRContext *)mlir::AffineExpr::operator%((unint64_t *)&v11, v7);
          break;
      }
    }
  }
  return result;
}

void mlir::AffineExpr::replace(unint64_t *a1, unint64_t a2, uint64_t a3)
{
  v7[0] = 0;
  v7[1] = 0;
  unsigned int v8 = 0;
  unint64_t v5 = a2;
  uint64_t v6 = a3;
  uint64_t v9 = 0;
  if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::LookupBucketFor<mlir::Value>((uint64_t *)v7, &v5, &v9) & 1) == 0)
  {
    int v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>,mlir::Value,llvm::SMLoc,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,llvm::SMLoc>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)v7, (uint64_t)&v5, &v5, v9);
    void *v4 = v5;
    v4[1] = v6;
  }
  mlir::AffineExpr::replace(a1, (uint64_t)v7);
  llvm::deallocate_buffer(v7[0], (void *)(16 * v8));
}

uint64_t sub_1804023C8()
{
  return v0;
}

uint64_t mlir::AffineExpr::isSymbolicOrConstant(mlir::AffineExpr *this)
{
  uint64_t v1 = *(void *)this;
  uint64_t v2 = *(unsigned int *)(*(void *)this + 8);
  uint64_t result = 1;
  switch(v2)
  {
    case 5:
    case 7:
      return result;
    case 6:
      uint64_t result = 0;
      break;
    default:
      uint64_t v5 = *(void *)(v1 + 16);
      uint64_t result = mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v5);
      if (result)
      {
        uint64_t v4 = *(void *)(v1 + 24);
        uint64_t result = mlir::AffineExpr::isSymbolicOrConstant((mlir::AffineExpr *)&v4);
      }
      break;
  }
  return result;
}

uint64_t mlir::AffineExpr::isPureAffine(mlir::AffineExpr *this)
{
  uint64_t v1 = *(void *)this;
  uint64_t v2 = *(unsigned int *)(*(void *)this + 8);
  uint64_t result = 1;
  switch(v2)
  {
    case 1:
      uint64_t v5 = *(void *)(v1 + 16);
      uint64_t v8 = v5;
      uint64_t result = mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v8);
      if (result)
      {
        uint64_t v6 = *(void *)(v1 + 24);
        uint64_t v7 = v6;
        uint64_t result = mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v7);
        if (result)
        {
          if (*(_DWORD *)(v5 + 8) != 5)
          {
            int v4 = *(_DWORD *)(v6 + 8);
            goto LABEL_4;
          }
          uint64_t result = 1;
        }
      }
      break;
    case 2:
    case 3:
    case 4:
      uint64_t v8 = *(void *)(v1 + 16);
      uint64_t result = mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v8);
      if (result)
      {
        int v4 = *(_DWORD *)(*(void *)(v1 + 24) + 8);
LABEL_4:
        uint64_t result = v4 == 5;
      }
      break;
    case 5:
    case 6:
    case 7:
      return result;
    default:
      uint64_t v8 = *(void *)(v1 + 16);
      uint64_t result = mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v8);
      if (result)
      {
        uint64_t v7 = *(void *)(v1 + 24);
        uint64_t result = mlir::AffineExpr::isPureAffine((mlir::AffineExpr *)&v7);
      }
      break;
  }
  return result;
}

uint64_t mlir::AffineExpr::getLargestKnownDivisor(mlir::AffineExpr *this)
{
  uint64_t v1 = *(void *)this;
  uint64_t v2 = *(unsigned int *)(*(void *)this + 8);
  uint64_t result = 1;
  switch(v2)
  {
    case 1:
      uint64_t v14 = *(void *)(v1 + 16);
      uint64_t LargestKnownDivisor = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v14);
      uint64_t v13 = *(void *)(v1 + 24);
      uint64_t result = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v13) * LargestKnownDivisor;
      break;
    case 3:
    case 4:
      uint64_t v7 = *(void *)(v1 + 24);
      if (v7) {
        BOOL v8 = *(_DWORD *)(v7 + 8) == 5;
      }
      else {
        BOOL v8 = 0;
      }
      if (v8 && (uint64_t v9 = *(void *)(v7 + 16)) != 0)
      {
        uint64_t v14 = *(void *)(v1 + 16);
        uint64_t v10 = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v14);
        if (v10 % v9) {
          uint64_t result = 1;
        }
        else {
          uint64_t result = v10 / v9;
        }
      }
      else
      {
        uint64_t result = 1;
      }
      break;
    case 5:
      uint64_t v12 = *(void *)(v1 + 16);
      if (v12 >= 0) {
        uint64_t result = *(void *)(v1 + 16);
      }
      else {
        uint64_t result = -v12;
      }
      break;
    case 6:
    case 7:
      return result;
    default:
      uint64_t v14 = *(void *)(v1 + 16);
      unint64_t v4 = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v14);
      uint64_t v13 = *(void *)(v1 + 24);
      uint64_t v5 = mlir::AffineExpr::getLargestKnownDivisor((mlir::AffineExpr *)&v13);
      if (v5)
      {
        unint64_t v6 = v5;
        do
        {
          uint64_t result = v6;
          unint64_t v6 = v4 % v6;
          unint64_t v4 = result;
        }
        while (v6);
      }
      else
      {
        uint64_t result = v4;
      }
      break;
  }
  return result;
}

void *mlir::AffineBinaryOpExpr::AffineBinaryOpExpr(void *result, uint64_t a2)
{
  *uint64_t result = a2;
  return result;
}

BOOL mlir::AffineExpr::operator==(mlir::MLIRContext ***a1, uint64_t a2)
{
  uint64_t v5 = **a1;
  uint64_t v6 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v5);
  return *a1 == (mlir::MLIRContext **)mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v5, &v6);
}

uint64_t mlir::getAffineConstantExpr(mlir *this, mlir::MLIRContext *a2, mlir::MLIRContext *a3)
{
  uint64_t v5 = a2;
  uint64_t v6 = this;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(a2);
  return mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v5, &v6);
}

uint64_t mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(unsigned __int8 **a1, const char *a2, unint64_t a3, void *a4)
{
  unint64_t v4 = 0x1E8EB8000uLL;
  {
    uint64_t v18 = a4;
    uint64_t v19 = a1;
    int v16 = a2;
    unint64_t v17 = a3;
    unint64_t v4 = 0x1E8EB8000;
    a2 = v16;
    a3 = v17;
    int v8 = v7;
    a4 = v18;
    a1 = v19;
    if (v8)
    {
      uint64_t v23 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::AffineConstantExprStorage]";
      unint64_t v24 = 89;
      unint64_t v9 = llvm::StringRef::find((uint64_t *)&v23, "DesiredTypeName = ", 0x12uLL, 0);
      if (v24 >= v9) {
        unint64_t v10 = v9;
      }
      else {
        unint64_t v10 = v24;
      }
      uint64_t v11 = &v23[v10];
      unint64_t v12 = v24 - v10;
      if (v24 - v10 >= 0x12) {
        uint64_t v13 = 18;
      }
      else {
        uint64_t v13 = v24 - v10;
      }
      unint64_t v14 = v12 - v13;
      if (v14 >= v14 - 1) {
        uint64_t v15 = v14 - 1;
      }
      else {
        uint64_t v15 = v14;
      }
      mlir::detail::TypeIDResolver<mlir::detail::AffineConstantExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v11[v13], v15);
      unint64_t v4 = 0x1E8EB8000;
      a2 = v16;
      a3 = v17;
      a4 = v18;
      a1 = v19;
    }
  }
  uint64_t v5 = *(void *)(v4 + 3712);
  uint64_t v23 = a2;
  unint64_t v24 = a3;
  uint64_t v22 = *a4;
  v20[0] = &v22;
  v20[1] = &v23;
  uint64_t v21 = &v22;
  return mlir::StorageUniquer::getParametricStorageTypeImpl(a1, v5, 37 * (int)v22, (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::detail::AffineConstantExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>,mlir::TypeID,long long &)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v21, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::detail::AffineConstantExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>,mlir::TypeID,long long &)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v20);
}

uint64_t mlir::AffineExpr::operator+(mlir::MLIRContext ***a1, uint64_t a2)
{
  uint64_t v6 = **a1;
  uint64_t v7 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  uint64_t v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v7);
  return mlir::AffineExpr::operator+(a1, v4);
}

uint64_t mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(unsigned __int8 **a1, uint64_t a2, uint64_t a3, _DWORD *a4, unint64_t *a5, void *a6)
{
  {
    uint64_t v26 = a5;
    uint64_t v27 = a6;
    uint64_t v24 = a3;
    uint64_t v25 = a4;
    uint64_t v23 = a2;
    a2 = v23;
    a3 = v24;
    a4 = v25;
    a5 = v26;
    a6 = v27;
    if (v15)
    {
      uint64_t v30 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::detail::AffineBinaryOpExprStorage]";
      unint64_t v31 = 89;
      unint64_t v16 = llvm::StringRef::find((uint64_t *)&v30, "DesiredTypeName = ", 0x12uLL, 0);
      if (v31 >= v16) {
        unint64_t v17 = v16;
      }
      else {
        unint64_t v17 = v31;
      }
      uint64_t v18 = &v30[v17];
      unint64_t v19 = v31 - v17;
      if (v31 - v17 >= 0x12) {
        uint64_t v20 = 18;
      }
      else {
        uint64_t v20 = v31 - v17;
      }
      unint64_t v21 = v19 - v20;
      if (v21 >= v21 - 1) {
        uint64_t v22 = v21 - 1;
      }
      else {
        uint64_t v22 = v21;
      }
      mlir::detail::TypeIDResolver<mlir::detail::AffineBinaryOpExprStorage,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v18[v20], v22);
      a2 = v23;
      a3 = v24;
      a4 = v25;
      a5 = v26;
      a6 = v27;
    }
  }
  uint64_t v7 = mlir::detail::TypeIDResolver<mlir::detail::AffineBinaryOpExprStorage,void>::resolveTypeID(void)::id;
  v33[0] = a2;
  v33[1] = a3;
  LODWORD(v30) = *a4;
  uint64_t v8 = *a6;
  unint64_t v31 = *a5;
  uint64_t v32 = v8;
  uint64_t v9 = (37 * v30);
  Hashuint64_t Value = llvm::DenseMapInfo<std::tuple<unsigned int,mlir::AffineExpr,mlir::AffineExpr>,void>::getHashValueImpl<1u>((uint64_t)&v30);
  unint64_t v11 = (HashValue | (unint64_t)(v9 << 32)) + ~((unint64_t)HashValue << 32);
  unint64_t v12 = (v11 ^ (v11 >> 22)) + ~((v11 ^ (v11 >> 22)) << 13);
  unint64_t v13 = (9 * (v12 ^ (v12 >> 8))) ^ ((9 * (v12 ^ (v12 >> 8))) >> 15);
  v28[0] = &v30;
  v28[1] = v33;
  uint64_t v29 = &v30;
  return mlir::StorageUniquer::getParametricStorageTypeImpl(a1, v7, ((v13 + ~(v13 << 27)) >> 31) ^ (v13 + ~(v13 << 27)), (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::detail::AffineBinaryOpExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(llvm::function_ref<void ()(mlir::detail::AffineBinaryOpExprStorage *)>,mlir::TypeID,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v29, (uint64_t (*)(uint64_t, uint64_t))llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::detail::AffineBinaryOpExprStorage * mlir::StorageUniquer::get<mlir::detail::AffineBinaryOpExprStorage,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&>(llvm::function_ref<void ()(mlir::detail::AffineBinaryOpExprStorage *)>,mlir::TypeID,unsigned int,mlir::AffineExpr const&,mlir::AffineExpr&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v28);
}

uint64_t mlir::AffineExpr::operator*(mlir::MLIRContext ***a1, uint64_t a2)
{
  uint64_t v6 = **a1;
  uint64_t v7 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  uint64_t v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v7);
  return mlir::AffineExpr::operator*(a1, v4);
}

uint64_t mlir::AffineExpr::operator-(unint64_t *a1)
{
  uint64_t v5 = *(mlir::MLIRContext **)*a1;
  uint64_t v6 = -1;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v5);
  uint64_t v3 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v5, &v6);
  return mlir::AffineExpr::operator*(a1, v3);
}

uint64_t mlir::AffineExpr::operator-(unint64_t *a1, mlir::MLIRContext **a2)
{
  uint64_t v7 = a2;
  uint64_t v8 = *a2;
  uint64_t v9 = -1;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v8);
  uint64_t v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v8, &v9);
  uint64_t v5 = mlir::AffineExpr::operator*((unint64_t *)&v7, v4);
  return mlir::AffineExpr::operator+(a1, v5);
}

uint64_t mlir::AffineExpr::floorDiv(mlir::MLIRContext ***this, uint64_t a2)
{
  uint64_t v6 = **this;
  uint64_t v7 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  uint64_t v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v7);
  return mlir::AffineExpr::floorDiv(this, v4);
}

uint64_t mlir::AffineExpr::operator%(mlir::MLIRContext ***a1, uint64_t a2)
{
  uint64_t v6 = **a1;
  uint64_t v7 = a2;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  uint64_t v4 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v6, &v7);
  return mlir::AffineExpr::operator%(a1, v4);
}

mlir::MLIRContext **mlir::getAffineExprFromFlatForm(uint64_t a1, uint64_t a2, unsigned int a3, int a4, unint64_t *a5, int a6, mlir::MLIRContext *this)
{
  uint64_t v34 = this;
  uint64_t v35 = 0;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(this);
  uint64_t result = (mlir::MLIRContext **)mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v34, &v35);
  BOOL v33 = result;
  unint64_t v14 = a4 + a3;
  if (a4 + a3)
  {
    unint64_t v15 = 0;
    unint64_t v16 = a3;
    int v17 = -a3;
    do
    {
      if (*(void *)(a1 + 8 * v15))
      {
        if (v15 >= v16)
        {
          LODWORD(v34) = v17 + v15;
          uint64_t v35 = this;
          uint64_t v18 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(this);
          LODWORD(v32) = 7;
        }
        else
        {
          LODWORD(v34) = v15;
          uint64_t v35 = this;
          uint64_t v18 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(this);
          LODWORD(v32) = 6;
        }
        uint64_t v32 = (mlir::MLIRContext **)mlir::StorageUniquer::get<mlir::detail::AffineDimExprStorage,unsigned int,unsigned int &>(v18, (const char *)llvm::function_ref<void ()(mlir::detail::AffineDimExprStorage *)>::callback_fn<getAffineDimOrSymbol(mlir::AffineExprKind,unsigned int,mlir::MLIRContext *)::$_0>, (unint64_t)&v35, (unsigned int *)&v32, (unsigned int *)&v34);
        unint64_t v19 = *(mlir::MLIRContext **)(a1 + 8 * v15);
        uint64_t v34 = *v32;
        uint64_t v35 = v19;
        uint64_t v20 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v34);
        uint64_t v21 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v20, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v34, &v35);
        uint64_t v22 = mlir::AffineExpr::operator*((unint64_t *)&v32, v21);
        uint64_t result = (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v33, v22);
        BOOL v33 = result;
      }
      ++v15;
    }
    while (v14 != v15);
  }
  unint64_t v23 = (a2 - 1);
  if (v14 < v23)
  {
    do
    {
      uint64_t v24 = *(mlir::MLIRContext **)(a1 + 8 * v14);
      if (v24)
      {
        uint64_t v34 = *(mlir::MLIRContext **)*a5;
        uint64_t v35 = v24;
        uint64_t v25 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v34);
        uint64_t v26 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v25, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v34, &v35);
        uint64_t v27 = mlir::AffineExpr::operator*(a5, v26);
        uint64_t result = (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v33, v27);
        BOOL v33 = result;
      }
      ++v14;
      ++a5;
    }
    while (v14 < v23);
  }
  uint64_t v28 = *(mlir::MLIRContext **)(a1 + 8 * a2 - 8);
  if (v28)
  {
    uint64_t v34 = *result;
    uint64_t v35 = v28;
    uint64_t v29 = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v34);
    uint64_t v30 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(v29, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v34, &v35);
    return (mlir::MLIRContext **)mlir::AffineExpr::operator+((unint64_t *)&v33, v30);
  }
  return result;
}

void std::vector<llvm::SmallVector<long long,8u>>::reserve(uint64_t a1, unint64_t a2)
{
  uint64_t v2 = *(char **)a1;
  if (0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(*(void *)(a1 + 16) - *(void *)a1) >> 4) < a2)
  {
    if (a2 >= 0x333333333333334) {
      abort();
    }
    uint64_t v4 = *(unsigned char **)(a1 + 8);
    uint64_t v5 = 80 * a2;
    uint64_t v6 = (char *)operator new(80 * a2);
    uint64_t v7 = &v6[v5];
    uint64_t v8 = &v6[v4 - v2];
    if (v4 == v2)
    {
      *(void *)a1 = v8;
      *(void *)(a1 + 8) = v8;
      *(void *)(a1 + 16) = v7;
    }
    else
    {
      uint64_t v9 = 0;
      do
      {
        *(void *)&v8[v9 - 80] = &v8[v9 - 64];
        *(void *)&v8[v9 - 72] = 0x800000000;
        if (*(_DWORD *)&v4[v9 - 72]) {
          llvm::SmallVectorImpl<llvm::SMLoc>::operator=((uint64_t)&v8[v9 - 80], (uint64_t)&v4[v9 - 80]);
        }
        v9 -= 80;
      }
      while (&v4[v9] != v2);
      uint64_t v2 = *(char **)a1;
      unint64_t v10 = *(char **)(a1 + 8);
      *(void *)a1 = &v8[v9];
      *(void *)(a1 + 8) = v8;
      *(void *)(a1 + 16) = v7;
      while (v10 != v2)
      {
        unint64_t v12 = (char *)*((void *)v10 - 10);
        v10 -= 80;
        unint64_t v11 = v12;
        if (v10 + 16 != v12) {
          free(v11);
        }
      }
    }
    if (v2)
    {
      operator delete(v2);
    }
  }
}

mlir::SimpleAffineExprFlattener *mlir::SimpleAffineExprFlattener::SimpleAffineExprFlattener(mlir::SimpleAffineExprFlattener *this, int a2, int a3)
{
  *(void *)this = &unk_1EC9C6D18;
  *((void *)this + 2) = 0;
  *((void *)this + 3) = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 8) = a2;
  *((_DWORD *)this + 9) = a3;
  *((_DWORD *)this + 10) = 0;
  *((void *)this + 6) = (char *)this + 64;
  *((void *)this + 7) = 0x400000000;
  std::vector<llvm::SmallVector<long long,8u>>::reserve((uint64_t)this + 8, 8uLL);
  return this;
}

uint64_t mlir::SimpleAffineExprFlattener::visitMulExpr(uint64_t a1, uint64_t a2)
{
  v37[8] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v35 = v37;
  *(void *)uint64_t v36 = 0x800000000;
  unsigned int v5 = *(_DWORD *)(v4 - 72);
  if (&v35 != (void **)(v4 - 80) && v5 != 0)
  {
    if (v5 < 9)
    {
      uint64_t v8 = v37;
      unsigned int v7 = *(_DWORD *)(v4 - 72);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v37, *(unsigned int *)(v4 - 72), 8);
      unsigned int v7 = *(_DWORD *)(v4 - 72);
      if (!v7)
      {
LABEL_10:
        v36[0] = v5;
        uint64_t v4 = *(void *)(a1 + 16);
        goto LABEL_11;
      }
      uint64_t v8 = v35;
    }
    memcpy(v8, *(const void **)(v4 - 80), 8 * v7);
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v9 = *(void **)(v4 - 80);
  if (v9 != (void *)(v4 - 64)) {
    free(v9);
  }
  *(void *)(a1 + 16) = v4 - 80;
  if (*(_DWORD *)(*(void *)(a2 + 24) + 8) == 5)
  {
    unint64_t v10 = v35;
    uint64_t v11 = *(unsigned int *)(v4 - 152);
    if (!v11) {
      goto LABEL_38;
    }
    uint64_t v12 = *((void *)v35 + (*(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 40)));
    uint64_t v13 = *(void *)(v4 - 160);
    if (v11 == 1)
    {
      uint64_t v14 = 0;
LABEL_36:
      unint64_t v31 = (void *)(v13 + 8 * v14);
      uint64_t v32 = v11 - v14;
      do
      {
        *v31++ *= v12;
        --v32;
      }
      while (v32);
      goto LABEL_38;
    }
    uint64_t v14 = v11 & 0xFFFFFFFE;
    uint64_t v28 = (uint64_t *)(v13 + 8);
    uint64_t v29 = v14;
    do
    {
      uint64_t v30 = *v28 * v12;
      *(v28 - 1) *= v12;
      uint64_t *v28 = v30;
      v28 += 2;
      v29 -= 2;
    }
    while (v29);
    if (v14 != v11) {
      goto LABEL_36;
    }
  }
  else
  {
    unint64_t v15 = *(mlir::MLIRContext **)a2;
    AffineExprFromFlatForm = mlir::getAffineExprFromFlatForm(*(void *)(v4 - 160), *(unsigned int *)(v4 - 152), *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(unint64_t **)(a1 + 48), *(_DWORD *)(a1 + 56), v15);
    unint64_t v16 = mlir::getAffineExprFromFlatForm((uint64_t)v35, v36[0], *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(unint64_t **)(a1 + 48), *(_DWORD *)(a1 + 56), v15);
    uint64_t v17 = mlir::AffineExpr::operator*((unint64_t *)&AffineExprFromFlatForm, (uint64_t)v16);
    uint64_t v18 = *(void *)(a1 + 48);
    uint64_t v19 = *(unsigned int *)(a1 + 56);
    if (!v19) {
      goto LABEL_29;
    }
    uint64_t v20 = 8 * v19;
    uint64_t v21 = *(void **)(a1 + 48);
    while (*v21 != v17)
    {
      ++v21;
      v20 -= 8;
      if (!v20)
      {
        uint64_t v21 = (void *)(v18 + 8 * v19);
        break;
      }
    }
    uint64_t v22 = (uint64_t)v21 - v18;
    if (v19 == v22 >> 3 || (unint64_t v23 = (unint64_t)v22 >> 3, ((unint64_t)v22 >> 3) == -1))
    {
LABEL_29:
      (*(void (**)(uint64_t, uint64_t))(*(void *)a1 + 24))(a1, v17);
      uint64_t v25 = *(void *)(v4 - 160);
      uint64_t v27 = *(unsigned int *)(v4 - 152);
      if (v27) {
        bzero(*(void **)(v4 - 160), 8 * v27);
      }
      unsigned int v26 = *(_DWORD *)(a1 + 32) + *(_DWORD *)(a1 + 36) + *(_DWORD *)(a1 + 40) - 1;
    }
    else
    {
      uint64_t v24 = *(unsigned int *)(v4 - 152);
      uint64_t v25 = *(void *)(v4 - 160);
      if (v24) {
        bzero(*(void **)(v4 - 160), 8 * v24);
      }
      unsigned int v26 = *(_DWORD *)(a1 + 32) + v23 + *(_DWORD *)(a1 + 36);
    }
    *(void *)(v25 + 8 * v26) = 1;
    unint64_t v10 = v35;
  }
LABEL_38:
  if (v10 != v37) {
    free(v10);
  }
  return 1;
}

uint64_t mlir::SimpleAffineExprFlattener::visitModExpr(_DWORD *a1, uint64_t a2)
{
  v67[8] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *((void *)a1 + 2);
  unint64_t v65 = v67;
  *(void *)int64x2_t v66 = 0x800000000;
  unsigned int v5 = *(_DWORD *)(v4 - 72);
  if (&v65 != (void **)(v4 - 80) && v5 != 0)
  {
    if (v5 < 9)
    {
      uint64_t v8 = v67;
      unsigned int v7 = *(_DWORD *)(v4 - 72);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v65, v67, *(unsigned int *)(v4 - 72), 8);
      unsigned int v7 = *(_DWORD *)(v4 - 72);
      if (!v7)
      {
LABEL_10:
        v66[0] = v5;
        uint64_t v4 = *((void *)a1 + 2);
        goto LABEL_11;
      }
      uint64_t v8 = v65;
    }
    memcpy(v8, *(const void **)(v4 - 80), 8 * v7);
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v9 = *(void **)(v4 - 80);
  if (v9 != (void *)(v4 - 64)) {
    free(v9);
  }
  *((void *)a1 + 2) = v4 - 80;
  unint64_t v10 = (void **)(v4 - 160);
  uint64_t v11 = *(mlir::MLIRContext **)a2;
  if (*(_DWORD *)(*(void *)(a2 + 24) + 8) != 5)
  {
    AffineExprFromFlatForm = mlir::getAffineExprFromFlatForm(*(void *)(v4 - 160), *(unsigned int *)(v4 - 152), a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], *(mlir::MLIRContext **)a2);
    uint64_t v17 = mlir::getAffineExprFromFlatForm((uint64_t)v65, v66[0], a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], v11);
    uint64_t v18 = mlir::AffineExpr::operator%((unint64_t *)&AffineExprFromFlatForm, (uint64_t)v17);
    uint64_t v19 = *((void *)a1 + 6);
    uint64_t v20 = a1[14];
    if (!v20) {
      goto LABEL_35;
    }
    uint64_t v21 = 8 * v20;
    uint64_t v22 = (void *)*((void *)a1 + 6);
    while (*v22 != v18)
    {
      ++v22;
      v21 -= 8;
      if (!v21)
      {
        uint64_t v22 = (void *)(v19 + 8 * v20);
        break;
      }
    }
    uint64_t v23 = (uint64_t)v22 - v19;
    if (v20 == v23 >> 3 || (unint64_t v26 = (unint64_t)v23 >> 3, ((unint64_t)v23 >> 3) == -1))
    {
LABEL_35:
      (*(void (**)(_DWORD *, uint64_t))(*(void *)a1 + 24))(a1, v18);
      uint64_t v30 = *(void *)(v4 - 160);
      uint64_t v31 = *(unsigned int *)(v4 - 152);
      if (v31) {
        bzero(*(void **)(v4 - 160), 8 * v31);
      }
      unsigned int v32 = a1[8] + a1[9] + a1[10] - 1;
      uint64_t v24 = 1;
      *(void *)(v30 + 8 * v32) = 1;
      uint64_t v25 = v65;
      if (v65 != v67) {
        goto LABEL_82;
      }
    }
    else
    {
      uint64_t v27 = *(unsigned int *)(v4 - 152);
      uint64_t v28 = *v10;
      if (v27) {
        bzero(*v10, 8 * v27);
      }
      int v29 = a1[8] + v26 + a1[9];
      uint64_t v24 = 1;
      v28[v29] = 1;
      uint64_t v25 = v65;
      if (v65 != v67) {
        goto LABEL_82;
      }
    }
    return v24;
  }
  uint64_t v12 = *((void *)v65 + (a1[9] + a1[8] + a1[10]));
  if (v12 < 1)
  {
    uint64_t v24 = 0;
    uint64_t v25 = v65;
    if (v65 == v67) {
      return v24;
    }
    goto LABEL_82;
  }
  uint64_t v13 = *(unsigned int *)(v4 - 152);
  if (v13)
  {
    uint64_t v14 = (uint64_t *)*v10;
    uint64_t v15 = *(unsigned int *)(v4 - 152);
    while (1)
    {
      uint64_t v16 = *v14++;
      if (v16 % v12) {
        break;
      }
      if (!--v15) {
        goto LABEL_45;
      }
    }
    if (!v15)
    {
LABEL_45:
      bzero(*v10, 8 * v13);
      goto LABEL_81;
    }
    unsigned int v33 = 0;
    AffineExprFromFlatForm = v64;
    uint64_t v63 = 0x800000000;
    unsigned int v34 = *(_DWORD *)(v4 - 152);
    if (&AffineExprFromFlatForm == v10 || !v34)
    {
LABEL_49:
      if (v34)
      {
        uint64_t v37 = 0;
        unint64_t v38 = v12;
        do
        {
          uint64_t v40 = *((void *)*v10 + v37);
          if (v40)
          {
            if (v40 >= 0) {
              unint64_t v41 = *((void *)*v10 + v37);
            }
            else {
              unint64_t v41 = -v40;
            }
            do
            {
              uint64_t v39 = v41;
              unint64_t v41 = v38 % v41;
              unint64_t v38 = v39;
            }
            while (v41);
          }
          else
          {
            uint64_t v39 = v38;
          }
          ++v37;
          unint64_t v38 = v39;
        }
        while (v37 != v34);
      }
      else
      {
        uint64_t v39 = v12;
      }
      if (v39 == 1)
      {
        unsigned int v42 = (uint64_t *)AffineExprFromFlatForm;
      }
      else
      {
        unsigned int v42 = (uint64_t *)AffineExprFromFlatForm;
        if (v33)
        {
          if (v33 == 1)
          {
            uint64_t v43 = 0;
          }
          else
          {
            uint64_t v44 = 0;
            uint64_t v43 = v33 & 0xFFFFFFFE;
            do
            {
              uint64_t v45 = &v42[v44];
              uint64_t v46 = v45[1] / v39;
              *v45 /= v39;
              v45[1] = v46;
              v44 += 2;
            }
            while (v43 != v44);
            if (v43 == v33) {
              goto LABEL_69;
            }
          }
          do
            v42[v43++] /= v39;
          while (v33 != v43);
        }
      }
LABEL_69:
      uint64_t v47 = v12 / v39;
      uint64_t v59 = mlir::getAffineExprFromFlatForm((uint64_t)v42, v33, a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], v11);
      uint64_t v60 = v11;
      uint64_t v61 = v47;
      AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v11);
      uint64_t v49 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v60, &v61);
      uint64_t v50 = mlir::AffineExpr::floorDiv(&v59, v49);
      uint64_t v51 = *((void *)a1 + 6);
      uint64_t v52 = a1[14];
      if (v52)
      {
        uint64_t v53 = 8 * v52;
        uint64_t v54 = (void *)*((void *)a1 + 6);
        while (*v54 != v50)
        {
          ++v54;
          v53 -= 8;
          if (!v53)
          {
            uint64_t v54 = (void *)(v51 + 8 * v52);
            break;
          }
        }
      }
      else
      {
        uint64_t v54 = (void *)*((void *)a1 + 6);
      }
      uint64_t v55 = (uint64_t)v54 - v51;
      if (v52 == v55 >> 3 || (unint64_t v56 = (unint64_t)v55 >> 3, v56 == -1))
      {
        (*(void (**)(_DWORD *, void *, void, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, AffineExprFromFlatForm, v63, v47, v50);
        unsigned int v57 = a1[8] + a1[9] + a1[10] - 1;
      }
      else
      {
        unsigned int v57 = a1[8] + v56 + a1[9];
      }
      *((void *)*v10 + v57) = -v12;
      if (AffineExprFromFlatForm != v64) {
        free(AffineExprFromFlatForm);
      }
      goto LABEL_81;
    }
    if (v34 < 9)
    {
      uint64_t v36 = v64;
      unsigned int v35 = *(_DWORD *)(v4 - 152);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AffineExprFromFlatForm, v64, *(unsigned int *)(v4 - 152), 8);
      unsigned int v35 = *(_DWORD *)(v4 - 152);
      if (!v35)
      {
LABEL_48:
        LODWORD(v63) = v34;
        unsigned int v33 = v34;
        unsigned int v34 = *(_DWORD *)(v4 - 152);
        goto LABEL_49;
      }
      uint64_t v36 = AffineExprFromFlatForm;
    }
    memcpy(v36, *v10, 8 * v35);
    goto LABEL_48;
  }
LABEL_81:
  uint64_t v24 = 1;
  uint64_t v25 = v65;
  if (v65 != v67) {
LABEL_82:
  }
    free(v25);
  return v24;
}

uint64_t mlir::SimpleAffineExprFlattener::visitDivExpr(_DWORD *a1, uint64_t a2, int a3)
{
  v77[8] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = *(mlir::MLIRContext **)a2;
  uint64_t v7 = *((void *)a1 + 2);
  int64_t v75 = v77;
  *(void *)int v76 = 0x800000000;
  unsigned int v8 = *(_DWORD *)(v7 - 72);
  if (&v75 != (void **)(v7 - 80) && v8 != 0)
  {
    if (v8 < 9)
    {
      uint64_t v11 = v77;
      unsigned int v10 = *(_DWORD *)(v7 - 72);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v77, *(unsigned int *)(v7 - 72), 8);
      unsigned int v10 = *(_DWORD *)(v7 - 72);
      if (!v10)
      {
LABEL_10:
        v76[0] = v8;
        uint64_t v7 = *((void *)a1 + 2);
        goto LABEL_11;
      }
      uint64_t v11 = v75;
    }
    memcpy(v11, *(const void **)(v7 - 80), 8 * v10);
    goto LABEL_10;
  }
LABEL_11:
  uint64_t v12 = *(void **)(v7 - 80);
  if (v12 != (void *)(v7 - 64)) {
    free(v12);
  }
  *((void *)a1 + 2) = v7 - 80;
  uint64_t v13 = (void **)(v7 - 160);
  if (*(_DWORD *)(*(void *)(a2 + 24) + 8) != 5)
  {
    AffineExprFromFlatForm = mlir::getAffineExprFromFlatForm(*(void *)(v7 - 160), *(unsigned int *)(v7 - 152), a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], v6);
    uint64_t v22 = mlir::getAffineExprFromFlatForm((uint64_t)v75, v76[0], a1[8], a1[9], *((unint64_t **)a1 + 6), a1[14], v6);
    if (a3)
    {
      uint64_t v23 = mlir::AffineExpr::ceilDiv((unint64_t *)&AffineExprFromFlatForm, (uint64_t)v22);
      uint64_t v24 = (char *)*((void *)a1 + 6);
      uint64_t v25 = a1[14];
      if (!v25) {
        goto LABEL_39;
      }
    }
    else
    {
      uint64_t v23 = mlir::AffineExpr::floorDiv((mlir::MLIRContext ***)&AffineExprFromFlatForm, (uint64_t)v22);
      uint64_t v24 = (char *)*((void *)a1 + 6);
      uint64_t v25 = a1[14];
      if (!v25) {
        goto LABEL_39;
      }
    }
    uint64_t v26 = 8 * v25;
    uint64_t v27 = v24;
    while (*(void *)v27 != v23)
    {
      v27 += 8;
      v26 -= 8;
      if (!v26)
      {
        uint64_t v27 = &v24[8 * v25];
        break;
      }
    }
    uint64_t v28 = v27 - v24;
    if (v25 != v28 >> 3)
    {
      unint64_t v29 = (unint64_t)v28 >> 3;
      if (((unint64_t)v28 >> 3) != -1)
      {
        uint64_t v30 = *(unsigned int *)(v7 - 152);
        uint64_t v31 = *v13;
        if (v30) {
          bzero(*v13, 8 * v30);
        }
        int v32 = a1[8] + v29 + a1[9];
        uint64_t v33 = 1;
        v31[v32] = 1;
        unsigned int v34 = v75;
        if (v75 != v77) {
          goto LABEL_42;
        }
        return v33;
      }
    }
LABEL_39:
    (*(void (**)(_DWORD *))(*(void *)a1 + 24))(a1);
    uint64_t v35 = *(void *)(v7 - 160);
    uint64_t v36 = *(unsigned int *)(v7 - 152);
    if (v36) {
      bzero(*(void **)(v7 - 160), 8 * v36);
    }
    unsigned int v37 = a1[8] + a1[9] + a1[10] - 1;
    uint64_t v33 = 1;
    *(void *)(v35 + 8 * v37) = 1;
    unsigned int v34 = v75;
    if (v75 != v77) {
      goto LABEL_42;
    }
    return v33;
  }
  unsigned int v14 = a1[8];
  int v15 = a1[9];
  uint64_t v16 = *((void *)v75 + v15 + v14 + a1[10]);
  if (v16 < 1)
  {
    uint64_t v33 = 0;
    unsigned int v34 = v75;
    if (v75 == v77) {
      return v33;
    }
    goto LABEL_42;
  }
  uint64_t v17 = *(unsigned int *)(v7 - 152);
  if (!v17)
  {
    uint64_t v19 = *((void *)v75 + v15 + v14 + a1[10]);
    goto LABEL_55;
  }
  uint64_t v18 = 0;
  uint64_t v19 = *((void *)v75 + v15 + v14 + a1[10]);
  do
  {
    uint64_t v20 = *((void *)*v13 + v18);
    if (v20)
    {
      if (v20 < 0) {
        uint64_t v20 = -v20;
      }
      unint64_t v21 = v19;
      do
      {
        uint64_t v19 = v20;
        uint64_t v20 = v21 % v20;
        unint64_t v21 = v19;
      }
      while (v20);
    }
    ++v18;
  }
  while (v18 != v17);
  if (v19 != 1)
  {
    uint64_t v39 = (char *)*v13;
    if (v17 < 2)
    {
      uint64_t v40 = 0;
LABEL_53:
      uint64_t v44 = (uint64_t *)&v39[8 * v40];
      uint64_t v45 = v17 - v40;
      do
      {
        *v44++ /= v19;
        --v45;
      }
      while (v45);
      goto LABEL_55;
    }
    uint64_t v40 = v17 & 0xFFFFFFFE;
    unint64_t v41 = (uint64_t *)(v39 + 8);
    uint64_t v42 = v40;
    do
    {
      uint64_t v43 = *v41;
      *(v41 - 1) /= v19;
      uint64_t *v41 = v43 / v19;
      v41 += 2;
      v42 -= 2;
    }
    while (v42);
    if (v40 != v17) {
      goto LABEL_53;
    }
  }
LABEL_55:
  uint64_t v46 = v16 / v19;
  if (v16 / v19 == 1)
  {
    uint64_t v33 = 1;
    unsigned int v34 = v75;
    if (v75 == v77) {
      return v33;
    }
    goto LABEL_42;
  }
  uint64_t v70 = mlir::getAffineExprFromFlatForm((uint64_t)*v13, v17, v14, v15, *((unint64_t **)a1 + 6), a1[14], v6);
  unsigned __int16 v71 = v6;
  AffineExprFromFlatForm = (void *)v46;
  AffineUniquer = (unsigned __int8 **)mlir::MLIRContext::getAffineUniquer(v6);
  uint64_t v48 = mlir::StorageUniquer::get<mlir::detail::AffineConstantExprStorage,long long &>(AffineUniquer, (const char *)llvm::function_ref<void ()(mlir::detail::AffineConstantExprStorage *)>::callback_fn<mlir::getAffineConstantExpr(long long,mlir::MLIRContext *)::$_0>, (unint64_t)&v71, &AffineExprFromFlatForm);
  if (a3)
  {
    uint64_t v49 = mlir::AffineExpr::ceilDiv((unint64_t *)&v70, v48);
    uint64_t v50 = (char *)*((void *)a1 + 6);
    uint64_t v51 = a1[14];
    if (v51) {
      goto LABEL_60;
    }
LABEL_65:
    uint64_t v53 = v50;
    goto LABEL_66;
  }
  uint64_t v49 = mlir::AffineExpr::floorDiv(&v70, v48);
  uint64_t v50 = (char *)*((void *)a1 + 6);
  uint64_t v51 = a1[14];
  if (!v51) {
    goto LABEL_65;
  }
LABEL_60:
  uint64_t v52 = 8 * v51;
  uint64_t v53 = v50;
  while (*(void *)v53 != v49)
  {
    v53 += 8;
    v52 -= 8;
    if (!v52)
    {
      uint64_t v53 = &v50[8 * v51];
      break;
    }
  }
LABEL_66:
  uint64_t v54 = v53 - v50;
  if (v51 != v54 >> 3)
  {
    unint64_t v55 = (unint64_t)v54 >> 3;
    if (((unint64_t)v54 >> 3) != -1)
    {
      uint64_t v56 = *(unsigned int *)(v7 - 152);
      uint64_t v57 = *(void *)(v7 - 160);
      if (v56) {
        bzero(*(void **)(v7 - 160), 8 * v56);
      }
      unsigned int v58 = a1[8] + v55 + a1[9];
      uint64_t v33 = 1;
      *(void *)(v57 + 8 * v58) = 1;
      unsigned int v34 = v75;
      if (v75 == v77) {
        return v33;
      }
LABEL_42:
      free(v34);
      return v33;
    }
  }
  uint64_t v59 = 0;
  if (a3)
  {
    AffineExprFromFlatForm = v74;
    uint64_t v73 = 0x800000000;
    if (&AffineExprFromFlatForm == v13 || (uint64_t v60 = *(unsigned int *)(v7 - 152), !v60))
    {
      int64x2_t v66 = v74;
LABEL_88:
      *(void *)&v66[8 * v59 - 8] = v46 + *(void *)&v66[8 * v59 - 8] - 1;
      goto LABEL_92;
    }
    if (v60 < 9)
    {
      uint64_t v62 = v74;
      unsigned int v61 = *(_DWORD *)(v7 - 152);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AffineExprFromFlatForm, v74, *(unsigned int *)(v7 - 152), 8);
      unsigned int v61 = *(_DWORD *)(v7 - 152);
      if (!v61)
      {
LABEL_87:
        LODWORD(v73) = v60;
        int64x2_t v66 = AffineExprFromFlatForm;
        uint64_t v59 = v60;
        goto LABEL_88;
      }
      uint64_t v62 = AffineExprFromFlatForm;
    }
    memcpy(v62, *v13, 8 * v61);
    goto LABEL_87;
  }
  AffineExprFromFlatForm = v74;
  uint64_t v73 = 0x800000000;
  if (&AffineExprFromFlatForm == v13 || (uint64_t v63 = *(unsigned int *)(v7 - 152), !v63))
  {
    int64x2_t v66 = v74;
    goto LABEL_92;
  }
  if (v63 < 9)
  {
    unint64_t v65 = v74;
    unsigned int v64 = *(_DWORD *)(v7 - 152);
    goto LABEL_90;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&AffineExprFromFlatForm, v74, *(unsigned int *)(v7 - 152), 8);
  unsigned int v64 = *(_DWORD *)(v7 - 152);
  if (v64)
  {
    unint64_t v65 = AffineExprFromFlatForm;
LABEL_90:
    memcpy(v65, *v13, 8 * v64);
  }
  LODWORD(v73) = v63;
  int64x2_t v66 = AffineExprFromFlatForm;
  uint64_t v59 = v63;
LABEL_92:
  (*(void (**)(_DWORD *, unsigned char *, uint64_t, uint64_t, uint64_t))(*(void *)a1 + 16))(a1, v66, v59, v46, v49);
  if (AffineExprFromFlatForm != v74) {
    free(AffineExprFromFlatForm);
  }
  uint64_t v67 = *(void *)(v7 - 160);
  uint64_t v68 = *(unsigned int *)(v7 - 152);
  if (v68) {
    bzero(*(void **)(v7 - 160), 8 * v68);
  }
  unsigned int v69 = a1[8] + a1[9] + a1[10] - 1;
  uint64_t v33 = 1;
  *(void *)(v67 + 8 * v69) = 1;
  unsigned int v34 = v75;
  if (v75 != v77) {
    goto LABEL_42;
  }
  return v33;
}