id GPU::getSlice(id *this, GPU::EncodeDescriptor *a2, MPSNDArray *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  GPU::EncodeDescriptor *v11;
  void *v12;
  id v13;
  void *v14;
  void *v15;
  char *v16;
  void *v17;
  void *v18;
  long long v20;
  uint64_t vars8;

  v11 = a2;
  if (v11)
  {
    v12 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)this);
    v13 = this[1];
    v14 = [(GPU::EncodeDescriptor *)v11 descriptor];
    v15 = v14;
    if (*(void *)((char *)v11 + (int)*MEMORY[0x1E4F359C8]) <= (unint64_t)a3)
    {
      if (a5 || a6 != 1) {
        __assert_rtn("getSlice", "GPURNNOps.mm", 33, "dimIndex < array->_numberOfDimensions || (offset == 0 && size == 1)");
      }
    }
    else
    {
      v16 = (char *)v11 + (int)*MEMORY[0x1E4F359E0];
      v20 = *(_OWORD *)((char *)v11 + (int)*MEMORY[0x1E4F359B0]);
      objc_msgSend(v14, "sliceDimension:withSubrange:", a3, *(unsigned int *)&v16[4 * (*(unsigned char *)((unint64_t)&v20 | a3 & 0xF) & 0xF)] + a5, a6, v20);
    }
    v18 = [(GPU::EncodeDescriptor *)v11 safeArrayViewWithCommandBuffer:v13 computeEncoder:v12 descriptor:v15 aliasing:1];
    v17 = v18;
    if (*((unsigned char *)v18 + (int)*MEMORY[0x1E4F359C0])) {
      objc_msgSend(v18, "setReadCount:", objc_msgSend(v18, "readCount") + a4);
    }
  }
  else
  {
    v17 = 0;
  }

  return v17;
}

void sub_18015B4D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *GPU::GRUGradientOpHandler::GRUGradientOpHandler(id *this, id *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  v6 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)this, (GPURegionRuntime *)a2, a3, a4);
  *(void *)v6 = &unk_1EC99EFF8;
  *(_OWORD *)((char *)v6 + 120) = 0u;
  *(_OWORD *)((char *)v6 + 136) = 0u;
  *(_OWORD *)((char *)v6 + 152) = 0u;
  *(_OWORD *)((char *)v6 + 168) = 0u;
  *(_OWORD *)((char *)v6 + 184) = 0u;
  *(_OWORD *)((char *)v6 + 200) = 0u;
  id v7 = objc_alloc(MEMORY[0x1E4F35770]);
  v8 = [a2[6] metalDevice];
  uint64_t v9 = [v7 initWithDevice:v8];
  id v10 = this[1];
  this[1] = (id)v9;

  id v11 = objc_alloc(MEMORY[0x1E4F357B8]);
  v12 = [a2[6] metalDevice];
  uint64_t v13 = [v11 initWithDevice:v12 sourceCount:2];
  id v14 = this[25];
  this[25] = (id)v13;

  [this[25] setBeta:0.0];
  id v15 = objc_alloc(MEMORY[0x1E4F35870]);
  v16 = [a2[6] metalDevice];
  uint64_t v17 = [v15 initWithDevice:v16 axis:0 operation:4];
  id v18 = this[26];
  this[26] = (id)v17;

  [this[26] setAxes:&unk_1EC9F1E08];
  id v19 = this[15];
  this[15] = 0;

  id v20 = this[16];
  this[16] = 0;

  id v21 = this[17];
  this[17] = 0;

  id v22 = this[18];
  this[18] = 0;

  id v23 = this[19];
  this[19] = 0;

  id v24 = this[20];
  this[20] = 0;

  id v25 = this[21];
  this[21] = 0;

  id v26 = this[22];
  this[22] = 0;

  id v27 = this[23];
  this[23] = 0;

  id v28 = this[24];
  this[24] = 0;

  objc_msgSend(this[1], "setOptions:", objc_msgSend(this[1], "options") | 1);
  objc_msgSend(this[25], "setOptions:", objc_msgSend(this[25], "options") | 1);
  objc_msgSend(this[26], "setOptions:", objc_msgSend(this[26], "options") | 1);
  return this;
}

void sub_18015B740(_Unwind_Exception *a1)
{
  v3 = v2;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void GPU::ForOpHandler::encodeOp(GPU::ForOpHandler *this, GPU::EncodeDescriptor *a2)
{
  v104[1] = *MEMORY[0x1E4F143B8];
  v97 = a2;
  v3 = (char *)this + 8;
  id v92 = *((id *)this + 1);
  v93 = (id *)v3;
  uint64_t v4 = *(void *)(*((void *)v3 + 2) + 48);
  v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v102[0] = *(void *)(v4 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v102);
    if (v84 == 7 && *AttrData == 778462067 && *(_DWORD *)((char *)AttrData + 3) == 1919903278)
    {
      __int16 v101 = 1283;
      v100[0] = (uint64_t)"classof on '";
      v100[2] = (uint64_t)"scf.for";
      v100[3] = 7;
      v98[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v99 = 259;
      llvm::operator+(v100, v98, (uint64_t)v102);
      llvm::report_fatal_error((llvm::Twine *)v102, 1);
    }
LABEL_77:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::scf::ForOp,void>::id) {
    goto LABEL_77;
  }
  v96 = (unsigned int *)*((void *)v3 + 2);
  uint64_t v6 = *((void *)this + 2);
  v102[0] = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v96);
  v100[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v102) + 2);
  id v7 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v6 + 88), v100);
  if (v7
    && (v98[0] = v102[0],
        (v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v7 + 3, v98)) != 0))
  {
    id v89 = (id)v8[3];
  }
  else
  {
    id v89 = 0;
  }
  uint64_t v9 = *((void *)this + 2);
  v102[0] = mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v96);
  v100[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v102) + 2);
  id v10 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v9 + 88), v100);
  if (v10
    && (v98[0] = v102[0],
        (id v11 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v10 + 3, v98)) != 0))
  {
    id v87 = (id)v11[3];
  }
  else
  {
    id v87 = 0;
  }
  uint64_t v12 = *((void *)this + 2);
  v102[0] = mlir::anec::GOC::getBias((mlir::anec::GOC *)&v96);
  v100[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v102) + 2);
  uint64_t v13 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v12 + 88), v100);
  if (v13
    && (v98[0] = v102[0],
        (id v14 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v13 + 3, v98)) != 0))
  {
    id v88 = (id)v14[3];
  }
  else
  {
    id v88 = 0;
  }
  uint64_t v95 = 0;
  int v94 = 0;
  unint64_t Body = mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v96);
  unint64_t v16 = v96[11];
  if ((v16 & 0x7FFFFF) == 0)
  {
    v79 = "index < numRegions && \"invalid region index\"";
    int v80 = 666;
    v81 = "Operation.h";
    v82 = "getRegion";
    goto LABEL_67;
  }
  unint64_t v17 = (unint64_t)&v96[4 * ((v16 >> 23) & 1) + 16] + ((v16 >> 21) & 0x7F8);
  if (v17 > 0xFFFFFFFFFFFFFFF8)
  {
    v79 = "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"";
    int v80 = 191;
    v81 = "Alignment.h";
    v82 = "alignAddr";
    goto LABEL_67;
  }
  id v18 = (void *)(((v17 + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * v96[10]);
  if ((void *)*v18 == v18)
  {
    v79 = "!region.empty() && \"unexpected empty region\"";
    int v80 = 895;
    v81 = "OpDefinition.h";
    v82 = "getBody";
LABEL_67:
    __assert_rtn(v82, v81, v80, v79);
  }
  id v19 = (void *)Body;
  uint64_t v20 = v18[1];
  if (v20) {
    uint64_t v21 = v20 - 8;
  }
  else {
    uint64_t v21 = 0;
  }
  v90 = **(uint64_t ***)(v21 + 48);
  v91 = [[MPSGraphTensorData alloc] initWithMPSNDArray:*((void *)this + 20)];
  id v22 = GPU::EncodeDescriptor::getcomputeEncoder(v97);
  uint64_t v23 = *((void *)v97 + 1);
  id v24 = [v89 mpsndarray];
  v104[0] = v24;
  id v25 = [MEMORY[0x1E4F1C978] arrayWithObjects:v104 count:1];
  [v92 encodeToMPSCommandEncoder:v22 commandBuffer:v23 sourceArrays:v25 resultState:0 destinationArray:*((void *)this + 20) kernelDAGObject:0];

  if (((*(uint64_t (**)(GPU::ForOpHandler *, GPU::EncodeDescriptor *))(*(void *)this + 64))(this, v97) & 1) == 0)
  {
    id v26 = v97;
    id v27 = (void *)*((void *)v97 + 9);
    if (v27)
    {
      [v27 endEncoding];
      id v28 = (void *)*((void *)v26 + 9);
      *((void *)v26 + 9) = 0;
    }
    v29 = [v89 mpsndarray];
    uint64_t v30 = *((void *)v97 + 1);
    uint64_t v31 = *((void *)this + 16);
    v32 = [v89 mpsndarray];
    objc_msgSend(v29, "exportDataWithCommandBuffer:toBuffer:destinationDataType:offset:rowStrides:", v30, v31, objc_msgSend(v32, "dataType"), 0, 0);

    v33 = [v87 mpsndarray];
    uint64_t v34 = *((void *)v97 + 1);
    uint64_t v35 = *((void *)this + 17);
    v36 = [v87 mpsndarray];
    objc_msgSend(v33, "exportDataWithCommandBuffer:toBuffer:destinationDataType:offset:rowStrides:", v34, v35, objc_msgSend(v36, "dataType"), 0, 0);

    v37 = [v88 mpsndarray];
    uint64_t v38 = *((void *)v97 + 1);
    uint64_t v39 = *((void *)this + 18);
    v40 = [v88 mpsndarray];
    objc_msgSend(v37, "exportDataWithCommandBuffer:toBuffer:destinationDataType:offset:rowStrides:", v38, v39, objc_msgSend(v40, "dataType"), 0, 0);

    v86 = [*((id *)v97 + 1) rootCommandBuffer];
    (**(void (***)(GPU::EncodeDescriptor *))v97)(v97);
    [v86 waitUntilCompleted];
    [*((id *)this + 21) readBytes:(char *)&v95 + 4 strideBytes:0];
    [*((id *)this + 22) readBytes:&v95 strideBytes:0];
    [*((id *)this + 23) readBytes:&v94 strideBytes:0];
    if (v96[9])
    {
      unint64_t v41 = 0;
      uint64_t v42 = -16;
      uint64_t v43 = 24;
      do
      {
        uint64_t InitsMutable = mlir::scf::ForOp::getInitsMutable((mlir::scf::ForOp *)&v96);
        if (v45 <= v41) {
          __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
        }
        uint64_t v46 = *(void *)(InitsMutable + v43);
        uint64_t v47 = *((void *)this + 2);
        v102[0] = v46;
        v100[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v102) + 2);
        v48 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v47 + 88), v100);
        if (!v48
          || (v98[0] = v102[0],
              (v49 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v48 + 3, v98)) == 0)|| (id v50 = (id)v49[3]) == 0)
        {
          __assert_rtn("encodeOp", "GPUControlFlowOps.mm", 646, "initArgTensorData != nil");
        }
        v51 = v50;
        if (HIDWORD(v95) >= v95)
        {
          uint64_t v56 = *((void *)this + 3);
          if (v41 >= *(unsigned int *)(v56 + 36)) {
            __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
          }
          if (v41 > 5) {
            v55 = (uint64_t *)(v56 - 24 * (v41 - 5) - 96);
          }
          else {
            v55 = (uint64_t *)(v56 + v42);
          }
        }
        else
        {
          if ((void *)*v19 == v19) {
            goto LABEL_69;
          }
          uint64_t v52 = v19[1];
          uint64_t v53 = v52 - 8;
          if (!v52) {
            uint64_t v53 = 0;
          }
          uint64_t v54 = *(void *)(v53 + 48);
          if (v41 + 1 >= (*(void *)(v53 + 56) - v54) >> 3) {
LABEL_69:
          }
            __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
          v55 = *(uint64_t **)(v54 + 8 * v41 + 8);
        }
        uint64_t v57 = *((void *)this + 2);
        v102[0] = v55;
        v100[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)v102) + 2);
        v58 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v57 + 88), v100);
        if (v58
          && (v98[0] = v102[0],
              (v59 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v58 + 3, v98)) != 0))
        {
          id v60 = (id)v59[3];
        }
        else
        {
          id v60 = 0;
        }
        uint64_t v61 = *((void *)this + 2);
        if ((isStaticMPSType((uint64_t **)(*(void *)(v46 + 8) & 0xFFFFFFFFFFFFFFF8)) & 1) == 0)
        {
          StaticType = (uint64_t **)GPURegionRuntime::getStaticType(v61, v46);
          GPURegionRuntime::setStaticJITypeForValue(v61, v55, StaticType);
        }
        v63 = (void *)*((void *)this + 2);
        v64 = GPU::EncodeDescriptor::getcomputeEncoder(v97);

        ++v41;
        v42 -= 16;
        v43 += 32;
      }
      while (v41 < v96[9]);
    }
    unsigned int v65 = v95;
    unsigned int v66 = HIDWORD(v95);
    if (HIDWORD(v95) < v95)
    {
      int v67 = v94;
      do
      {
        LOBYTE(v100[0]) = v66 + v67 >= v65;
        BaseRuntime::setTensorDataToDataMap(*((void *)this + 2), v90, v91);
        v102[0] = this;
        v102[1] = &v96;
        v102[2] = v100;
        v102[3] = &v97;
        for (i = (void *)v19[1]; i != v19; i = (void *)i[1])
        {
          v69 = i - 1;
          if (!i) {
            v69 = 0;
          }
          v70 = (mlir::GenericProgramPoint *)(v69 + 4);
          v71 = (mlir::GenericProgramPoint *)v69[5];
          if (v71 != (mlir::GenericProgramPoint *)(v69 + 4))
          {
            do
            {
              v72 = (mlir::GenericProgramPoint *)*((void *)v71 + 1);
              mlir::GenericProgramPoint::~GenericProgramPoint(v71);
              mlir::detail::walk<mlir::ForwardIterator>(v73, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::ForOpHandler::encodeOp(GPU::EncodeDescriptor *)::$_0>, (uint64_t)v102, 1);
              v71 = v72;
            }
            while (v72 != v70);
          }
        }
        v74 = GPU::EncodeDescriptor::getcomputeEncoder(v97);
        uint64_t v75 = *((void *)v97 + 1);
        uint64_t v76 = *((void *)this + 23);
        v103[0] = *((void *)this + 20);
        v103[1] = v76;
        v77 = [MEMORY[0x1E4F1C978] arrayWithObjects:v103 count:2];
        [v92 encodeToMPSCommandEncoder:v74 commandBuffer:v75 sourceArrays:v77 resultState:0 destinationArray:*((void *)this + 20) kernelDAGObject:*((void *)this + 26)];

        HIDWORD(v78) = -858993459 * v66;
        LODWORD(v78) = -858993459 * v66;
        if ((v78 >> 1) <= 0x19999999) {
          (**(void (***)(GPU::EncodeDescriptor *))v97)(v97);
        }
        int v67 = v94;
        unsigned int v65 = v95;
        v66 += v94;
      }
      while (v66 < v95);
    }
  }
}

void sub_18015C1A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t mlir::anec::Convolution::getInput(mlir::anec::Convolution *this)
{
  return *(void *)(*(void *)(*(void *)this + 72) + 24);
}

void sub_18015C5A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E4FBE4C8, MEMORY[0x1E4FBA1C8]);
}

void sub_18015C600(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void getMPSGraphBuildSDKVersion(void)::$_0::operator()()
{
  if ((atomic_load_explicit((atomic_uchar *volatile)&qword_1E8EBF238, memory_order_acquire) & 1) == 0
    && __cxa_guard_acquire(&qword_1E8EBF238))
  {
    std::string::basic_string[abi:ne180100]<0>(&qword_1E8EBF288, "180200");
    __cxa_atexit(MEMORY[0x1E4FBA210], &qword_1E8EBF288, &dword_180159000);
    __cxa_guard_release(&qword_1E8EBF238);
  }
  if (byte_1E8EBF29F < 0)
  {
    v1 = (uint64_t *)qword_1E8EBF288;
    unint64_t v0 = qword_1E8EBF290;
  }
  else
  {
    unint64_t v0 = byte_1E8EBF29F;
    v1 = &qword_1E8EBF288;
  }
  unint64_t v2 = v0 - 4;
  if (v0 >= v0 - 4) {
    std::string::size_type v3 = v0 - 4;
  }
  else {
    std::string::size_type v3 = v0;
  }
  if (v3 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_60;
  }
  if (v3 >= 0x17)
  {
    uint64_t v5 = (v3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v3 | 7) != 0x17) {
      uint64_t v5 = v3 | 7;
    }
    uint64_t v6 = v5 + 1;
    p_dst = (std::string *)operator new(v5 + 1);
    __dst.__r_.__value_.__l.__size_ = v3;
    __dst.__r_.__value_.__r.__words[2] = v6 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
    goto LABEL_15;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v3;
  p_dst = &__dst;
  if (v3) {
LABEL_15:
  }
    memmove(p_dst, v1, v3);
  p_dst->__r_.__value_.__s.__data_[v3] = 0;
  unsigned int v7 = std::stoul(&__dst, 0, 10);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    unsigned __int8 v8 = byte_1E8EBF29F;
    if ((byte_1E8EBF29F & 0x80000000) == 0) {
      goto LABEL_18;
    }
  }
  else
  {
    unsigned __int8 v8 = byte_1E8EBF29F;
    if ((byte_1E8EBF29F & 0x80000000) == 0)
    {
LABEL_18:
      if (v2 > v8) {
        goto LABEL_61;
      }
      uint64_t v9 = &qword_1E8EBF288;
      unint64_t v10 = v0 - 2;
      unint64_t v11 = v8 - v2;
      if (v11 >= v0 - 2) {
        std::string::size_type v12 = v0 - 2;
      }
      else {
        std::string::size_type v12 = v11;
      }
      if (v12 > 0x7FFFFFFFFFFFFFF7) {
        goto LABEL_60;
      }
      goto LABEL_30;
    }
  }
  if (qword_1E8EBF290 < v2) {
    goto LABEL_61;
  }
  uint64_t v9 = (uint64_t *)qword_1E8EBF288;
  unint64_t v10 = v0 - 2;
  if (qword_1E8EBF290 - v2 >= v0 - 2) {
    std::string::size_type v12 = v0 - 2;
  }
  else {
    std::string::size_type v12 = qword_1E8EBF290 - v2;
  }
  if (v12 > 0x7FFFFFFFFFFFFFF7) {
LABEL_60:
  }
    std::string::__throw_length_error[abi:ne180100]();
LABEL_30:
  if (v12 >= 0x17)
  {
    uint64_t v14 = (v12 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v12 | 7) != 0x17) {
      uint64_t v14 = v12 | 7;
    }
    uint64_t v15 = v14 + 1;
    uint64_t v13 = (std::string *)operator new(v14 + 1);
    __dst.__r_.__value_.__l.__size_ = v12;
    __dst.__r_.__value_.__r.__words[2] = v15 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v13;
    goto LABEL_36;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v12;
  uint64_t v13 = &__dst;
  if (v12) {
LABEL_36:
  }
    memmove(v13, (char *)v9 + v2, v12);
  v13->__r_.__value_.__s.__data_[v12] = 0;
  unsigned int v16 = std::stoul(&__dst, 0, 10);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(__dst.__r_.__value_.__l.__data_);
    unsigned __int8 v17 = byte_1E8EBF29F;
    if ((byte_1E8EBF29F & 0x80000000) == 0)
    {
LABEL_39:
      if (v10 <= v17)
      {
        id v18 = &qword_1E8EBF288;
        std::string::size_type v19 = v17 - v10;
        if (v19 >= v0) {
          std::string::size_type v20 = v0;
        }
        else {
          std::string::size_type v20 = v19;
        }
        if (v20 > 0x7FFFFFFFFFFFFFF7) {
          goto LABEL_60;
        }
        goto LABEL_44;
      }
LABEL_61:
      std::string::__throw_out_of_range[abi:ne180100]();
    }
  }
  else
  {
    unsigned __int8 v17 = byte_1E8EBF29F;
    if ((byte_1E8EBF29F & 0x80000000) == 0) {
      goto LABEL_39;
    }
  }
  if (qword_1E8EBF290 < v10) {
    goto LABEL_61;
  }
  id v18 = (uint64_t *)qword_1E8EBF288;
  if (qword_1E8EBF290 - v10 >= v0) {
    std::string::size_type v20 = v0;
  }
  else {
    std::string::size_type v20 = qword_1E8EBF290 - v10;
  }
  if (v20 > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_60;
  }
LABEL_44:
  if (v20 >= 0x17)
  {
    uint64_t v22 = (v20 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v20 | 7) != 0x17) {
      uint64_t v22 = v20 | 7;
    }
    uint64_t v23 = v22 + 1;
    uint64_t v21 = (std::string *)operator new(v22 + 1);
    __dst.__r_.__value_.__l.__size_ = v20;
    __dst.__r_.__value_.__r.__words[2] = v23 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
    goto LABEL_50;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v20;
  uint64_t v21 = &__dst;
  if (v20) {
LABEL_50:
  }
    memmove(v21, (char *)v18 + v10, v20);
  v21->__r_.__value_.__s.__data_[v20] = 0;
  unsigned int v24 = std::stoul(&__dst, 0, 10);
  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  *(void *)&xmmword_1E8EBF270 = v7;
  *((void *)&xmmword_1E8EBF270 + 1) = v16;
  qword_1E8EBF280 = v24;
}

void sub_18015C980(_Unwind_Exception *a1)
{
}

void sub_18015C998(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void sub_18015CC90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  _Unwind_Resume(a1);
}

void sub_18015CCCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a17 < 0)
  {
    operator delete(__p);
    if ((a23 & 0x80000000) == 0)
    {
LABEL_3:

      if ((SHIBYTE(a11) & 0x80000000) == 0) {
        goto LABEL_4;
      }
      goto LABEL_7;
    }
  }
  else if ((a23 & 0x80000000) == 0)
  {
    goto LABEL_3;
  }
  operator delete(a18);

  if ((SHIBYTE(a11) & 0x80000000) == 0)
  {
LABEL_4:

    _Unwind_Resume(a1);
  }
LABEL_7:
  JUMPOUT(0x18015CD30);
}

void sub_18015CD20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0) {
    JUMPOUT(0x18015CD30);
  }
  JUMPOUT(0x18015CCECLL);
}

void GPU::ForOpHandler::ForOpHandler(GPU::ForOpHandler *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  id v26 = a3;
  uint64_t v5 = GPU::BaseOpHandler::BaseOpHandler(this, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1EC99CAE8;
  *(_OWORD *)((char *)v5 + 120) = 0u;
  *(_OWORD *)((char *)v5 + 136) = 0u;
  *(_OWORD *)((char *)v5 + 152) = 0u;
  *(_OWORD *)((char *)v5 + 168) = 0u;
  *(_OWORD *)((char *)v5 + 184) = 0u;
  *(_OWORD *)((char *)v5 + 200) = 0u;
  uint64_t v6 = [*(id *)(*((void *)v5 + 2) + 48) metalDevice];
  if ([v6 supportsCommandBufferJump]) {
    BOOL v7 = *((unsigned char *)this + 40) != 0;
  }
  else {
    BOOL v7 = 0;
  }
  *((unsigned char *)this + 41) = v7;

  uint64_t v8 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v9 = *(void **)(v8 + 16);
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v31 = *(void **)(v8 + 8);
    AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v31);
    if (v23 == 7 && *AttrData == 778462067 && *(_DWORD *)((char *)AttrData + 3) == 1919903278)
    {
      __int16 v30 = 1283;
      __p[0] = "classof on '";
      __p[2] = "scf.for";
      __p[3] = (void *)7;
      id v27 = "' failed due to the operation not being registered";
      __int16 v28 = 259;
      llvm::operator+((uint64_t *)__p, (uint64_t *)&v27, (uint64_t)&v31);
      llvm::report_fatal_error((llvm::Twine *)&v31, 1);
    }
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::scf::ForOp,void>::id)
  {
    uint64_t v25 = *((void *)this + 3);
    unint64_t Body = mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v25);
    uint64_t v31 = &v26;
    v32 = this;
    for (uint64_t i = *(void *)(Body + 8); i != Body; uint64_t i = *(void *)(i + 8))
    {
      uint64_t v12 = i - 8;
      if (!i) {
        uint64_t v12 = 0;
      }
      uint64_t v13 = (mlir::GenericProgramPoint *)(v12 + 32);
      uint64_t v14 = *(mlir::GenericProgramPoint **)(v12 + 40);
      if (v14 != (mlir::GenericProgramPoint *)(v12 + 32))
      {
        do
        {
          uint64_t v15 = (mlir::GenericProgramPoint *)*((void *)v14 + 1);
          mlir::GenericProgramPoint::~GenericProgramPoint(v14);
          mlir::detail::walk<mlir::ForwardIterator>(v16, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::ForOpHandler::ForOpHandler(GPURegionRuntime *,mlir::Operation *,GPU::MPSGraphKernelDAG *)::$_0>, (uint64_t)&v31, 1);
          uint64_t v14 = v15;
        }
        while (v15 != v13);
      }
    }
    id v17 = objc_alloc(MEMORY[0x1E4F35770]);
    id v18 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
    uint64_t v19 = [v17 initWithDevice:v18];
    std::string::size_type v20 = (void *)*((void *)this + 1);
    *((void *)this + 1) = v19;

    uint64_t v21 = operator new(8uLL);
    uint64_t v31 = v21;
    *uint64_t v21 = 1;
    v32 = (GPU::ForOpHandler *)(v21 + 1);
    v33 = v21 + 1;
    operator new();
  }
  __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
}

void sub_18015D484(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  id v26 = v25;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v23);
  _Unwind_Resume(a1);
}

GPU::IfOpHandler *GPU::IfOpHandler::IfOpHandler(GPU::IfOpHandler *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v5 = GPU::BaseOpHandler::BaseOpHandler(this, a2, a3, a4);
  *(void *)uint64_t v5 = &unk_1EC99C8B0;
  *((void *)v5 + 15) = 0;
  uint64_t v6 = (uint64_t *)((char *)v5 + 120);
  *((void *)v5 + 16) = 0;
  *((void *)v5 + 17) = 0;
  BOOL v7 = [*(id *)(*((void *)v5 + 2) + 48) metalDevice];
  if ([v7 supportsCommandBufferJump]) {
    BOOL v8 = *((unsigned char *)this + 40) != 0;
  }
  else {
    BOOL v8 = 0;
  }
  *((unsigned char *)this + 41) = v8;

  uint64_t v9 = *(void *)(*((void *)this + 3) + 48);
  unint64_t v10 = *(void **)(v9 + 16);
  if (v10 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v47[0] = *(void **)(v9 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)v47);
    if (v40 == 6 && *(_DWORD *)AttrData == 778462067 && *(_WORD *)(AttrData + 4) == 26217)
    {
      __int16 v46 = 1283;
      __p[0] = "classof on '";
      __p[2] = "scf.if";
      __p[3] = (void *)6;
      uint64_t v43 = "' failed due to the operation not being registered";
      __int16 v44 = 259;
      llvm::operator+((uint64_t *)__p, (uint64_t *)&v43, (uint64_t)v47);
      llvm::report_fatal_error((llvm::Twine *)v47, 1);
    }
LABEL_38:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v10 != &mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id) {
    goto LABEL_38;
  }
  uint64_t v42 = *((void *)this + 3);
  unint64_t Body = mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v42);
  v47[0] = this;
  for (uint64_t i = *(void *)(Body + 8); i != Body; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v13 = i - 8;
    if (!i) {
      uint64_t v13 = 0;
    }
    uint64_t v14 = (mlir::GenericProgramPoint *)(v13 + 32);
    uint64_t v15 = *(mlir::GenericProgramPoint **)(v13 + 40);
    if (v15 != (mlir::GenericProgramPoint *)(v13 + 32))
    {
      do
      {
        unsigned int v16 = (mlir::GenericProgramPoint *)*((void *)v15 + 1);
        mlir::GenericProgramPoint::~GenericProgramPoint(v15);
        mlir::detail::walk<mlir::ForwardIterator>(v17, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::IfOpHandler::IfOpHandler(GPURegionRuntime *,mlir::Operation *,GPU::MPSGraphKernelDAG *)::$_0>, (uint64_t)v47, 1);
        uint64_t v15 = v16;
      }
      while (v16 != v14);
    }
  }
  unint64_t v18 = mlir::scf::WhileOp::getAfter((mlir::scf::WhileOp *)&v42);
  v47[0] = this;
  for (uint64_t j = *(void *)(v18 + 8); j != v18; uint64_t j = *(void *)(j + 8))
  {
    uint64_t v20 = j - 8;
    if (!j) {
      uint64_t v20 = 0;
    }
    uint64_t v21 = (mlir::GenericProgramPoint *)(v20 + 32);
    uint64_t v22 = *(mlir::GenericProgramPoint **)(v20 + 40);
    if (v22 != (mlir::GenericProgramPoint *)(v20 + 32))
    {
      do
      {
        uint64_t v23 = (mlir::GenericProgramPoint *)*((void *)v22 + 1);
        mlir::GenericProgramPoint::~GenericProgramPoint(v22);
        mlir::detail::walk<mlir::ForwardIterator>(v24, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::IfOpHandler::IfOpHandler(GPURegionRuntime *,mlir::Operation *,GPU::MPSGraphKernelDAG *)::$_1>, (uint64_t)v47, 1);
        uint64_t v22 = v23;
      }
      while (v23 != v21);
    }
  }
  id v25 = objc_alloc(MEMORY[0x1E4F35770]);
  id v26 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v27 = [v25 initWithDevice:v26];
  __int16 v28 = (void *)*((void *)this + 1);
  *((void *)this + 1) = v27;

  if (*((unsigned char *)this + 41)) {
    uint64_t v29 = 32;
  }
  else {
    uint64_t v29 = 2147483656;
  }
  if (*((unsigned char *)this + 41)) {
    uint64_t v30 = 4;
  }
  else {
    uint64_t v30 = 1;
  }
  if (*((unsigned char *)this + 41))
  {
    uint64_t v31 = operator new(8uLL);
    *uint64_t v31 = 1;
    v47[1] = v31 + 1;
    v47[2] = v31 + 1;
    v47[0] = v31;
    operator new();
  }
  v32 = [MEMORY[0x1E4F35720] descriptorWithDataType:v29 shape:&unk_1EC9F1F28];
  [v32 setPreferPackedRows:1];
  v33 = [*(id *)(*((void *)this + 2) + 48) metalDevice];
  uint64_t v34 = [v33 newBufferWithLength:v30 options:0];
  uint64_t v35 = (void *)*v6;
  uint64_t *v6 = v34;

  uint64_t v36 = [objc_alloc(MEMORY[0x1E4F35690]) initWithBuffer:*v6 descriptor:v32];
  v37 = (void *)*((void *)this + 16);
  *((void *)this + 16) = v36;

  return this;
}

void sub_18015DAF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21)
{
  mlir::FrozenRewritePatternSet::~FrozenRewritePatternSet((mlir::FrozenRewritePatternSet *)&a10);
  if (__p)
  {
    a21 = (uint64_t)__p;
    operator delete(__p);
  }

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v21);
  _Unwind_Resume(a1);
}

void GPU::IfOpHandler::encodeOp(GPU::IfOpHandler *this, GPU::EncodeDescriptor *a2)
{
  v37 = a2;
  uint64_t v2 = *(void *)(*((void *)this + 3) + 48);
  std::string::size_type v3 = *(void **)(v2 + 16);
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    uint64_t v42 = *(GPU::IfOpHandler **)(v2 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v42);
    if (v34 == 6 && *(_DWORD *)AttrData == 778462067 && *(_WORD *)(AttrData + 4) == 26217)
    {
      __int16 v41 = 1283;
      v40[0] = (uint64_t)"classof on '";
      v40[2] = (uint64_t)"scf.if";
      v40[3] = 6;
      v38[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v39 = 259;
      llvm::operator+(v40, v38, (uint64_t)&v42);
      llvm::report_fatal_error((llvm::Twine *)&v42, 1);
    }
LABEL_36:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v3 != &mlir::detail::TypeIDResolver<mlir::scf::IfOp,void>::id) {
    goto LABEL_36;
  }
  uint64_t v36 = (GPU::IfOpHandler *)*((void *)this + 3);
  Input = (GPU::IfOpHandler *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v36);
  uint64_t v6 = *((void *)this + 2);
  uint64_t v42 = Input;
  v40[0] = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v42) + 2);
  BOOL v7 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v6 + 88), v40);
  if (v7
    && (v38[0] = (uint64_t)v42,
        (BOOL v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v7 + 3, v38)) != 0))
  {
    id v9 = (id)v8[3];
  }
  else
  {
    id v9 = 0;
  }
  if (((*(uint64_t (**)(GPU::IfOpHandler *, GPU::EncodeDescriptor *))(*(void *)this + 64))(this, v37) & 1) == 0)
  {
    unint64_t v10 = v37;
    unint64_t v11 = (void *)*((void *)v37 + 9);
    if (v11)
    {
      [v11 endEncoding];
      uint64_t v12 = (void *)*((void *)v10 + 9);
      *((void *)v10 + 9) = 0;
    }
    uint64_t v13 = [v9 mpsndarray];
    uint64_t v14 = *((void *)v37 + 1);
    uint64_t v15 = *((void *)this + 15);
    unsigned int v16 = [v9 mpsndarray];
    objc_msgSend(v13, "exportDataWithCommandBuffer:toBuffer:destinationDataType:offset:rowStrides:", v14, v15, objc_msgSend(v16, "dataType"), 0, 0);

    id v17 = [*((id *)v37 + 1) rootCommandBuffer];
    (**(void (***)(GPU::EncodeDescriptor *))v37)(v37);
    [v17 waitUntilCompleted];
    if (*(unsigned char *)[*((id *)this + 15) contents])
    {
      unint64_t Body = mlir::anec::A11Legacy::getBody((mlir::anec::A11Legacy *)&v36);
      uint64_t v42 = this;
      uint64_t v43 = &v37;
      for (uint64_t i = *(void *)(Body + 8); i != Body; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v27 = i - 8;
        if (!i) {
          uint64_t v27 = 0;
        }
        __int16 v28 = (mlir::GenericProgramPoint *)(v27 + 32);
        uint64_t v29 = *(mlir::GenericProgramPoint **)(v27 + 40);
        if (v29 != (mlir::GenericProgramPoint *)(v27 + 32))
        {
          do
          {
            uint64_t v30 = (mlir::GenericProgramPoint *)*((void *)v29 + 1);
            mlir::GenericProgramPoint::~GenericProgramPoint(v29);
            mlir::detail::walk<mlir::ForwardIterator>(v31, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::IfOpHandler::encodeOp(GPU::EncodeDescriptor *)::$_0>, (uint64_t)&v42, 1);
            uint64_t v29 = v30;
          }
          while (v30 != v28);
        }
      }
    }
    else
    {
      unint64_t v18 = mlir::scf::WhileOp::getAfter((mlir::scf::WhileOp *)&v36);
      uint64_t v42 = this;
      uint64_t v43 = &v37;
      for (uint64_t j = *(void *)(v18 + 8); j != v18; uint64_t j = *(void *)(j + 8))
      {
        uint64_t v20 = j - 8;
        if (!j) {
          uint64_t v20 = 0;
        }
        uint64_t v21 = (mlir::GenericProgramPoint *)(v20 + 32);
        uint64_t v22 = *(mlir::GenericProgramPoint **)(v20 + 40);
        if (v22 != (mlir::GenericProgramPoint *)(v20 + 32))
        {
          do
          {
            uint64_t v23 = (mlir::GenericProgramPoint *)*((void *)v22 + 1);
            mlir::GenericProgramPoint::~GenericProgramPoint(v22);
            mlir::detail::walk<mlir::ForwardIterator>(v24, (mlir::Operation *)llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::IfOpHandler::encodeOp(GPU::EncodeDescriptor *)::$_1>, (uint64_t)&v42, 1);
            uint64_t v22 = v23;
          }
          while (v23 != v21);
        }
      }
    }
    uint64_t v32 = *((void *)this + 2);
    uint64_t v42 = v36;
    std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>>>::__erase_unique<mlir::Operation *>((void *)(v32 + 304), (uint64_t *)&v42);
    std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,mlir::Type>>>>::__erase_unique<mlir::Operation *>((void *)(v32 + 344), (uint64_t *)&v42);
  }
}

void sub_18015DFA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015DFB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015DFC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015DFD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015DFEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015DFFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015E014(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015E024(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015E038(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18015E04C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

GPU::BaseOpHandler *GPU::BaseOpHandler::BaseOpHandler(GPU::BaseOpHandler *this, GPURegionRuntime *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  *(void *)this = &unk_1EC99CE60;
  *((void *)this + 1) = 0;
  *((void *)this + 2) = a2;
  *((void *)this + 3) = a3;
  *((void *)this + 4) = a4;
  *((void *)this + 6) = 0;
  *((void *)this + 8) = 0;
  *((void *)this + 10) = 0;
  v49 = (char *)this + 112;
  *((void *)this + 11) = (char *)this + 112;
  uint64_t v5 = (void *)((char *)this + 88);
  *((_OWORD *)this + 6) = xmmword_1810FE2E0;
  if ((*((unsigned char *)a3 + 46) & 0x80) == 0 || (uint64_t v6 = *((unsigned int *)a3 + 17), !v6))
  {
    char v9 = 1;
    int v17 = *((_DWORD *)a3 + 9);
    if (!v17) {
      goto LABEL_22;
    }
LABEL_19:
    uint64_t v18 = *((void *)a3 + 6);
    uint64_t v19 = *(void **)(v18 + 16);
    if (v19 == &mlir::detail::TypeIDResolver<void,void>::id)
    {
      uint64_t v54 = *(uint64_t ***)(v18 + 8);
      uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v54);
      if (v22 == 12 && *(void *)AttrData == 0x736E6F632E73706DLL && *(_DWORD *)(AttrData + 8) == 1953390964)
      {
        __int16 v53 = 1283;
        v52[0] = (uint64_t)"classof on '";
        v52[2] = (uint64_t)"mps.constant";
        v52[3] = 12;
        id v50 = "' failed due to the operation not being registered";
        __int16 v51 = 259;
        llvm::operator+(v52, (uint64_t *)&v50, (uint64_t)&v54);
        llvm::report_fatal_error((llvm::Twine *)&v54, 1);
      }
      BOOL v20 = 1;
    }
    else
    {
      BOOL v20 = v19 != &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id;
    }
    uint64_t v24 = *((void *)this + 3);
    uint64_t v25 = *(unsigned int *)(v24 + 36);
    *((unsigned char *)this + 57) = v20;
    if (v25) {
      uint64_t v26 = v24 - 16;
    }
    else {
      uint64_t v26 = 0;
    }
    if (!v25)
    {
      LOBYTE(v17) = 0;
      goto LABEL_52;
    }
    uint64_t v27 = 0;
    char v28 = 1;
    while (1)
    {
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v26, v27);
      uint64_t v30 = *(void *)(NextResultAtOffset + 8);
      uint64_t v31 = (uint64_t **)(v30 & 0xFFFFFFFFFFFFFFF8);
      if ((v30 & 0xFFFFFFFFFFFFFFF8) == 0)
      {
        int v45 = 650;
        __int16 v46 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
        uint64_t v47 = "Casting.h";
        v48 = "dyn_cast";
        goto LABEL_69;
      }
      if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v30 & 0xFFFFFFFFFFFFFFF8)))
      {
        uint64_t InterfaceFor = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v31);
        if (!InterfaceFor)
        {
          int v45 = 98;
          v48 = "Interface";
          uint64_t v47 = "InterfaceSupport.h";
          __int16 v46 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
LABEL_69:
          __assert_rtn(v48, v47, v45, v46);
        }
        uint64_t v54 = v31;
        uint64_t v55 = InterfaceFor;
        if (v31)
        {
          if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v54)) {
            goto LABEL_47;
          }
          ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v54);
          if (v34)
          {
            uint64_t v35 = 8 * v34;
            while (*ArgAttrsAttr != 0x8000000000000000)
            {
              ++ArgAttrsAttr;
              v35 -= 8;
              if (!v35) {
                goto LABEL_48;
              }
            }
LABEL_47:
            char v28 = 0;
          }
        }
      }
      else
      {
        uint64_t v54 = 0;
        uint64_t v55 = 0;
      }
LABEL_48:
      if (!GPURegionRuntime::isSmallIntType(*((void *)this + 2), (uint64_t **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), 1))*((unsigned char *)this + 57) = 0; {
      if (++v27 == v25)
      }
      {
        LOBYTE(v17) = *(_DWORD *)(*((void *)this + 3) + 36) != 0;
        goto LABEL_53;
      }
    }
  }
  uint64_t v7 = 0;
  uint64_t v8 = *((void *)a3 + 9);
  char v9 = 1;
  unint64_t v10 = "dyn_cast";
  do
  {
    uint64_t v11 = *(void *)(*(void *)(v8 + 32 * v7 + 24) + 8);
    uint64_t v12 = (uint64_t **)(v11 & 0xFFFFFFFFFFFFFFF8);
    if ((v11 & 0xFFFFFFFFFFFFFFF8) == 0)
    {
      int v42 = 650;
      uint64_t v43 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
      __int16 v44 = "Casting.h";
      goto LABEL_66;
    }
    if (mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v11 & 0xFFFFFFFFFFFFFFF8)))
    {
      uint64_t v13 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v12);
      if (!v13)
      {
        int v42 = 98;
        unint64_t v10 = "Interface";
        __int16 v44 = "InterfaceSupport.h";
        uint64_t v43 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
LABEL_66:
        __assert_rtn(v10, v44, v42, v43);
      }
      uint64_t v54 = v12;
      uint64_t v55 = v13;
      if (v12)
      {
        if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v54)) {
          goto LABEL_4;
        }
        uint64_t v14 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v54);
        if (v15)
        {
          uint64_t v16 = 8 * v15;
          while (*v14 != 0x8000000000000000)
          {
            ++v14;
            v16 -= 8;
            if (!v16) {
              goto LABEL_5;
            }
          }
LABEL_4:
          char v9 = 0;
        }
      }
    }
    else
    {
      uint64_t v54 = 0;
      uint64_t v55 = 0;
    }
LABEL_5:
    ++v7;
  }
  while (v7 != v6);
  a3 = (mlir::Operation *)*((void *)this + 3);
  int v17 = *((_DWORD *)a3 + 9);
  if (v17) {
    goto LABEL_19;
  }
LABEL_22:
  *((unsigned char *)this + 57) = 0;
LABEL_52:
  char v28 = 1;
LABEL_53:
  char v36 = v9 & v28 & 1;
  *((unsigned char *)this + 40) = v36;
  *((unsigned char *)this + 56) = v17 & (v28 ^ 1);
  *((unsigned char *)this + 41) = v36;
  v37 = (void *)*((void *)this + 6);
  *((void *)this + 6) = 0;

  *((void *)this + 9) = 0;
  unint64_t v38 = *(unsigned int *)(*((void *)this + 3) + 36);
  unint64_t v39 = *((void *)this + 12);
  if (v39 != v38)
  {
    unint64_t v40 = *((void *)this + 13);
    if (v39 > v38)
    {
      if (v40 >= v38) {
        goto LABEL_56;
      }
LABEL_63:
      __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
    }
    if (v40 < v38)
    {
      llvm::SmallVectorBase<unsigned long long>::grow_pod((uint64_t)v5, v49, *(unsigned int *)(*((void *)this + 3) + 36), 1);
      unint64_t v39 = *((void *)this + 12);
    }
    if (v38 != v39) {
      bzero((void *)(*v5 + v39), v38 - v39);
    }
    if (*((void *)this + 13) < v38) {
      goto LABEL_63;
    }
LABEL_56:
    *((void *)this + 12) = v38;
  }
  return this;
}

void sub_18015E4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  if (*v10 != a9) {
    free(*v10);
  }
  uint64_t v12 = *(id **)(v9 + 80);
  *(void *)(v9 + 80) = 0;
  if (v12)
  {

    MEMORY[0x1852FDE70](v12, 0x1080C40CC6EE3FDLL);
  }

  _Unwind_Resume(a1);
}

void std::string::__throw_length_error[abi:ne180100]()
{
}

void llvm::report_fatal_error(llvm::Twine *a1, uint64_t a2)
{
  std::mutex::lock(&_MergedGlobals_42);
  uint64_t v5 = (uint64_t (*)(uint64_t, std::string *, uint64_t))_MergedGlobals_9;
  uint64_t v4 = unk_1E8EBF140;
  std::mutex::unlock(&_MergedGlobals_42);
  if (v5)
  {
    llvm::Twine::str(a1, &__p);
    if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
      p_p = &__p;
    }
    else {
      p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
    }
    unint64_t v10 = (llvm::sys *)v5(v4, p_p, a2);
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      operator delete(__p.__r_.__value_.__l.__data_);
    }
LABEL_14:
    llvm::sys::RunInterruptHandlers(v10);
    if (a2) {
      abort();
    }
    exit(1);
  }
  uint64_t v19 = &__p;
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)v21;
  *(_OWORD *)&__p.__r_.__value_.__r.__words[1] = xmmword_181101A40;
  int v12 = 0;
  char v16 = 0;
  uint64_t v17 = 0;
  int v18 = 1;
  uint64_t v14 = 0;
  uint64_t v15 = 0;
  uint64_t v13 = 0;
  uint64_t v11 = &unk_1EC9A3930;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v11, 0, 0, 0);
  uint64_t v6 = (void *)v15;
  if ((unint64_t)(v14 - v15) > 0xB)
  {
    *(_DWORD *)(v15 + 8) = 540693071;
    void *v6 = *(void *)"LLVM ERROR: ";
    v15 += 12;
    uint64_t v7 = (llvm::raw_ostream *)&v11;
    llvm::Twine::print(a1, (llvm::raw_ostream *)&v11);
    uint64_t v8 = (unsigned char *)v15;
    if (v14 != v15) {
      goto LABEL_4;
    }
  }
  else
  {
    uint64_t v7 = llvm::raw_ostream::write((llvm::raw_ostream *)&v11, "LLVM ERROR: ", 0xCuLL);
    llvm::Twine::print(a1, v7);
    uint64_t v8 = (unsigned char *)*((void *)v7 + 4);
    if (*((unsigned char **)v7 + 3) != v8)
    {
LABEL_4:
      unsigned char *v8 = 10;
      ++*((void *)v7 + 4);
      goto LABEL_12;
    }
  }
  llvm::raw_ostream::write(v7, "\n", 1uLL);
LABEL_12:
  write(2, v19->__r_.__value_.__l.__data_, v19->__r_.__value_.__l.__size_);
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v11);
  unint64_t v10 = (llvm::sys *)__p.__r_.__value_.__r.__words[0];
  if (__p.__r_.__value_.__l.__data_ != v21) {
    free(__p.__r_.__value_.__l.__data_);
  }
  goto LABEL_14;
}

void GPU::GetCoordOpHandler::encodeNDArrayOp(GPU::GetCoordOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v7 = *(void **)(v6 + 16);
  v62 = v5;
  if (v7 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    v74 = *(void **)(v6 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v74);
    if (v58 == 19)
    {
      BOOL v59 = *AttrData == 0x5F7465672E73706DLL && AttrData[1] == 0x616E6964726F6F63;
      if (v59 && *(void *)((char *)AttrData + 11) == 0x736574616E696472)
      {
        __int16 v73 = 1283;
        v69 = "classof on '";
        v71 = "mps.get_coordinates";
        uint64_t v72 = 19;
        int v67 = "' failed due to the operation not being registered";
        __int16 v68 = 259;
        llvm::operator+((uint64_t *)&v69, (uint64_t *)&v67, (uint64_t)&v74);
        llvm::report_fatal_error((llvm::Twine *)&v74, 1);
      }
    }
LABEL_55:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::mps::GetCoordOp,void>::id) {
    goto LABEL_55;
  }
  uint64_t v8 = v5;
  uint64_t v66 = *((void *)this + 3);
  uint64_t v9 = *((void *)this + 2);
  Input = (void *)mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v66);
  GPURegionRuntime::waitAndReadIntTensorData(v9, (uint64_t)a2, Input, (uint64_t)&v74);
  uint64_t v11 = [(NSArray *)v8 objectAtIndexedSubscript:0];
  int v12 = [v11 mpsndarray];

  id v13 = v12;
  if (!v13 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  Filter = (void *)mlir::anec::Convolution::getFilter((mlir::anec::Convolution *)&v66);
  uint64_t v16 = CoordAxis;
  uint64_t v17 = (char *)v74;
  int v18 = v75;
  size_t v19 = v75 - (unsigned char *)v74;
  uint64_t v20 = (v75 - (unsigned char *)v74) >> 3;
  if (CoordAxis >= 0) {
    uint64_t v21 = (v75 - (unsigned char *)v74) >> 3;
  }
  else {
    uint64_t v21 = 0;
  }
  uint64_t v22 = v21 + ~CoordAxis;
  if (v22 < 4)
  {
    uint64_t v61 = v13;
  }
  else
  {
    uint64_t v23 = [v13 descriptor];
    [v23 transposeDimension:v22 withDimension:3];
    if (*((unsigned char *)v13 + (int)*MEMORY[0x1E4F359C0])) {
      objc_msgSend(v13, "setReadCount:", objc_msgSend(v13, "readCount") + 1);
    }
    uint64_t v24 = *((void *)a2 + 1);
    uint64_t v25 = (void *)*((void *)a2 + 9);
    if (!v25)
    {
      uint64_t v26 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
      uint64_t v27 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v26;

      char v28 = (void *)*((void *)a2 + 11);
      uint64_t v25 = (void *)*((void *)a2 + 9);
      if (v28)
      {
        uint64_t v29 = [v28 wrapComputeEncoder:*((void *)a2 + 9)];
        uint64_t v30 = (void *)*((void *)a2 + 9);
        *((void *)a2 + 9) = v29;

        uint64_t v25 = (void *)*((void *)a2 + 9);
      }
    }
    if (*((void *)a2 + 10))
    {
      objc_msgSend(v25, "setLabel:");
      uint64_t v25 = (void *)*((void *)a2 + 9);
    }
    id v31 = v25;
    uint64_t v61 = [v13 safeArrayViewWithCommandBuffer:v24 computeEncoder:v31 descriptor:v23 aliasing:1];

    uint64_t v17 = (char *)v74;
    int v18 = v75;
    size_t v19 = v75 - (unsigned char *)v74;
    uint64_t v20 = (v75 - (unsigned char *)v74) >> 3;
  }
  id v32 = *((id *)this + 1);
  v69 = 0;
  v70 = 0;
  v71 = 0;
  int64_t v33 = v18 - v17;
  if (v18 == v17)
  {
    uint64_t v35 = 0;
    std::string __p = 0;
    v64 = 0;
    unsigned int v65 = 0;
    goto LABEL_29;
  }
  if ((v19 & 0x8000000000000000) != 0) {
    std::vector<long>::__throw_length_error[abi:ne180100]();
  }
  uint64_t v34 = (const char *)operator new(v19);
  uint64_t v35 = (char *)v34;
  v69 = v34;
  v70 = v34;
  v71 = &v34[8 * v20];
  if ((unint64_t)(v33 - 8) < 0x18)
  {
    char v36 = v18;
    v37 = (char *)v34;
    do
    {
LABEL_25:
      uint64_t v44 = *((void *)v36 - 1);
      v36 -= 8;
      *(void *)v37 = v44;
      v37 += 8;
    }
    while (v36 != v17);
    goto LABEL_26;
  }
  unint64_t v38 = ((unint64_t)(v33 - 8) >> 3) + 1;
  uint64_t v39 = 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
  char v36 = &v18[-v39];
  v37 = (char *)&v34[v39];
  unint64_t v40 = (int8x16_t *)(v34 + 16);
  __int16 v41 = (int8x16_t *)(v18 - 16);
  uint64_t v42 = v38 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    int8x16_t v43 = vextq_s8(v41[-1], v41[-1], 8uLL);
    v40[-1] = vextq_s8(*v41, *v41, 8uLL);
    int8x16_t *v40 = v43;
    v40 += 2;
    v41 -= 2;
    v42 -= 4;
  }
  while (v42);
  if (v38 != (v38 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_25;
  }
LABEL_26:
  std::string __p = 0;
  v64 = 0;
  unsigned int v65 = 0;
  int64_t v45 = v37 - v34;
  if (v37 != v34)
  {
    if (v45 < 0) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    __int16 v46 = (char *)operator new(v37 - v34);
    uint64_t v47 = &v46[8 * (v45 >> 3)];
    std::string __p = v46;
    unsigned int v65 = v47;
    memcpy(v46, v35, v45);
    v64 = v47;
  }
LABEL_29:
  uint64_t Result = mlir::anec::Broadcast::getResult((mlir::anec::Broadcast *)&v66);
  getMPSDataType((void *)(*(void *)(Result + 8) & 0xFFFFFFFFFFFFFFF8));
  v49 = GPU::GetCoordOpHandler::_getKernelDAGObject((uint64_t)this, v16, (uint64_t *)&__p);
  if (__p)
  {
    v64 = __p;
    operator delete(__p);
  }
  id v50 = (void *)*((void *)a2 + 9);
  if (!v50)
  {
    uint64_t v51 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    uint64_t v52 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = v51;

    __int16 v53 = (void *)*((void *)a2 + 11);
    id v50 = (void *)*((void *)a2 + 9);
    if (v53)
    {
      uint64_t v54 = [v53 wrapComputeEncoder:*((void *)a2 + 9)];
      uint64_t v55 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v54;

      id v50 = (void *)*((void *)a2 + 9);
    }
  }
  if (*((void *)a2 + 10))
  {
    objc_msgSend(v50, "setLabel:");
    id v50 = (void *)*((void *)a2 + 9);
  }
  id v56 = v50;
  [v32 encodeToMPSCommandEncoder:v56 commandBuffer:*((void *)a2 + 1) sourceArrays:MEMORY[0x1E4F1CBF0] resultState:0 destinationArray:v61 kernelDAGObject:v49];

  if (v35) {
    operator delete(v35);
  }

  if (v74)
  {
    uint64_t v75 = (char *)v74;
    operator delete(v74);
  }
}

void sub_18015EC8C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  if (__p) {
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

void getSignatureOfModule(std::string *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5)
{
  uint64_t FuncOpInModule = getFuncOpInModule(a2);
  a1->__r_.__value_.__l.__size_ = 0;
  a1->__r_.__value_.__r.__words[2] = 0;
  a1->__r_.__value_.__r.__words[0] = 0;
  int v22 = 0;
  char v26 = 0;
  uint64_t v27 = 0;
  int v28 = 1;
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  uint64_t v23 = 0;
  uint64_t v21 = &unk_1EC9A38B8;
  uint64_t v29 = a1;
  llvm::raw_ostream::SetBufferAndMode((uint64_t)&v21, 0, 0, 0);
  if (!a5)
  {
    uint64_t FunctionType = mlir::func::FuncOp::getFunctionType((mlir::func::FuncOp *)&FuncOpInModule);
    Inputs = (const void *)mlir::FunctionType::getInputs((mlir::FunctionType *)&FunctionType);
    uint64_t v10 = v13;
    uint64_t FunctionType = 0;
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    if (v13) {
      goto LABEL_3;
    }
LABEL_6:
    int v12 = 0;
    goto LABEL_7;
  }
  Inputs = *(const void **)a5;
  uint64_t v10 = (uint64_t)(*(void *)(a5 + 8) - *(void *)a5) >> 3;
  uint64_t FunctionType = 0;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  if (!v10) {
    goto LABEL_6;
  }
LABEL_3:
  if (v10 < 0) {
    std::vector<int>::__throw_length_error[abi:ne180100]();
  }
  size_t v11 = 8 * v10;
  int v12 = (uint64_t *)operator new(8 * v10);
  uint64_t v10 = (uint64_t)&v12[v10];
  uint64_t FunctionType = (uint64_t)v12;
  uint64_t v20 = v10;
  memcpy(v12, Inputs, v11);
  uint64_t v19 = v10;
LABEL_7:
  std::string::append(v29, "inputs (");
  if (v12 != (uint64_t *)v10)
  {
    uint64_t v31 = *v12;
    mlir::Type::print((llvm::raw_ostream *)&v31, (llvm::raw_ostream *)&v21);
    for (uint64_t i = v12 + 1; i != (uint64_t *)v10; ++i)
    {
      if ((unint64_t)(v24 - (void)v25) > 1) {
        *v25++ = 8236;
      }
      else {
        llvm::raw_ostream::write((llvm::raw_ostream *)&v21, ", ", 2uLL);
      }
      uint64_t v31 = *i;
      mlir::Type::print((llvm::raw_ostream *)&v31, (llvm::raw_ostream *)&v21);
    }
  }
  std::string::append(v29, ")");
  if (v12) {
    operator delete(v12);
  }
  if (a4)
  {
    std::string::append(v29, " attributes {");
    uint64_t FunctionType = mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)a3);
    mlir::Attribute::print((mlir::Attribute *)&FunctionType, (llvm::raw_ostream *)&v21, 0);
    std::string::append(v29, " : ");
    uint64_t FunctionType = a3[1];
    mlir::Attribute::print((mlir::Attribute *)&FunctionType, (llvm::raw_ostream *)&v21, 0);
    if (a4 == 1)
    {
      std::string::append(v29, "}");
    }
    else
    {
      std::string::append(v29, ", ");
      uint64_t v15 = (mlir::CallGraphNode *)(a3 + 2);
      unint64_t v16 = 1;
      do
      {
        uint64_t FunctionType = mlir::CallGraphNode::getCallableRegion(v15);
        mlir::Attribute::print((mlir::Attribute *)&FunctionType, (llvm::raw_ostream *)&v21, 0);
        std::string::append(v29, " : ");
        uint64_t FunctionType = *((void *)v15 + 1);
        mlir::Attribute::print((mlir::Attribute *)&FunctionType, (llvm::raw_ostream *)&v21, 0);
        if (a4 - 1 <= v16) {
          uint64_t v17 = "}";
        }
        else {
          uint64_t v17 = ", ";
        }
        std::string::append(v29, v17);
        ++v16;
        uint64_t v15 = (mlir::CallGraphNode *)((char *)v15 + 16);
      }
      while (a4 != v16);
    }
  }
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&v21);
}

void sub_18015F080(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  llvm::raw_ostream::~raw_ostream((llvm::raw_ostream *)&a12);
  if (*(char *)(v12 + 23) < 0) {
    operator delete(*(void **)v12);
  }
  _Unwind_Resume(a1);
}

double mlir::Attribute::print(mlir::Attribute *this, llvm::raw_ostream *a2, int a3)
{
  if (*(void *)this)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext(this);
    mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)&v17);
    uint64_t v7 = (char *)operator new(0x2C0uLL);
    uint64_t v8 = mlir::DialectInterfaceCollection<mlir::OpAsmDialectInterface>::DialectInterfaceCollection(v7, Context);
    *(void *)(v8 + 56) = v8 + 72;
    *(void *)(v8 + 64) = 0x600000000;
    *(_OWORD *)(v8 + 120) = 0u;
    *(_DWORD *)(v8 + 136) = 0;
    *(_OWORD *)(v8 + 144) = 0u;
    uint64_t v9 = (uint64_t *)(v8 + 144);
    *(_DWORD *)(v8 + 160) = 0;
    *(_OWORD *)(v8 + 184) = 0u;
    *(void *)(v8 + 168) = v8 + 184;
    *(void *)(v8 + 176) = 0;
    *(void *)(v8 + 200) = v8 + 216;
    *(void *)(v8 + 208) = 0x400000000;
    *(void *)(v8 + 248) = v8 + 264;
    *(_OWORD *)(v8 + 256) = 0u;
    *(void *)(v8 + 272) = 1;
    *(_OWORD *)(v8 + 280) = 0u;
    *(_DWORD *)(v8 + 296) = 0;
    *(_DWORD *)(v8 + 320) = 0;
    *(_OWORD *)(v8 + 304) = 0u;
    *(_DWORD *)(v8 + 344) = 0;
    *(_OWORD *)(v8 + 328) = 0u;
    *(_DWORD *)(v8 + 368) = 0;
    *(_OWORD *)(v8 + 352) = 0u;
    *(_DWORD *)(v8 + 392) = 0;
    *(_OWORD *)(v8 + 376) = 0u;
    *(_DWORD *)(v8 + 416) = 0;
    *(_OWORD *)(v8 + 400) = 0u;
    *(_OWORD *)(v8 + 424) = 0u;
    *(void *)(v8 + 440) = 0;
    *(void *)(v8 + 448) = v8 + 464;
    *(void *)(v8 + 456) = 0x400000000;
    *(void *)(v8 + 496) = v8 + 512;
    *(_OWORD *)(v8 + 504) = 0u;
    *(void *)(v8 + 520) = 1;
    *(void *)(v8 + 528) = 0;
    *((_DWORD *)v7 + 134) = 0;
    mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)(v8 + 544));
    *((_DWORD *)v7 + 152) = 0;
    *((void *)v7 + 75) = 0;
    *(_OWORD *)(v7 + 584) = 0u;
    long long v10 = v18;
    *(_OWORD *)(v7 + 616) = v17;
    *(_OWORD *)(v7 + 632) = v10;
    *((void *)v7 + 81) = v19;
    *((void *)v7 + 82) = 0;
    *(_OWORD *)(v7 + 664) = 0u;
    *((_DWORD *)v7 + 170) = 0;
    *((void *)v7 + 86) = v7 + 704;
    *((void *)v7 + 87) = 0;
    *(void *)&long long v17 = a2;
    *((void *)&v17 + 1) = v7;
    long long v11 = *(_OWORD *)(v7 + 632);
    long long v18 = *(_OWORD *)(v7 + 616);
    long long v19 = v11;
    uint64_t v20 = *((void *)v7 + 81);
    int v21 = 1;
    if (a3) {
      int v12 = 2;
    }
    else {
      int v12 = 0;
    }
    uint64_t v13 = *(uint64_t ***)this;
    if (v13)
    {
        mlir::AsmPrinter::Impl::printAttributeImpl((llvm::raw_ostream **)&v17, v13, v12);
    }
    else
    {
      uint64_t v16 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v16) > 0x11)
      {
        *(_WORD *)(v16 + 16) = 15934;
        *(_OWORD *)uint64_t v16 = *(_OWORD *)"<<NULL ATTRIBUTE>>";
        *((void *)a2 + 4) += 18;
      }
      else
      {
        llvm::raw_ostream::write(a2, "<<NULL ATTRIBUTE>>", 0x12uLL);
      }
    }
    mlir::detail::AsmStateImpl::~AsmStateImpl((mlir::detail::AsmStateImpl *)v7);
  }
  uint64_t v14 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v14) > 0x11)
  {
    *(_WORD *)(v14 + 16) = 15934;
    double result = *(double *)"<<NULL ATTRIBUTE>>";
    *(_OWORD *)uint64_t v14 = *(_OWORD *)"<<NULL ATTRIBUTE>>";
    *((void *)a2 + 4) += 18;
  }
  else
  {
    llvm::raw_ostream::write(a2, "<<NULL ATTRIBUTE>>", 0x12uLL);
  }
  return result;
}

uint64_t mlir::CallGraphNode::getCallableRegion(mlir::CallGraphNode *this)
{
  return *(void *)this;
}

void llvm::raw_ostream::~raw_ostream(llvm::raw_ostream *this)
{
  *(void *)this = &unk_1EC9A1858;
  if (*((_DWORD *)this + 14) == 1)
  {
    v1 = (void *)*((void *)this + 2);
    if (v1) {
      operator delete[](v1);
    }
  }
}

void sub_18015FAD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

void GPU::GRUOpHandler::encodeNDArrayOp(GPU::GRUOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v409 = *MEMORY[0x1E4F143B8];
  v322 = a3;
  v367 = this;
  uint64_t v4 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v407 = *(void *)(v4 + 8);
    uint64_t AttrData = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v407);
    if (v307 == 7 && *AttrData == 779317357 && *(_DWORD *)((char *)AttrData + 3) == 1970431790)
    {
      __int16 v406 = 1283;
      *(void *)&long long v403 = "classof on '";
      uint64_t v404 = (uint64_t)"mps.gru";
      uint64_t v405 = 7;
      v373 = "' failed due to the operation not being registered";
      __int16 v376 = 259;
      llvm::operator+((uint64_t *)&v403, (uint64_t *)&v373, (uint64_t)&v407);
      llvm::report_fatal_error((llvm::Twine *)&v407, 1);
    }
LABEL_464:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GRUOp,void>::id) {
    goto LABEL_464;
  }
  uint64_t v372 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v372);
  uint64_t RecurrentWeight = mlir::mps::LSTMOp::getRecurrentWeight((mlir::mps::LSTMOp *)&v372);
  uint64_t InputState = mlir::mps::LSTMOp::getInputState((mlir::mps::LSTMOp *)&v372);
  uint64_t InputCell = mlir::mps::LSTMOp::getInputCell((mlir::mps::LSTMOp *)&v372);
  BOOL Training = mlir::mps::GRUOp::getTraining((mlir::mps::GRUOp *)&v372);
  BOOL ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v372);
  mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v372);
  uint64_t Mask = mlir::mps::LSTMOp::getMask((mlir::mps::LSTMOp *)&v372);
  int v12 = (void *)*((void *)a2 + 9);
  if (v12)
  {
    if (*((void *)a2 + 10))
    {
LABEL_5:
      objc_msgSend(v12, "setLabel:");
      uint64_t v13 = a2;
      int v12 = (void *)*((void *)a2 + 9);
      goto LABEL_10;
    }
  }
  else
  {
    uint64_t v14 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    uint64_t v15 = (void *)*((void *)a2 + 9);
    *((void *)a2 + 9) = v14;

    uint64_t v16 = (void *)*((void *)a2 + 11);
    int v12 = (void *)*((void *)a2 + 9);
    if (v16)
    {
      uint64_t v17 = [v16 wrapComputeEncoder:*((void *)a2 + 9)];
      long long v18 = (void *)*((void *)a2 + 9);
      *((void *)a2 + 9) = v17;

      int v12 = (void *)*((void *)a2 + 9);
    }
    if (*((void *)a2 + 10)) {
      goto LABEL_5;
    }
  }
  uint64_t v13 = a2;
LABEL_10:
  id v365 = v12;
  id v366 = *((id *)v13 + 1);
  id v353 = *((id *)v367 + 1);
  long long v19 = (int8x8_t *)*((void *)v367 + 2);
  *(void *)&long long v407 = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)&v407);
  int8x8_t v21 = v19[12];
  if (!*(void *)&v21) {
    goto LABEL_51;
  }
  unint64_t v22 = *((void *)ParentRegion + 2);
  unint64_t v23 = 0x9DDFEA08EB382D69 * (((8 * v22) + 8) ^ HIDWORD(v22));
  unint64_t v24 = 0x9DDFEA08EB382D69 * (HIDWORD(v22) ^ (v23 >> 47) ^ v23);
  unint64_t v25 = 0x9DDFEA08EB382D69 * (v24 ^ (v24 >> 47));
  uint8x8_t v26 = (uint8x8_t)vcnt_s8(v21);
  v26.i16[0] = vaddlv_u8(v26);
  if (v26.u32[0] > 1uLL)
  {
    unint64_t v27 = 0x9DDFEA08EB382D69 * (v24 ^ (v24 >> 47));
    if (v25 >= *(void *)&v21) {
      unint64_t v27 = v25 % *(void *)&v21;
    }
  }
  else
  {
    unint64_t v27 = v25 & (*(void *)&v21 - 1);
  }
  int v28 = *(void **)(*(void *)&v19[11] + 8 * v27);
  if (!v28) {
    goto LABEL_51;
  }
  uint64_t v29 = (void *)*v28;
  if (!v29) {
    goto LABEL_51;
  }
  if (v26.u32[0] < 2uLL)
  {
    uint64_t v30 = *(void *)&v21 - 1;
    while (1)
    {
      uint64_t v32 = v29[1];
      if (v32 == v25)
      {
        if (v29[2] == v22) {
          goto LABEL_31;
        }
      }
      else if ((v32 & v30) != v27)
      {
        goto LABEL_51;
      }
      uint64_t v29 = (void *)*v29;
      if (!v29) {
        goto LABEL_51;
      }
    }
  }
  while (1)
  {
    unint64_t v31 = v29[1];
    if (v31 == v25) {
      break;
    }
    if (v31 >= *(void *)&v21) {
      v31 %= *(void *)&v21;
    }
    if (v31 != v27) {
      goto LABEL_51;
    }
LABEL_20:
    uint64_t v29 = (void *)*v29;
    if (!v29) {
      goto LABEL_51;
    }
  }
  if (v29[2] != v22) {
    goto LABEL_20;
  }
LABEL_31:
  int8x8_t v33 = (int8x8_t)v29[4];
  if (v33)
  {
    unint64_t v34 = 0x9DDFEA08EB382D69 * (((8 * v407) + 8) ^ DWORD1(v407));
    unint64_t v35 = 0x9DDFEA08EB382D69 * (DWORD1(v407) ^ (v34 >> 47) ^ v34);
    unint64_t v36 = 0x9DDFEA08EB382D69 * (v35 ^ (v35 >> 47));
    uint8x8_t v37 = (uint8x8_t)vcnt_s8(v33);
    v37.i16[0] = vaddlv_u8(v37);
    if (v37.u32[0] > 1uLL)
    {
      unint64_t v38 = v36;
      if (v36 >= *(void *)&v33) {
        unint64_t v38 = v36 % *(void *)&v33;
      }
    }
    else
    {
      unint64_t v38 = v36 & (*(void *)&v33 - 1);
    }
    uint64_t v39 = *(uint64_t ****)(v29[3] + 8 * v38);
    if (v39)
    {
      unint64_t v40 = *v39;
      if (v40)
      {
        if (v37.u32[0] < 2uLL)
        {
          uint64_t v41 = *(void *)&v33 - 1;
          while (1)
          {
            uint64_t v44 = v40[1];
            if (v44 == (uint64_t *)v36)
            {
              if (v40[2] == (uint64_t *)v407) {
                goto LABEL_444;
              }
            }
            else if (((unint64_t)v44 & v41) != v38)
            {
              goto LABEL_51;
            }
            uint64_t v42 = 0;
            unint64_t v40 = (uint64_t **)*v40;
            if (!v40) {
              goto LABEL_52;
            }
          }
        }
        while (1)
        {
          unint64_t v43 = (unint64_t)v40[1];
          if (v43 == v36)
          {
            if (v40[2] == (uint64_t *)v407)
            {
LABEL_444:
              uint64_t v42 = v40[3];
              goto LABEL_52;
            }
          }
          else
          {
            if (v43 >= *(void *)&v33) {
              v43 %= *(void *)&v33;
            }
            if (v43 != v38) {
              break;
            }
          }
          uint64_t v42 = 0;
          unint64_t v40 = (uint64_t **)*v40;
          if (!v40) {
            goto LABEL_52;
          }
        }
      }
    }
  }
LABEL_51:
  uint64_t v42 = 0;
LABEL_52:
  v318 = [v42 mpsndarray];

  int64_t v45 = (int8x8_t *)*((void *)v367 + 2);
  *(void *)&long long v407 = RecurrentWeight;
  __int16 v46 = mlir::Value::getParentRegion((mlir::Value *)&v407);
  int8x8_t v47 = v45[12];
  if (!*(void *)&v47) {
    goto LABEL_93;
  }
  unint64_t v48 = *((void *)v46 + 2);
  unint64_t v49 = 0x9DDFEA08EB382D69 * (((8 * v48) + 8) ^ HIDWORD(v48));
  unint64_t v50 = 0x9DDFEA08EB382D69 * (HIDWORD(v48) ^ (v49 >> 47) ^ v49);
  unint64_t v51 = 0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47));
  uint8x8_t v52 = (uint8x8_t)vcnt_s8(v47);
  v52.i16[0] = vaddlv_u8(v52);
  if (v52.u32[0] > 1uLL)
  {
    unint64_t v53 = 0x9DDFEA08EB382D69 * (v50 ^ (v50 >> 47));
    if (v51 >= *(void *)&v47) {
      unint64_t v53 = v51 % *(void *)&v47;
    }
  }
  else
  {
    unint64_t v53 = v51 & (*(void *)&v47 - 1);
  }
  uint64_t v54 = *(void **)(*(void *)&v45[11] + 8 * v53);
  if (!v54) {
    goto LABEL_93;
  }
  uint64_t v55 = (void *)*v54;
  if (!v55) {
    goto LABEL_93;
  }
  if (v52.u32[0] < 2uLL)
  {
    uint64_t v56 = *(void *)&v47 - 1;
    while (1)
    {
      uint64_t v58 = v55[1];
      if (v58 == v51)
      {
        if (v55[2] == v48) {
          goto LABEL_73;
        }
      }
      else if ((v58 & v56) != v53)
      {
        goto LABEL_93;
      }
      uint64_t v55 = (void *)*v55;
      if (!v55) {
        goto LABEL_93;
      }
    }
  }
  while (1)
  {
    unint64_t v57 = v55[1];
    if (v57 == v51) {
      break;
    }
    if (v57 >= *(void *)&v47) {
      v57 %= *(void *)&v47;
    }
    if (v57 != v53) {
      goto LABEL_93;
    }
LABEL_62:
    uint64_t v55 = (void *)*v55;
    if (!v55) {
      goto LABEL_93;
    }
  }
  if (v55[2] != v48) {
    goto LABEL_62;
  }
LABEL_73:
  int8x8_t v59 = (int8x8_t)v55[4];
  if (!*(void *)&v59) {
    goto LABEL_93;
  }
  unint64_t v60 = 0x9DDFEA08EB382D69 * (((8 * v407) + 8) ^ DWORD1(v407));
  unint64_t v61 = 0x9DDFEA08EB382D69 * (DWORD1(v407) ^ (v60 >> 47) ^ v60);
  unint64_t v62 = 0x9DDFEA08EB382D69 * (v61 ^ (v61 >> 47));
  uint8x8_t v63 = (uint8x8_t)vcnt_s8(v59);
  v63.i16[0] = vaddlv_u8(v63);
  if (v63.u32[0] > 1uLL)
  {
    unint64_t v64 = v62;
    if (v62 >= *(void *)&v59) {
      unint64_t v64 = v62 % *(void *)&v59;
    }
  }
  else
  {
    unint64_t v64 = v62 & (*(void *)&v59 - 1);
  }
  unsigned int v65 = *(uint64_t ****)(v55[3] + 8 * v64);
  if (!v65 || (uint64_t v66 = *v65) == 0)
  {
LABEL_93:
    __int16 v68 = 0;
    goto LABEL_94;
  }
  if (v63.u32[0] < 2uLL)
  {
    uint64_t v67 = *(void *)&v59 - 1;
    while (1)
    {
      v70 = v66[1];
      if (v70 == (uint64_t *)v62)
      {
        if (v66[2] == (uint64_t *)v407) {
          goto LABEL_445;
        }
      }
      else if (((unint64_t)v70 & v67) != v64)
      {
        goto LABEL_93;
      }
      __int16 v68 = 0;
      uint64_t v66 = (uint64_t **)*v66;
      if (!v66) {
        goto LABEL_94;
      }
    }
  }
  while (1)
  {
    unint64_t v69 = (unint64_t)v66[1];
    if (v69 == v62) {
      break;
    }
    if (v69 >= *(void *)&v59) {
      v69 %= *(void *)&v59;
    }
    if (v69 != v64) {
      goto LABEL_93;
    }
LABEL_83:
    __int16 v68 = 0;
    uint64_t v66 = (uint64_t **)*v66;
    if (!v66) {
      goto LABEL_94;
    }
  }
  if (v66[2] != (uint64_t *)v407) {
    goto LABEL_83;
  }
LABEL_445:
  __int16 v68 = v66[3];
LABEL_94:
  v319 = [v68 mpsndarray];

  if (!InputState)
  {
    v316 = 0;
    goto LABEL_139;
  }
  v71 = (int8x8_t *)*((void *)v367 + 2);
  *(void *)&long long v407 = InputState;
  uint64_t v72 = mlir::Value::getParentRegion((mlir::Value *)&v407);
  int8x8_t v73 = v71[12];
  if (!*(void *)&v73) {
    goto LABEL_137;
  }
  unint64_t v74 = *((void *)v72 + 2);
  unint64_t v75 = 0x9DDFEA08EB382D69 * (((8 * v74) + 8) ^ HIDWORD(v74));
  unint64_t v76 = 0x9DDFEA08EB382D69 * (HIDWORD(v74) ^ (v75 >> 47) ^ v75);
  unint64_t v77 = 0x9DDFEA08EB382D69 * (v76 ^ (v76 >> 47));
  uint8x8_t v78 = (uint8x8_t)vcnt_s8(v73);
  v78.i16[0] = vaddlv_u8(v78);
  if (v78.u32[0] > 1uLL)
  {
    unint64_t v79 = 0x9DDFEA08EB382D69 * (v76 ^ (v76 >> 47));
    if (v77 >= *(void *)&v73) {
      unint64_t v79 = v77 % *(void *)&v73;
    }
  }
  else
  {
    unint64_t v79 = v77 & (*(void *)&v73 - 1);
  }
  int v80 = *(void **)(*(void *)&v71[11] + 8 * v79);
  if (!v80) {
    goto LABEL_137;
  }
  v81 = (void *)*v80;
  if (!v81) {
    goto LABEL_137;
  }
  if (v78.u32[0] < 2uLL)
  {
    uint64_t v82 = *(void *)&v73 - 1;
    while (1)
    {
      uint64_t v84 = v81[1];
      if (v84 == v77)
      {
        if (v81[2] == v74) {
          goto LABEL_117;
        }
      }
      else if ((v84 & v82) != v79)
      {
        goto LABEL_137;
      }
      v81 = (void *)*v81;
      if (!v81) {
        goto LABEL_137;
      }
    }
  }
  while (1)
  {
    unint64_t v83 = v81[1];
    if (v83 == v77) {
      break;
    }
    if (v83 >= *(void *)&v73) {
      v83 %= *(void *)&v73;
    }
    if (v83 != v79) {
      goto LABEL_137;
    }
LABEL_106:
    v81 = (void *)*v81;
    if (!v81) {
      goto LABEL_137;
    }
  }
  if (v81[2] != v74) {
    goto LABEL_106;
  }
LABEL_117:
  int8x8_t v85 = (int8x8_t)v81[4];
  if (!*(void *)&v85) {
    goto LABEL_137;
  }
  unint64_t v86 = 0x9DDFEA08EB382D69 * (((8 * v407) + 8) ^ DWORD1(v407));
  unint64_t v87 = 0x9DDFEA08EB382D69 * (DWORD1(v407) ^ (v86 >> 47) ^ v86);
  unint64_t v88 = 0x9DDFEA08EB382D69 * (v87 ^ (v87 >> 47));
  uint8x8_t v89 = (uint8x8_t)vcnt_s8(v85);
  v89.i16[0] = vaddlv_u8(v89);
  if (v89.u32[0] > 1uLL)
  {
    unint64_t v90 = v88;
    if (v88 >= *(void *)&v85) {
      unint64_t v90 = v88 % *(void *)&v85;
    }
  }
  else
  {
    unint64_t v90 = v88 & (*(void *)&v85 - 1);
  }
  v91 = *(uint64_t ****)(v81[3] + 8 * v90);
  if (!v91 || (id v92 = *v91) == 0)
  {
LABEL_137:
    int v94 = 0;
    goto LABEL_138;
  }
  if (v89.u32[0] < 2uLL)
  {
    uint64_t v93 = *(void *)&v85 - 1;
    while (1)
    {
      v96 = v92[1];
      if (v96 == (uint64_t *)v88)
      {
        if (v92[2] == (uint64_t *)v407) {
          goto LABEL_446;
        }
      }
      else if (((unint64_t)v96 & v93) != v90)
      {
        goto LABEL_137;
      }
      int v94 = 0;
      id v92 = (uint64_t **)*v92;
      if (!v92) {
        goto LABEL_138;
      }
    }
  }
  while (1)
  {
    unint64_t v95 = (unint64_t)v92[1];
    if (v95 == v88) {
      break;
    }
    if (v95 >= *(void *)&v85) {
      v95 %= *(void *)&v85;
    }
    if (v95 != v90) {
      goto LABEL_137;
    }
LABEL_127:
    int v94 = 0;
    id v92 = (uint64_t **)*v92;
    if (!v92) {
      goto LABEL_138;
    }
  }
  if (v92[2] != (uint64_t *)v407) {
    goto LABEL_127;
  }
LABEL_446:
  int v94 = v92[3];
LABEL_138:
  v316 = [v94 mpsndarray];

LABEL_139:
  if (!InputCell)
  {
    id v311 = 0;
    goto LABEL_184;
  }
  v97 = (int8x8_t *)*((void *)v367 + 2);
  *(void *)&long long v407 = InputCell;
  v98 = mlir::Value::getParentRegion((mlir::Value *)&v407);
  int8x8_t v99 = v97[12];
  if (!*(void *)&v99) {
    goto LABEL_182;
  }
  unint64_t v100 = *((void *)v98 + 2);
  unint64_t v101 = 0x9DDFEA08EB382D69 * (((8 * v100) + 8) ^ HIDWORD(v100));
  unint64_t v102 = 0x9DDFEA08EB382D69 * (HIDWORD(v100) ^ (v101 >> 47) ^ v101);
  unint64_t v103 = 0x9DDFEA08EB382D69 * (v102 ^ (v102 >> 47));
  uint8x8_t v104 = (uint8x8_t)vcnt_s8(v99);
  v104.i16[0] = vaddlv_u8(v104);
  if (v104.u32[0] > 1uLL)
  {
    unint64_t v105 = 0x9DDFEA08EB382D69 * (v102 ^ (v102 >> 47));
    if (v103 >= *(void *)&v99) {
      unint64_t v105 = v103 % *(void *)&v99;
    }
  }
  else
  {
    unint64_t v105 = v103 & (*(void *)&v99 - 1);
  }
  v106 = *(void **)(*(void *)&v97[11] + 8 * v105);
  if (!v106) {
    goto LABEL_182;
  }
  v107 = (void *)*v106;
  if (!v107) {
    goto LABEL_182;
  }
  if (v104.u32[0] < 2uLL)
  {
    uint64_t v108 = *(void *)&v99 - 1;
    while (1)
    {
      uint64_t v110 = v107[1];
      if (v110 == v103)
      {
        if (v107[2] == v100) {
          goto LABEL_162;
        }
      }
      else if ((v110 & v108) != v105)
      {
        goto LABEL_182;
      }
      v107 = (void *)*v107;
      if (!v107) {
        goto LABEL_182;
      }
    }
  }
  while (1)
  {
    unint64_t v109 = v107[1];
    if (v109 == v103) {
      break;
    }
    if (v109 >= *(void *)&v99) {
      v109 %= *(void *)&v99;
    }
    if (v109 != v105) {
      goto LABEL_182;
    }
LABEL_151:
    v107 = (void *)*v107;
    if (!v107) {
      goto LABEL_182;
    }
  }
  if (v107[2] != v100) {
    goto LABEL_151;
  }
LABEL_162:
  int8x8_t v111 = (int8x8_t)v107[4];
  if (!*(void *)&v111) {
    goto LABEL_182;
  }
  unint64_t v112 = 0x9DDFEA08EB382D69 * (((8 * v407) + 8) ^ DWORD1(v407));
  unint64_t v113 = 0x9DDFEA08EB382D69 * (DWORD1(v407) ^ (v112 >> 47) ^ v112);
  unint64_t v114 = 0x9DDFEA08EB382D69 * (v113 ^ (v113 >> 47));
  uint8x8_t v115 = (uint8x8_t)vcnt_s8(v111);
  v115.i16[0] = vaddlv_u8(v115);
  if (v115.u32[0] > 1uLL)
  {
    unint64_t v116 = v114;
    if (v114 >= *(void *)&v111) {
      unint64_t v116 = v114 % *(void *)&v111;
    }
  }
  else
  {
    unint64_t v116 = v114 & (*(void *)&v111 - 1);
  }
  v117 = *(uint64_t ****)(v107[3] + 8 * v116);
  if (!v117 || (v118 = *v117) == 0)
  {
LABEL_182:
    v120 = 0;
    goto LABEL_183;
  }
  if (v115.u32[0] < 2uLL)
  {
    uint64_t v119 = *(void *)&v111 - 1;
    while (1)
    {
      v122 = v118[1];
      if (v122 == (uint64_t *)v114)
      {
        if (v118[2] == (uint64_t *)v407) {
          goto LABEL_447;
        }
      }
      else if (((unint64_t)v122 & v119) != v116)
      {
        goto LABEL_182;
      }
      v120 = 0;
      v118 = (uint64_t **)*v118;
      if (!v118) {
        goto LABEL_183;
      }
    }
  }
  while (1)
  {
    unint64_t v121 = (unint64_t)v118[1];
    if (v121 == v114) {
      break;
    }
    if (v121 >= *(void *)&v111) {
      v121 %= *(void *)&v111;
    }
    if (v121 != v116) {
      goto LABEL_182;
    }
LABEL_172:
    v120 = 0;
    v118 = (uint64_t **)*v118;
    if (!v118) {
      goto LABEL_183;
    }
  }
  if (v118[2] != (uint64_t *)v407) {
    goto LABEL_172;
  }
LABEL_447:
  v120 = v118[3];
LABEL_183:
  id v311 = [v120 mpsndarray];

LABEL_184:
  if (!Mask)
  {
    v321 = 0;
    goto LABEL_229;
  }
  v123 = (int8x8_t *)*((void *)v367 + 2);
  *(void *)&long long v407 = Mask;
  v124 = mlir::Value::getParentRegion((mlir::Value *)&v407);
  int8x8_t v125 = v123[12];
  if (!*(void *)&v125) {
    goto LABEL_227;
  }
  unint64_t v126 = *((void *)v124 + 2);
  unint64_t v127 = 0x9DDFEA08EB382D69 * (((8 * v126) + 8) ^ HIDWORD(v126));
  unint64_t v128 = 0x9DDFEA08EB382D69 * (HIDWORD(v126) ^ (v127 >> 47) ^ v127);
  unint64_t v129 = 0x9DDFEA08EB382D69 * (v128 ^ (v128 >> 47));
  uint8x8_t v130 = (uint8x8_t)vcnt_s8(v125);
  v130.i16[0] = vaddlv_u8(v130);
  if (v130.u32[0] > 1uLL)
  {
    unint64_t v131 = 0x9DDFEA08EB382D69 * (v128 ^ (v128 >> 47));
    if (v129 >= *(void *)&v125) {
      unint64_t v131 = v129 % *(void *)&v125;
    }
  }
  else
  {
    unint64_t v131 = v129 & (*(void *)&v125 - 1);
  }
  v132 = *(void **)(*(void *)&v123[11] + 8 * v131);
  if (!v132) {
    goto LABEL_227;
  }
  v133 = (void *)*v132;
  if (!v133) {
    goto LABEL_227;
  }
  if (v130.u32[0] < 2uLL)
  {
    uint64_t v134 = *(void *)&v125 - 1;
    while (1)
    {
      uint64_t v136 = v133[1];
      if (v136 == v129)
      {
        if (v133[2] == v126) {
          goto LABEL_207;
        }
      }
      else if ((v136 & v134) != v131)
      {
        goto LABEL_227;
      }
      v133 = (void *)*v133;
      if (!v133) {
        goto LABEL_227;
      }
    }
  }
  while (1)
  {
    unint64_t v135 = v133[1];
    if (v135 == v129) {
      break;
    }
    if (v135 >= *(void *)&v125) {
      v135 %= *(void *)&v125;
    }
    if (v135 != v131) {
      goto LABEL_227;
    }
LABEL_196:
    v133 = (void *)*v133;
    if (!v133) {
      goto LABEL_227;
    }
  }
  if (v133[2] != v126) {
    goto LABEL_196;
  }
LABEL_207:
  int8x8_t v137 = (int8x8_t)v133[4];
  if (!*(void *)&v137) {
    goto LABEL_227;
  }
  unint64_t v138 = 0x9DDFEA08EB382D69 * (((8 * v407) + 8) ^ DWORD1(v407));
  unint64_t v139 = 0x9DDFEA08EB382D69 * (DWORD1(v407) ^ (v138 >> 47) ^ v138);
  unint64_t v140 = 0x9DDFEA08EB382D69 * (v139 ^ (v139 >> 47));
  uint8x8_t v141 = (uint8x8_t)vcnt_s8(v137);
  v141.i16[0] = vaddlv_u8(v141);
  if (v141.u32[0] > 1uLL)
  {
    unint64_t v142 = v140;
    if (v140 >= *(void *)&v137) {
      unint64_t v142 = v140 % *(void *)&v137;
    }
  }
  else
  {
    unint64_t v142 = v140 & (*(void *)&v137 - 1);
  }
  v143 = *(uint64_t ****)(v133[3] + 8 * v142);
  if (!v143 || (v144 = *v143) == 0)
  {
LABEL_227:
    v146 = 0;
    goto LABEL_228;
  }
  if (v141.u32[0] < 2uLL)
  {
    uint64_t v145 = *(void *)&v137 - 1;
    while (1)
    {
      v148 = v144[1];
      if (v148 == (uint64_t *)v140)
      {
        if (v144[2] == (uint64_t *)v407) {
          goto LABEL_448;
        }
      }
      else if (((unint64_t)v148 & v145) != v142)
      {
        goto LABEL_227;
      }
      v146 = 0;
      v144 = (uint64_t **)*v144;
      if (!v144) {
        goto LABEL_228;
      }
    }
  }
  while (1)
  {
    unint64_t v147 = (unint64_t)v144[1];
    if (v147 == v140) {
      break;
    }
    if (v147 >= *(void *)&v137) {
      v147 %= *(void *)&v137;
    }
    if (v147 != v142) {
      goto LABEL_227;
    }
LABEL_217:
    v146 = 0;
    v144 = (uint64_t **)*v144;
    if (!v144) {
      goto LABEL_228;
    }
  }
  if (v144[2] != (uint64_t *)v407) {
    goto LABEL_217;
  }
LABEL_448:
  v146 = v144[3];
LABEL_228:
  v321 = [v146 mpsndarray];

LABEL_229:
  v309 = [(NSArray *)v322 objectAtIndexedSubscript:0];
  v320 = [v309 mpsndarray];
  if ((!v318 || !v320) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (Training)
  {
    [(NSArray *)v322 count];
    if ([(NSArray *)v322 count] <= 1 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    v149 = [(NSArray *)v322 objectAtIndexedSubscript:1];
    v345 = [v149 mpsndarray];

    if (v345)
    {
      if (*((unsigned char *)v345 + (int)*MEMORY[0x1E4F359C0]) && ![v345 readCount])
      {

        goto LABEL_237;
      }
    }
    else
    {
      v345 = 0;
    }
    int v344 = 1;
  }
  else
  {
LABEL_237:
    v345 = 0;
    int v344 = 0;
  }
  v310 = [v319 descriptor];
  [v310 transposeDimension:0 withDimension:1];
  v312 = [v319 safeArrayViewWithCommandBuffer:v366 computeEncoder:v365 descriptor:v310 aliasing:1];
  v150 = [v320 descriptor];
  v151 = v150;
  if (v150) {
    [v150 getShapeVector];
  }
  else {
    v371 = 0;
  }

  mlir::mps::Conv3DOp::getWeightsLayout((mlir::mps::Conv3DOp *)&v372);
  mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v372);
  mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v372);
  id v152 = v312;
  v327 = v318;
  id v317 = v311;
  if (!*((void *)v367 + 15))
  {
    long long v407 = 0uLL;
    uint64_t v408 = 0;
    v154 = *v371;
    v153 = v371[1];
    int64_t v155 = v153 - (unsigned char *)*v371;
    if (v153 != *v371)
    {
      if (v155 < 0) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      v156 = operator new(v153 - (unsigned char *)*v371);
      v157 = (char *)&v156[v155 >> 3];
      *(void *)&long long v407 = v156;
      uint64_t v408 = (uint64_t)v157;
      memcpy(v156, v154, v155);
      *((void *)&v407 + 1) = v157;
      uint64_t v158 = 8 * (v155 >> 3);
      if ((unint64_t)v158 > 0x17)
      {
        v156[2] = 1;
        long long v403 = 0uLL;
        uint64_t v404 = 0;
        if ((v158 & 0x8000000000000000) == 0)
        {
          v159 = operator new(8 * (v155 >> 3));
          *(void *)&long long v403 = v159;
          uint64_t v404 = (uint64_t)&v159[v158 >> 3];
          memcpy(v159, v156, 8 * (v155 >> 3));
          *((void *)&v403 + 1) = &v159[v158 >> 3];
          v160 = operator new(8 * (v155 >> 3));
          memcpy(v160, v156, v157 - (char *)v156);
          *v160 *= 2;
          *v159 *= 3;
          __src = v160;
          v161 = [v152 descriptor];
          v162 = v161;
          if (v161) {
            [v161 getShapeVector];
          }
          else {
            uint64_t v380 = 0;
          }

          uint64_t v163 = v380;
          v374 = 0;
          v373 = 0;
          v375 = 0;
          uint64_t v164 = *(void *)(v380 + 8);
          v165 = *(const void **)v380;
          int64_t v166 = v164 - *(void *)v380;
          if (v166 >= 0)
          {
            v167 = operator new(v164 - *(void *)v380);
            v373 = v167;
            v375 = &v167[v166 >> 3];
            memcpy(v167, v165, v166);
            v374 = &v167[v166 >> 3];
            void *v167 = *__src;
            v378 = 0;
            v377 = 0;
            v379 = 0;
            uint64_t v168 = *(void *)(v163 + 8);
            v169 = *(const void **)v163;
            int64_t v170 = v168 - *(void *)v163;
            if (v170 >= 0)
            {
              v171 = operator new(v168 - *(void *)v163);
              v377 = v171;
              v378 = v171;
              v379 = &v171[v170 >> 3];
              memcpy(v171, v169, v170);
              v378 = &v171[v170 >> 3];
              void *v171 = *(void *)v407;
              operator new();
            }
            std::vector<long>::__throw_length_error[abi:ne180100]();
          }
          std::vector<long>::__throw_length_error[abi:ne180100]();
        }
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
    }
    __assert_rtn("_getGRUKernelDAGObjects", "GPURNNOps.mm", 3207, "shape.size() >= 3");
  }
  if (!*((unsigned char *)v367 + 40) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }

  uint64_t v346 = *((void *)*v371 + 2);
  char v172 = !ResetAfter;
  if (!v345) {
    char v172 = 1;
  }
  if ((v172 & 1) == 0)
  {
    v173 = v327;
    v174 = v173;
    if (v173 && *((unsigned char *)v173 + (int)*MEMORY[0x1E4F359C0])) {
      [(GPU::EncodeDescriptor *)v173 setReadCount:[(GPU::EncodeDescriptor *)v173 readCount] + 1];
    }
  }
  v175 = v320;
  v176 = v175;
  if (v175 && *((unsigned char *)v175 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v175 setReadCount:[(GPU::EncodeDescriptor *)v175 readCount] + 2];
  }
  v358 = v176;

  if (ResetAfter) {
    uint64_t v177 = 2;
  }
  else {
    uint64_t v177 = 1;
  }
  v178 = v345;
  v179 = v178;
  if (v178 && *((unsigned char *)v178 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v178 setReadCount:[(GPU::EncodeDescriptor *)v178 readCount] + v177];
  }
  v337 = v179;

  v180 = (GPU::EncodeDescriptor *)v152;
  v181 = v180;
  if (v180 && 100 * v346 && *((unsigned char *)v180 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v180 setReadCount:[(GPU::EncodeDescriptor *)v180 readCount] + 100 * v346];
  }
  v329 = v181;

  GPU::getSlice((id *)a2, v358, (MPSNDArray *)2, 20 * v346, 0, 1);
  v361 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)a2, v358, (MPSNDArray *)2, 20 * v346, 0, 1);
  v360 = (char *)objc_claimAutoreleasedReturnValue();
  long long v407 = xmmword_181134E80;
  uint64_t v408 = 1;
  long long v403 = xmmword_181134E80;
  uint64_t v404 = 1;
  v182 = (int *)MEMORY[0x1E4F359D8];
  v183 = (int *)MEMORY[0x1E4F359B0];
  v184 = (long long *)((char *)v327 + (int)*MEMORY[0x1E4F359D8]);
  v185 = (char *)v327 + (int)*MEMORY[0x1E4F359B0];
  long long v186 = *v184;
  long long v187 = v184[1];
  long long v188 = v184[2];
  long long v189 = v184[3];
  LOBYTE(v184) = *(_OWORD *)v185;
  v370[2] = v188;
  v370[3] = v189;
  v370[0] = v186;
  v370[1] = v187;
  *(void *)&long long v407 = *((unsigned int *)v370 + (v184 & 0xF));
  *(void *)&long long v403 = v407;
  uint64_t v190 = v185[1] & 0xF;
  v369[2] = v188;
  v369[3] = v189;
  v369[0] = v186;
  v369[1] = v187;
  *((void *)&v407 + 1) = *((unsigned int *)v369 + v190);
  unint64_t v191 = v407 / 3uLL;
  *(void *)&long long v403 = v191;
  *((void *)&v403 + 1) = *((void *)&v407 + 1);
  v313 = [MEMORY[0x1E4F35720] descriptorWithDataType:*(unsigned int *)((char *)v327 + (int)*MEMORY[0x1E4F359A0]) dimensionCount:3 dimensionSizes:&v407];
  [v313 setPreferPackedRows:1];
  v314 = [MEMORY[0x1E4F35720] descriptorWithDataType:*(unsigned int *)((char *)v327 + (int)*MEMORY[0x1E4F359A0]) dimensionCount:3 dimensionSizes:&v403];
  [v314 setPreferPackedRows:1];
  if (v345)
  {
    GPU::getSlice((id *)a2, v337, (MPSNDArray *)2, 50 * v346, 0, 1);
    v348 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
    if (ResetAfter)
    {
      *(_DWORD *)((char *)v348 + 4 * *(_OWORD *)((char *)v348 + *v183) + *v182) = 3 * v191;
      v315 = GPU::getSlice((id *)a2, v337, 0, 1, 3 * v191, v191);
      goto LABEL_283;
    }
  }
  else
  {
    v192 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v366 descriptor:v313];
    *(void *)&v192[*MEMORY[0x1E4F35A20]] = 50 * v346;
    v348 = v192;
  }
  v315 = 0;
LABEL_283:
  int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v372);
  if (Layout == 1)
  {
    uint64_t v194 = 0;
    int v338 = 1;
    uint64_t v195 = v191;
  }
  else
  {
    if (Layout == 2)
    {
      uint64_t v194 = 0;
      int v338 = 0;
      uint64_t v195 = 2 * v191;
      uint64_t v196 = v191;
      goto LABEL_289;
    }
    uint64_t v195 = 0;
    int v338 = 1;
    uint64_t v194 = v191;
  }
  uint64_t v196 = 2 * v191;
LABEL_289:
  uint64_t v197 = 10 * v346;
  GPU::getSlice((id *)a2, v348, 0, 10 * v346, v194, v191);
  v357 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)a2, v348, 0, 10 * v346, v195, v191);
  v356 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)a2, v348, 0, 10 * v346, v196, v191);
  v355 = (char *)objc_claimAutoreleasedReturnValue();
  if (v338)
  {
    GPU::getSlice((id *)a2, v348, 0, v197, 0, 2 * v191);
    v349 = (char *)(id)objc_claimAutoreleasedReturnValue();

    GPU::getSlice((id *)a2, v181, 0, v197, 0, 2 * v191);
    id v326 = (id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    id v326 = 0;
    v349 = 0;
  }
  v325 = GPU::getSlice((id *)a2, v181, 0, v197, v194, v191);
  v324 = GPU::getSlice((id *)a2, v181, 0, v197, v195, v191);
  v328 = GPU::getSlice((id *)a2, v181, 0, v197, v196, v191);
  GPU::getSlice((id *)a2, v327, (MPSNDArray *)2, 4 * v346, 0, 1);
  v198 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)a2, v198, 0, v197, v194, v191);
  v359 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)a2, v198, 0, v197, v195, v191);
  __srca = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)a2, v198, 0, v197, v196, v191);
  __sz = (char *)objc_claimAutoreleasedReturnValue();
  if (v338)
  {
    GPU::getSlice((id *)a2, v198, 0, v197, 0, 2 * v191);
    v354 = (char *)(id)objc_claimAutoreleasedReturnValue();

    BOOL v199 = ResetAfter;
    if (!v345) {
      BOOL v199 = 0;
    }
    if (v199) {
      goto LABEL_296;
    }
LABEL_300:
    v323 = 0;
  }
  else
  {
    v354 = 0;
    BOOL v200 = ResetAfter;
    if (!v345) {
      BOOL v200 = 0;
    }
    if (!v200) {
      goto LABEL_300;
    }
LABEL_296:
    v323 = GPU::getSlice((id *)a2, v327, 0, 0, v196, v191);
  }
  GPU::getSlice((id *)a2, v316, (MPSNDArray *)2, v197, 0, 1);
  v201 = (char *)objc_claimAutoreleasedReturnValue();
  v342 = GPU::getSlice((id *)a2, v321, (MPSNDArray *)1, v197, 0, 1);
  if ((ResetAfter | v344) == 1)
  {
    v202 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v366 descriptor:v314];
    *(void *)&v202[*MEMORY[0x1E4F35A20]] = 50;
    v336 = v202;

    if (v346) {
      goto LABEL_303;
    }
LABEL_378:
    v262 = v201;
    if (v323) {
      goto LABEL_379;
    }
  }
  else
  {
    v336 = v357;
    if (!v346) {
      goto LABEL_378;
    }
LABEL_303:
    uint64_t v203 = 0;
    v340 = (char *)v358 + 2;
    v351 = (GPU::EncodeDescriptor *)((char *)v198 + 2);
    v204 = (char *)v337 + 2;
    BOOL v205 = ResetAfter;
    if (!v342) {
      BOOL v205 = 0;
    }
    BOOL v330 = v205;
    v206 = (int *)MEMORY[0x1E4F359E0];
    do
    {
      v207 = v358;
      v208 = v207;
      if (v361)
      {
        uint64_t v209 = *v206;
        uint64_t v210 = *v183;
        int v211 = (int)v358;
        if (v358) {
          int v211 = *(_DWORD *)((char *)v207 + 4 * (v340[v210] & 0xF) + v209);
        }
        *(_DWORD *)&v361[4 * v361[v210 + 2] + v209] = v211 + v203;
      }

      v212 = v198;
      v213 = v212;
      if (v359)
      {
        uint64_t v214 = *v206;
        uint64_t v215 = *v183;
        if (v198) {
          int v216 = *(_DWORD *)((char *)v212 + 4 * (*((unsigned char *)v351 + v215) & 0xF) + v214);
        }
        else {
          int v216 = 0;
        }
        *(_DWORD *)&v359[4 * v359[v215 + 2] + v214] = v216 + v203;
      }

      v217 = v213;
      v218 = v217;
      if (__srca)
      {
        uint64_t v219 = *v206;
        uint64_t v220 = *v183;
        if (v198) {
          int v221 = *(_DWORD *)((char *)v217 + 4 * (*((unsigned char *)v351 + v220) & 0xF) + v219);
        }
        else {
          int v221 = 0;
        }
        *(_DWORD *)&__srca[4 * __srca[v220 + 2] + v219] = v221 + v203;
      }

      v222 = v218;
      v223 = v222;
      if (__sz)
      {
        uint64_t v224 = *v206;
        uint64_t v225 = *v183;
        if (v198) {
          int v226 = *(_DWORD *)((char *)v222 + 4 * (*((unsigned char *)v351 + v225) & 0xF) + v224);
        }
        else {
          int v226 = 0;
        }
        *(_DWORD *)&__sz[4 * __sz[v225 + 2] + v224] = v226 + v203;
      }

      v227 = v223;
      if (v354)
      {
        uint64_t v228 = *v206;
        uint64_t v229 = *v183;
        if (v198) {
          int v230 = *(_DWORD *)((char *)v227 + 4 * (*((unsigned char *)v351 + v229) & 0xF) + v228);
        }
        else {
          int v230 = 0;
        }
        *(_DWORD *)&v354[4 * v354[v229 + 2] + v228] = v230 + v203;
      }

      if (v345)
      {
        v231 = v337;
        v232 = v231;
        if (v357) {
          *(_DWORD *)&v357[4 * v357[*v183 + 2] + *v206] = v203
        }
                                                                         + *(_DWORD *)((char *)v231
                                                                                     + 4 * (v204[*v183] & 0xF)
                                                                                     + *v206);

        v233 = v232;
        v234 = v233;
        if (v356) {
          *(_DWORD *)&v356[4 * v356[*v183 + 2] + *v206] = v203
        }
                                                                         + *(_DWORD *)((char *)v233
                                                                                     + 4 * (v204[*v183] & 0xF)
                                                                                     + *v206);

        v235 = v234;
        v236 = v235;
        if (v355) {
          *(_DWORD *)&v355[4 * v355[*v183 + 2] + *v206] = v203
        }
                                                                         + *(_DWORD *)((char *)v235
                                                                                     + 4 * (v204[*v183] & 0xF)
                                                                                     + *v206);

        v237 = v236;
        v238 = v237;
        if (v349) {
          *(_DWORD *)&v349[4 * v349[*v183 + 2] + *v206] = v203
        }
                                                                         + *(_DWORD *)((char *)v237
                                                                                     + 4 * (v204[*v183] & 0xF)
                                                                                     + *v206);

        v239 = v238;
        if (v348) {
          *(_DWORD *)((char *)v348 + 4 * *((unsigned __int8 *)v348 + *v183 + 2) + *v206) = v203
        }
                                                                                         + *(_DWORD *)&v239[4 * (v204[*v183] & 0xF) + *v206];
      }
      if (v201)
      {
        v240 = (void *)*((void *)v367 + 26);
        if (ResetAfter)
        {
          v402[0] = v201;
          v402[1] = v329;
          v241 = [MEMORY[0x1E4F1C978] arrayWithObjects:v402 count:2];
          [v240 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v241 resultState:0 destinationArray:v348 kernelDAGObject:0];

          if (v344)
          {
            if (v338)
            {
              v401[0] = v349;
              v401[1] = v354;
              v242 = [MEMORY[0x1E4F1C978] arrayWithObjects:v401 count:2];
              [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v242 resultState:0 destinationArray:v349 kernelDAGObject:*((void *)v367 + 23)];
            }
            else
            {
              v400[0] = v356;
              v400[1] = __srca;
              v256 = [MEMORY[0x1E4F1C978] arrayWithObjects:v400 count:2];
              [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v256 resultState:0 destinationArray:v356 kernelDAGObject:*((void *)v367 + 24)];

              v399[0] = v357;
              v399[1] = v359;
              v242 = [MEMORY[0x1E4F1C978] arrayWithObjects:v399 count:2];
              [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v242 resultState:0 destinationArray:v357 kernelDAGObject:*((void *)v367 + 24)];
            }

            if (v342)
            {
              v398[0] = v355;
              v398[1] = v342;
              v257 = [MEMORY[0x1E4F1C978] arrayWithObjects:v398 count:2];
              [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v257 resultState:0 destinationArray:v355 kernelDAGObject:*((void *)v367 + 25)];
            }
            v397[0] = v355;
            v397[1] = v357;
            v397[2] = __sz;
            v397[3] = v201;
            v397[4] = v356;
            v250 = [MEMORY[0x1E4F1C978] arrayWithObjects:v397 count:5];
            [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v250 resultState:0 destinationArray:v361 kernelDAGObject:*((void *)v367 + 19)];
          }
          else
          {
            v396[0] = v355;
            v396[1] = v357;
            v396[2] = v359;
            v396[3] = __sz;
            v396[4] = v201;
            v396[5] = v356;
            v396[6] = __srca;
            v250 = [MEMORY[0x1E4F1C978] arrayWithObjects:v396 count:7];
            if (v342)
            {
              v395[0] = v355;
              v395[1] = v342;
              v395[2] = v357;
              v395[3] = v359;
              v395[4] = __sz;
              v395[5] = v201;
              v395[6] = v356;
              v395[7] = __srca;
              uint64_t v251 = [MEMORY[0x1E4F1C978] arrayWithObjects:v395 count:8];

              v250 = (void *)v251;
            }
            [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v250 resultState:0 destinationArray:v361 kernelDAGObject:*((void *)v367 + 20)];
          }
        }
        else
        {
          if (v338)
          {
            v394[0] = v201;
            v394[1] = v326;
            v394[2] = v354;
            v244 = [MEMORY[0x1E4F1C978] arrayWithObjects:v394 count:3];
            [v240 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v244 resultState:0 destinationArray:v349 kernelDAGObject:*((void *)v367 + 15)];
          }
          else
          {
            v393[0] = v201;
            v393[1] = v325;
            v393[2] = v359;
            v245 = [MEMORY[0x1E4F1C978] arrayWithObjects:v393 count:3];
            [v240 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v245 resultState:0 destinationArray:v357 kernelDAGObject:*((void *)v367 + 16)];

            v246 = (void *)*((void *)v367 + 26);
            v392[0] = v201;
            v392[1] = v324;
            v392[2] = __srca;
            v244 = [MEMORY[0x1E4F1C978] arrayWithObjects:v392 count:3];
            [v246 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v244 resultState:0 destinationArray:v356 kernelDAGObject:*((void *)v367 + 16)];
          }

          v391[0] = v201;
          v391[1] = v357;
          v247 = [MEMORY[0x1E4F1C978] arrayWithObjects:v391 count:2];
          [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v247 resultState:0 destinationArray:v336 kernelDAGObject:*((void *)v367 + 17)];

          v248 = (void *)*((void *)v367 + 26);
          if (v344)
          {
            v389[0] = v336;
            v389[1] = v328;
            v389[2] = __sz;
            v249 = [MEMORY[0x1E4F1C978] arrayWithObjects:v389 count:3];
            [v248 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v249 resultState:0 destinationArray:v355 kernelDAGObject:*((void *)v367 + 16)];

            v388[0] = v355;
            v388[1] = v201;
            v388[2] = v356;
            v250 = [MEMORY[0x1E4F1C978] arrayWithObjects:v388 count:3];
            [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v250 resultState:0 destinationArray:v361 kernelDAGObject:*((void *)v367 + 19)];
          }
          else
          {
            v390[0] = v336;
            v390[1] = v328;
            v390[2] = __sz;
            v390[3] = v356;
            v390[4] = v201;
            v250 = [MEMORY[0x1E4F1C978] arrayWithObjects:v390 count:5];
            [v248 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v250 resultState:0 destinationArray:v361 kernelDAGObject:*((void *)v367 + 18)];
          }
        }
      }
      else
      {
        if (v344)
        {
          if (v338)
          {
            v387 = v354;
            v243 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v387 count:1];
            [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v243 resultState:0 destinationArray:v349 kernelDAGObject:0];
          }
          else
          {
            v386 = v359;
            v252 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v386 count:1];
            [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v252 resultState:0 destinationArray:v357 kernelDAGObject:0];

            v385 = __srca;
            v243 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v385 count:1];
            [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v243 resultState:0 destinationArray:v356 kernelDAGObject:0];
          }

          if (v330)
          {
            v253 = (void *)*((void *)v367 + 26);
            v384[0] = v342;
            v384[1] = v328;
            v254 = [MEMORY[0x1E4F1C978] arrayWithObjects:v384 count:2];
            [v253 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v254 resultState:0 destinationArray:v355 kernelDAGObject:0];
          }
          else
          {
            [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:MEMORY[0x1E4F1CBF0] resultState:0 destinationArray:v355 kernelDAGObject:*((void *)v367 + 22)];
          }
        }
        v383[0] = __srca;
        v383[1] = __sz;
        v250 = [MEMORY[0x1E4F1C978] arrayWithObjects:v383 count:2];
        if (v330)
        {
          v382[0] = __srca;
          v382[1] = __sz;
          v382[2] = v359;
          v382[3] = v342;
          uint64_t v255 = [MEMORY[0x1E4F1C978] arrayWithObjects:v382 count:4];

          v250 = (void *)v255;
        }
        [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v250 resultState:0 destinationArray:v361 kernelDAGObject:*((void *)v367 + 21)];
      }

      v258 = v208;
      if (v360)
      {
        uint64_t v259 = *v206;
        uint64_t v260 = *v183;
        int v261 = (int)v358;
        if (v358) {
          int v261 = *(_DWORD *)((char *)v258 + 4 * (v340[v260] & 0xF) + v259);
        }
        *(_DWORD *)&v360[4 * v360[v260 + 2] + v259] = v261 + v203;
      }

      v262 = v360;
      ++v203;
      v201 = v262;
    }
    while (v346 != v203);
    if (v323)
    {
LABEL_379:
      v381 = v323;
      v263 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v381 count:1];
      [v353 encodeToMPSCommandEncoder:v365 commandBuffer:v366 sourceArrays:v263 resultState:0 destinationArray:v315 kernelDAGObject:0];
    }
  }
  v264 = v361;
  v265 = v264;
  if (v264 && v264[*MEMORY[0x1E4F359C0]]) {
    [v264 setReadCount:0];
  }
  v333 = v265;

  v266 = v348;
  v267 = v266;
  if (v266 && *((unsigned char *)v266 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v266 setReadCount:0];
  }

  v268 = v357;
  v269 = (GPU *)v268;
  if (v268 && v268[*MEMORY[0x1E4F359C0]]) {
    [v268 setReadCount:0];
  }
  v352 = v269;

  v270 = v356;
  v271 = v270;
  if (v270 && v270[*MEMORY[0x1E4F359C0]]) {
    [v270 setReadCount:0];
  }
  v347 = v271;

  v272 = v355;
  v273 = v272;
  if (v272 && v272[*MEMORY[0x1E4F359C0]]) {
    [v272 setReadCount:0];
  }
  v341 = v273;

  v274 = v349;
  v275 = v274;
  if (v274 && v274[*MEMORY[0x1E4F359C0]]) {
    [v274 setReadCount:0];
  }
  v339 = v275;

  v276 = v198;
  v277 = v276;
  if (v276 && *((unsigned char *)v276 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v276 setReadCount:0];
  }
  v368 = v277;

  v278 = v329;
  v279 = v278;
  if (v329 && *((unsigned char *)v278 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v278 setReadCount:0];
  }
  v331 = v279;

  id v280 = v326;
  v281 = v280;
  if (v280 && *((unsigned char *)v280 + (int)*MEMORY[0x1E4F359C0])) {
    [v280 setReadCount:0];
  }
  v332 = v281;

  id v282 = v328;
  v283 = v282;
  if (v282 && *((unsigned char *)v282 + (int)*MEMORY[0x1E4F359C0])) {
    [v282 setReadCount:0];
  }
  v334 = v283;

  v284 = v359;
  v285 = v284;
  if (v284 && v284[*MEMORY[0x1E4F359C0]]) {
    [v284 setReadCount:0];
  }
  v335 = v285;

  v286 = __srca;
  v287 = v286;
  if (v286 && v286[*MEMORY[0x1E4F359C0]]) {
    [v286 setReadCount:0];
  }
  v288 = v287;

  v289 = __sz;
  v290 = v289;
  if (v289 && v289[*MEMORY[0x1E4F359C0]]) {
    [v289 setReadCount:0];
  }

  v291 = v354;
  v292 = v291;
  if (v291 && v291[*MEMORY[0x1E4F359C0]]) {
    [v291 setReadCount:0];
  }

  v293 = v262;
  v294 = v293;
  if (v293 && v293[*MEMORY[0x1E4F359C0]]) {
    [v293 setReadCount:0];
  }

  id v295 = v342;
  v296 = v295;
  if (v295 && *((unsigned char *)v295 + (int)*MEMORY[0x1E4F359C0])) {
    [v295 setReadCount:0];
  }

  id v297 = v323;
  v298 = v297;
  if (v323 && *((unsigned char *)v297 + (int)*MEMORY[0x1E4F359C0])) {
    [v297 setReadCount:0];
  }
  v299 = v298;

  id v300 = v315;
  v301 = v300;
  if (v300 && *((unsigned char *)v300 + (int)*MEMORY[0x1E4F359C0])) {
    [v300 setReadCount:0];
  }

  if ((ResetAfter & v344) == 1)
  {
    v302 = v336;
    v303 = v302;
    if (v302 && v302[*MEMORY[0x1E4F359C0]]) {
      [v302 setReadCount:0];
    }
  }
  v304 = v371;
  v371 = 0;
  if (v304)
  {
    v305 = *v304;
    if (*v304)
    {
      v304[1] = v305;
      operator delete(v305);
    }
    MEMORY[0x1852FDE70](v304, 0x10C402FEFCB83);
  }
}

void sub_18016362C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,void *a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,void *__p,uint64_t a63)
{
  std::unique_ptr<std::vector<long> const,std::default_delete<std::vector<long> const>>::~unique_ptr[abi:ne180100]((uint64_t *)&STACK[0x258]);
  _Unwind_Resume(a1);
}

void llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<GPU::WhileOpHandler::encodeCSCBOp(GPU::EncodeDescriptor *)::$_2>(uint64_t *a1, uint64_t a2)
{
  v53[1] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  ParentOp = *(mlir::Block **)(a2 + 16);
  __int16 v46 = (mlir::Operation *)a2;
  if (ParentOp)
  {
    ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
    a2 = (uint64_t)v46;
  }
  if (ParentOp == *(mlir::Block **)(v3 + 24))
  {
    uint64_t v5 = a2;
    uint64_t v6 = llvm::DefaultDoCastIfPossible<mlir::scf::ConditionOp,mlir::Operation *,llvm::CastInfo<mlir::scf::ConditionOp,mlir::Operation *,void>>::doCastIfPossible(a2);
    unint64_t v48 = (void *)v3;
    uint64_t v7 = *(GPURegionRuntime **)(v3 + 16);
    if (v6)
    {
      if ((*(unsigned char *)(v5 + 46) & 0x80) == 0) {
        __assert_rtn("getOperandStorage", "Operation.h", 960, "hasOperandStorage && \"expected operation to have operand storage\"");
      }
      int8x8_t v47 = a1;
      if (!*(_DWORD *)(v5 + 68)) {
        __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
      }
      uint64_t v51 = *(void *)(*(void *)(v5 + 72) + 24);
      uint64_t v50 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v51) + 2);
      uint64_t v8 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)v7 + 11, &v50);
      if (v8
        && (uint64_t v49 = v51,
            (uint64_t v9 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v8 + 3, &v49)) != 0))
      {
        id v10 = (id)v9[3];
      }
      else
      {
        id v10 = 0;
      }
      long long v11 = [v10 mpsndarray];
      if (!v11) {
        __assert_rtn("operator()", "GPUControlFlowOps.mm", 991, "predicateTensorData.mpsndarray != nil");
      }
      int64_t v45 = v10;

      int v12 = *(void **)a1[1];
      uint64_t v13 = GPU::EncodeDescriptor::getcomputeEncoder(*(GPU::EncodeDescriptor **)a1[2]);
      uint64_t v14 = *(void *)(*(void *)a1[2] + 8);
      uint64_t v15 = [v10 mpsndarray];
      v53[0] = v15;
      uint64_t v16 = [MEMORY[0x1E4F1C978] arrayWithObjects:v53 count:1];
      [v12 encodeToMPSCommandEncoder:v13 commandBuffer:v14 sourceArrays:v16 resultState:0 destinationArray:v48[16] kernelDAGObject:v48[17]];

      if (*(_DWORD *)(v48[3] + 36))
      {
        unint64_t v17 = 0;
        uint64_t v18 = 56;
        while ((*((unsigned char *)v46 + 46) & 0x80) != 0)
        {
          unint64_t v19 = v17 + 1;
          if (v17 + 1 >= *((unsigned int *)v46 + 17))
          {
            int v41 = 443;
            uint64_t v44 = "operator[]";
            unint64_t v43 = "ArrayRef.h";
            uint64_t v42 = "Index < this->size() && \"Invalid index!\"";
LABEL_37:
            __assert_rtn(v44, v43, v41, v42);
          }
          uint64_t v20 = v48[2];
          uint64_t v51 = *(void *)(*((void *)v46 + 9) + v18);
          uint64_t v50 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v51) + 2);
          int8x8_t v21 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v20 + 88), &v50);
          if (v21
            && (uint64_t v49 = v51,
                (unint64_t v22 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v21 + 3, &v49)) != 0))
          {
            id v23 = (id)v22[3];
          }
          else
          {
            id v23 = 0;
          }
          unint64_t v24 = objc_msgSend(v23, "mpsndarray", v45);
          if (!v24) {
            __assert_rtn("operator()", "GPUControlFlowOps.mm", 1003, "condAfterArgTensorData.mpsndarray != nil");
          }

          unint64_t v25 = (void *)v47[3];
          if ((void *)*v25 == v25) {
            goto LABEL_42;
          }
          uint64_t v26 = v25[1];
          uint64_t v27 = v26 - 8;
          if (!v26) {
            uint64_t v27 = 0;
          }
          uint64_t v28 = *(void *)(v27 + 48);
          if (v17 >= (*(void *)(v27 + 56) - v28) >> 3) {
LABEL_42:
          }
            __assert_rtn("operator[]", "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"");
          uint64_t v29 = *(void *)(v28 + 8 * v17);
          uint64_t v30 = v48[2];
          uint64_t v51 = v29;
          uint64_t v50 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v51) + 2);
          unint64_t v31 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v30 + 88), &v50);
          if (v31
            && (uint64_t v49 = v51,
                (uint64_t v32 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v31 + 3, &v49)) != 0))
          {
            id v33 = (id)v32[3];
          }
          else
          {
            id v33 = 0;
          }
          unint64_t v34 = *(void **)v47[1];
          unint64_t v35 = GPU::EncodeDescriptor::getcomputeEncoder(*(GPU::EncodeDescriptor **)v47[2]);
          uint64_t v36 = *(void *)(*(void *)v47[2] + 8);
          uint8x8_t v37 = [v23 mpsndarray];
          uint8x8_t v52 = v37;
          unint64_t v38 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v52 count:1];
          uint64_t v39 = [v33 mpsndarray];
          [v34 encodeToMPSCommandEncoder:v35 commandBuffer:v36 sourceArrays:v38 resultState:0 destinationArray:v39 kernelDAGObject:0];

          v18 += 32;
          unint64_t v17 = v19;
          if (v19 >= *(unsigned int *)(v48[3] + 36)) {
            goto LABEL_30;
          }
        }
        int v41 = 960;
        uint64_t v42 = "hasOperandStorage && \"expected operation to have operand storage\"";
        unint64_t v43 = "Operation.h";
        uint64_t v44 = "getOperandStorage";
        goto LABEL_37;
      }
LABEL_30:
    }
    else
    {
      unint64_t v40 = *(id **)a1[2];
      GPURegionRuntime::encodeOp(v7, (mlir::GenericProgramPoint ***)v46, v40);
    }
  }
}

void sub_1801644F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  _Unwind_Resume(a1);
}

uint64_t MILToMLIR::SliceByIndexPattern::matchAndRewrite(MILToMLIR::SliceByIndexPattern *this, const MIL::IROperation *a2, mlir::StringAttr **a3)
{
  __p[38] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t LocationForOp = MILToMLIRRewriter::getLocationForOp(a3, a2);
  if ((*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 192))(a2) == 1)
  {
    uint64_t v224 = this;
    uint64_t ArgValue = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "x");
    uint64_t v7 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "begin");
    uint64_t v232 = v7;
    uint64_t v231 = MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "end");
    uint64_t OptionalArgValue = MILToMLIRRewriter::getOptionalArgValue((int8x8_t *)a3, a2, "stride");
    if (OptionalArgValue) {
      goto LABEL_25;
    }
    uint64_t v8 = *(void *)(v7 + 8);
    uint64_t v9 = (uint64_t **)(v8 & 0xFFFFFFFFFFFFFFF8);
    if ((v8 & 0xFFFFFFFFFFFFFFF8) == 0) {
      __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
    }
    uint64_t InterfaceFor = (long long *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor((uint64_t **)(v8 & 0xFFFFFFFFFFFFFFF8));
    if (InterfaceFor)
    {
      uint64_t InterfaceFor = (long long *)mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v9);
      if (!InterfaceFor) {
        __assert_rtn("Interface", "InterfaceSupport.h", 98, "(!t || conceptImpl) && \"expected value to provide interface instance\"");
      }
    }
    else
    {
      uint64_t v9 = 0;
    }
    v239[0] = (long long *)v9;
    v239[1] = InterfaceFor;
    ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v239);
    v237[0] = 0;
    if (!v13) {
      __assert_rtn("operator[]", "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"");
    }
    v237[0] = *ArgAttrsAttr;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)(a3 + 18), 0x20u, 1);
    uint64_t v15 = (uint64_t **)mlir::RankedTensorType::get((uint64_t)v237, 1, IntegerType, 0);
    unint64_t v16 = v237[0];
    __p[0] = &__p[2];
    HIDWORD(__p[1]) = 4;
    if (v237[0] < 5uLL)
    {
      if (v237[0]) {
        memset_pattern16(&__p[2], &xmmword_18112A9B0, 4 * v237[0]);
      }
    }
    else
    {
      LODWORD(__p[1]) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)__p, &__p[2], v237[0], 4);
      memset_pattern16(__p[0], &xmmword_18112A9B0, 4 * v16);
      if (v16 > HIDWORD(__p[1])) {
        __assert_rtn("set_size", "SmallVector.h", 102, "N <= capacity()");
      }
    }
    LODWORD(__p[1]) = v16;
    if (!mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v15)) {
      goto LABEL_92;
    }
    if (v15)
    {
      uint64_t v17 = mlir::TypeInterface<mlir::ShapedType,mlir::detail::ShapedTypeInterfaceTraits>::getInterfaceFor(v15);
      if (!v17)
      {
        uint64_t v18 = "(!t || conceptImpl) && \"expected value to provide interface instance\"";
        int v19 = 98;
        uint64_t v20 = "InterfaceSupport.h";
        int8x8_t v21 = "Interface";
        goto LABEL_96;
      }
    }
    else
    {
      uint64_t v17 = 0;
    }
    unint64_t v22 = (uint64_t *)mlir::DenseElementsAttr::getFromRawBuffer(v15, v17, __p[0], 4 * LODWORD(__p[1]), 4, 1, 1);
    if (mlir::DenseIntElementsAttr::classof((uint64_t)v22))
    {
      v235[0] = v22;
      id v23 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::DenseIntElementsAttr>((mlir::OpBuilder *)(a3 + 18), LocationForOp, v235);
      if (*((_DWORD *)v23 + 9))
      {
        uint64_t OptionalArgValue = (uint64_t)v23 - 16;
        if (__p[0] != &__p[2]) {
          free(__p[0]);
        }
LABEL_25:
        uint64_t v229 = 0;
        unsigned int v228 = 0;
        unint64_t v24 = (const void ***)(*(uint64_t (**)(const MIL::IROperation *))(*(void *)a2 + 160))(a2);
        v223 = (mlir::Builder *)(a3 + 18);
        v227[0] = 0;
        v227[1] = 0;
        uint64_t v225 = LocationForOp;
        int v226 = v227;
        uint64_t v26 = v24 + 1;
        unint64_t v25 = *v24;
        if (*v24 == (const void **)(v24 + 1))
        {
          uint64_t v27 = 0;
          goto LABEL_102;
        }
        do
        {
          std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::__emplace_hint_unique_key_args<std::string,std::pair<std::string const,std::vector<std::shared_ptr<MIL::IRArgument>>> const&>((uint64_t **)&v226, (uint64_t *)v227, v25 + 4, (uint64_t)(v25 + 4));
          uint64_t v28 = (const void **)v25[1];
          if (v28)
          {
            do
            {
              uint64_t v29 = (const void ***)v28;
              uint64_t v28 = (const void **)*v28;
            }
            while (v28);
          }
          else
          {
            do
            {
              uint64_t v29 = (const void ***)v25[2];
              BOOL v174 = *v29 == v25;
              unint64_t v25 = (const void **)v29;
            }
            while (!v174);
          }
          unint64_t v25 = (const void **)v29;
        }
        while (v29 != v26);
        uint64_t v27 = v227[0];
        HIBYTE(__p[2]) = 10;
        strcpy((char *)__p, "begin_mask");
        if (!v227[0]) {
          goto LABEL_102;
        }
        uint64_t v30 = v227;
        unint64_t v31 = v227[0];
        do
        {
          uint64_t v32 = v31;
          id v33 = v30;
          unint64_t v35 = v31 + 32;
          unint64_t v34 = (char *)*((void *)v31 + 4);
          unint64_t v36 = v31[55];
          int v37 = (char)v36;
          if ((v36 & 0x80u) != 0) {
            unint64_t v36 = *((void *)v32 + 5);
          }
          if (v37 >= 0) {
            unint64_t v38 = v35;
          }
          else {
            unint64_t v38 = v34;
          }
          if (v36 >= 0xA) {
            size_t v39 = 10;
          }
          else {
            size_t v39 = v36;
          }
          BOOL v40 = v36 < 0xA;
          int v41 = memcmp(v38, __p, v39);
          if (v41) {
            BOOL v40 = v41 < 0;
          }
          if (v40) {
            uint64_t v42 = (char **)(v32 + 8);
          }
          else {
            uint64_t v42 = (char **)v32;
          }
          if (v40) {
            uint64_t v30 = v33;
          }
          else {
            uint64_t v30 = (char **)v32;
          }
          unint64_t v31 = *v42;
        }
        while (v31);
        if (v30 == v227) {
          goto LABEL_102;
        }
        unint64_t v43 = (char *)(v33 + 4);
        if (v40) {
          uint64_t v44 = v33;
        }
        else {
          uint64_t v44 = v32;
        }
        if (!v40) {
          unint64_t v43 = v35;
        }
        unint64_t v45 = *((unsigned __int8 *)v30 + 55);
        int v46 = (char)v45;
        unint64_t v48 = (char *)v44[4];
        unint64_t v47 = v44[5];
        if ((v45 & 0x80u) != 0) {
          unint64_t v45 = v47;
        }
        if (v46 >= 0) {
          uint64_t v49 = v43;
        }
        else {
          uint64_t v49 = v48;
        }
        if (v45 >= 0xA) {
          size_t v50 = 10;
        }
        else {
          size_t v50 = v45;
        }
        BOOL v51 = v45 > 0xA;
        int v52 = memcmp(__p, v49, v50);
        BOOL v53 = v52 < 0;
        if (!v52) {
          BOOL v53 = v51;
        }
        if (v53)
        {
LABEL_102:
          HIBYTE(__p[2]) = 8;
          strcpy((char *)__p, "end_mask");
          if (!v27) {
            goto LABEL_162;
          }
          unint64_t v88 = v227;
          uint8x8_t v89 = v27;
          do
          {
            unint64_t v90 = v89;
            v91 = v88;
            uint64_t v93 = v89 + 32;
            id v92 = (const void *)*((void *)v89 + 4);
            unint64_t v94 = v89[55];
            int v95 = (char)v94;
            if ((v94 & 0x80u) != 0) {
              unint64_t v94 = *((void *)v90 + 5);
            }
            if (v95 >= 0) {
              v96 = v93;
            }
            else {
              v96 = v92;
            }
            if (v94 >= 8) {
              size_t v97 = 8;
            }
            else {
              size_t v97 = v94;
            }
            BOOL v98 = v94 < 8;
            int v99 = memcmp(v96, __p, v97);
            if (v99) {
              BOOL v98 = v99 < 0;
            }
            if (v98) {
              unint64_t v100 = (char **)(v90 + 8);
            }
            else {
              unint64_t v100 = (char **)v90;
            }
            if (v98) {
              unint64_t v88 = v91;
            }
            else {
              unint64_t v88 = (char **)v90;
            }
            uint8x8_t v89 = *v100;
          }
          while (v89);
          if (v88 == v227) {
            goto LABEL_162;
          }
          unint64_t v101 = (char *)(v91 + 4);
          if (v98) {
            unint64_t v102 = v91;
          }
          else {
            unint64_t v102 = (char **)v90;
          }
          if (!v98) {
            unint64_t v101 = (char *)v93;
          }
          unint64_t v103 = *((unsigned __int8 *)v88 + 55);
          int v104 = (char)v103;
          v106 = v102[4];
          unint64_t v105 = (unint64_t)v102[5];
          if ((v103 & 0x80u) != 0) {
            unint64_t v103 = v105;
          }
          if (v104 >= 0) {
            v107 = v101;
          }
          else {
            v107 = v106;
          }
          if (v103 >= 8) {
            size_t v108 = 8;
          }
          else {
            size_t v108 = v103;
          }
          BOOL v109 = v103 > 8;
          int v110 = memcmp(__p, v107, v108);
          BOOL v111 = v110 < 0;
          if (!v110) {
            BOOL v111 = v109;
          }
          if (v111)
          {
LABEL_162:
            HIBYTE(__p[2]) = 12;
            strcpy((char *)__p, "squeeze_mask");
            if (!v27) {
              goto LABEL_198;
            }
            v144 = v227;
            do
            {
              uint64_t v145 = v27;
              v146 = v144;
              unint64_t v147 = v27 + 32;
              unint64_t v148 = v27[55];
              int v149 = (char)v148;
              if ((v148 & 0x80u) != 0) {
                unint64_t v148 = *((void *)v27 + 5);
              }
              if (v149 >= 0) {
                v150 = v27 + 32;
              }
              else {
                v150 = (const void *)*((void *)v27 + 4);
              }
              if (v148 >= 0xC) {
                size_t v151 = 12;
              }
              else {
                size_t v151 = v148;
              }
              BOOL v152 = v148 < 0xC;
              int v153 = memcmp(v150, __p, v151);
              if (v153) {
                BOOL v152 = v153 < 0;
              }
              if (v152) {
                v154 = v27 + 8;
              }
              else {
                v154 = v27;
              }
              if (v152) {
                v144 = v146;
              }
              else {
                v144 = (char **)v27;
              }
              uint64_t v27 = *(char **)v154;
            }
            while (*(void *)v154);
            if (v144 == v227) {
              goto LABEL_198;
            }
            int64_t v155 = (char *)(v146 + 4);
            if (v152) {
              v156 = v146;
            }
            else {
              v156 = v145;
            }
            if (!v152) {
              int64_t v155 = v147;
            }
            unint64_t v157 = *((unsigned __int8 *)v144 + 55);
            int v158 = (char)v157;
            v160 = (char *)v156[4];
            unint64_t v159 = v156[5];
            if ((v157 & 0x80u) != 0) {
              unint64_t v157 = v159;
            }
            if (v158 >= 0) {
              v161 = v155;
            }
            else {
              v161 = v160;
            }
            if (v157 >= 0xC) {
              size_t v162 = 12;
            }
            else {
              size_t v162 = v157;
            }
            BOOL v163 = v157 > 0xC;
            int v164 = memcmp(__p, v161, v162);
            BOOL v165 = v164 < 0;
            if (!v164) {
              BOOL v165 = v163;
            }
            if (v165)
            {
LABEL_198:
              int64_t v166 = v224;
              uint64_t v167 = v225;
LABEL_199:
              uint64_t v168 = *((unsigned __int8 *)v166 + 31);
              BOOL v169 = (v168 & 0x80u) != 0;
              if ((v168 & 0x80u) != 0) {
                uint64_t v168 = *((void *)v166 + 2);
              }
              if (v169) {
                int64_t v170 = (char *)*((void *)v166 + 1);
              }
              else {
                int64_t v170 = (char *)v166 + 8;
              }
              if (v168 >= 12)
              {
                v171 = &v170[v168];
                char v172 = v170;
                while (1)
                {
                  v173 = (char *)memchr(v172, 115, v168 - 11);
                  if (!v173) {
                    goto LABEL_227;
                  }
                  BOOL v174 = *(void *)v173 == 0x70755F6563696C73 && *((_DWORD *)v173 + 2) == 1702125924;
                  if (v174) {
                    break;
                  }
                  char v172 = v173 + 1;
                  uint64_t v168 = v171 - (unsigned char *)v172;
                  if (v171 - (unsigned char *)v172 < 12) {
                    goto LABEL_227;
                  }
                }
                if (v173 != v171 && v173 - v170 != -1)
                {
                  __p[0] = (void *)MILToMLIRRewriter::getArgValue((int8x8_t *)a3, a2, "update");
                  LOBYTE(v239[0]) = 0;
                  uint64_t v182 = mlir::OpBuilder::create<mlir::mps::StridedSliceUpdateOp,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,mlir::Value &,unsigned int &,unsigned int &,unsigned int &,BOOL>(v223, v167, &ArgValue, (uint64_t *)__p, &v232, &v231, &OptionalArgValue, (unsigned int *)&v229 + 1, (unsigned int *)&v229, &v228, (char *)v239);
                  if (!*(_DWORD *)(v182 + 36)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
                  goto LABEL_231;
                }
              }
LABEL_227:
              uint64_t v234 = v167;
              Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v234);
              uint64_t v184 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.strided_slice", (const unsigned __int8 *)0x11, Context);
              if (!v185)
              {
                __int16 v238 = 1283;
                v237[2] = (uint64_t)"mps.strided_slice";
                v237[3] = 17;
                                     "ration hasn't been added by the dialect. See also https://mlir.llvm.org/getting_sta"
                                     "rted/Faq/#registered-loaded-dependent-whats-up-with-dialects-management";
                __int16 v236 = 259;
                llvm::operator+(v237, (uint64_t *)v235, (uint64_t)v239);
                llvm::report_fatal_error((llvm::Twine *)v239, 1);
              }
              mlir::OperationState::OperationState(__p, v167, v184);
              mlir::mps::StridedSliceOp::build(v223, (uint64_t)__p, ArgValue, v232, v231, OptionalArgValue, HIDWORD(v229), v229, v228, 0);
              long long v186 = mlir::OpBuilder::create(v223, (const mlir::OperationState *)__p);
              if (v186)
              {
                uint64_t v182 = llvm::DefaultDoCastIfPossible<mlir::mps::StridedSliceOp,mlir::Operation *,llvm::CastInfo<mlir::mps::StridedSliceOp,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v186);
                if (v182)
                {
                  mlir::OperationState::~OperationState((mlir::OperationState *)__p);
                  if (!*(_DWORD *)(v182 + 36)) {
                    __assert_rtn("getOpResultImpl", "Operation.h", 984, "resultNumber < getNumResults() && \"Result number is out of range for operation\"");
                  }
LABEL_231:
                  (*(void (**)(void **__return_ptr, const MIL::IROperation *))(*(void *)a2 + 200))(__p, a2);
                  long long v187 = (long long *)__p[0];
                  long long v188 = (char *)operator new(8uLL);
                  *(void *)long long v188 = v182 - 16;
                  v239[0] = v187;
                  long long v189 = std::__hash_table<std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::__unordered_map_hasher<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::hash<std::string>,std::equal_to<std::string>,true>,std::__unordered_map_equal<std::string,std::__hash_value_type<std::string,std::vector<mlir::Value>>,std::equal_to<std::string>,std::hash<std::string>,true>,std::allocator<std::__hash_value_type<std::string,std::vector<mlir::Value>>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)(a3 + 8), (uint64_t)v187, (uint64_t)&std::piecewise_construct, v239);
                  std::vector<long>::__assign_with_size[abi:ne180100]<long *,long *>(v189 + 5, v188, v188 + 8, 1uLL);
                  operator delete(v188);
                  uint64_t v190 = (void **)__p[0];
                  if (__p[0])
                  {
                    unint64_t v191 = (void **)__p[1];
                    v192 = __p[0];
                    if (__p[1] != __p[0])
                    {
                      do
                      {
                        if (*((char *)v191 - 1) < 0) {
                          operator delete(*(v191 - 3));
                        }
                        v191 -= 3;
                      }
                      while (v191 != v190);
                      v192 = __p[0];
                    }
                    __p[1] = v190;
                    operator delete(v192);
                  }
                  uint64_t v11 = 1;
LABEL_240:
                  std::__tree<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::__map_value_compare<std::string,std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,std::vector<std::shared_ptr<MIL::IRArgument>>>>>::destroy((uint64_t)&v226, v227[0]);
                  return v11;
                }
                uint64_t v219 = "result && \"builder didn't return the right type\"";
                int v220 = 497;
                int v221 = "Builders.h";
                v222 = "create";
              }
              else
              {
                uint64_t v219 = "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"";
                int v220 = 662;
                int v221 = "Casting.h";
                v222 = "dyn_cast";
              }
              __assert_rtn(v222, v221, v220, v219);
            }
            if (v152) {
              v175 = v146;
            }
            else {
              v175 = v145;
            }
            if (v175[8] - v175[7] == 16)
            {
              HIBYTE(__p[2]) = 12;
              strcpy((char *)__p, "squeeze_mask");
              uint64_t ParameterValue = MIL::IROperation::TryGetParameterValue();
              uint64_t v167 = v225;
              if (SHIBYTE(__p[2]) < 0) {
                operator delete(__p[0]);
              }
              if (ParameterValue)
              {
                (*(void (**)(uint64_t))(*(void *)ParameterValue + 40))(ParameterValue);
                uint64_t Data = MIL::IRTensorValue::GetDataView<BOOL>();
                int64_t v166 = v224;
                unsigned int v180 = v228;
                if (v178)
                {
                  if (v178 < 8)
                  {
                    unint64_t v181 = 0;
                    do
                    {
LABEL_259:
                      v180 |= *(unsigned __int8 *)(Data + v181) << v181;
                      ++v181;
LABEL_260:
                      ;
                    }
                    while (v178 != v181);
                    goto LABEL_261;
                  }
                  if (v178 < 0x10)
                  {
                    unint64_t v181 = 0;
                    goto LABEL_246;
                  }
                  unint64_t v181 = v178 & 0xFFFFFFFFFFFFFFF0;
                  int8x16_t v206 = 0uLL;
                  int8x16_t v207 = (int8x16_t)v228;
                  int32x4_t v208 = (int32x4_t)xmmword_181134030;
                  int32x4_t v209 = (int32x4_t)xmmword_181134040;
                  int32x4_t v210 = (int32x4_t)xmmword_181134050;
                  int32x4_t v211 = (int32x4_t)xmmword_1810FFF10;
                  v179.i64[1] = 0xFFFFFF07FFFFFF06;
                  v212.i64[0] = 0x1000000010;
                  v212.i64[1] = 0x1000000010;
                  unint64_t v213 = v178 & 0xFFFFFFFFFFFFFFF0;
                  uint64_t v214 = (int8x16_t *)Data;
                  int8x16_t v215 = 0uLL;
                  int8x16_t v216 = 0uLL;
                  do
                  {
                    int8x16_t v217 = *v214++;
                    int8x16_t v215 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v217, (int8x16_t)xmmword_181132980), (uint32x4_t)v209), v215);
                    int8x16_t v206 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v217, (int8x16_t)xmmword_181132990), (uint32x4_t)v210), v206);
                    int8x16_t v207 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v217, (int8x16_t)xmmword_1811329A0), (uint32x4_t)v211), v207);
                    int8x16_t v216 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v217, (int8x16_t)xmmword_181132970), (uint32x4_t)v208), v216);
                    int32x4_t v211 = vaddq_s32(v211, v212);
                    int32x4_t v210 = vaddq_s32(v210, v212);
                    int32x4_t v209 = vaddq_s32(v209, v212);
                    int32x4_t v208 = vaddq_s32(v208, v212);
                    v213 -= 16;
                  }
                  while (v213);
                  int8x16_t v218 = vorrq_s8(vorrq_s8(v207, v215), vorrq_s8(v206, v216));
                  *(int8x8_t *)v218.i8 = vorr_s8(*(int8x8_t *)v218.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v218, v218, 8uLL));
                  unsigned int v180 = v218.i32[0] | v218.i32[1];
                  if (v178 != v181)
                  {
                    if ((v178 & 8) == 0) {
                      goto LABEL_259;
                    }
LABEL_246:
                    unint64_t v194 = v181;
                    unint64_t v181 = v178 & 0xFFFFFFFFFFFFFFF8;
                    int8x16_t v195 = 0uLL;
                    int8x16_t v196 = (int8x16_t)v180;
                    int8x16_t v197 = (int8x16_t)vdupq_n_s32(v194);
                    int32x4_t v198 = (int32x4_t)vorrq_s8(v197, (int8x16_t)xmmword_181134050);
                    int32x4_t v199 = (int32x4_t)vorrq_s8(v197, (int8x16_t)xmmword_1810FFF10);
                    BOOL v200 = (uint64_t *)(Data + v194);
                    unint64_t v201 = v194 - (v178 & 0xFFFFFFFFFFFFFFF8);
                    v202.i64[0] = 0x800000008;
                    v202.i64[1] = 0x800000008;
                    do
                    {
                      uint64_t v203 = *v200++;
                      v179.i64[0] = v203;
                      uint32x4_t v204 = (uint32x4_t)vqtbl1q_s8(v179, (int8x16_t)xmmword_181132990);
                      int8x16_t v179 = (int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v179, (int8x16_t)xmmword_1811329A0), (uint32x4_t)v199);
                      int8x16_t v195 = vorrq_s8((int8x16_t)vshlq_u32(v204, (uint32x4_t)v198), v195);
                      int8x16_t v196 = vorrq_s8(v179, v196);
                      int32x4_t v199 = vaddq_s32(v199, v202);
                      int32x4_t v198 = vaddq_s32(v198, v202);
                      v201 += 8;
                    }
                    while (v201);
                    int8x16_t v205 = vorrq_s8(v196, v195);
                    *(int8x8_t *)v205.i8 = vorr_s8(*(int8x8_t *)v205.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v205, v205, 8uLL));
                    unsigned int v180 = v205.i32[0] | v205.i32[1];
                    goto LABEL_260;
                  }
                }
LABEL_261:
                unsigned int v228 = v180;
                goto LABEL_199;
              }
              __p[0] = operator new(0x28uLL);
              *(_OWORD *)&__p[1] = xmmword_181129D80;
              uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
            }
            else
            {
              __p[0] = operator new(0x30uLL);
              *(_OWORD *)&__p[1] = xmmword_18112B080;
              strcpy((char *)__p[0], "Unexpected argument size for 'squeeze_mask'");
              uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
            }
LABEL_97:
            uint64_t v11 = v61;
            if (SHIBYTE(__p[2]) < 0) {
              operator delete(__p[0]);
            }
            goto LABEL_240;
          }
          if (v98) {
            unint64_t v112 = v91;
          }
          else {
            unint64_t v112 = (char **)v90;
          }
          if (v112[8] - v112[7] != 16)
          {
            __p[0] = operator new(0x28uLL);
            *(_OWORD *)&__p[1] = xmmword_1811286F0;
            strcpy((char *)__p[0], "Unexpected argument size for 'end_mask'");
            uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
            goto LABEL_97;
          }
          HIBYTE(__p[2]) = 8;
          strcpy((char *)__p, "end_mask");
          uint64_t v113 = MIL::IROperation::TryGetParameterValue();
          if (SHIBYTE(__p[2]) < 0) {
            operator delete(__p[0]);
          }
          if (!v113)
          {
            __p[0] = operator new(0x20uLL);
            *(_OWORD *)&__p[1] = xmmword_181129E80;
            uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
            goto LABEL_97;
          }
          (*(void (**)(uint64_t))(*(void *)v113 + 40))(v113);
          uint64_t v114 = MIL::IRTensorValue::GetDataView<BOOL>();
          unsigned __int32 v117 = v229;
          if (v115)
          {
            if (v115 < 8)
            {
              unint64_t v118 = 0;
              do
              {
LABEL_159:
                v117 |= *(unsigned __int8 *)(v114 + v118) << v118;
                ++v118;
LABEL_160:
                ;
              }
              while (v115 != v118);
              goto LABEL_161;
            }
            if (v115 < 0x10)
            {
              unint64_t v118 = 0;
              goto LABEL_152;
            }
            unint64_t v118 = v115 & 0xFFFFFFFFFFFFFFF0;
            int8x16_t v131 = 0uLL;
            int8x16_t v132 = (int8x16_t)v229;
            int32x4_t v133 = (int32x4_t)xmmword_181134030;
            int32x4_t v134 = (int32x4_t)xmmword_181134040;
            int32x4_t v135 = (int32x4_t)xmmword_181134050;
            int32x4_t v136 = (int32x4_t)xmmword_1810FFF10;
            v116.i64[1] = 0xFFFFFF07FFFFFF06;
            v137.i64[0] = 0x1000000010;
            v137.i64[1] = 0x1000000010;
            unint64_t v138 = v115 & 0xFFFFFFFFFFFFFFF0;
            unint64_t v139 = (int8x16_t *)v114;
            int8x16_t v140 = 0uLL;
            int8x16_t v141 = 0uLL;
            do
            {
              int8x16_t v142 = *v139++;
              int8x16_t v140 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v142, (int8x16_t)xmmword_181132980), (uint32x4_t)v134), v140);
              int8x16_t v131 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v142, (int8x16_t)xmmword_181132990), (uint32x4_t)v135), v131);
              int8x16_t v132 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v142, (int8x16_t)xmmword_1811329A0), (uint32x4_t)v136), v132);
              int8x16_t v141 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v142, (int8x16_t)xmmword_181132970), (uint32x4_t)v133), v141);
              int32x4_t v136 = vaddq_s32(v136, v137);
              int32x4_t v135 = vaddq_s32(v135, v137);
              int32x4_t v134 = vaddq_s32(v134, v137);
              int32x4_t v133 = vaddq_s32(v133, v137);
              v138 -= 16;
            }
            while (v138);
            int8x16_t v143 = vorrq_s8(vorrq_s8(v132, v140), vorrq_s8(v131, v141));
            *(int8x8_t *)v143.i8 = vorr_s8(*(int8x8_t *)v143.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v143, v143, 8uLL));
            unsigned __int32 v117 = v143.i32[0] | v143.i32[1];
            if (v115 != v118)
            {
              if ((v115 & 8) == 0) {
                goto LABEL_159;
              }
LABEL_152:
              unint64_t v119 = v118;
              unint64_t v118 = v115 & 0xFFFFFFFFFFFFFFF8;
              int8x16_t v120 = 0uLL;
              int8x16_t v121 = (int8x16_t)v117;
              int8x16_t v122 = (int8x16_t)vdupq_n_s32(v119);
              int32x4_t v123 = (int32x4_t)vorrq_s8(v122, (int8x16_t)xmmword_181134050);
              int32x4_t v124 = (int32x4_t)vorrq_s8(v122, (int8x16_t)xmmword_1810FFF10);
              int8x8_t v125 = (uint64_t *)(v114 + v119);
              unint64_t v126 = v119 - (v115 & 0xFFFFFFFFFFFFFFF8);
              v127.i64[0] = 0x800000008;
              v127.i64[1] = 0x800000008;
              do
              {
                uint64_t v128 = *v125++;
                v116.i64[0] = v128;
                uint32x4_t v129 = (uint32x4_t)vqtbl1q_s8(v116, (int8x16_t)xmmword_181132990);
                int8x16_t v116 = (int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v116, (int8x16_t)xmmword_1811329A0), (uint32x4_t)v124);
                int8x16_t v120 = vorrq_s8((int8x16_t)vshlq_u32(v129, (uint32x4_t)v123), v120);
                int8x16_t v121 = vorrq_s8(v116, v121);
                int32x4_t v124 = vaddq_s32(v124, v127);
                int32x4_t v123 = vaddq_s32(v123, v127);
                v126 += 8;
              }
              while (v126);
              int8x16_t v130 = vorrq_s8(v121, v120);
              *(int8x8_t *)v130.i8 = vorr_s8(*(int8x8_t *)v130.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v130, v130, 8uLL));
              unsigned __int32 v117 = v130.i32[0] | v130.i32[1];
              goto LABEL_160;
            }
          }
LABEL_161:
          LODWORD(v229) = v117;
          uint64_t v27 = v227[0];
          goto LABEL_162;
        }
        if (v40) {
          uint64_t v54 = v33;
        }
        else {
          uint64_t v54 = v32;
        }
        if (v54[8] - v54[7] != 16)
        {
          __p[0] = operator new(0x30uLL);
          *(_OWORD *)&__p[1] = xmmword_181129D90;
          strcpy((char *)__p[0], "Unexpected argument size for 'begin_mask'");
          uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
          goto LABEL_97;
        }
        HIBYTE(__p[2]) = 10;
        strcpy((char *)__p, "begin_mask");
        uint64_t v55 = MIL::IROperation::TryGetParameterValue();
        if (SHIBYTE(__p[2]) < 0) {
          operator delete(__p[0]);
        }
        if (!v55)
        {
          __p[0] = operator new(0x28uLL);
          *(_OWORD *)&__p[1] = xmmword_181128700;
          uint64_t v61 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
          goto LABEL_97;
        }
        (*(void (**)(uint64_t))(*(void *)v55 + 40))(v55);
        uint64_t v56 = MIL::IRTensorValue::GetDataView<BOOL>();
        unsigned __int32 v59 = HIDWORD(v229);
        if (v57)
        {
          if (v57 < 8)
          {
            unint64_t v60 = 0;
            do
            {
LABEL_99:
              v59 |= *(unsigned __int8 *)(v56 + v60) << v60;
              ++v60;
LABEL_100:
              ;
            }
            while (v57 != v60);
            goto LABEL_101;
          }
          if (v57 < 0x10)
          {
            unint64_t v60 = 0;
            goto LABEL_84;
          }
          unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF0;
          int8x16_t v75 = (int8x16_t)HIDWORD(v229);
          int8x16_t v76 = 0uLL;
          int32x4_t v77 = (int32x4_t)xmmword_181134030;
          int32x4_t v78 = (int32x4_t)xmmword_181134040;
          int32x4_t v79 = (int32x4_t)xmmword_181134050;
          int32x4_t v80 = (int32x4_t)xmmword_1810FFF10;
          v58.i64[1] = 0xFFFFFF0FFFFFFF0ELL;
          v81.i64[0] = 0x1000000010;
          v81.i64[1] = 0x1000000010;
          unint64_t v82 = v57 & 0xFFFFFFFFFFFFFFF0;
          unint64_t v83 = (int8x16_t *)v56;
          int8x16_t v84 = 0uLL;
          int8x16_t v85 = 0uLL;
          do
          {
            int8x16_t v86 = *v83++;
            int8x16_t v84 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v86, (int8x16_t)xmmword_181132980), (uint32x4_t)v78), v84);
            int8x16_t v76 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v86, (int8x16_t)xmmword_181132990), (uint32x4_t)v79), v76);
            int8x16_t v75 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v86, (int8x16_t)xmmword_1811329A0), (uint32x4_t)v80), v75);
            int8x16_t v85 = vorrq_s8((int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v86, (int8x16_t)xmmword_181132970), (uint32x4_t)v77), v85);
            int32x4_t v80 = vaddq_s32(v80, v81);
            int32x4_t v79 = vaddq_s32(v79, v81);
            int32x4_t v78 = vaddq_s32(v78, v81);
            int32x4_t v77 = vaddq_s32(v77, v81);
            v82 -= 16;
          }
          while (v82);
          int8x16_t v87 = vorrq_s8(vorrq_s8(v75, v84), vorrq_s8(v76, v85));
          *(int8x8_t *)v87.i8 = vorr_s8(*(int8x8_t *)v87.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v87, v87, 8uLL));
          unsigned __int32 v59 = v87.i32[0] | v87.i32[1];
          if (v57 != v60)
          {
            if ((v57 & 8) == 0) {
              goto LABEL_99;
            }
LABEL_84:
            unint64_t v62 = v60;
            unint64_t v60 = v57 & 0xFFFFFFFFFFFFFFF8;
            int8x16_t v63 = (int8x16_t)v59;
            int8x16_t v64 = 0uLL;
            int8x16_t v65 = (int8x16_t)vdupq_n_s32(v62);
            int32x4_t v66 = (int32x4_t)vorrq_s8(v65, (int8x16_t)xmmword_181134050);
            int32x4_t v67 = (int32x4_t)vorrq_s8(v65, (int8x16_t)xmmword_1810FFF10);
            __int16 v68 = (uint64_t *)(v56 + v62);
            unint64_t v69 = v62 - (v57 & 0xFFFFFFFFFFFFFFF8);
            v70.i64[0] = 0x800000008;
            v70.i64[1] = 0x800000008;
            do
            {
              uint64_t v71 = *v68++;
              v58.i64[0] = v71;
              uint32x4_t v72 = (uint32x4_t)vqtbl1q_s8(v58, (int8x16_t)xmmword_181132990);
              int8x16_t v58 = (int8x16_t)vshlq_u32((uint32x4_t)vqtbl1q_s8(v58, (int8x16_t)xmmword_1811329A0), (uint32x4_t)v67);
              int8x16_t v64 = vorrq_s8((int8x16_t)vshlq_u32(v72, (uint32x4_t)v66), v64);
              int8x16_t v63 = vorrq_s8(v58, v63);
              int32x4_t v67 = vaddq_s32(v67, v70);
              int32x4_t v66 = vaddq_s32(v66, v70);
              v69 += 8;
            }
            while (v69);
            int8x16_t v73 = vorrq_s8(v63, v64);
            int8x8_t v74 = vorr_s8(*(int8x8_t *)v73.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v73, v73, 8uLL));
            unsigned __int32 v59 = v74.i32[0] | v74.i32[1];
            goto LABEL_100;
          }
        }
LABEL_101:
        HIDWORD(v229) = v59;
        uint64_t v27 = v227[0];
        goto LABEL_102;
      }
      uint64_t v18 = "resultNumber < getNumResults() && \"Result number is out of range for operation\"";
      int v19 = 984;
      uint64_t v20 = "Operation.h";
      int8x8_t v21 = "getOpResultImpl";
    }
    else
    {
LABEL_92:
      uint64_t v18 = "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"";
      int v19 = 566;
      uint64_t v20 = "Casting.h";
      int8x8_t v21 = "cast";
    }
LABEL_96:
    __assert_rtn(v21, v20, v19, v18);
  }
  __p[0] = operator new(0x40uLL);
  *(_OWORD *)&__p[1] = xmmword_181129DA0;
  strcpy((char *)__p[0], "The number of outputs does not match the number of results.");
  uint64_t v11 = MILToMLIRRewriter::notifyFailure((uint64_t)a3, (uint64_t)a2, (const std::string::value_type *)__p);
  if (SHIBYTE(__p[2]) < 0) {
    operator delete(__p[0]);
  }
  return v11;
}

void sub_180165F18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,void *__p,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40)
{
  _Unwind_Resume(a1);
}

void std::vector<mlir::Value>::__throw_out_of_range[abi:ne180100]()
{
}

void sub_180166448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void sub_180166744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

id *GPU::GRUOpHandler::GRUOpHandler(id *this, id *a2, mlir::Operation *a3, GPU::MPSGraphKernelDAG *a4)
{
  uint64_t v6 = GPU::BaseOpHandler::BaseOpHandler((GPU::BaseOpHandler *)this, (GPURegionRuntime *)a2, a3, a4);
  *(void *)uint64_t v6 = &unk_1EC99CB40;
  *(_OWORD *)((char *)v6 + 120) = 0u;
  *(_OWORD *)((char *)v6 + 136) = 0u;
  *(_OWORD *)((char *)v6 + 152) = 0u;
  *(_OWORD *)((char *)v6 + 168) = 0u;
  *(_OWORD *)((char *)v6 + 184) = 0u;
  *(_OWORD *)((char *)v6 + 200) = 0u;
  id v7 = objc_alloc(MEMORY[0x1E4F35770]);
  uint64_t v8 = [a2[6] metalDevice];
  uint64_t v9 = [v7 initWithDevice:v8];
  id v10 = this[1];
  this[1] = (id)v9;

  id v11 = objc_alloc(MEMORY[0x1E4F357B8]);
  int v12 = [a2[6] metalDevice];
  uint64_t v13 = [v11 initWithDevice:v12 sourceCount:2];
  id v14 = this[26];
  this[26] = (id)v13;

  [this[26] setBeta:0.0];
  id v15 = this[15];
  this[15] = 0;

  id v16 = this[16];
  this[16] = 0;

  id v17 = this[17];
  this[17] = 0;

  id v18 = this[18];
  this[18] = 0;

  id v19 = this[19];
  this[19] = 0;

  id v20 = this[20];
  this[20] = 0;

  id v21 = this[21];
  this[21] = 0;

  id v22 = this[22];
  this[22] = 0;

  id v23 = this[23];
  this[23] = 0;

  id v24 = this[24];
  this[24] = 0;

  id v25 = this[25];
  this[25] = 0;

  objc_msgSend(this[1], "setOptions:", objc_msgSend(this[1], "options") | 1);
  objc_msgSend(this[26], "setOptions:", objc_msgSend(this[26], "options") | 1);
  return this;
}

void sub_18016694C(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)v1);
  _Unwind_Resume(a1);
}

void sub_1801671FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, void *a20,uint64_t a21,void *a22,void *a23,void *a24,uint64_t a25,void *a26,void *a27,void *a28,void *a29,void *a30)
{
  _Unwind_Resume(a1);
}

void GPU::GRUGradientOpHandler::encodeNDArrayOp(GPU::GRUGradientOpHandler *this, GPU::EncodeDescriptor *a2, NSArray *a3)
{
  uint64_t v617 = *MEMORY[0x1E4F143B8];
  v492 = a3;
  v573 = this;
  uint64_t v5 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v6 = *(void **)(v5 + 16);
  if (v6 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v615 = *(void *)(v5 + 8);
    uint64_t AttrData = (void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v615);
    if (v455 == 16 && *AttrData == 0x5F7572672E73706DLL && AttrData[1] == 0x746E656964617267)
    {
      __int16 v614 = 1283;
      *(void *)&long long v611 = "classof on '";
      uint64_t v612 = (uint64_t)"mps.gru_gradient";
      uint64_t v613 = 16;
      v609[0] = (uint64_t)"' failed due to the operation not being registered";
      __int16 v610 = 259;
      llvm::operator+((uint64_t *)&v611, v609, (uint64_t)&v615);
      llvm::report_fatal_error((llvm::Twine *)&v615, 1);
    }
LABEL_631:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v6 != &mlir::detail::TypeIDResolver<mlir::mps::GRUGradientOp,void>::id) {
    goto LABEL_631;
  }
  uint64_t v586 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v586);
  uint64_t RecurrentWeight = mlir::mps::LSTMGradientOp::getRecurrentWeight((mlir::mps::LSTMGradientOp *)&v586);
  uint64_t TrainingState = mlir::mps::LSTMGradientOp::getTrainingState((mlir::mps::LSTMGradientOp *)&v586);
  uint64_t InputState = mlir::mps::LSTMGradientOp::getInputState((mlir::mps::LSTMGradientOp *)&v586);
  uint64_t OutputCellFwd = mlir::mps::LSTMGradientOp::getOutputCellFwd((mlir::mps::LSTMGradientOp *)&v586);
  uint64_t InputCell = mlir::mps::LSTMGradientOp::getInputCell((mlir::mps::LSTMGradientOp *)&v586);
  BOOL ResetAfter = mlir::mps::GRUOp::getResetAfter((mlir::mps::GRUOp *)&v586);
  mlir::pdl_interp::CreateOperationOp::getInferredResultTypes((mlir::pdl_interp::CreateOperationOp *)&v586);
  uint64_t Mask = mlir::mps::LSTMGradientOp::getMask((mlir::mps::LSTMGradientOp *)&v586);
  id v14 = (void *)*((void *)a2 + 9);
  v498 = a2;
  if (!v14)
  {
    uint64_t v15 = [objc_alloc(MEMORY[0x1E4F35528]) initWithCommandBuffer:*((void *)a2 + 1) withDispatchType:0];
    id v17 = (void *)*((void *)a2 + 9);
    id v16 = (uint64_t *)((char *)a2 + 72);
    uint64_t *v16 = v15;

    id v18 = (void *)*((void *)v498 + 11);
    id v14 = (void *)*v16;
    if (v18)
    {
      uint64_t v19 = [v18 wrapComputeEncoder:*v16];
      id v20 = (void *)*((void *)v498 + 9);
      *((void *)v498 + 9) = v19;

      id v14 = (void *)*((void *)v498 + 9);
    }
    a2 = v498;
    if (!*((void *)v498 + 10)) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if (*((void *)a2 + 10))
  {
LABEL_9:
    objc_msgSend(v14, "setLabel:");
    id v14 = (void *)*((void *)a2 + 9);
  }
LABEL_10:
  id v569 = v14;
  id v572 = *((id *)a2 + 1);
  id v566 = *((id *)v573 + 1);
  id v21 = (int8x8_t *)*((void *)v573 + 2);
  *(void *)&long long v615 = Input;
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)&v615);
  int8x8_t v23 = v21[12];
  if (!*(void *)&v23) {
    goto LABEL_51;
  }
  unint64_t v24 = *((void *)ParentRegion + 2);
  unint64_t v25 = 0x9DDFEA08EB382D69 * (((8 * v24) + 8) ^ HIDWORD(v24));
  unint64_t v26 = 0x9DDFEA08EB382D69 * (HIDWORD(v24) ^ (v25 >> 47) ^ v25);
  unint64_t v27 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
  uint8x8_t v28 = (uint8x8_t)vcnt_s8(v23);
  v28.i16[0] = vaddlv_u8(v28);
  if (v28.u32[0] > 1uLL)
  {
    unint64_t v29 = 0x9DDFEA08EB382D69 * (v26 ^ (v26 >> 47));
    if (v27 >= *(void *)&v23) {
      unint64_t v29 = v27 % *(void *)&v23;
    }
  }
  else
  {
    unint64_t v29 = v27 & (*(void *)&v23 - 1);
  }
  uint64_t v30 = *(void **)(*(void *)&v21[11] + 8 * v29);
  if (!v30) {
    goto LABEL_51;
  }
  unint64_t v31 = (void *)*v30;
  if (!v31) {
    goto LABEL_51;
  }
  if (v28.u32[0] < 2uLL)
  {
    uint64_t v32 = *(void *)&v23 - 1;
    while (1)
    {
      uint64_t v34 = v31[1];
      if (v34 == v27)
      {
        if (v31[2] == v24) {
          goto LABEL_31;
        }
      }
      else if ((v34 & v32) != v29)
      {
        goto LABEL_51;
      }
      unint64_t v31 = (void *)*v31;
      if (!v31) {
        goto LABEL_51;
      }
    }
  }
  while (1)
  {
    unint64_t v33 = v31[1];
    if (v33 == v27) {
      break;
    }
    if (v33 >= *(void *)&v23) {
      v33 %= *(void *)&v23;
    }
    if (v33 != v29) {
      goto LABEL_51;
    }
LABEL_20:
    unint64_t v31 = (void *)*v31;
    if (!v31) {
      goto LABEL_51;
    }
  }
  if (v31[2] != v24) {
    goto LABEL_20;
  }
LABEL_31:
  int8x8_t v35 = (int8x8_t)v31[4];
  if (v35)
  {
    unint64_t v36 = 0x9DDFEA08EB382D69 * (((8 * v615) + 8) ^ DWORD1(v615));
    unint64_t v37 = 0x9DDFEA08EB382D69 * (DWORD1(v615) ^ (v36 >> 47) ^ v36);
    unint64_t v38 = 0x9DDFEA08EB382D69 * (v37 ^ (v37 >> 47));
    uint8x8_t v39 = (uint8x8_t)vcnt_s8(v35);
    v39.i16[0] = vaddlv_u8(v39);
    if (v39.u32[0] > 1uLL)
    {
      unint64_t v40 = v38;
      if (v38 >= *(void *)&v35) {
        unint64_t v40 = v38 % *(void *)&v35;
      }
    }
    else
    {
      unint64_t v40 = v38 & (*(void *)&v35 - 1);
    }
    int v41 = *(uint64_t ****)(v31[3] + 8 * v40);
    if (v41)
    {
      uint64_t v42 = *v41;
      if (v42)
      {
        if (v39.u32[0] < 2uLL)
        {
          uint64_t v43 = *(void *)&v35 - 1;
          while (1)
          {
            int v46 = v42[1];
            if (v46 == (uint64_t *)v38)
            {
              if (v42[2] == (uint64_t *)v615) {
                goto LABEL_606;
              }
            }
            else if (((unint64_t)v46 & v43) != v40)
            {
              goto LABEL_51;
            }
            uint64_t v44 = 0;
            uint64_t v42 = (uint64_t **)*v42;
            if (!v42) {
              goto LABEL_52;
            }
          }
        }
        while (1)
        {
          unint64_t v45 = (unint64_t)v42[1];
          if (v45 == v38)
          {
            if (v42[2] == (uint64_t *)v615)
            {
LABEL_606:
              uint64_t v44 = v42[3];
              goto LABEL_52;
            }
          }
          else
          {
            if (v45 >= *(void *)&v35) {
              v45 %= *(void *)&v35;
            }
            if (v45 != v40) {
              break;
            }
          }
          uint64_t v44 = 0;
          uint64_t v42 = (uint64_t **)*v42;
          if (!v42) {
            goto LABEL_52;
          }
        }
      }
    }
  }
LABEL_51:
  uint64_t v44 = 0;
LABEL_52:
  v487 = [v44 mpsndarray];

  unint64_t v47 = (int8x8_t *)*((void *)v573 + 2);
  *(void *)&long long v615 = RecurrentWeight;
  unint64_t v48 = mlir::Value::getParentRegion((mlir::Value *)&v615);
  int8x8_t v49 = v47[12];
  if (!*(void *)&v49) {
    goto LABEL_93;
  }
  unint64_t v50 = *((void *)v48 + 2);
  unint64_t v51 = 0x9DDFEA08EB382D69 * (((8 * v50) + 8) ^ HIDWORD(v50));
  unint64_t v52 = 0x9DDFEA08EB382D69 * (HIDWORD(v50) ^ (v51 >> 47) ^ v51);
  unint64_t v53 = 0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47));
  uint8x8_t v54 = (uint8x8_t)vcnt_s8(v49);
  v54.i16[0] = vaddlv_u8(v54);
  if (v54.u32[0] > 1uLL)
  {
    unint64_t v55 = 0x9DDFEA08EB382D69 * (v52 ^ (v52 >> 47));
    if (v53 >= *(void *)&v49) {
      unint64_t v55 = v53 % *(void *)&v49;
    }
  }
  else
  {
    unint64_t v55 = v53 & (*(void *)&v49 - 1);
  }
  uint64_t v56 = *(void **)(*(void *)&v47[11] + 8 * v55);
  if (!v56) {
    goto LABEL_93;
  }
  unint64_t v57 = (void *)*v56;
  if (!v57) {
    goto LABEL_93;
  }
  if (v54.u32[0] < 2uLL)
  {
    uint64_t v58 = *(void *)&v49 - 1;
    while (1)
    {
      uint64_t v60 = v57[1];
      if (v60 == v53)
      {
        if (v57[2] == v50) {
          goto LABEL_73;
        }
      }
      else if ((v60 & v58) != v55)
      {
        goto LABEL_93;
      }
      unint64_t v57 = (void *)*v57;
      if (!v57) {
        goto LABEL_93;
      }
    }
  }
  while (2)
  {
    unint64_t v59 = v57[1];
    if (v59 != v53)
    {
      if (v59 >= *(void *)&v49) {
        v59 %= *(void *)&v49;
      }
      if (v59 != v55) {
        goto LABEL_93;
      }
      goto LABEL_62;
    }
    if (v57[2] != v50)
    {
LABEL_62:
      unint64_t v57 = (void *)*v57;
      if (!v57) {
        goto LABEL_93;
      }
      continue;
    }
    break;
  }
LABEL_73:
  int8x8_t v61 = (int8x8_t)v57[4];
  if (v61)
  {
    unint64_t v62 = 0x9DDFEA08EB382D69 * (((8 * v615) + 8) ^ DWORD1(v615));
    unint64_t v63 = 0x9DDFEA08EB382D69 * (DWORD1(v615) ^ (v62 >> 47) ^ v62);
    unint64_t v64 = 0x9DDFEA08EB382D69 * (v63 ^ (v63 >> 47));
    uint8x8_t v65 = (uint8x8_t)vcnt_s8(v61);
    v65.i16[0] = vaddlv_u8(v65);
    if (v65.u32[0] > 1uLL)
    {
      unint64_t v66 = v64;
      if (v64 >= *(void *)&v61) {
        unint64_t v66 = v64 % *(void *)&v61;
      }
    }
    else
    {
      unint64_t v66 = v64 & (*(void *)&v61 - 1);
    }
    int32x4_t v67 = *(uint64_t ****)(v57[3] + 8 * v66);
    if (v67)
    {
      __int16 v68 = *v67;
      if (v68)
      {
        if (v65.u32[0] < 2uLL)
        {
          uint64_t v69 = *(void *)&v61 - 1;
          while (1)
          {
            uint32x4_t v72 = v68[1];
            if (v72 == (uint64_t *)v64)
            {
              if (v68[2] == (uint64_t *)v615) {
                goto LABEL_607;
              }
            }
            else if (((unint64_t)v72 & v69) != v66)
            {
              goto LABEL_93;
            }
            int32x4_t v70 = 0;
            __int16 v68 = (uint64_t **)*v68;
            if (!v68) {
              goto LABEL_94;
            }
          }
        }
        while (1)
        {
          unint64_t v71 = (unint64_t)v68[1];
          if (v71 == v64)
          {
            if (v68[2] == (uint64_t *)v615)
            {
LABEL_607:
              int32x4_t v70 = v68[3];
              goto LABEL_94;
            }
          }
          else
          {
            if (v71 >= *(void *)&v61) {
              v71 %= *(void *)&v61;
            }
            if (v71 != v66) {
              break;
            }
          }
          int32x4_t v70 = 0;
          __int16 v68 = (uint64_t **)*v68;
          if (!v68) {
            goto LABEL_94;
          }
        }
      }
    }
  }
LABEL_93:
  int32x4_t v70 = 0;
LABEL_94:
  v475 = [v70 mpsndarray];

  int8x16_t v73 = (int8x8_t *)*((void *)v573 + 2);
  *(void *)&long long v615 = TrainingState;
  int8x8_t v74 = mlir::Value::getParentRegion((mlir::Value *)&v615);
  int8x8_t v75 = v73[12];
  if (!*(void *)&v75) {
    goto LABEL_135;
  }
  unint64_t v76 = *((void *)v74 + 2);
  unint64_t v77 = 0x9DDFEA08EB382D69 * (((8 * v76) + 8) ^ HIDWORD(v76));
  unint64_t v78 = 0x9DDFEA08EB382D69 * (HIDWORD(v76) ^ (v77 >> 47) ^ v77);
  unint64_t v79 = 0x9DDFEA08EB382D69 * (v78 ^ (v78 >> 47));
  uint8x8_t v80 = (uint8x8_t)vcnt_s8(v75);
  v80.i16[0] = vaddlv_u8(v80);
  if (v80.u32[0] > 1uLL)
  {
    unint64_t v81 = 0x9DDFEA08EB382D69 * (v78 ^ (v78 >> 47));
    if (v79 >= *(void *)&v75) {
      unint64_t v81 = v79 % *(void *)&v75;
    }
  }
  else
  {
    unint64_t v81 = v79 & (*(void *)&v75 - 1);
  }
  unint64_t v82 = *(void **)(*(void *)&v73[11] + 8 * v81);
  if (!v82) {
    goto LABEL_135;
  }
  unint64_t v83 = (void *)*v82;
  if (!v83) {
    goto LABEL_135;
  }
  if (v80.u32[0] < 2uLL)
  {
    uint64_t v84 = *(void *)&v75 - 1;
    while (1)
    {
      uint64_t v86 = v83[1];
      if (v86 == v79)
      {
        if (v83[2] == v76) {
          goto LABEL_115;
        }
      }
      else if ((v86 & v84) != v81)
      {
        goto LABEL_135;
      }
      unint64_t v83 = (void *)*v83;
      if (!v83) {
        goto LABEL_135;
      }
    }
  }
  while (1)
  {
    unint64_t v85 = v83[1];
    if (v85 == v79) {
      break;
    }
    if (v85 >= *(void *)&v75) {
      v85 %= *(void *)&v75;
    }
    if (v85 != v81) {
      goto LABEL_135;
    }
LABEL_104:
    unint64_t v83 = (void *)*v83;
    if (!v83) {
      goto LABEL_135;
    }
  }
  if (v83[2] != v76) {
    goto LABEL_104;
  }
LABEL_115:
  int8x8_t v87 = (int8x8_t)v83[4];
  if (!*(void *)&v87) {
    goto LABEL_135;
  }
  unint64_t v88 = 0x9DDFEA08EB382D69 * (((8 * v615) + 8) ^ DWORD1(v615));
  unint64_t v89 = 0x9DDFEA08EB382D69 * (DWORD1(v615) ^ (v88 >> 47) ^ v88);
  unint64_t v90 = 0x9DDFEA08EB382D69 * (v89 ^ (v89 >> 47));
  uint8x8_t v91 = (uint8x8_t)vcnt_s8(v87);
  v91.i16[0] = vaddlv_u8(v91);
  if (v91.u32[0] > 1uLL)
  {
    unint64_t v92 = v90;
    if (v90 >= *(void *)&v87) {
      unint64_t v92 = v90 % *(void *)&v87;
    }
  }
  else
  {
    unint64_t v92 = v90 & (*(void *)&v87 - 1);
  }
  uint64_t v93 = *(uint64_t ****)(v83[3] + 8 * v92);
  if (!v93 || (unint64_t v94 = *v93) == 0)
  {
LABEL_135:
    v96 = 0;
    goto LABEL_136;
  }
  if (v91.u32[0] < 2uLL)
  {
    uint64_t v95 = *(void *)&v87 - 1;
    while (1)
    {
      BOOL v98 = v94[1];
      if (v98 == (uint64_t *)v90)
      {
        if (v94[2] == (uint64_t *)v615) {
          goto LABEL_608;
        }
      }
      else if (((unint64_t)v98 & v95) != v92)
      {
        goto LABEL_135;
      }
      v96 = 0;
      unint64_t v94 = (uint64_t **)*v94;
      if (!v94) {
        goto LABEL_136;
      }
    }
  }
  while (1)
  {
    unint64_t v97 = (unint64_t)v94[1];
    if (v97 == v90) {
      break;
    }
    if (v97 >= *(void *)&v87) {
      v97 %= *(void *)&v87;
    }
    if (v97 != v92) {
      goto LABEL_135;
    }
LABEL_125:
    v96 = 0;
    unint64_t v94 = (uint64_t **)*v94;
    if (!v94) {
      goto LABEL_136;
    }
  }
  if (v94[2] != (uint64_t *)v615) {
    goto LABEL_125;
  }
LABEL_608:
  v96 = v94[3];
LABEL_136:
  v536 = [v96 mpsndarray];

  if (!InputState)
  {
    v484 = 0;
    goto LABEL_181;
  }
  int v99 = (int8x8_t *)*((void *)v573 + 2);
  *(void *)&long long v615 = InputState;
  unint64_t v100 = mlir::Value::getParentRegion((mlir::Value *)&v615);
  int8x8_t v101 = v99[12];
  if (!*(void *)&v101) {
    goto LABEL_179;
  }
  unint64_t v102 = *((void *)v100 + 2);
  unint64_t v103 = 0x9DDFEA08EB382D69 * (((8 * v102) + 8) ^ HIDWORD(v102));
  unint64_t v104 = 0x9DDFEA08EB382D69 * (HIDWORD(v102) ^ (v103 >> 47) ^ v103);
  unint64_t v105 = 0x9DDFEA08EB382D69 * (v104 ^ (v104 >> 47));
  uint8x8_t v106 = (uint8x8_t)vcnt_s8(v101);
  v106.i16[0] = vaddlv_u8(v106);
  if (v106.u32[0] > 1uLL)
  {
    unint64_t v107 = 0x9DDFEA08EB382D69 * (v104 ^ (v104 >> 47));
    if (v105 >= *(void *)&v101) {
      unint64_t v107 = v105 % *(void *)&v101;
    }
  }
  else
  {
    unint64_t v107 = v105 & (*(void *)&v101 - 1);
  }
  size_t v108 = *(void **)(*(void *)&v99[11] + 8 * v107);
  if (!v108) {
    goto LABEL_179;
  }
  BOOL v109 = (void *)*v108;
  if (!v109) {
    goto LABEL_179;
  }
  if (v106.u32[0] < 2uLL)
  {
    uint64_t v110 = *(void *)&v101 - 1;
    while (1)
    {
      uint64_t v112 = v109[1];
      if (v112 == v105)
      {
        if (v109[2] == v102) {
          goto LABEL_159;
        }
      }
      else if ((v112 & v110) != v107)
      {
        goto LABEL_179;
      }
      BOOL v109 = (void *)*v109;
      if (!v109) {
        goto LABEL_179;
      }
    }
  }
  while (1)
  {
    unint64_t v111 = v109[1];
    if (v111 == v105) {
      break;
    }
    if (v111 >= *(void *)&v101) {
      v111 %= *(void *)&v101;
    }
    if (v111 != v107) {
      goto LABEL_179;
    }
LABEL_148:
    BOOL v109 = (void *)*v109;
    if (!v109) {
      goto LABEL_179;
    }
  }
  if (v109[2] != v102) {
    goto LABEL_148;
  }
LABEL_159:
  int8x8_t v113 = (int8x8_t)v109[4];
  if (!*(void *)&v113) {
    goto LABEL_179;
  }
  unint64_t v114 = 0x9DDFEA08EB382D69 * (((8 * v615) + 8) ^ DWORD1(v615));
  unint64_t v115 = 0x9DDFEA08EB382D69 * (DWORD1(v615) ^ (v114 >> 47) ^ v114);
  unint64_t v116 = 0x9DDFEA08EB382D69 * (v115 ^ (v115 >> 47));
  uint8x8_t v117 = (uint8x8_t)vcnt_s8(v113);
  v117.i16[0] = vaddlv_u8(v117);
  if (v117.u32[0] > 1uLL)
  {
    unint64_t v118 = v116;
    if (v116 >= *(void *)&v113) {
      unint64_t v118 = v116 % *(void *)&v113;
    }
  }
  else
  {
    unint64_t v118 = v116 & (*(void *)&v113 - 1);
  }
  unint64_t v119 = *(uint64_t ****)(v109[3] + 8 * v118);
  if (!v119 || (int8x16_t v120 = *v119) == 0)
  {
LABEL_179:
    int8x16_t v122 = 0;
    goto LABEL_180;
  }
  if (v117.u32[0] < 2uLL)
  {
    uint64_t v121 = *(void *)&v113 - 1;
    while (1)
    {
      int32x4_t v124 = v120[1];
      if (v124 == (uint64_t *)v116)
      {
        if (v120[2] == (uint64_t *)v615) {
          goto LABEL_609;
        }
      }
      else if (((unint64_t)v124 & v121) != v118)
      {
        goto LABEL_179;
      }
      int8x16_t v122 = 0;
      int8x16_t v120 = (uint64_t **)*v120;
      if (!v120) {
        goto LABEL_180;
      }
    }
  }
  while (1)
  {
    unint64_t v123 = (unint64_t)v120[1];
    if (v123 == v116) {
      break;
    }
    if (v123 >= *(void *)&v113) {
      v123 %= *(void *)&v113;
    }
    if (v123 != v118) {
      goto LABEL_179;
    }
LABEL_169:
    int8x16_t v122 = 0;
    int8x16_t v120 = (uint64_t **)*v120;
    if (!v120) {
      goto LABEL_180;
    }
  }
  if (v120[2] != (uint64_t *)v615) {
    goto LABEL_169;
  }
LABEL_609:
  int8x16_t v122 = v120[3];
LABEL_180:
  v484 = [v122 mpsndarray];

LABEL_181:
  if (!OutputCellFwd)
  {
    id v473 = 0;
    goto LABEL_226;
  }
  int8x8_t v125 = (int8x8_t *)*((void *)v573 + 2);
  *(void *)&long long v615 = OutputCellFwd;
  unint64_t v126 = mlir::Value::getParentRegion((mlir::Value *)&v615);
  int8x8_t v127 = v125[12];
  if (!*(void *)&v127) {
    goto LABEL_224;
  }
  unint64_t v128 = *((void *)v126 + 2);
  unint64_t v129 = 0x9DDFEA08EB382D69 * (((8 * v128) + 8) ^ HIDWORD(v128));
  unint64_t v130 = 0x9DDFEA08EB382D69 * (HIDWORD(v128) ^ (v129 >> 47) ^ v129);
  unint64_t v131 = 0x9DDFEA08EB382D69 * (v130 ^ (v130 >> 47));
  uint8x8_t v132 = (uint8x8_t)vcnt_s8(v127);
  v132.i16[0] = vaddlv_u8(v132);
  if (v132.u32[0] > 1uLL)
  {
    unint64_t v133 = 0x9DDFEA08EB382D69 * (v130 ^ (v130 >> 47));
    if (v131 >= *(void *)&v127) {
      unint64_t v133 = v131 % *(void *)&v127;
    }
  }
  else
  {
    unint64_t v133 = v131 & (*(void *)&v127 - 1);
  }
  int32x4_t v134 = *(void **)(*(void *)&v125[11] + 8 * v133);
  if (!v134) {
    goto LABEL_224;
  }
  int32x4_t v135 = (void *)*v134;
  if (!v135) {
    goto LABEL_224;
  }
  if (v132.u32[0] < 2uLL)
  {
    uint64_t v136 = *(void *)&v127 - 1;
    while (1)
    {
      uint64_t v138 = v135[1];
      if (v138 == v131)
      {
        if (v135[2] == v128) {
          goto LABEL_204;
        }
      }
      else if ((v138 & v136) != v133)
      {
        goto LABEL_224;
      }
      int32x4_t v135 = (void *)*v135;
      if (!v135) {
        goto LABEL_224;
      }
    }
  }
  while (1)
  {
    unint64_t v137 = v135[1];
    if (v137 == v131) {
      break;
    }
    if (v137 >= *(void *)&v127) {
      v137 %= *(void *)&v127;
    }
    if (v137 != v133) {
      goto LABEL_224;
    }
LABEL_193:
    int32x4_t v135 = (void *)*v135;
    if (!v135) {
      goto LABEL_224;
    }
  }
  if (v135[2] != v128) {
    goto LABEL_193;
  }
LABEL_204:
  int8x8_t v139 = (int8x8_t)v135[4];
  if (!*(void *)&v139) {
    goto LABEL_224;
  }
  unint64_t v140 = 0x9DDFEA08EB382D69 * (((8 * v615) + 8) ^ DWORD1(v615));
  unint64_t v141 = 0x9DDFEA08EB382D69 * (DWORD1(v615) ^ (v140 >> 47) ^ v140);
  unint64_t v142 = 0x9DDFEA08EB382D69 * (v141 ^ (v141 >> 47));
  uint8x8_t v143 = (uint8x8_t)vcnt_s8(v139);
  v143.i16[0] = vaddlv_u8(v143);
  if (v143.u32[0] > 1uLL)
  {
    unint64_t v144 = v142;
    if (v142 >= *(void *)&v139) {
      unint64_t v144 = v142 % *(void *)&v139;
    }
  }
  else
  {
    unint64_t v144 = v142 & (*(void *)&v139 - 1);
  }
  uint64_t v145 = *(uint64_t ****)(v135[3] + 8 * v144);
  if (!v145 || (v146 = *v145) == 0)
  {
LABEL_224:
    unint64_t v148 = 0;
    goto LABEL_225;
  }
  if (v143.u32[0] < 2uLL)
  {
    uint64_t v147 = *(void *)&v139 - 1;
    while (1)
    {
      v150 = v146[1];
      if (v150 == (uint64_t *)v142)
      {
        if (v146[2] == (uint64_t *)v615) {
          goto LABEL_610;
        }
      }
      else if (((unint64_t)v150 & v147) != v144)
      {
        goto LABEL_224;
      }
      unint64_t v148 = 0;
      v146 = (uint64_t **)*v146;
      if (!v146) {
        goto LABEL_225;
      }
    }
  }
  while (1)
  {
    unint64_t v149 = (unint64_t)v146[1];
    if (v149 == v142) {
      break;
    }
    if (v149 >= *(void *)&v139) {
      v149 %= *(void *)&v139;
    }
    if (v149 != v144) {
      goto LABEL_224;
    }
LABEL_214:
    unint64_t v148 = 0;
    v146 = (uint64_t **)*v146;
    if (!v146) {
      goto LABEL_225;
    }
  }
  if (v146[2] != (uint64_t *)v615) {
    goto LABEL_214;
  }
LABEL_610:
  unint64_t v148 = v146[3];
LABEL_225:
  id v473 = [v148 mpsndarray];

LABEL_226:
  if (!InputCell)
  {
    id v476 = 0;
    goto LABEL_271;
  }
  size_t v151 = (int8x8_t *)*((void *)v573 + 2);
  *(void *)&long long v615 = InputCell;
  BOOL v152 = mlir::Value::getParentRegion((mlir::Value *)&v615);
  int8x8_t v153 = v151[12];
  if (!*(void *)&v153) {
    goto LABEL_269;
  }
  unint64_t v154 = *((void *)v152 + 2);
  unint64_t v155 = 0x9DDFEA08EB382D69 * (((8 * v154) + 8) ^ HIDWORD(v154));
  unint64_t v156 = 0x9DDFEA08EB382D69 * (HIDWORD(v154) ^ (v155 >> 47) ^ v155);
  unint64_t v157 = 0x9DDFEA08EB382D69 * (v156 ^ (v156 >> 47));
  uint8x8_t v158 = (uint8x8_t)vcnt_s8(v153);
  v158.i16[0] = vaddlv_u8(v158);
  if (v158.u32[0] > 1uLL)
  {
    unint64_t v159 = 0x9DDFEA08EB382D69 * (v156 ^ (v156 >> 47));
    if (v157 >= *(void *)&v153) {
      unint64_t v159 = v157 % *(void *)&v153;
    }
  }
  else
  {
    unint64_t v159 = v157 & (*(void *)&v153 - 1);
  }
  v160 = *(void **)(*(void *)&v151[11] + 8 * v159);
  if (!v160) {
    goto LABEL_269;
  }
  v161 = (void *)*v160;
  if (!v161) {
    goto LABEL_269;
  }
  if (v158.u32[0] < 2uLL)
  {
    uint64_t v162 = *(void *)&v153 - 1;
    while (1)
    {
      uint64_t v164 = v161[1];
      if (v164 == v157)
      {
        if (v161[2] == v154) {
          goto LABEL_249;
        }
      }
      else if ((v164 & v162) != v159)
      {
        goto LABEL_269;
      }
      v161 = (void *)*v161;
      if (!v161) {
        goto LABEL_269;
      }
    }
  }
  while (1)
  {
    unint64_t v163 = v161[1];
    if (v163 == v157) {
      break;
    }
    if (v163 >= *(void *)&v153) {
      v163 %= *(void *)&v153;
    }
    if (v163 != v159) {
      goto LABEL_269;
    }
LABEL_238:
    v161 = (void *)*v161;
    if (!v161) {
      goto LABEL_269;
    }
  }
  if (v161[2] != v154) {
    goto LABEL_238;
  }
LABEL_249:
  int8x8_t v165 = (int8x8_t)v161[4];
  if (!*(void *)&v165) {
    goto LABEL_269;
  }
  unint64_t v166 = 0x9DDFEA08EB382D69 * (((8 * v615) + 8) ^ DWORD1(v615));
  unint64_t v167 = 0x9DDFEA08EB382D69 * (DWORD1(v615) ^ (v166 >> 47) ^ v166);
  unint64_t v168 = 0x9DDFEA08EB382D69 * (v167 ^ (v167 >> 47));
  uint8x8_t v169 = (uint8x8_t)vcnt_s8(v165);
  v169.i16[0] = vaddlv_u8(v169);
  if (v169.u32[0] > 1uLL)
  {
    unint64_t v170 = v168;
    if (v168 >= *(void *)&v165) {
      unint64_t v170 = v168 % *(void *)&v165;
    }
  }
  else
  {
    unint64_t v170 = v168 & (*(void *)&v165 - 1);
  }
  v171 = *(uint64_t ****)(v161[3] + 8 * v170);
  if (!v171 || (char v172 = *v171) == 0)
  {
LABEL_269:
    BOOL v174 = 0;
    goto LABEL_270;
  }
  if (v169.u32[0] < 2uLL)
  {
    uint64_t v173 = *(void *)&v165 - 1;
    while (1)
    {
      v176 = v172[1];
      if (v176 == (uint64_t *)v168)
      {
        if (v172[2] == (uint64_t *)v615) {
          goto LABEL_611;
        }
      }
      else if (((unint64_t)v176 & v173) != v170)
      {
        goto LABEL_269;
      }
      BOOL v174 = 0;
      char v172 = (uint64_t **)*v172;
      if (!v172) {
        goto LABEL_270;
      }
    }
  }
  while (1)
  {
    unint64_t v175 = (unint64_t)v172[1];
    if (v175 == v168) {
      break;
    }
    if (v175 >= *(void *)&v165) {
      v175 %= *(void *)&v165;
    }
    if (v175 != v170) {
      goto LABEL_269;
    }
LABEL_259:
    BOOL v174 = 0;
    char v172 = (uint64_t **)*v172;
    if (!v172) {
      goto LABEL_270;
    }
  }
  if (v172[2] != (uint64_t *)v615) {
    goto LABEL_259;
  }
LABEL_611:
  BOOL v174 = v172[3];
LABEL_270:
  id v476 = [v174 mpsndarray];

LABEL_271:
  if (!Mask)
  {
    id v474 = 0;
    goto LABEL_316;
  }
  uint64_t v177 = (int8x8_t *)*((void *)v573 + 2);
  *(void *)&long long v615 = Mask;
  unint64_t v178 = mlir::Value::getParentRegion((mlir::Value *)&v615);
  int8x8_t v179 = v177[12];
  if (!*(void *)&v179) {
    goto LABEL_314;
  }
  unint64_t v180 = *((void *)v178 + 2);
  unint64_t v181 = 0x9DDFEA08EB382D69 * (((8 * v180) + 8) ^ HIDWORD(v180));
  unint64_t v182 = 0x9DDFEA08EB382D69 * (HIDWORD(v180) ^ (v181 >> 47) ^ v181);
  unint64_t v183 = 0x9DDFEA08EB382D69 * (v182 ^ (v182 >> 47));
  uint8x8_t v184 = (uint8x8_t)vcnt_s8(v179);
  v184.i16[0] = vaddlv_u8(v184);
  if (v184.u32[0] > 1uLL)
  {
    unint64_t v185 = 0x9DDFEA08EB382D69 * (v182 ^ (v182 >> 47));
    if (v183 >= *(void *)&v179) {
      unint64_t v185 = v183 % *(void *)&v179;
    }
  }
  else
  {
    unint64_t v185 = v183 & (*(void *)&v179 - 1);
  }
  long long v186 = *(void **)(*(void *)&v177[11] + 8 * v185);
  if (!v186) {
    goto LABEL_314;
  }
  long long v187 = (void *)*v186;
  if (!v187) {
    goto LABEL_314;
  }
  if (v184.u32[0] < 2uLL)
  {
    uint64_t v188 = *(void *)&v179 - 1;
    while (1)
    {
      uint64_t v190 = v187[1];
      if (v190 == v183)
      {
        if (v187[2] == v180) {
          goto LABEL_294;
        }
      }
      else if ((v190 & v188) != v185)
      {
        goto LABEL_314;
      }
      long long v187 = (void *)*v187;
      if (!v187) {
        goto LABEL_314;
      }
    }
  }
  while (1)
  {
    unint64_t v189 = v187[1];
    if (v189 == v183) {
      break;
    }
    if (v189 >= *(void *)&v179) {
      v189 %= *(void *)&v179;
    }
    if (v189 != v185) {
      goto LABEL_314;
    }
LABEL_283:
    long long v187 = (void *)*v187;
    if (!v187) {
      goto LABEL_314;
    }
  }
  if (v187[2] != v180) {
    goto LABEL_283;
  }
LABEL_294:
  int8x8_t v191 = (int8x8_t)v187[4];
  if (!*(void *)&v191) {
    goto LABEL_314;
  }
  unint64_t v192 = 0x9DDFEA08EB382D69 * (((8 * v615) + 8) ^ DWORD1(v615));
  unint64_t v193 = 0x9DDFEA08EB382D69 * (DWORD1(v615) ^ (v192 >> 47) ^ v192);
  unint64_t v194 = 0x9DDFEA08EB382D69 * (v193 ^ (v193 >> 47));
  uint8x8_t v195 = (uint8x8_t)vcnt_s8(v191);
  v195.i16[0] = vaddlv_u8(v195);
  if (v195.u32[0] > 1uLL)
  {
    unint64_t v196 = v194;
    if (v194 >= *(void *)&v191) {
      unint64_t v196 = v194 % *(void *)&v191;
    }
  }
  else
  {
    unint64_t v196 = v194 & (*(void *)&v191 - 1);
  }
  int8x16_t v197 = *(uint64_t ****)(v187[3] + 8 * v196);
  if (!v197 || (int32x4_t v198 = *v197) == 0)
  {
LABEL_314:
    BOOL v200 = 0;
    goto LABEL_315;
  }
  if (v195.u32[0] < 2uLL)
  {
    uint64_t v199 = *(void *)&v191 - 1;
    while (1)
    {
      int32x4_t v202 = v198[1];
      if (v202 == (uint64_t *)v194)
      {
        if (v198[2] == (uint64_t *)v615) {
          goto LABEL_612;
        }
      }
      else if (((unint64_t)v202 & v199) != v196)
      {
        goto LABEL_314;
      }
      BOOL v200 = 0;
      int32x4_t v198 = (uint64_t **)*v198;
      if (!v198) {
        goto LABEL_315;
      }
    }
  }
  while (1)
  {
    unint64_t v201 = (unint64_t)v198[1];
    if (v201 == v194) {
      break;
    }
    if (v201 >= *(void *)&v191) {
      v201 %= *(void *)&v191;
    }
    if (v201 != v196) {
      goto LABEL_314;
    }
LABEL_304:
    BOOL v200 = 0;
    int32x4_t v198 = (uint64_t **)*v198;
    if (!v198) {
      goto LABEL_315;
    }
  }
  if (v198[2] != (uint64_t *)v615) {
    goto LABEL_304;
  }
LABEL_612:
  BOOL v200 = v198[3];
LABEL_315:
  id v474 = [v200 mpsndarray];

LABEL_316:
  if ([(NSArray *)v492 count] <= 2) {
    __assert_rtn("encodeNDArrayOp", "GPURNNOps.mm", 3520, "resultsArray.count >= 3");
  }
  v470 = [(NSArray *)v492 objectAtIndexedSubscript:0];
  v490 = [v470 mpsndarray];
  if ((!v487 || !v490) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  v471 = [(NSArray *)v492 objectAtIndexedSubscript:1];
  v485 = [v471 mpsndarray];
  if (!v485 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  v472 = [(NSArray *)v492 objectAtIndexedSubscript:2];
  v486 = [v472 mpsndarray];
  if (!v486 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if ([(NSArray *)v492 count] == 4 && ResetAfter)
  {
    uint32x4_t v204 = [(NSArray *)v492 objectAtIndexedSubscript:3];
    uint64_t v205 = [v204 mpsndarray];
    if (!v205 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
  }
  else
  {
    uint64_t v205 = 0;
  }
  int8x16_t v206 = [v490 descriptor];
  int8x16_t v207 = v206;
  v480 = (void *)v205;
  if (v206) {
    [v206 getShapeVector];
  }
  else {
    v585 = 0;
  }

  mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v586);
  mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v586);
  mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v586);
  v491 = v475;
  id v561 = v487;
  id v559 = v476;
  if (!*((void *)v573 + 15))
  {
    long long v615 = 0uLL;
    uint64_t v616 = 0;
    int32x4_t v209 = *v585;
    int32x4_t v208 = v585[1];
    int64_t v210 = v208 - (unsigned char *)*v585;
    if (v208 != *v585)
    {
      if (v210 < 0) {
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
      int32x4_t v211 = operator new(v208 - (unsigned char *)*v585);
      int32x4_t v212 = (char *)&v211[v210 >> 3];
      *(void *)&long long v615 = v211;
      uint64_t v616 = (uint64_t)v212;
      memcpy(v211, v209, v210);
      *((void *)&v615 + 1) = v212;
      int64_t v213 = 8 * (v210 >> 3);
      if ((unint64_t)(v212 - (char *)v211) > 0x17)
      {
        v211[2] = 1;
        long long v611 = 0uLL;
        uint64_t v612 = 0;
        if ((v213 & 0x8000000000000000) == 0)
        {
          uint64_t v214 = (uint64_t *)operator new(v212 - (char *)v211);
          *(void *)&long long v611 = v214;
          uint64_t v612 = (uint64_t)&v214[v213 >> 3];
          memcpy(v214, v211, v213);
          *((void *)&v611 + 1) = &v214[v213 >> 3];
          *v214 /= 3;
          int8x16_t v215 = operator new(v213);
          memcpy(v215, v214, v213);
          *v215 *= 2;
          operator new();
        }
        std::vector<long>::__throw_length_error[abi:ne180100]();
      }
    }
    __assert_rtn("_getGRUGradKernelDAGObjects", "GPURNNOps.mm", 4095, "shape3.size() >= 3");
  }
  if (!*((unsigned char *)v573 + 40) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }

  uint64_t v543 = *((void *)*v585 + 2);
  int8x16_t v216 = v485;
  int8x16_t v217 = v216;
  if (v485 && *((unsigned char *)v216 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v216 setReadCount:[(GPU::EncodeDescriptor *)v216 readCount] + 4];
  }
  v488 = v217;

  int8x16_t v218 = v490;
  uint64_t v219 = v218;
  if (v218 && *((unsigned char *)v218 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v218 setReadCount:[(GPU::EncodeDescriptor *)v218 readCount] + 5];
  }
  v558 = v219;

  int v220 = v486;
  int v221 = v220;
  if (v486 && *((unsigned char *)v220 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v220 setReadCount:[(GPU::EncodeDescriptor *)v220 readCount] + 1];
  }
  v483 = v221;

  v222 = (GPU::EncodeDescriptor *)v473;
  v223 = v222;
  if (v222 && *((unsigned char *)v222 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v222 setReadCount:[(GPU::EncodeDescriptor *)v222 readCount] + 1];
  }
  v534 = v223;

  uint64_t v224 = (GPU::EncodeDescriptor *)v561;
  uint64_t v225 = v224;
  if (v224 && *((unsigned char *)v224 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v224 setReadCount:[(GPU::EncodeDescriptor *)v224 readCount] + 1];
  }
  v545 = v225;

  unint64_t v505 = v543 - 1;
  id v226 = v559;
  v227 = v226;
  if (v226 && v543 != 1 && *((unsigned char *)v226 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v226, "setReadCount:", objc_msgSend(v226, "readCount") + v505);
  }
  v463 = v227;

  id v228 = v474;
  uint64_t v229 = v228;
  if (v228 && *((unsigned char *)v228 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v228, "setReadCount:", objc_msgSend(v228, "readCount") - 1);
  }
  v462 = v229;

  uint64_t v230 = 100 * v543;
  uint64_t v231 = 100 * v543 + 4;
  uint64_t v232 = (id *)v498;
  GPU::getSlice((id *)v498, v558, (MPSNDArray *)2, v231, 0, 1);
  v533 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)v498, v491, (MPSNDArray *)2, v231, 0, 1);
  v489 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
  v526 = GPU::getSlice((id *)v498, v484, (MPSNDArray *)2, v231, 0, 1);
  unsigned int v233 = *(_DWORD *)((char *)v533
                   + 4 * (*(_OWORD *)((unsigned char *)v533 + (int)*MEMORY[0x1E4F359B0]) & 0xF)
                   + (int)*MEMORY[0x1E4F359D8]);
  int Layout = mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v586);
  unint64_t v235 = v233 / 3uLL;
  unint64_t v496 = v235;
  uint64_t v236 = 2 * v235;
  if (Layout == 1)
  {
    uint64_t v237 = 0;
    int v527 = 1;
    uint64_t v239 = 2 * v235;
    unint64_t v238 = v235;
    uint64_t v240 = v235;
  }
  else if (Layout == 2)
  {
    int v527 = 0;
    uint64_t v237 = 0;
    unint64_t v238 = v233 / 3uLL;
    uint64_t v239 = v238;
    uint64_t v240 = 2 * v235;
  }
  else
  {
    uint64_t v240 = 0;
    int v527 = 1;
    uint64_t v239 = 2 * v235;
    unint64_t v238 = v235;
    uint64_t v237 = v235;
  }
  GPU::getSlice((id *)v498, v533, 0, v230, v240, v238);
  v550 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)v498, v533, 0, v230, v237, v238);
  v549 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)v498, v533, 0, v230, v239, v238);
  v564 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice((id *)v498, v533, 0, v230, 0, v236);
  v540 = (char *)objc_claimAutoreleasedReturnValue();
  v469 = GPU::getSlice((id *)v498, v558, 0, v230, v240, v496);
  v468 = GPU::getSlice((id *)v498, v558, 0, v230, v237, v496);
  v467 = GPU::getSlice((id *)v498, v558, 0, v230, v239, v496);
  v466 = GPU::getSlice((id *)v498, v558, 0, v230, 0, v236);
  uint64_t v241 = 10 * v543;
  if (v527)
  {
    GPU::getSlice((id *)v498, v489, (MPSNDArray *)1, 10 * v543, 0, v236);
    id v502 = (id)objc_claimAutoreleasedReturnValue();

    uint64_t v232 = (id *)v498;
  }
  else
  {
    id v502 = 0;
  }
  v500 = GPU::getSlice(v232, v489, (MPSNDArray *)1, v241, v237, v496);
  v501 = GPU::getSlice(v232, v489, (MPSNDArray *)1, v241, v240, v496);
  v525 = GPU::getSlice(v232, v489, (MPSNDArray *)1, v241, v239, v496);
  if (v527)
  {
    GPU::getSlice(v232, v488, (MPSNDArray *)1, v241, 0, v236);
    id v479 = (id)objc_claimAutoreleasedReturnValue();

    uint64_t v232 = (id *)v498;
  }
  else
  {
    id v479 = 0;
  }
  v478 = GPU::getSlice(v232, v488, (MPSNDArray *)1, v241, v237, v496);
  v477 = GPU::getSlice(v232, v488, (MPSNDArray *)1, v241, v240, v496);
  v481 = GPU::getSlice(v232, v488, (MPSNDArray *)1, v241, v239, v496);
  GPU::getSlice(v232, v536, (MPSNDArray *)2, 4, 0, 1);
  v548 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(v232, v548, 0, v230, v240, v496);
  v563 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(v232, v548, 0, v230, v237, v496);
  v565 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(v232, v548, 0, v230, v239, v496);
  v560 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
  if (ResetAfter)
  {
    GPU::getSlice(v232, v548, 0, v230, 3 * v496, v496);
    v539 = (char *)(id)objc_claimAutoreleasedReturnValue();

    uint64_t v232 = (id *)v498;
  }
  else
  {
    v539 = 0;
  }
  GPU::getSlice(v232, v545, (MPSNDArray *)2, v241, v505, 1);
  std::string __p = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(v232, v534, (MPSNDArray *)2, v241, v505, 1);
  v535 = (char *)objc_claimAutoreleasedReturnValue();
  v546 = GPU::getSlice(v232, v483, (MPSNDArray *)2, v230, 0, 1);
  GPU::getSlice(v232, v545, (MPSNDArray *)2, v241, v505, 1);
  v567 = (char *)objc_claimAutoreleasedReturnValue();
  long long v615 = xmmword_181134E80;
  uint64_t v616 = 1;
  v242 = (long long *)((char *)v545 + (int)*MEMORY[0x1E4F359D8]);
  v243 = (char *)v545 + (int)*MEMORY[0x1E4F359B0];
  long long v244 = *v242;
  long long v245 = v242[1];
  long long v246 = v242[2];
  long long v247 = v242[3];
  LOBYTE(v242) = *(_OWORD *)v243;
  v577[2] = v246;
  v577[3] = v247;
  v577[0] = v244;
  v577[1] = v245;
  *(void *)&long long v615 = *((unsigned int *)v577 + (v242 & 0xF));
  uint64_t v248 = v243[1] & 0xF;
  v576[2] = v246;
  v576[3] = v247;
  v576[0] = v244;
  v576[1] = v245;
  *((void *)&v615 + 1) = *((unsigned int *)v576 + v248);
  uint64_t v249 = v243[2] & 0xF;
  v575[2] = v246;
  v575[3] = v247;
  v575[0] = v244;
  v575[1] = v245;
  uint64_t v616 = *((unsigned int *)v575 + v249);
  *(void *)&long long v615 = v496;
  v482 = [MEMORY[0x1E4F35720] descriptorWithDataType:*(unsigned int *)((char *)v545 + (int)*MEMORY[0x1E4F359A0]) dimensionCount:3 dimensionSizes:&v615];
  [v482 setPreferPackedRows:1];
  uint64_t v616 = 1;
  v464 = [MEMORY[0x1E4F35720] descriptorWithDataType:*(unsigned int *)((char *)v545 + (int)*MEMORY[0x1E4F359A0]) dimensionCount:3 dimensionSizes:&v615];
  [v464 setPreferPackedRows:1];
  id v250 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v572 descriptor:v464];
  uint64_t v251 = v250;
  if (v250 && v241 != -10 && *((unsigned char *)v250 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v250, "setReadCount:", objc_msgSend(v250, "readCount") + v241 + 10);
  }
  v547 = v251;

  v252 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v572 descriptor:v482];
  *(void *)&v252[*MEMORY[0x1E4F35A20]] = 50;
  v532 = v252;

  GPU::getSlice((id *)v498, v532, (MPSNDArray *)2, v241, v505, 1);
  v562 = (char *)objc_claimAutoreleasedReturnValue();
  if ((v505 & 0x8000000000000000) == 0)
  {
    uint64_t v253 = 0;
    v537 = (GPU::EncodeDescriptor *)((char *)v558 + 2);
    v522 = (GPU::EncodeDescriptor *)(__p + 2);
    v517 = (char *)v545 + 2;
    v529 = (GPU::EncodeDescriptor *)((char *)v548 + 2);
    v493 = (char *)v534 + 2;
    v503 = v535 + 2;
    int v519 = v543 - 2;
    int v570 = v543 - 1;
    while (1)
    {
      v254 = v558;
      uint64_t v255 = v254;
      uint64_t v256 = (int)*MEMORY[0x1E4F359E0];
      uint64_t v257 = (int)*MEMORY[0x1E4F359B0];
      if (v558) {
        int v258 = *(_DWORD *)((char *)v254 + 4 * (*((unsigned char *)v537 + v257) & 0xF) + v256);
      }
      else {
        int v258 = 0;
      }
      *(_DWORD *)((char *)v533 + 4 * *((unsigned __int8 *)v533 + v257 + 2) + v256) = v570 + v253 + v258;

      v551 = v545;
      if (__p)
      {
        uint64_t v259 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v260 = (int)*MEMORY[0x1E4F359B0];
        int v261 = (int)v545;
        if (v545) {
          int v261 = *(_DWORD *)((char *)v551 + 4 * (v517[v260] & 0xF) + v259);
        }
        *(_DWORD *)&__p[4 * *((unsigned __int8 *)v522 + v260) + v259] = v570 + v253 + v261;
      }

      if (!v253)
      {
        v262 = v551;
        if (v567)
        {
          uint64_t v263 = (int)*MEMORY[0x1E4F359E0];
          uint64_t v264 = (int)*MEMORY[0x1E4F359B0];
          int v265 = (int)v545;
          if (v545) {
            int v265 = *(_DWORD *)((char *)v262 + 4 * (v517[v264] & 0xF) + v263);
          }
          *(_DWORD *)&v567[4 * v567[v264 + 2] + v263] = v265 + v505;
        }
      }
      v266 = v255;
      v267 = v266;
      if (v550)
      {
        uint64_t v268 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v269 = (int)*MEMORY[0x1E4F359B0];
        int v270 = (int)v558;
        if (v558) {
          int v270 = *(_DWORD *)((char *)v266 + 4 * (*((unsigned char *)v537 + v269) & 0xF) + v268);
        }
        *(_DWORD *)&v550[4 * v550[v269 + 2] + v268] = v570 + v253 + v270;
      }

      v271 = v267;
      v272 = v271;
      if (v549)
      {
        uint64_t v273 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v274 = (int)*MEMORY[0x1E4F359B0];
        int v275 = (int)v558;
        if (v558) {
          int v275 = *(_DWORD *)((char *)v271 + 4 * (*((unsigned char *)v537 + v274) & 0xF) + v273);
        }
        *(_DWORD *)&v549[4 * v549[v274 + 2] + v273] = v570 + v253 + v275;
      }

      v276 = v272;
      v277 = v276;
      if (v564)
      {
        uint64_t v278 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v279 = (int)*MEMORY[0x1E4F359B0];
        int v280 = (int)v558;
        if (v558) {
          int v280 = *(_DWORD *)((char *)v276 + 4 * (*((unsigned char *)v537 + v279) & 0xF) + v278);
        }
        *(_DWORD *)&v564[4 * v564[v279 + 2] + v278] = v570 + v253 + v280;
      }

      v281 = v277;
      if (v540)
      {
        uint64_t v282 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v283 = (int)*MEMORY[0x1E4F359B0];
        int v284 = (int)v558;
        if (v558) {
          int v284 = *(_DWORD *)&v281[4 * (*((unsigned char *)v537 + v283) & 0xF) + v282];
        }
        *(_DWORD *)&v540[4 * v540[v283 + 2] + v282] = v570 + v253 + v284;
      }

      v285 = v548;
      v286 = v285;
      if (v563)
      {
        uint64_t v287 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v288 = (int)*MEMORY[0x1E4F359B0];
        int v289 = (int)v548;
        if (v548) {
          int v289 = *(_DWORD *)((char *)v285 + 4 * (*((unsigned char *)v529 + v288) & 0xF) + v287);
        }
        *(_DWORD *)&v563[4 * v563[v288 + 2] + v287] = v570 + v253 + v289;
      }

      v290 = v286;
      v291 = v290;
      if (v565)
      {
        uint64_t v292 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v293 = (int)*MEMORY[0x1E4F359B0];
        int v294 = (int)v548;
        if (v548) {
          int v294 = *(_DWORD *)((char *)v290 + 4 * (*((unsigned char *)v529 + v293) & 0xF) + v292);
        }
        *(_DWORD *)&v565[4 * v565[v293 + 2] + v292] = v570 + v253 + v294;
      }

      id v295 = v291;
      if (v560)
      {
        uint64_t v296 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v297 = (int)*MEMORY[0x1E4F359B0];
        int v298 = (int)v548;
        if (v548) {
          int v298 = *(_DWORD *)((char *)v295 + 4 * (*((unsigned char *)v529 + v297) & 0xF) + v296);
        }
        *(_DWORD *)((char *)v560 + 4 * *((unsigned __int8 *)v560 + v297 + 2) + v296) = v570 + v253 + v298;
      }

      v299 = v532;
      if (v562) {
        *(_DWORD *)&v562[4 * v562[*MEMORY[0x1E4F359B0] + 2] + *MEMORY[0x1E4F359E0]] = v570 + v253 + *(_DWORD *)((char *)v299 + 4 * (*((unsigned char *)v532 + *MEMORY[0x1E4F359B0] + 2) & 0xF) + *MEMORY[0x1E4F359E0]);
      }

      id v300 = v536;
      if (v539)
      {
        uint64_t v301 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v302 = (int)*MEMORY[0x1E4F359B0];
        int v303 = (int)v536;
        if (v536) {
          int v303 = *(_DWORD *)((char *)v300 + 4 * (*((unsigned char *)v536 + v302 + 2) & 0xF) + v301);
        }
        *(_DWORD *)&v539[4 * v539[v302 + 2] + v301] = v570 + v253 + v303;
      }

      v541 = v535;
      if (v543 + v253 == 1)
      {
        v556 = v526;
        v304 = v541;
      }
      else
      {
        v304 = v534;
        if (v535)
        {
          uint64_t v305 = (int)*MEMORY[0x1E4F359E0];
          uint64_t v306 = (int)*MEMORY[0x1E4F359B0];
          if (v534) {
            int v307 = *(_DWORD *)((char *)v304 + 4 * (v493[v306] & 0xF) + v305);
          }
          else {
            int v307 = 0;
          }
          *(_DWORD *)((char *)v541 + 4 * v503[v306] + v305) = v519 + v253 + v307;
          v556 = v541;
        }
        else
        {
          v556 = 0;
        }
      }

      v608[0] = v567;
      v608[1] = v560;
      v608[2] = v563;
      v308 = [MEMORY[0x1E4F1C978] arrayWithObjects:v608 count:3];
      if (ResetAfter)
      {
        v607[0] = v567;
        v607[1] = v560;
        v607[2] = v563;
        v607[3] = v565;
        v607[4] = v539;
        uint64_t v309 = [MEMORY[0x1E4F1C978] arrayWithObjects:v607 count:5];

        v308 = (void *)v309;
      }
      [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v308 resultState:0 destinationArray:v564 kernelDAGObject:*((void *)v573 + 15)];
      id v310 = v308;
      id v311 = v310;
      if (v556)
      {
        uint64_t v312 = objc_msgSend(v310, "arrayByAddingObject:");

        v313 = (void *)v312;
        uint64_t v314 = 1;
      }
      else
      {
        v313 = v310;
        uint64_t v314 = 2;
      }
      [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v313 resultState:0 destinationArray:v550 kernelDAGObject:*((void *)v573 + v314 + 15)];
      if (ResetAfter)
      {
        v605[0] = v564;
        v605[1] = v565;
        v315 = [MEMORY[0x1E4F1C978] arrayWithObjects:v605 count:2];
        [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v315 resultState:0 destinationArray:v562 kernelDAGObject:*((void *)v573 + 22)];
        v316 = v564;
        id v317 = v560;
      }
      else
      {
        v318 = (void *)*((void *)v573 + 25);
        v606[0] = v564;
        v606[1] = v525;
        v315 = [MEMORY[0x1E4F1C978] arrayWithObjects:v606 count:2];
        v319 = v318;
        v316 = v562;
        [v319 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v315 resultState:0 destinationArray:v562 kernelDAGObject:0];
        id v317 = v556;
      }

      v320 = v317;
      v321 = v316;
      if (v320)
      {
        v604[0] = v565;
        v322 = v321;
        v604[1] = v321;
        v323 = v320;
        v604[2] = v320;
        v324 = [MEMORY[0x1E4F1C978] arrayWithObjects:v604 count:3];
        uint64_t v325 = 3;
      }
      else
      {
        v323 = 0;
        v603[0] = v565;
        v322 = v321;
        v603[1] = v321;
        v324 = [MEMORY[0x1E4F1C978] arrayWithObjects:v603 count:2];
        uint64_t v325 = 4;
      }
      id v326 = v324;

      [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v326 resultState:0 destinationArray:v549 kernelDAGObject:*((void *)v573 + v325 + 15)];
      v327 = (void *)*((void *)v573 + 25);
      if (v527)
      {
        v602[0] = v540;
        v602[1] = v502;
        v328 = [MEMORY[0x1E4F1C978] arrayWithObjects:v602 count:2];
        [v327 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v328 resultState:0 destinationArray:v547 kernelDAGObject:0];
      }
      else
      {
        v601[0] = v550;
        v601[1] = v501;
        v329 = [MEMORY[0x1E4F1C978] arrayWithObjects:v601 count:2];
        [v327 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v329 resultState:0 destinationArray:v547 kernelDAGObject:0];

        BOOL v330 = (void *)*((void *)v573 + 25);
        v600[0] = v549;
        v600[1] = v500;
        v600[2] = v546;
        v328 = [MEMORY[0x1E4F1C978] arrayWithObjects:v600 count:3];
        [v330 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v328 resultState:0 destinationArray:v547 kernelDAGObject:*((void *)v573 + 24)];
      }

      if (v543 + v253 == 1)
      {
        uint64_t v335 = 5;
        if (!ResetAfter) {
          goto LABEL_461;
        }
      }
      else
      {
        v331 = v551;
        if (__p)
        {
          uint64_t v332 = (int)*MEMORY[0x1E4F359E0];
          uint64_t v333 = (int)*MEMORY[0x1E4F359B0];
          int v334 = (int)v545;
          if (v545) {
            int v334 = *(_DWORD *)((char *)v331 + 4 * (v517[v333] & 0xF) + v332);
          }
          *(_DWORD *)&__p[4 * *((unsigned __int8 *)v522 + v333) + v332] = v519 + v253 + v334;
        }

        uint64_t v335 = 6;
        if (!ResetAfter)
        {
LABEL_461:
          v598[0] = v547;
          v598[1] = v562;
          v598[2] = v567;
          v598[3] = v563;
          v598[4] = v565;
          v339 = [MEMORY[0x1E4F1C978] arrayWithObjects:v598 count:5];
          v340 = v339;
          if (v543 + v253 != 1)
          {
            uint64_t v341 = [v339 arrayByAddingObject:__p];

            v340 = (void *)v341;
          }
          [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v340 resultState:0 destinationArray:v546 kernelDAGObject:*((void *)v573 + v335 + 15)];

          v342 = (GPU::EncodeDescriptor *)v526;
          if (v543 + v253 != 1)
          {
            v343 = v534;
            if (v535)
            {
              uint64_t v344 = (int)*MEMORY[0x1E4F359E0];
              uint64_t v345 = (int)*MEMORY[0x1E4F359B0];
              int v346 = (int)v534;
              if (v534) {
                int v346 = *(_DWORD *)((char *)v343 + 4 * (v493[v345] & 0xF) + v344);
              }
              *(_DWORD *)((char *)v541 + 4 * v503[v345] + v344) = v519 + v253 + v346;
            }

            v342 = v541;
          }
          v347 = v342;
          v348 = v347;
          if (v347)
          {
            v597[0] = v347;
            v597[1] = v565;
            v349 = [MEMORY[0x1E4F1C978] arrayWithObjects:v597 count:2];
            [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v349 resultState:0 destinationArray:v562 kernelDAGObject:*((void *)v573 + 22)];

            v337 = v348;
          }
          else
          {
            [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:MEMORY[0x1E4F1CBF0] resultState:0 destinationArray:v562 kernelDAGObject:*((void *)v573 + 23)];
            v337 = 0;
          }
          goto LABEL_472;
        }
      }
      v599[0] = v547;
      v599[1] = v562;
      v599[2] = v567;
      v599[3] = v563;
      v599[4] = v525;
      v336 = [MEMORY[0x1E4F1C978] arrayWithObjects:v599 count:5];
      v337 = v336;
      if (v543 + v253 != 1)
      {
        uint64_t v338 = [v336 arrayByAddingObject:__p];

        v337 = (void *)v338;
      }
      [*((id *)v573 + 25) encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v337 resultState:0 destinationArray:v546 kernelDAGObject:*((void *)v573 + v335 + 15)];
LABEL_472:

      if (!v253)
      {
        v350 = v567;
        v351 = v350;
        if (v350 && v350[*MEMORY[0x1E4F359C0]]) {
          [v350 setReadCount:0];
        }
      }
      v352 = v546;

      --v253;
      v567 = v352;
      if (v543 + v253 <= 0) {
        goto LABEL_480;
      }
    }
  }
  v352 = v567;
LABEL_480:
  *((void *)&v611 + 1) = 1;
  uint64_t v612 = 1;
  *(void *)&long long v611 = v496;
  uint64_t v353 = v543;
  if (!v526) {
    uint64_t v353 = v543 - 1;
  }
  *((void *)&v611 + 1) = *(unsigned int *)((char *)v536
                                           + 4 * (*((unsigned char *)v536 + *MEMORY[0x1E4F359B0] + 1) & 0xF)
                                           + *MEMORY[0x1E4F359D8]);
  uint64_t v612 = v353;
  v530 = v469;
  v354 = v468;
  v355 = v467;
  v523 = v466;
  GPU::getSlice((id *)v498, v534, (MPSNDArray *)2, 10, 0, v505);
  id v557 = (id)objc_claimAutoreleasedReturnValue();
  if (v526)
  {
    v356 = [MEMORY[0x1E4F35720] descriptorWithDataType:*(unsigned int *)((char *)v536 + (int)*MEMORY[0x1E4F359A0]) dimensionCount:3 dimensionSizes:&v611];
    [v356 setPreferPackedRows:1];
    v538 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v572 descriptor:v356];

    [(GPU::EncodeDescriptor *)v538 setReadCount:3];
    v357 = GPU::getSlice((id *)v498, v538, (MPSNDArray *)2, 0, 0, 1);
    v596 = v526;
    v358 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v596 count:1];
    [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v358 resultState:0 destinationArray:v357 kernelDAGObject:0];

    v359 = GPU::getSlice((id *)v498, v538, (MPSNDArray *)2, 0, 1, v505);
    id v595 = v557;
    v360 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v595 count:1];
    [v566 encodeToMPSCommandEncoder:v569 commandBuffer:v572 sourceArrays:v360 resultState:0 destinationArray:v359 kernelDAGObject:0];

    id v361 = v357;
    v362 = v361;
    if (v361 && *((unsigned char *)v361 + (int)*MEMORY[0x1E4F359C0])) {
      [v361 setReadCount:0];
    }

    id v363 = v359;
    v364 = v363;
    if (v363 && *((unsigned char *)v363 + (int)*MEMORY[0x1E4F359C0])) {
      [v363 setReadCount:0];
    }

    v520 = v354;
    v521 = v530;
    v516 = v523;
    v518 = v355;
  }
  else
  {
    v521 = GPU::getSlice((id *)v498, v530, (MPSNDArray *)2, 0, 1, v505);

    v520 = GPU::getSlice((id *)v498, v354, (MPSNDArray *)2, 0, 1, v505);

    v518 = GPU::getSlice((id *)v498, v355, (MPSNDArray *)2, 0, 1, v505);

    v516 = GPU::getSlice((id *)v498, v523, (MPSNDArray *)2, 0, 1, v505);
    v356 = v523;
    v538 = (GPU::EncodeDescriptor *)v557;
  }

  v581[0] = MEMORY[0x1E4F143A8];
  v581[1] = 3221225472;
  v581[2] = ___ZN3GPU20GRUGradientOpHandler15encodeNDArrayOpEPNS_16EncodeDescriptorEP7NSArray_block_invoke;
  v581[3] = &unk_1E4FC1508;
  id v515 = v566;
  id v582 = v515;
  id v365 = v569;
  id v583 = v365;
  id v366 = v572;
  id v584 = v366;
  v571 = (void (**)(void, void, void, void))MEMORY[0x1852FE7D0](v581);
  v578[0] = MEMORY[0x1E4F143A8];
  v578[1] = 3221225472;
  v578[2] = ___ZN3GPU20GRUGradientOpHandler15encodeNDArrayOpEPNS_16EncodeDescriptorEP7NSArray_block_invoke_2;
  v578[3] = &unk_1E4FC1530;
  id v552 = v366;
  id v579 = v552;
  id v544 = v365;
  id v580 = v544;
  v542 = (void (**)(void, void, void, void))MEMORY[0x1852FE7D0](v578);
  v609[0] = v611;
  v609[1] = v612 * *((void *)&v611 + 1);
  v609[2] = 1;
  ((void (**)(void, GPU::EncodeDescriptor *, uint64_t, uint64_t *))v571)[2](v571, v538, 3, v609);
  id v367 = (id)objc_claimAutoreleasedReturnValue();
  v368 = v367;
  v568 = v367;
  if (v367 && *((unsigned char *)v367 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v367, "setReadCount:", objc_msgSend(v367, "readCount") + 10);
  }

  v594[0] = v611;
  v594[1] = v612 * *((void *)&v611 + 1);
  v594[2] = 1;
  v593[0] = 2 * v611;
  v593[1] = v612 * *((void *)&v611 + 1);
  v593[2] = 1;
  v369 = v571[2];
  if (v527)
  {
    v370 = v369(v571, v523, 3, v593);
    v371 = ((void (**)(void, void *, void, uint64_t))v542)[2](v542, v370, 0, 1);
    uint64_t v372 = (void *)*((void *)v573 + 25);
    v592[0] = v371;
    v592[1] = v568;
    v373 = [MEMORY[0x1E4F1C978] arrayWithObjects:v592 count:2];
    [v372 encodeToMPSCommandEncoder:v544 commandBuffer:v552 sourceArrays:v373 resultState:0 destinationArray:v479 kernelDAGObject:0];
  }
  else
  {
    v370 = v369(v571, v354, 3, v594);
    v371 = ((void (**)(void, void *, void, uint64_t))v542)[2](v542, v370, 0, 1);
    v374 = (void *)*((void *)v573 + 25);
    v591[0] = v371;
    v591[1] = v568;
    v375 = [MEMORY[0x1E4F1C978] arrayWithObjects:v591 count:2];
    [v374 encodeToMPSCommandEncoder:v544 commandBuffer:v552 sourceArrays:v375 resultState:0 destinationArray:v478 kernelDAGObject:0];

    v373 = ((void (**)(void, GPU::EncodeDescriptor *, uint64_t, void *))v571)[2](v571, v530, 3, v594);
    __int16 v376 = ((void (**)(void, void *, void, uint64_t))v542)[2](v542, v373, 0, 1);
    v377 = (void *)*((void *)v573 + 25);
    v590[0] = v376;
    v590[1] = v568;
    v378 = [MEMORY[0x1E4F1C978] arrayWithObjects:v590 count:2];
    [v377 encodeToMPSCommandEncoder:v544 commandBuffer:v552 sourceArrays:v378 resultState:0 destinationArray:v477 kernelDAGObject:0];
  }
  ((void (**)(void, GPU::EncodeDescriptor *, uint64_t, void *))v571)[2](v571, v532, 3, v594);
  id v379 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v380 = v379;
  v528 = v379;
  if (v379 && *((unsigned char *)v379 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v379, "setReadCount:", objc_msgSend(v379, "readCount") + 1);
  }

  if (ResetAfter)
  {
    v381 = ((void (**)(void, void *, void, uint64_t))v542)[2](v542, v528, 0, 1);
    v382 = (void *)*((void *)v573 + 25);
    v589[0] = v381;
    v589[1] = v568;
    v383 = [MEMORY[0x1E4F1C978] arrayWithObjects:v589 count:2];
    [v382 encodeToMPSCommandEncoder:v544 commandBuffer:v552 sourceArrays:v383 resultState:0 destinationArray:v481 kernelDAGObject:0];

    if (!v480) {
      goto LABEL_505;
    }
    v384 = (void *)*((void *)v573 + 26);
    v588 = v528;
    v385 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v588 count:1];
    [v384 encodeToMPSCommandEncoder:v544 commandBuffer:v552 sourceArrays:v385 resultState:0 destinationArray:v480 kernelDAGObject:0];
  }
  else
  {
    v381 = ((void (**)(void, GPU::EncodeDescriptor *, uint64_t, void *))v571)[2](v571, v355, 3, v594);
    v385 = ((void (**)(void, void *, void, uint64_t))v542)[2](v542, v381, 0, 1);
    v386 = (void *)*((void *)v573 + 25);
    v587[0] = v385;
    v587[1] = v528;
    v387 = [MEMORY[0x1E4F1C978] arrayWithObjects:v587 count:2];
    [v386 encodeToMPSCommandEncoder:v544 commandBuffer:v552 sourceArrays:v387 resultState:0 destinationArray:v481 kernelDAGObject:0];
  }
LABEL_505:

  v388 = v533;
  v389 = v388;
  if (*((unsigned char *)v388 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v388 setReadCount:0];
  }
  v555 = v389;

  v390 = v489;
  v391 = v390;
  if (v390 && *((unsigned char *)v390 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v390 setReadCount:0];
  }
  v513 = v391;

  v392 = v550;
  v393 = v392;
  if (v392 && v392[*MEMORY[0x1E4F359C0]]) {
    [v392 setReadCount:0];
  }
  v574 = v393;

  v394 = v549;
  v395 = v394;
  if (v394 && v394[*MEMORY[0x1E4F359C0]]) {
    [v394 setReadCount:0];
  }
  v514 = v395;

  v396 = v564;
  v397 = v396;
  if (v396 && v396[*MEMORY[0x1E4F359C0]]) {
    [v396 setReadCount:0];
  }
  v512 = v397;

  v398 = v540;
  v399 = v398;
  if (v398 && v398[*MEMORY[0x1E4F359C0]]) {
    [v398 setReadCount:0];
  }
  v511 = v399;

  v400 = v530;
  v401 = v400;
  if (v400 && *((unsigned char *)v400 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v400 setReadCount:0];
  }
  v531 = v401;

  v402 = v354;
  long long v403 = v402;
  if (v402 && *((unsigned char *)v402 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v402 setReadCount:0];
  }
  v510 = v403;

  uint64_t v404 = v355;
  uint64_t v405 = v404;
  if (v404 && *((unsigned char *)v404 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v404 setReadCount:0];
  }
  v509 = v405;

  __int16 v406 = v523;
  long long v407 = v406;
  if (v406 && *((unsigned char *)v406 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v406 setReadCount:0];
  }
  v524 = v407;

  id v408 = v502;
  uint64_t v409 = v408;
  if (v408 && *((unsigned char *)v408 + (int)*MEMORY[0x1E4F359C0])) {
    [v408 setReadCount:0];
  }
  v508 = v409;

  id v410 = v500;
  v411 = v410;
  if (v410 && *((unsigned char *)v410 + (int)*MEMORY[0x1E4F359C0])) {
    [v410 setReadCount:0];
  }
  v507 = v411;

  id v412 = v501;
  v413 = v412;
  if (v412 && *((unsigned char *)v412 + (int)*MEMORY[0x1E4F359C0])) {
    [v412 setReadCount:0];
  }
  v506 = v413;

  id v414 = v525;
  v415 = v414;
  if (v414 && *((unsigned char *)v414 + (int)*MEMORY[0x1E4F359C0])) {
    [v414 setReadCount:0];
  }
  v504 = v415;

  v416 = (GPU *)v479;
  v417 = v416;
  if (v416 && *((unsigned char *)v416 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU *)v416 setReadCount:0];
  }
  v499 = v417;

  id v418 = v478;
  v419 = v418;
  if (v418 && *((unsigned char *)v418 + (int)*MEMORY[0x1E4F359C0])) {
    [v418 setReadCount:0];
  }
  v497 = v419;

  id v420 = v477;
  v421 = v420;
  if (v420 && *((unsigned char *)v420 + (int)*MEMORY[0x1E4F359C0])) {
    [v420 setReadCount:0];
  }
  v495 = v421;

  id v422 = v481;
  v423 = v422;
  if (v422 && *((unsigned char *)v422 + (int)*MEMORY[0x1E4F359C0])) {
    [v422 setReadCount:0];
  }
  v494 = v423;

  v424 = v548;
  v425 = v424;
  if (v424 && *((unsigned char *)v424 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v424 setReadCount:0];
  }
  v465 = v425;

  v426 = v563;
  v427 = v426;
  if (v426 && v426[*MEMORY[0x1E4F359C0]]) {
    [v426 setReadCount:0];
  }
  v461 = v427;

  v428 = v565;
  v429 = v428;
  if (v428 && v428[*MEMORY[0x1E4F359C0]]) {
    [v428 setReadCount:0];
  }
  v459 = v429;

  v430 = v560;
  v431 = v430;
  if (v430 && v430[*MEMORY[0x1E4F359C0]]) {
    [v430 setReadCount:0];
  }
  v457 = v431;

  v432 = __p;
  v433 = v432;
  if (v432 && v432[*MEMORY[0x1E4F359C0]]) {
    objc_msgSend(v432, "setReadCount:", 0, v457);
  }
  v460 = v433;

  v434 = v535;
  v435 = v434;
  if (v434 && v434[*MEMORY[0x1E4F359C0]]) {
    [v434 setReadCount:0];
  }
  v458 = v435;

  v436 = v539;
  v437 = v436;
  if (v436 && v436[*MEMORY[0x1E4F359C0]]) {
    [v436 setReadCount:0];
  }

  id v438 = v546;
  v439 = v438;
  if (v438 && *((unsigned char *)v438 + (int)*MEMORY[0x1E4F359C0])) {
    [v438 setReadCount:0];
  }

  v440 = v532;
  v441 = v440;
  if (v440 && *((unsigned char *)v440 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v440 setReadCount:0];
  }

  id v442 = v547;
  v443 = v442;
  if (v547 && *((unsigned char *)v442 + (int)*MEMORY[0x1E4F359C0])) {
    [v442 setReadCount:0];
  }

  v444 = v562;
  v445 = v444;
  if (v444 && v444[*MEMORY[0x1E4F359C0]]) {
    [v444 setReadCount:0];
  }

  id v446 = v568;
  v447 = v446;
  if (v568 && *((unsigned char *)v446 + (int)*MEMORY[0x1E4F359C0])) {
    [v446 setReadCount:0];
  }

  id v448 = v557;
  v449 = v448;
  if (v448 && *((unsigned char *)v448 + (int)*MEMORY[0x1E4F359C0])) {
    [v448 setReadCount:0];
  }

  id v450 = v526;
  v451 = v450;
  if (v526 && *((unsigned char *)v450 + (int)*MEMORY[0x1E4F359C0])) {
    [v450 setReadCount:0];
  }

  v452 = v585;
  v585 = 0;
  if (v452)
  {
    v453 = *v452;
    if (*v452)
    {
      v452[1] = v453;
      operator delete(v453);
    }
    MEMORY[0x1852FDE70](v452, 0x10C402FEFCB83);
  }
}

void sub_18016BDBC(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,void *a38,void *a39,void *a40,uint64_t a41,uint64_t a42,void *a43,void *a44,void *a45)
{
  STACK[0x2F8] = a1;

  std::unique_ptr<std::vector<long> const,std::default_delete<std::vector<long> const>>::~unique_ptr[abi:ne180100]((uint64_t *)&STACK[0x430]);
  _Unwind_Resume((_Unwind_Exception *)STACK[0x2F8]);
}

uint64_t GPU::activationToDAGTensor(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  switch(a1)
  {
    case 0:
      uint64_t result = a5;
      break;
    case 1:
      MPSKernelDAG::constantOp();
      uint64_t result = MPSKernelDAG::maximumOp();
      break;
    case 2:
      uint64_t result = MPSKernelDAG::tanhOp();
      break;
    case 3:
      MPSKernelDAG::constantOp();
      MPSKernelDAG::negativeOp();
      MPSKernelDAG::exponentOp();
      MPSKernelDAG::additionOp();
      uint64_t result = MPSKernelDAG::reciprocalOp();
      break;
    case 4:
      MPSKernelDAG::constantOp();
      MPSKernelDAG::constantOp();
      MPSKernelDAG::constantOp();
      MPSKernelDAG::constantOp();
      MPSKernelDAG::multiplicationOp();
      MPSKernelDAG::additionOp();
      uint64_t result = MPSKernelDAG::clampOp();
      break;
    case 5:
      MPSKernelDAG::constantOp();
      MPSKernelDAG::constantOp();
      MPSKernelDAG::multiplicationOp();
      MPSKernelDAG::tanhOp();
      uint64_t result = MPSKernelDAG::multiplicationOp();
      break;
    default:
      __assert_rtn("activationToDAGTensor", "GPURNNOps.mm", 387, "0 && \"Unsupported activation\"");
  }
  return result;
}

unint64_t GPU::anonymous namespace'::getCoordAxis(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v13 = 0;
  id v14 = 0;
  uint64_t v15 = &v13;
  id v16 = a1;
  if (!a1) {
    __assert_rtn("matchPattern", "Matchers.h", 402, "value");
  }
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v16);
  if (!DefiningOp
    || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v15, DefiningOp)
    || (unint64_t result = mlir::getSingleIntValue<long long>((uint64_t)v13, (uint64_t)v14), !v8))
  {
    unint64_t v9 = a1[1] & 0xFFFFFFFFFFFFFFF8;
    if (!v9) {
      __assert_rtn("dyn_cast", "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"");
    }
    if (!*(void *)v9) {
      __assert_rtn("getAbstractType", "TypeSupport.h", 160, "abstractType && \"Malformed type storage object.\"");
    }
    id v10 = *(void **)(*(void *)v9 + 136);
    if (v10 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      unint64_t v9 = 0;
    }
    id v16 = (void *)v9;
    if (v10 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id) {
      goto LABEL_11;
    }
    if (!mlir::TensorType::hasRank((mlir::TensorType *)&v16)) {
      __assert_rtn("getRank", "BuiltinTypeInterfaces.h.inc", 227, "(*static_cast<const ConcreteType *>(this)).hasRank() && \"cannot query rank of unranked shaped type\"");
    }
    mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v16);
    if (v12 < 1 || *(void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v16))
    {
LABEL_11:
      if (!a2 || !a3) {
        __assert_rtn("getCoordAxis", "GPUCoordOps.mm", 47, "runtime && encodeDescriptor && \"axis expected to be static\"");
      }
      GPURegionRuntime::waitAndReadIntTensorData(a2, a3, a1, (uint64_t)&v13);
      if (v14 - (unsigned char *)v13 != 8) {
        __assert_rtn("getCoordAxis", "GPUCoordOps.mm", 49, "axisVector.size() == 1");
      }
      uint64_t v11 = *v13;
      id v14 = v13;
      operator delete(v13);
      return v11;
    }
    else
    {
      return -1;
    }
  }
  return result;
}

void sub_18016CE98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(uint64_t ***a1, uint64_t a2)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if (!(*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v4)) {
    return 0;
  }
  v10[0] = v11;
  v10[1] = (void *)0x100000000;
  mlir::Operation::fold(a2, 0, 0, (uint64_t)v10);
  uint64_t v5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible((uint64_t *)(*(void *)v10[0] & 0xFFFFFFFFFFFFFFF8));
  BOOL v7 = v5 != 0;
  if (v5)
  {
    char v8 = *a1;
    if (*a1)
    {
      void *v8 = v5;
      v8[1] = v6;
    }
  }
  if (v10[0] != v11) {
    free(v10[0]);
  }
  return v7;
}

uint64_t mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>()
{
  unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    if (v2)
    {
      id v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
      unint64_t v11 = 84;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    }
  }
  return v0[6];
}

void GPU::LSTMGradientOpHandler::encodeNDArrayOp(GPU::LSTMGradientOpHandler *this, id *a2, NSArray *a3)
{
  uint64_t v466 = *MEMORY[0x1E4F143B8];
  v357 = a3;
  v431 = this;
  uint64_t v4 = *(void *)(*((void *)this + 3) + 48);
  uint64_t v5 = *(void **)(v4 + 16);
  if (v5 == &mlir::detail::TypeIDResolver<void,void>::id)
  {
    *(void *)&long long v464 = *(void *)(v4 + 8);
    uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v464);
    if (v321 == 17)
    {
      BOOL v322 = *(void *)AttrData == 0x6D74736C2E73706DLL && *(void *)(AttrData + 8) == 0x6E6569646172675FLL;
      if (v322 && *(unsigned char *)(AttrData + 16) == 116)
      {
        __int16 v463 = 1283;
        v459 = "classof on '";
        uint64_t v461 = (uint64_t)"mps.lstm_gradient";
        uint64_t v462 = 17;
        v457[0] = (uint64_t)"' failed due to the operation not being registered";
        __int16 v458 = 259;
        llvm::operator+((uint64_t *)&v459, v457, (uint64_t)&v464);
        llvm::report_fatal_error((llvm::Twine *)&v464, 1);
      }
    }
LABEL_425:
    __assert_rtn("cast", "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"");
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGradientOp,void>::id) {
    goto LABEL_425;
  }
  uint64_t v438 = *((void *)this + 3);
  uint64_t Input = mlir::anec::Convolution::getInput((mlir::anec::Convolution *)&v438);
  uint64_t CellGradient = mlir::mps::LSTMGradientOp::getCellGradient((mlir::mps::LSTMGradientOp *)&v438);
  uint64_t OutputCellFwd = mlir::mps::LSTMGradientOp::getOutputCellFwd((mlir::mps::LSTMGradientOp *)&v438);
  uint64_t RecurrentWeight = mlir::mps::LSTMGradientOp::getRecurrentWeight((mlir::mps::LSTMGradientOp *)&v438);
  uint64_t TrainingState = mlir::mps::LSTMGradientOp::getTrainingState((mlir::mps::LSTMGradientOp *)&v438);
  uint64_t InputState = mlir::mps::LSTMGradientOp::getInputState((mlir::mps::LSTMGradientOp *)&v438);
  uint64_t InputCell = mlir::mps::LSTMGradientOp::getInputCell((mlir::mps::LSTMGradientOp *)&v438);
  uint64_t Mask = mlir::mps::LSTMGradientOp::getMask((mlir::mps::LSTMGradientOp *)&v438);
  uint64_t Peephole = mlir::mps::LSTMGradientOp::getPeephole((mlir::mps::LSTMGradientOp *)&v438);
  CellClip = (GPU::EncodeDescriptor *)mlir::mps::LSTMGradientOp::getCellClip((mlir::mps::LSTMGradientOp *)&v438);
  v429 = GPU::EncodeDescriptor::getcomputeEncoder((GPU::EncodeDescriptor *)a2);
  id v430 = a2[1];
  id v428 = *((id *)v431 + 1);
  uint64_t v15 = *((void *)v431 + 2);
  *(void *)&long long v464 = Input;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  id v16 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v15 + 88), (uint64_t *)&v459);
  if (v16
    && (v457[0] = v464,
        (id v17 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v16 + 3, v457)) != 0))
  {
    id v18 = (id)v17[3];
  }
  else
  {
    id v18 = 0;
  }
  v396 = [v18 mpsndarray];

  uint64_t v19 = *((void *)v431 + 2);
  *(void *)&long long v464 = RecurrentWeight;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  id v20 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v19 + 88), (uint64_t *)&v459);
  if (v20
    && (v457[0] = v464,
        (id v21 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v20 + 3, v457)) != 0))
  {
    id v22 = (id)v21[3];
  }
  else
  {
    id v22 = 0;
  }
  v393 = [v22 mpsndarray];

  uint64_t v23 = *((void *)v431 + 2);
  *(void *)&long long v464 = TrainingState;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  unint64_t v24 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v23 + 88), (uint64_t *)&v459);
  if (v24
    && (v457[0] = v464,
        (unint64_t v25 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v24 + 3, v457)) != 0))
  {
    id v26 = (id)v25[3];
  }
  else
  {
    id v26 = 0;
  }
  uint64_t v332 = [v26 mpsndarray];

  uint64_t v27 = *((void *)v431 + 2);
  *(void *)&long long v464 = OutputCellFwd;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  uint8x8_t v28 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v27 + 88), (uint64_t *)&v459);
  if (v28
    && (v457[0] = v464,
        (unint64_t v29 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v28 + 3, v457)) != 0))
  {
    id v30 = (id)v29[3];
  }
  else
  {
    id v30 = 0;
  }
  v339 = [v30 mpsndarray];

  if (!CellGradient)
  {
    v390 = 0;
    if (InputState) {
      goto LABEL_25;
    }
LABEL_51:
    id v347 = 0;
    if (InputCell) {
      goto LABEL_30;
    }
LABEL_52:
    id v389 = 0;
    if (Mask) {
      goto LABEL_35;
    }
LABEL_53:
    id v394 = 0;
    if (Peephole) {
      goto LABEL_40;
    }
    goto LABEL_54;
  }
  uint64_t v31 = *((void *)v431 + 2);
  *(void *)&long long v464 = CellGradient;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  uint64_t v32 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v31 + 88), (uint64_t *)&v459);
  if (v32
    && (v457[0] = v464,
        (unint64_t v33 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v32 + 3, v457)) != 0))
  {
    id v34 = (id)v33[3];
  }
  else
  {
    id v34 = 0;
  }
  v390 = [v34 mpsndarray];

  if (!InputState) {
    goto LABEL_51;
  }
LABEL_25:
  uint64_t v35 = *((void *)v431 + 2);
  *(void *)&long long v464 = InputState;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  unint64_t v36 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v35 + 88), (uint64_t *)&v459);
  if (v36
    && (v457[0] = v464,
        (unint64_t v37 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v36 + 3, v457)) != 0))
  {
    id v38 = (id)v37[3];
  }
  else
  {
    id v38 = 0;
  }
  id v347 = [v38 mpsndarray];

  if (!InputCell) {
    goto LABEL_52;
  }
LABEL_30:
  uint64_t v39 = *((void *)v431 + 2);
  *(void *)&long long v464 = InputCell;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  unint64_t v40 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v39 + 88), (uint64_t *)&v459);
  if (v40
    && (v457[0] = v464,
        (int v41 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v40 + 3, v457)) != 0))
  {
    id v42 = (id)v41[3];
  }
  else
  {
    id v42 = 0;
  }
  id v389 = [v42 mpsndarray];

  if (!Mask) {
    goto LABEL_53;
  }
LABEL_35:
  uint64_t v43 = *((void *)v431 + 2);
  *(void *)&long long v464 = Mask;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  uint64_t v44 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v43 + 88), (uint64_t *)&v459);
  if (v44
    && (v457[0] = v464,
        (unint64_t v45 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v44 + 3, v457)) != 0))
  {
    id v46 = (id)v45[3];
  }
  else
  {
    id v46 = 0;
  }
  id v394 = [v46 mpsndarray];

  if (Peephole)
  {
LABEL_40:
    uint64_t v47 = *((void *)v431 + 2);
    *(void *)&long long v464 = Peephole;
    v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
    unint64_t v48 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v47 + 88), (uint64_t *)&v459);
    if (v48
      && (v457[0] = v464,
          (int8x8_t v49 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v48 + 3, v457)) != 0))
    {
      id v50 = (id)v49[3];
    }
    else
    {
      id v50 = 0;
    }
    id v395 = [v50 mpsndarray];

    unint64_t v51 = CellClip;
    if (CellClip) {
      goto LABEL_45;
    }
LABEL_55:
    id v331 = 0;
    goto LABEL_56;
  }
LABEL_54:
  id v395 = 0;
  unint64_t v51 = CellClip;
  if (!CellClip) {
    goto LABEL_55;
  }
LABEL_45:
  uint64_t v52 = *((void *)v431 + 2);
  *(void *)&long long v464 = v51;
  v459 = (char *)*((void *)mlir::Value::getParentRegion((mlir::Value *)&v464) + 2);
  unint64_t v53 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>((void *)(v52 + 88), (uint64_t *)&v459);
  if (v53
    && (v457[0] = v464,
        (uint8x8_t v54 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v53 + 3, v457)) != 0))
  {
    id v55 = (id)v54[3];
  }
  else
  {
    id v55 = 0;
  }
  id v331 = [v55 mpsndarray];

LABEL_56:
  if ([(NSArray *)v357 count] <= 3) {
    __assert_rtn("encodeNDArrayOp", "GPURNNOps.mm", 1773, "resultsArray.count >= 4");
  }
  uint64_t v325 = [(NSArray *)v357 objectAtIndexedSubscript:0];
  v348 = [v325 mpsndarray];
  if ((!v396 || !v348) && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  v328 = [(NSArray *)v357 objectAtIndexedSubscript:1];
  uint64_t v338 = [v328 mpsndarray];
  if (!v338 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  v329 = [(NSArray *)v357 objectAtIndexedSubscript:2];
  uint64_t v345 = [v329 mpsndarray];
  if (!v345 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  BOOL v330 = [(NSArray *)v357 objectAtIndexedSubscript:3];
  int v346 = [v330 mpsndarray];
  if (!v346 && MTLReportFailureTypeEnabled()) {
    MTLReportFailure();
  }
  if (!v345)
  {
    int v327 = 0;
    uint64_t v345 = 0;
    uint64_t v56 = v346;
    if (v346) {
      goto LABEL_66;
    }
LABEL_70:
    int v326 = 0;
    int v346 = 0;
    goto LABEL_74;
  }
  if (*((unsigned char *)v345 + (int)*MEMORY[0x1E4F359C0]) && ![v345 readCount])
  {
    unint64_t v57 = [v345 descriptor];
    uint64_t v58 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v430 descriptor:v57];

    int v327 = 1;
    uint64_t v345 = (void *)v58;
    uint64_t v56 = v346;
    if (v346) {
      goto LABEL_66;
    }
    goto LABEL_70;
  }
  int v327 = 0;
  uint64_t v56 = v346;
  if (!v346) {
    goto LABEL_70;
  }
LABEL_66:
  if (v56[*MEMORY[0x1E4F359C0]] && ![v56 readCount])
  {
    unint64_t v59 = [v346 descriptor];
    uint64_t v60 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v430 descriptor:v59];

    int v326 = 1;
    int v346 = (unsigned char *)v60;
  }
  else
  {
    int v326 = 0;
  }
LABEL_74:
  if ([(NSArray *)v357 count] == 5)
  {
    int8x8_t v61 = [(NSArray *)v357 objectAtIndexedSubscript:4];
    uint64_t v62 = [v61 mpsndarray];
    if (!v62 && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    v351 = (void *)v62;
  }
  else
  {
    v351 = 0;
  }
  unint64_t v63 = [v348 descriptor];
  unint64_t v64 = v63;
  if (v63) {
    [v63 getShapeVector];
  }
  else {
    v437 = 0;
  }

  uint64_t v65 = 0;
  v417 = v437;
  do
  {
    mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle((mlir::mps::DepthwiseConv2DDataGradientOp *)&v438);
    mlir::mps::SampleGridOp::getLayout((mlir::mps::SampleGridOp *)&v438);
    mlir::mps::StencilOp::getPaddingStyle((mlir::mps::StencilOp *)&v438);
    mlir::mps::Conv3DOp::getPaddingStyle((mlir::mps::Conv3DOp *)&v438);
    mlir::mps::MaterializeSparseTensorOp::getStorageType((mlir::mps::MaterializeSparseTensorOp *)&v438);
    id v423 = v393;
    v427 = v396;
    id v421 = v394;
    long long v464 = 0uLL;
    uint64_t v465 = 0;
    int32x4_t v67 = (const void *)*v417;
    uint64_t v66 = v417[1];
    int64_t v68 = v66 - *v417;
    if (v66 == *v417) {
      goto LABEL_401;
    }
    if (v68 < 0) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v69 = operator new(v66 - *v417);
    *(void *)&long long v464 = v69;
    uint64_t v465 = (uint64_t)&v69[v68 >> 3];
    memcpy(v69, v67, v68);
    *((void *)&v464 + 1) = &v69[v68 >> 3];
    int64_t v70 = 8 * (v68 >> 3);
    if ((unint64_t)v70 <= 0x17) {
LABEL_401:
    }
      __assert_rtn("_getLSTMGradKernelDAGObject", "GPURNNOps.mm", 2417, "shape4.size() >= 3");
    v69[2] = 1;
    v459 = 0;
    v460 = 0;
    uint64_t v461 = 0;
    if (v70 < 0) {
      std::vector<long>::__throw_length_error[abi:ne180100]();
    }
    unint64_t v71 = (uint64_t *)operator new(8 * (v68 >> 3));
    v459 = (char *)v71;
    uint64_t v461 = (uint64_t)&v71[v70 >> 3];
    memcpy(v71, v69, v70);
    v460 = (char *)&v71[v70 >> 3];
    *v71 /= 4;
    if (!*((void *)v431 + v65 + 15)) {
      operator new();
    }
    if (!*((unsigned char *)v431 + 40) && MTLReportFailureTypeEnabled()) {
      MTLReportFailure();
    }
    if (v459)
    {
      v460 = v459;
      operator delete(v459);
    }
    if ((void)v464)
    {
      *((void *)&v464 + 1) = v464;
      operator delete((void *)v464);
    }

    ++v65;
  }
  while (v65 != 15);
  uint64_t v400 = *(void *)(*v417 + 16);
  if (v351) {
    uint64_t v72 = 6;
  }
  else {
    uint64_t v72 = 2;
  }
  int8x16_t v73 = v348;
  int8x8_t v74 = v73;
  if (v73 && *((unsigned char *)v73 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v73 setReadCount:[(GPU::EncodeDescriptor *)v73 readCount] + v72];
  }
  v415 = v74;

  int8x8_t v75 = v346;
  unint64_t v76 = v75;
  if (v75 && *((unsigned char *)v75 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v75 setReadCount:[(GPU::EncodeDescriptor *)v75 readCount] + 1];
  }
  uint64_t v344 = v76;

  unint64_t v77 = v345;
  unint64_t v78 = v77;
  if (v77 && *((unsigned char *)v77 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v77 setReadCount:[(GPU::EncodeDescriptor *)v77 readCount] + 1];
  }
  v343 = v78;

  if (v351)
  {
    id v79 = v389;
    uint8x8_t v80 = v79;
    if (v79 && *((unsigned char *)v79 + (int)*MEMORY[0x1E4F359C0])) {
      objc_msgSend(v79, "setReadCount:", objc_msgSend(v79, "readCount") + 3);
    }
  }
  uint64_t v358 = v400 - 1;
  id v81 = v423;
  unint64_t v82 = v81;
  if (v81 && v400 != 1 && *((unsigned char *)v81 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v81, "setReadCount:", objc_msgSend(v81, "readCount") + v358);
  }
  v388 = v82;

  unint64_t v83 = v332;
  uint64_t v84 = v83;
  if (v83 && *((unsigned char *)v83 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v83 setReadCount:[(GPU::EncodeDescriptor *)v83 readCount] + 1];
  }
  v350 = v84;

  id v85 = v421;
  uint64_t v86 = v85;
  if (v85 && v400 != 1 && *((unsigned char *)v85 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v85, "setReadCount:", objc_msgSend(v85, "readCount") + v358);
  }
  v324 = v86;

  unint64_t v354 = 100 * v400;
  GPU::getSlice(a2, v415, (MPSNDArray *)2, 100 * v400 + 4, 0, 1);
  v398 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v339, (MPSNDArray *)3, 100 * v400 + 4, 0, 1);
  v399 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
  unsigned int v87 = *(_DWORD *)((char *)v398
                  + 4 * (*(_OWORD *)((unsigned char *)v398 + (int)*MEMORY[0x1E4F359B0]) & 0xF)
                  + (int)*MEMORY[0x1E4F359D8]);
  Gateint Layout = mlir::mps::LSTMOp::getGateLayout((mlir::mps::LSTMOp *)&v438);
  uint64_t v89 = v87 >> 2;
  uint64_t v90 = 2 * v89;
  uint64_t v91 = 3 * v89;
  if (GateLayout == 1)
  {
    uint64_t v92 = 3 * v89;
    uint64_t v91 = v87 >> 2;
  }
  else
  {
    if (GateLayout == 2)
    {
      uint64_t v92 = 2 * (v87 >> 2);
    }
    else
    {
      if (GateLayout == 3)
      {
        uint64_t v92 = v87 >> 2;
        goto LABEL_135;
      }
      uint64_t v92 = 3 * v89;
      uint64_t v91 = 2 * (v87 >> 2);
    }
    uint64_t v90 = v87 >> 2;
  }
LABEL_135:
  GPU::getSlice(a2, v398, 0, v354, 0, v89);
  v411 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v398, 0, v354, v90, v89);
  uint64_t v409 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v398, 0, v354, v91, v89);
  id v410 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v398, 0, v354, v92, v89);
  __int16 v406 = (char *)objc_claimAutoreleasedReturnValue();
  if (v351)
  {
    GPU::getSlice(a2, v415, 0, v354, 0, v89);
    uint64_t v335 = (GPU::EncodeDescriptor *)(id)objc_claimAutoreleasedReturnValue();

    GPU::getSlice(a2, v415, 0, v354, v90, v89);
    int v334 = (GPU::EncodeDescriptor *)(id)objc_claimAutoreleasedReturnValue();

    GPU::getSlice(a2, v415, 0, v354, v91, v89);
    uint64_t v333 = (GPU::EncodeDescriptor *)(id)objc_claimAutoreleasedReturnValue();

    GPU::getSlice(a2, v415, 0, v354, v92, v89);
    v340 = (char *)(id)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v340 = 0;
    int v334 = 0;
    uint64_t v335 = 0;
    uint64_t v333 = 0;
  }
  GPU::getSlice(a2, v350, (MPSNDArray *)2, 4, 0, 1);
  id v412 = (GPU::EncodeDescriptor *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v412, 0, v354, 0, v89);
  id v414 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v412, 0, v354, v90, v89);
  v416 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v412, 0, v354, v91, v89);
  v413 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v412, 0, v354, v92, v89);
  long long v407 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v350, 0, v354, v92, v89);
  v337 = (char *)objc_claimAutoreleasedReturnValue();
  if (!v395)
  {
    v377 = 0;
    v378 = 0;
    __int16 v376 = 0;
    v356 = 0;
LABEL_146:
    v349 = 0;
    uint64_t v341 = 0;
    v342 = 0;
    v336 = 0;
    goto LABEL_147;
  }
  id v93 = v395;
  unint64_t v94 = v93;
  if (*((unsigned char *)v93 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v93, "setReadCount:", objc_msgSend(v93, "readCount", v324) + 3);
  }

  unint64_t v404 = v92;
  uint64_t v95 = GPU::getSlice(a2, (GPU::EncodeDescriptor *)v94, 0, 4 * v400, 0, v89);
  uint64_t v96 = GPU::getSlice(a2, (GPU::EncodeDescriptor *)v94, 0, 4 * v400, v90, v89);
  uint64_t v97 = GPU::getSlice(a2, (GPU::EncodeDescriptor *)v94, 0, 4 * v400, v91, v89);
  BOOL v98 = (GPU::EncodeDescriptor *)v94;
  int v99 = (void *)v97;
  GPU::getSlice(a2, v98, 0, 4 * v400, v404, v89);
  uint64_t v100 = v87 >> 2;
  v356 = uint64_t v101 = 4 * v400;
  __int16 v376 = v99;
  v377 = (void *)v96;
  v378 = (void *)v95;
  if (!v351) {
    goto LABEL_146;
  }
  id v102 = v351;
  unint64_t v103 = v102;
  if (*((unsigned char *)v102 + (int)*MEMORY[0x1E4F359C0])) {
    objc_msgSend(v102, "setReadCount:", objc_msgSend(v102, "readCount") + 4);
  }

  v349 = GPU::getSlice(a2, (GPU::EncodeDescriptor *)v103, 0, v101, 0, v100);
  uint64_t v104 = GPU::getSlice(a2, (GPU::EncodeDescriptor *)v103, 0, v101, v90, v100);
  uint64_t v424 = GPU::getSlice(a2, (GPU::EncodeDescriptor *)v103, 0, v101, v91, v100);
  v336 = GPU::getSlice(a2, (GPU::EncodeDescriptor *)v103, 0, v101, v404, v100);
  uint64_t v341 = (void *)v424;
  v342 = (void *)v104;
LABEL_147:
  GPU::getSlice(a2, v427, (MPSNDArray *)2, 10 * v400, v358, 1);
  id v408 = (char *)(id)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v399, (MPSNDArray *)2, 10 * v400, 0, 1);
  id v422 = (char *)objc_claimAutoreleasedReturnValue();
  GPU::getSlice(a2, v390, (MPSNDArray *)2, 10 * v400, 0, 1);
  uint64_t v405 = (char *)objc_claimAutoreleasedReturnValue();
  id v420 = GPU::getSlice(a2, v344, (MPSNDArray *)2, v354, 0, 1);
  v397 = GPU::getSlice(a2, v78, (MPSNDArray *)2, v354, 0, 1);
  if (v390) {
    BOOL v105 = *(_DWORD *)((char *)v390 + 4 * (*((unsigned char *)v390 + *MEMORY[0x1E4F359B0] + 2) & 0xF) + *MEMORY[0x1E4F359D8]) > 1u;
  }
  else {
    BOOL v105 = 0;
  }
  v425 = (void *)[objc_alloc(MEMORY[0x1E4F1CA48]) initWithCapacity:8];
  if (v358 < 0)
  {
    id v187 = 0;
    int8x16_t v197 = v408;
  }
  else
  {
    uint64_t v106 = 0;
    unint64_t v107 = 0;
    size_t v108 = (char *)v415 + 2;
    v385 = v422 + 2;
    uint64_t v372 = (char *)v427 + 2;
    v374 = (char *)v399 + 2;
    v382 = v408 + 2;
    v352 = (char *)v390 + 2;
    v362 = v405 + 2;
    v391 = (char *)v412 + 2;
    int v379 = v400 - 2;
    int v109 = v400 - 1;
    id v418 = v408;
    do
    {
      uint64_t v110 = v415;
      unint64_t v111 = v110;
      uint64_t v112 = (int)*MEMORY[0x1E4F359E0];
      uint64_t v113 = (int)*MEMORY[0x1E4F359B0];
      if (v415) {
        int v114 = *(_DWORD *)((char *)v110 + 4 * (v108[v113] & 0xF) + v112);
      }
      else {
        int v114 = 0;
      }
      *(_DWORD *)((char *)v398 + 4 * *((unsigned __int8 *)v398 + v113 + 2) + v112) = v109 + v106 + v114;

      unint64_t v115 = v399;
      unint64_t v116 = v115;
      if (v422)
      {
        uint64_t v117 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v118 = (int)*MEMORY[0x1E4F359B0];
        int v119 = (int)v399;
        if (v399) {
          int v119 = *(_DWORD *)((char *)v115 + 4 * (v374[v118] & 0xF) + v117);
        }
        *(_DWORD *)&v422[4 * v385[v118] + v117] = v109 + v106 + v119;
      }

      int8x16_t v120 = v427;
      uint64_t v121 = v120;
      if (v408)
      {
        uint64_t v122 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v123 = (int)*MEMORY[0x1E4F359B0];
        int v124 = (int)v427;
        if (v427) {
          int v124 = *(_DWORD *)((char *)v120 + 4 * (v372[v123] & 0xF) + v122);
        }
        *(_DWORD *)&v408[4 * v382[v123] + v122] = v109 + v106 + v124;
      }

      if (v105)
      {
        int8x8_t v125 = v390;
        if (v405)
        {
          uint64_t v126 = (int)*MEMORY[0x1E4F359E0];
          uint64_t v127 = (int)*MEMORY[0x1E4F359B0];
          int v128 = (int)v390;
          if (v390) {
            int v128 = *(_DWORD *)((char *)v125 + 4 * (v352[v127] & 0xF) + v126);
          }
          *(_DWORD *)&v405[4 * v362[v127] + v126] = v109 + v106 + v128;
        }
      }
      unint64_t v129 = v111;
      unint64_t v130 = v129;
      if (v411)
      {
        uint64_t v131 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v132 = (int)*MEMORY[0x1E4F359B0];
        int v133 = (int)v415;
        if (v415) {
          int v133 = *(_DWORD *)((char *)v129 + 4 * (v108[v132] & 0xF) + v131);
        }
        *(_DWORD *)&v411[4 * v411[v132 + 2] + v131] = v109 + v106 + v133;
      }

      int32x4_t v134 = v130;
      int32x4_t v135 = v134;
      if (v409)
      {
        uint64_t v136 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v137 = (int)*MEMORY[0x1E4F359B0];
        int v138 = (int)v415;
        if (v415) {
          int v138 = *(_DWORD *)((char *)v134 + 4 * (v108[v137] & 0xF) + v136);
        }
        *(_DWORD *)&v409[4 * v409[v137 + 2] + v136] = v109 + v106 + v138;
      }

      int8x8_t v139 = v135;
      unint64_t v140 = v139;
      if (v410)
      {
        uint64_t v141 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v142 = (int)*MEMORY[0x1E4F359B0];
        int v143 = (int)v415;
        if (v415) {
          int v143 = *(_DWORD *)((char *)v139 + 4 * (v108[v142] & 0xF) + v141);
        }
        *(_DWORD *)&v410[4 * v410[v142 + 2] + v141] = v109 + v106 + v143;
      }

      unint64_t v144 = v140;
      if (v406)
      {
        uint64_t v145 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v146 = (int)*MEMORY[0x1E4F359B0];
        int v147 = (int)v415;
        if (v415) {
          int v147 = *(_DWORD *)&v144[4 * (v108[v146] & 0xF) + v145];
        }
        *(_DWORD *)&v406[4 * v406[v146 + 2] + v145] = v109 + v106 + v147;
      }

      unint64_t v148 = v412;
      unint64_t v149 = v148;
      if (v407)
      {
        uint64_t v150 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v151 = (int)*MEMORY[0x1E4F359B0];
        int v152 = (int)v412;
        if (v412) {
          int v152 = *(_DWORD *)((char *)v148 + 4 * (v391[v151] & 0xF) + v150);
        }
        *(_DWORD *)&v407[4 * v407[v151 + 2] + v150] = v109 + v106 + v152;
      }

      int8x8_t v153 = v149;
      unint64_t v154 = v153;
      if (v414)
      {
        uint64_t v155 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v156 = (int)*MEMORY[0x1E4F359B0];
        int v157 = (int)v412;
        if (v412) {
          int v157 = *(_DWORD *)((char *)v153 + 4 * (v391[v156] & 0xF) + v155);
        }
        *(_DWORD *)&v414[4 * v414[v156 + 2] + v155] = v109 + v106 + v157;
      }

      uint8x8_t v158 = v154;
      unint64_t v159 = v158;
      if (v416)
      {
        uint64_t v160 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v161 = (int)*MEMORY[0x1E4F359B0];
        int v162 = (int)v412;
        if (v412) {
          int v162 = *(_DWORD *)((char *)v158 + 4 * (v391[v161] & 0xF) + v160);
        }
        *(_DWORD *)&v416[4 * v416[v161 + 2] + v160] = v109 + v106 + v162;
      }

      unint64_t v163 = v159;
      if (v413)
      {
        uint64_t v164 = (int)*MEMORY[0x1E4F359E0];
        uint64_t v165 = (int)*MEMORY[0x1E4F359B0];
        int v166 = (int)v412;
        if (v412) {
          int v166 = *(_DWORD *)((char *)v163 + 4 * (v391[v165] & 0xF) + v164);
        }
        *(_DWORD *)&v413[4 * v413[v165 + 2] + v164] = v109 + v106 + v166;
      }

      v456[0] = v418;
      v456[1] = v422;
      v456[2] = v407;
      unint64_t v167 = [MEMORY[0x1E4F1C978] arrayWithObjects:v456 count:3];
      [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v167 resultState:0 destinationArray:v406 kernelDAGObject:*((void *)v431 + 15)];

      if (v106) {
        char v168 = v105;
      }
      else {
        char v168 = 1;
      }
      if (((v405 != 0) & v168) == 1)
      {
        unint64_t v169 = v405;
        if (v105)
        {
          unint64_t v170 = v390;
          uint64_t v171 = (int)*MEMORY[0x1E4F359E0];
          uint64_t v172 = (int)*MEMORY[0x1E4F359B0];
          if (v390) {
            int v173 = *(_DWORD *)((char *)v170 + 4 * (v352[v172] & 0xF) + v171);
          }
          else {
            int v173 = 0;
          }
          *(_DWORD *)(v169 + v171 + 4 * v362[v172]) = v109 + v106 + v173;
        }
      }
      else
      {
        unint64_t v169 = 0;
      }
      uint64_t v174 = 3;
      if (!(v169 | v107)) {
        uint64_t v174 = 4;
      }
      if (v107) {
        BOOL v175 = v169 == 0;
      }
      else {
        BOOL v175 = 1;
      }
      if (v175) {
        uint64_t v176 = v174;
      }
      else {
        uint64_t v176 = 2;
      }
      if (v106)
      {
        [v425 setObject:v418 atIndexedSubscript:0];
      }
      else
      {
        [v425 addObject:v418];
        [v425 addObject:v407];
        [v425 addObject:v422];
        if (v395)
        {
          [v425 addObject:v406];
          [v425 addObject:v356];
        }
      }
      if (v169) {
        [v425 addObject:v169];
      }
      if (v107) {
        [v425 addObject:v107];
      }
      objc_msgSend(v428, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v429, v430, v425, 0, v420, *((void *)v431 + v176 + 15), v324);
      if (v169) {
        [v425 removeLastObject];
      }
      if (v107) {
        [v425 removeLastObject];
      }

      v455[0] = v420;
      v455[1] = v413;
      v455[2] = v414;
      uint64_t v177 = [MEMORY[0x1E4F1C978] arrayWithObjects:v455 count:3];
      [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v177 resultState:0 destinationArray:v411 kernelDAGObject:*((void *)v431 + 20)];

      v454[0] = v420;
      v454[1] = v414;
      v454[2] = v413;
      unint64_t v178 = [MEMORY[0x1E4F1C978] arrayWithObjects:v454 count:3];
      [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v178 resultState:0 destinationArray:v410 kernelDAGObject:*((void *)v431 + 21)];

      int8x8_t v179 = (char *)v389;
      if (v400 + v106 != 1)
      {
        unint64_t v180 = v116;
        if (v422)
        {
          uint64_t v181 = (int)*MEMORY[0x1E4F359E0];
          uint64_t v182 = (int)*MEMORY[0x1E4F359B0];
          int v183 = (int)v399;
          if (v399) {
            int v183 = *(_DWORD *)((char *)v180 + 4 * (v374[v182] & 0xF) + v181);
          }
          *(_DWORD *)&v422[4 * v385[v182] + v181] = v379 + v106 + v183;
        }

        int8x8_t v179 = v422;
      }
      uint8x8_t v184 = v179;
      unint64_t v185 = v184;
      if (v184)
      {
        v453[0] = v420;
        v453[1] = v184;
        v453[2] = v416;
        long long v186 = [MEMORY[0x1E4F1C978] arrayWithObjects:v453 count:3];
        [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v186 resultState:0 destinationArray:v409 kernelDAGObject:*((void *)v431 + 22)];
      }
      else
      {
        [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:MEMORY[0x1E4F1CBF0] resultState:0 destinationArray:v409 kernelDAGObject:*((void *)v431 + 23)];
      }
      id v187 = v420;

      v452[0] = v187;
      v452[1] = v416;
      uint64_t v188 = [MEMORY[0x1E4F1C978] arrayWithObjects:v452 count:2];
      if (v395)
      {
        v451[0] = v187;
        v451[1] = v416;
        v451[2] = v411;
        v451[3] = v409;
        v451[4] = v410;
        v451[5] = v378;
        v451[6] = v377;
        v451[7] = v376;
        uint64_t v189 = [MEMORY[0x1E4F1C978] arrayWithObjects:v451 count:8];

        uint64_t v188 = (void *)v189;
      }
      [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v188 resultState:0 destinationArray:v187 kernelDAGObject:*((void *)v431 + 16)];
      if (v400 + v106 == 1)
      {
        unint64_t v196 = (void *)*((void *)v431 + 30);
        v449[0] = v398;
        v449[1] = v388;
        uint8x8_t v195 = [MEMORY[0x1E4F1C978] arrayWithObjects:v449 count:2];
        [v196 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v195 resultState:0 destinationArray:v397 kernelDAGObject:0];
      }
      else
      {
        uint64_t v190 = v121;
        if (v408)
        {
          uint64_t v191 = (int)*MEMORY[0x1E4F359E0];
          uint64_t v192 = (int)*MEMORY[0x1E4F359B0];
          int v193 = (int)v427;
          if (v427) {
            int v193 = *(_DWORD *)((char *)v190 + 4 * (v372[v192] & 0xF) + v191);
          }
          *(_DWORD *)&v408[4 * v382[v192] + v191] = v379 + v106 + v193;
        }

        unint64_t v194 = (void *)*((void *)v431 + 30);
        v450[0] = v408;
        v450[1] = v398;
        v450[2] = v388;
        uint8x8_t v195 = [MEMORY[0x1E4F1C978] arrayWithObjects:v450 count:3];
        [v194 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v195 resultState:0 destinationArray:v397 kernelDAGObject:*((void *)v431 + 27)];
      }

      int8x16_t v197 = v397;
      --v106;
      unint64_t v107 = (unint64_t)v187;
      id v418 = v197;
    }
    while (v400 + v106 > 0);
  }
  int32x4_t v198 = v187;
  v419 = v197;
  long long v464 = xmmword_181134E80;
  uint64_t v465 = 1;
  uint64_t v199 = (long long *)((char *)v350 + (int)*MEMORY[0x1E4F359D8]);
  long long v200 = *v199;
  long long v201 = v199[1];
  int32x4_t v202 = (char *)v350 + (int)*MEMORY[0x1E4F359B0];
  char v203 = *(_OWORD *)v202;
  long long v204 = v199[3];
  long long v435 = v199[2];
  long long v436 = v204;
  v434[0] = v200;
  v434[1] = v201;
  *(void *)&long long v464 = *((_DWORD *)v434 + (v203 & 0xF)) >> 2;
  uint64_t v205 = v202[1] & 0xF;
  v433[2] = v435;
  v433[3] = v204;
  v433[0] = v200;
  v433[1] = v201;
  uint64_t v206 = *((unsigned int *)v433 + v205);
  uint64_t v207 = v400 - 1;
  if (v347) {
    uint64_t v207 = v400;
  }
  *((void *)&v464 + 1) = v206;
  uint64_t v465 = v207;
  if (v207)
  {
    int32x4_t v208 = [MEMORY[0x1E4F35720] descriptorWithDataType:*(unsigned int *)((char *)v350 + (int)*MEMORY[0x1E4F359A0]) dimensionCount:3 dimensionSizes:&v464];
    [v208 setPreferPackedRows:1];
    id v209 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v430 descriptor:v208];
    int64_t v210 = v415;
    int32x4_t v211 = (char *)v210;
    if (v347)
    {
      [v209 setReadCount:3];
      int32x4_t v212 = [v209 descriptor];
      objc_msgSend(v212, "sliceDimension:withSubrange:", 2, 0, 1);
      int64_t v213 = [v209 safeArrayViewWithCommandBuffer:v430 computeEncoder:v429 descriptor:v212 aliasing:1];
      id v448 = v347;
      uint64_t v214 = [MEMORY[0x1E4F1C978] arrayWithObjects:&v448 count:1];
      [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v214 resultState:0 destinationArray:v213 kernelDAGObject:0];

      [v213 setReadCount:0];
      int8x16_t v215 = [v209 descriptor];
      objc_msgSend(v215, "sliceDimension:withSubrange:", 2, 1, v358);
      v401 = [v209 safeArrayViewWithCommandBuffer:v430 computeEncoder:v429 descriptor:v215 aliasing:1];
    }
    else
    {
      int32x4_t v212 = [(GPU::EncodeDescriptor *)v210 descriptor];
      int64_t v213 = v211;
      objc_msgSend(v212, "sliceDimension:withSubrange:", 2, 1, v358);
      [v211 safeArrayViewWithCommandBuffer:v430 computeEncoder:v429 descriptor:v212 aliasing:0];
      v401 = v209;
      int32x4_t v211 = (char *)objc_claimAutoreleasedReturnValue();
    }

    int8x16_t v217 = [v337 descriptor];
    objc_msgSend(v217, "sliceDimension:withSubrange:", 2, *(unsigned int *)&v337[4 * (v337[*MEMORY[0x1E4F359B0] + 2] & 0xF) + *MEMORY[0x1E4F359E0]], v358);
    v392 = [v337 safeArrayViewWithCommandBuffer:v430 computeEncoder:v429 descriptor:v217 aliasing:0];
    int8x16_t v218 = [(GPU::EncodeDescriptor *)v399 descriptor];
    objc_msgSend(v218, "sliceDimension:withSubrange:", 2, *(unsigned int *)((char *)v399 + 4 * (*((unsigned char *)v399 + *MEMORY[0x1E4F359B0] + 2) & 0xF) + *MEMORY[0x1E4F359E0]), v358);
    v386 = [(GPU::EncodeDescriptor *)v399 safeArrayViewWithCommandBuffer:v430 computeEncoder:v429 descriptor:v218 aliasing:0];

    v447[0] = v392;
    v447[1] = v386;
    uint64_t v219 = [MEMORY[0x1E4F1C978] arrayWithObjects:v447 count:2];
    [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v219 resultState:0 destinationArray:v401 kernelDAGObject:*((void *)v431 + 28)];

    v459 = (char *)v464;
    v460 = (char *)(v465 * *((void *)&v464 + 1));
    uint64_t v461 = 1;
    v383 = [v428 reshapeWithCommandEncoder:v429 commandBuffer:v430 sourceArray:v209 dimensionCount:3 dimensionSizes:&v459 destinationArray:0];
    v457[0] = 4 * v464;
    v457[1] = v465 * *((void *)&v464 + 1);
    v457[2] = 1;
    int v220 = [v428 reshapeWithCommandEncoder:v429 commandBuffer:v430 sourceArray:v211 dimensionCount:3 dimensionSizes:v457 destinationArray:0];
    if (!v220)
    {
      int v221 = [MEMORY[0x1E4F35720] descriptorWithDataType:*(unsigned int *)&v211[*MEMORY[0x1E4F359A0]] dimensionCount:3 dimensionSizes:v457];
      int v220 = [MEMORY[0x1E4F35988] temporaryNDArrayWithCommandBuffer:v430 descriptor:v221];
      id v222 = (id)[v428 reshapeWithCommandEncoder:v429 commandBuffer:v430 sourceArray:v211 dimensionCount:3 dimensionSizes:v457 destinationArray:v220];
    }
    v223 = objc_msgSend(v220, "descriptor", v324);
    [v223 transposeDimension:0 withDimension:1];
    uint64_t v224 = [v220 safeArrayViewWithCommandBuffer:v430 computeEncoder:v429 descriptor:v223 aliasing:1];
    uint64_t v225 = (void *)*((void *)v431 + 30);
    v446[0] = v224;
    v446[1] = v383;
    id v226 = [MEMORY[0x1E4F1C978] arrayWithObjects:v446 count:2];
    [v225 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v226 resultState:0 destinationArray:v338 kernelDAGObject:0];
  }
  else
  {
    [v428 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:MEMORY[0x1E4F1CBF0] resultState:0 destinationArray:v338 kernelDAGObject:*((void *)v431 + 29)];
    int8x16_t v216 = v415;
    if (v415)
    {
      int32x4_t v208 = v216;
      if (*((unsigned char *)v216 + (int)*MEMORY[0x1E4F359C0])) {
        [(GPU::EncodeDescriptor *)v216 setReadCount:[(GPU::EncodeDescriptor *)v216 readCount] - 1];
      }
    }
    else
    {
      int32x4_t v208 = 0;
    }
  }

  if (v351)
  {
    v227 = (void *)*((void *)v431 + 31);
    v445[0] = v340;
    v445[1] = v399;
    id v228 = [MEMORY[0x1E4F1C978] arrayWithObjects:v445 count:2];
    [v227 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v228 resultState:0 destinationArray:v336 kernelDAGObject:*((void *)v431 + 24)];

    unsigned int v229 = *(_DWORD *)&v340[4 * (v340[*MEMORY[0x1E4F359B0] + 2] & 0xF) + *MEMORY[0x1E4F359D8]];
    if (v229 < 2)
    {
      id v231 = 0;
      id v402 = 0;
      id v230 = 0;
    }
    else
    {
      GPU::getSlice(a2, v335, (MPSNDArray *)2, v354, 1, v358);
      id v402 = (id)objc_claimAutoreleasedReturnValue();

      GPU::getSlice(a2, v334, (MPSNDArray *)2, v354, 1, v358);
      id v230 = (id)objc_claimAutoreleasedReturnValue();

      GPU::getSlice(a2, v333, (MPSNDArray *)2, v354, 1, v358);
      id v231 = (id)objc_claimAutoreleasedReturnValue();
    }
    uint64_t v232 = GPU::getSlice(a2, v399, (MPSNDArray *)2, v354, 0, v358);
    if (v229 <= 1)
    {
      id v233 = v428;
      uint64_t v234 = (void *)MEMORY[0x1E4F1CBF0];
    }
    else
    {
      id v233 = *((id *)v431 + 31);
      v444[0] = v402;
      v444[1] = v232;
      uint64_t v234 = [MEMORY[0x1E4F1C978] arrayWithObjects:v444 count:2];
    }
    objc_msgSend(v233, "encodeToMPSCommandEncoder:commandBuffer:sourceArrays:resultState:destinationArray:kernelDAGObject:", v429, v430, v234, 0, v349, *((void *)v431 + 25), v324);
    if (v229 < 2)
    {
      unint64_t v235 = (void *)MEMORY[0x1E4F1CBF0];
    }
    else
    {

      v443[0] = v230;
      v443[1] = v232;
      unint64_t v235 = [MEMORY[0x1E4F1C978] arrayWithObjects:v443 count:2];
    }
    [v233 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v235 resultState:0 destinationArray:v342 kernelDAGObject:*((void *)v431 + 25)];
    if (v229 < 2)
    {
      uint64_t v236 = (void *)MEMORY[0x1E4F1CBF0];
    }
    else
    {

      v442[0] = v231;
      v442[1] = v232;
      uint64_t v236 = [MEMORY[0x1E4F1C978] arrayWithObjects:v442 count:2];
    }
    [v233 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v236 resultState:0 destinationArray:v341 kernelDAGObject:*((void *)v431 + 25)];
    if (v229 >= 2) {

    }
    id v237 = v402;
    unint64_t v238 = v237;
    if (v237 && *((unsigned char *)v237 + (int)*MEMORY[0x1E4F359C0])) {
      [v237 setReadCount:0];
    }

    id v239 = v230;
    uint64_t v240 = v239;
    if (v239 && *((unsigned char *)v239 + (int)*MEMORY[0x1E4F359C0])) {
      [v239 setReadCount:0];
    }

    id v241 = v231;
    v242 = v241;
    if (v241 && *((unsigned char *)v241 + (int)*MEMORY[0x1E4F359C0])) {
      [v241 setReadCount:0];
    }

    id v243 = v232;
    long long v244 = v243;
    if (v243 && *((unsigned char *)v243 + (int)*MEMORY[0x1E4F359C0])) {
      [v243 setReadCount:0];
    }

    if (v389)
    {
      long long v245 = v398;
      long long v246 = v245;
      if (v411) {
        *(_DWORD *)&v411[4 * v411[*MEMORY[0x1E4F359B0] + 2] + *MEMORY[0x1E4F359E0]] = *(_DWORD *)((char *)v245 + 4 * (*((unsigned char *)v245 + *MEMORY[0x1E4F359B0] + 2) & 0xF) + *MEMORY[0x1E4F359E0]);
      }

      long long v247 = v246;
      uint64_t v248 = v247;
      if (v409) {
        *(_DWORD *)&v409[4 * v409[*MEMORY[0x1E4F359B0] + 2] + *MEMORY[0x1E4F359E0]] = *(_DWORD *)((char *)v247 + 4 * (*((unsigned char *)v247 + *MEMORY[0x1E4F359B0] + 2) & 0xF) + *MEMORY[0x1E4F359E0]);
      }

      uint64_t v249 = v248;
      if (v410) {
        *(_DWORD *)&v410[4 * v410[*MEMORY[0x1E4F359B0] + 2] + *MEMORY[0x1E4F359E0]] = *(_DWORD *)((char *)v249 + 4 * (*((unsigned char *)v249 + *MEMORY[0x1E4F359B0] + 2) & 0xF) + *MEMORY[0x1E4F359E0]);
      }

      id v250 = (void *)*((void *)v431 + 31);
      v441[0] = v411;
      v441[1] = v389;
      v441[2] = v349;
      uint64_t v251 = [MEMORY[0x1E4F1C978] arrayWithObjects:v441 count:3];
      [v250 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v251 resultState:0 destinationArray:v349 kernelDAGObject:*((void *)v431 + 26)];

      v252 = (void *)*((void *)v431 + 31);
      v440[0] = v409;
      v440[1] = v389;
      v440[2] = v342;
      uint64_t v253 = [MEMORY[0x1E4F1C978] arrayWithObjects:v440 count:3];
      [v252 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v253 resultState:0 destinationArray:v342 kernelDAGObject:*((void *)v431 + 26)];

      v254 = (void *)*((void *)v431 + 31);
      v439[0] = v410;
      v439[1] = v389;
      v439[2] = v341;
      uint64_t v255 = [MEMORY[0x1E4F1C978] arrayWithObjects:v439 count:3];
      [v254 encodeToMPSCommandEncoder:v429 commandBuffer:v430 sourceArrays:v255 resultState:0 destinationArray:v341 kernelDAGObject:*((void *)v431 + 26)];
    }
  }
  uint64_t v256 = v398;
  uint64_t v257 = v256;
  if (*((unsigned char *)v256 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v256 setReadCount:0];
  }
  long long v403 = v257;

  int v258 = v399;
  uint64_t v259 = v258;
  if (v258 && *((unsigned char *)v258 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v258 setReadCount:0];
  }

  v432 = v411;
  if (v432 && v432[*MEMORY[0x1E4F359C0]]) {
    [v432 setReadCount:0];
  }

  uint64_t v260 = v409;
  int v261 = v260;
  if (v260 && v260[*MEMORY[0x1E4F359C0]]) {
    [v260 setReadCount:0];
  }

  v262 = v410;
  uint64_t v263 = v262;
  if (v262 && v262[*MEMORY[0x1E4F359C0]]) {
    [v262 setReadCount:0];
  }
  v387 = v263;

  uint64_t v264 = v406;
  int v265 = v264;
  if (v264 && v264[*MEMORY[0x1E4F359C0]]) {
    [v264 setReadCount:0];
  }
  v384 = v265;

  v266 = v335;
  v267 = v266;
  if (v266 && *((unsigned char *)v266 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v266 setReadCount:0];
  }
  v381 = v267;

  uint64_t v268 = v334;
  uint64_t v269 = v268;
  if (v268 && *((unsigned char *)v268 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v268 setReadCount:0];
  }
  uint64_t v380 = v269;

  int v270 = v333;
  v271 = v270;
  if (v270 && *((unsigned char *)v270 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v270 setReadCount:0];
  }
  v375 = v271;

  v272 = v340;
  uint64_t v273 = v272;
  if (v272 && v272[*MEMORY[0x1E4F359C0]]) {
    [v272 setReadCount:0];
  }
  v373 = v273;

  uint64_t v274 = v412;
  int v275 = v274;
  if (v274 && *((unsigned char *)v274 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v274 setReadCount:0];
  }
  v371 = v275;

  v276 = v414;
  v277 = v276;
  if (v276 && v276[*MEMORY[0x1E4F359C0]]) {
    [v276 setReadCount:0];
  }
  v370 = v277;

  uint64_t v278 = v416;
  uint64_t v279 = v278;
  if (v278 && v278[*MEMORY[0x1E4F359C0]]) {
    [v278 setReadCount:0];
  }
  v369 = v279;

  int v280 = v413;
  v281 = v280;
  if (v280 && v280[*MEMORY[0x1E4F359C0]]) {
    [v280 setReadCount:0];
  }
  v368 = v281;

  uint64_t v282 = v407;
  uint64_t v283 = v282;
  if (v282 && v282[*MEMORY[0x1E4F359C0]]) {
    [v282 setReadCount:0];
  }
  id v367 = v283;

  int v284 = v337;
  v285 = v284;
  if (v284 && v284[*MEMORY[0x1E4F359C0]]) {
    [v284 setReadCount:0];
  }
  id v366 = v285;

  id v286 = v378;
  uint64_t v287 = v286;
  if (v286 && *((unsigned char *)v286 + (int)*MEMORY[0x1E4F359C0])) {
    [v286 setReadCount:0];
  }
  id v365 = v287;

  id v288 = v377;
  int v289 = v288;
  if (v288 && *((unsigned char *)v288 + (int)*MEMORY[0x1E4F359C0])) {
    [v288 setReadCount:0];
  }
  v364 = v289;

  id v290 = v376;
  v291 = v290;
  if (v290 && *((unsigned char *)v290 + (int)*MEMORY[0x1E4F359C0])) {
    [v290 setReadCount:0];
  }
  id v363 = v291;

  uint64_t v292 = v356;
  uint64_t v293 = v292;
  if (v292 && *((unsigned char *)v292 + (int)*MEMORY[0x1E4F359C0])) {
    [(GPU::EncodeDescriptor *)v292 setReadCount:0];
  }
  id v361 = v293;

  id v294 = v349;
  id v295 = v294;
  if (v294 && *((unsigned char *)v294 + (int)*MEMORY[0x1E4F359C0])) {
    [v294 setReadCount:0];
  }
  v359 = v295;

  id v296 = v342;
  uint64_t v297 = v296;
  if (v296 && *((unsigned char *)v296 + (int)*MEMORY[0x1E4F359C0])) {
    [v296 setReadCount:0];
  }
  v355 = v297;

  id v298 = v341;
  v299 = v298;
  if (v298 && *((unsigned char *)v298 + (int)*MEMORY[0x1E4F359C0])) {
    [v298 setReadCount:0];
  }
  uint64_t v353 = v299;

  id v300 = v336;
  uint64_t v301 = v300;
  if (v300 && *((unsigned char *)v300 + (int)*MEMORY[0x1E4F359C0])) {
    [v300 setReadCount:0];
  }
  uint64_t v302 = v301;

  int v303 = v408;
  v304 = v303;
  if (v303 && v303[*MEMORY[0x1E4F359C0]]) {
    [v303 setReadCount:0];
  }
  uint64_t v305 = v304;

  uint64_t v306 = v422;
  int v307 = v306;
  if (v306 && v306[*MEMORY[0x1E4F359C0]]) {
    [v306 setReadCount:0];
  }

  v308 = v405;
  uint64_t v309 = v308;
  if (v308 && v308[*MEMORY[0x1E4F359C0]]) {
    [v308 setReadCount:0];
  }

  id v310 = v420;
  id v311 = v310;
  if (v310 && *((unsigned char *)v310 + (int)*MEMORY[0x1E4F359C0])) {
    [v310 setReadCount:0];
  }

  id v312 = v397;
  v313 = v312;
  if (v312 && *((unsigned char *)v312 + (int)*MEMORY[0x1E4F359C0])) {
    [v312 setReadCount:0];
  }

  if (v327)
  {
    uint64_t v314 = v343;
    v315 = v314;
    if (v343 && *((unsigned char *)v314 + (int)*MEMORY[0x1E4F359C0])) {
      [(GPU::EncodeDescriptor *)v314 setReadCount:0];
    }
  }
  if (v326)
  {
    v316 = v344;
    id v317 = v316;
    if (v344 && *((unsigned char *)v316 + (int)*MEMORY[0x1E4F359C0])) {
      [(GPU::EncodeDescriptor *)v316 setReadCount:0];
    }
  }
  v318 = (void **)v437;
  v437 = 0;
  if (v318)
  {
    v319 = *v318;
    if (*v318)
    {
      v318[1] = v319;
      operator delete(v319);
    }
    MEMORY[0x1852FDE70](v318, 0x10C402FEFCB83);
  }
}

void sub_1801713C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,void *a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,void *a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61,void *a62,uint64_t a63)
{
  _Unwind_Resume(a1);
}

void sub_180173918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,_Unwind_Exception *exception_objecta,void *a29,uint64_t a30,void *a31,void *a32,uint64_t a33,void *a34)
{
  _Unwind_Resume(a1);
}

llvm::raw_ostream *mlir::Type::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  if (*(void *)this)
  {
    unint64_t v3 = (uint64_t ***)this;
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext(this);
    mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)&v12);
    uint64_t v5 = (char *)operator new(0x2C0uLL);
    uint64_t v6 = mlir::DialectInterfaceCollection<mlir::OpAsmDialectInterface>::DialectInterfaceCollection(v5, Context);
    *(void *)(v6 + 56) = v6 + 72;
    *(void *)(v6 + 64) = 0x600000000;
    *(_OWORD *)(v6 + 120) = 0u;
    *(_DWORD *)(v6 + 136) = 0;
    *(_OWORD *)(v6 + 144) = 0u;
    *(_DWORD *)(v6 + 160) = 0;
    *(_OWORD *)(v6 + 184) = 0u;
    *(void *)(v6 + 168) = v6 + 184;
    *(void *)(v6 + 176) = 0;
    *(void *)(v6 + 200) = v6 + 216;
    *(void *)(v6 + 208) = 0x400000000;
    *(void *)(v6 + 248) = v6 + 264;
    *(_OWORD *)(v6 + 256) = 0u;
    *(void *)(v6 + 272) = 1;
    *(_OWORD *)(v6 + 280) = 0u;
    *(_DWORD *)(v6 + 296) = 0;
    *(_DWORD *)(v6 + 320) = 0;
    *(_OWORD *)(v6 + 304) = 0u;
    *(_DWORD *)(v6 + 344) = 0;
    *(_OWORD *)(v6 + 328) = 0u;
    *(_DWORD *)(v6 + 368) = 0;
    *(_OWORD *)(v6 + 352) = 0u;
    *(_DWORD *)(v6 + 392) = 0;
    *(_OWORD *)(v6 + 376) = 0u;
    *(_DWORD *)(v6 + 416) = 0;
    *(_OWORD *)(v6 + 400) = 0u;
    *(_OWORD *)(v6 + 424) = 0u;
    *(void *)(v6 + 440) = 0;
    *(void *)(v6 + 448) = v6 + 464;
    *(void *)(v6 + 456) = 0x400000000;
    *(void *)(v6 + 496) = v6 + 512;
    *(_OWORD *)(v6 + 504) = 0u;
    *(void *)(v6 + 520) = 1;
    *(void *)(v6 + 528) = 0;
    *((_DWORD *)v5 + 134) = 0;
    mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)(v6 + 544));
    *((_DWORD *)v5 + 152) = 0;
    *((void *)v5 + 75) = 0;
    *(_OWORD *)(v5 + 584) = 0u;
    long long v7 = v13;
    *(_OWORD *)(v5 + 616) = v12;
    *(_OWORD *)(v5 + 632) = v7;
    *((void *)v5 + 81) = v14;
    *((void *)v5 + 82) = 0;
    *(_OWORD *)(v5 + 664) = 0u;
    *((_DWORD *)v5 + 170) = 0;
    *((void *)v5 + 86) = v5 + 704;
    *((void *)v5 + 87) = 0;
    *(void *)&long long v12 = a2;
    *((void *)&v12 + 1) = v5;
    long long v8 = *(_OWORD *)(v5 + 632);
    long long v13 = *(_OWORD *)(v5 + 616);
    long long v14 = v8;
    uint64_t v15 = *((void *)v5 + 81);
    int v16 = 1;
    uint64_t v9 = *v3;
    if (v9)
    {
      if (!mlir::AsmPrinter::Impl::printAlias((uint64_t)&v12, (uint64_t)v9)) {
        mlir::AsmPrinter::Impl::printTypeImpl((uint64_t)&v12, v9);
      }
    }
    else
    {
      unint64_t v11 = (void *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v11 > 0xCuLL)
      {
        qmemcpy(v11, "<<NULL TYPE>>", 13);
        *((void *)a2 + 4) += 13;
      }
      else
      {
        llvm::raw_ostream::write(a2, "<<NULL TYPE>>", 0xDuLL);
      }
    }
    mlir::detail::AsmStateImpl::~AsmStateImpl((mlir::detail::AsmStateImpl *)v5);
  }
  id v10 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v10 > 0xCuLL)
  {
    qmemcpy(v10, "<<NULL TYPE>>", 13);
    *((void *)a2 + 4) += 13;
  }
  else
  {
    return llvm::raw_ostream::write(a2, "<<NULL TYPE>>", 0xDuLL);
  }
  return this;
}

void MILToMLIR::SliceByIndexPattern::~SliceByIndexPattern(void **this)
{
  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }
}

{
  uint64_t vars8;

  *this = &unk_1EC995CF0;
  if (*((char *)this + 31) < 0) {
    operator delete(this[1]);
  }

  JUMPOUT(0x1852FDE70);
}

void GPU::anonymous namespace'::copyNDArrayOrListToTarget(void *a1, void *a2, void *a3, id *a4, void *a5, void *a6, uint64_t *a7, uint64_t a8)
{
  id v15 = a2;
  id v16 = a3;
  id v17 = a5;
  id v18 = a6;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if (v18) {
      __assert_rtn("copyNDArrayOrListToTarget", "GPUControlFlowOps.mm", 53, "targettedTensorData == nil");
    }
    uint64_t v24 = (uint64_t)a7;
    uint64_t v23 = *((void *)mlir::Value::getParentRegion((mlir::Value *)&v24) + 2);
    uint64_t v19 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(a1 + 11, &v23);
    if (v19)
    {
      uint64_t v22 = v24;
      id v20 = std::__hash_table<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::__unordered_map_hasher<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::hash<mlir::Operation *>,std::equal_to<mlir::Operation *>,true>,std::__unordered_map_equal<mlir::Operation *,std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>,std::equal_to<mlir::Operation *>,std::hash<mlir::Operation *>,true>,std::allocator<std::__hash_value_type<mlir::Operation *,std::unordered_map<void *,MPSGraphTensorData * {__strong}>>>>::find<mlir::Operation *>(v19 + 3, &v22);
      if (v20)
      {
        if ((id)v20[3]) {
          __assert_rtn("copyNDArrayOrListToTarget", "GPUControlFlowOps.mm", 54, "runtime->getTensorDataFromDataMap(resultValue) == nil");
        }
      }
    }
    BaseRuntime::setTensorDataToDataMap((uint64_t)a1, a7, v17);
  }
  else
  {
    id v21 = [v17 mpsndarray];
    GPURegionRuntime::copyNDArrayToTarget(a1, v15, v16, a4, v21, v18, a7, a8);
  }
}

void sub_180174228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180174248(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_180174268(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void GPU::GRUOpHandler::~GRUOpHandler(id *this)
{
  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);
}

{
  uint64_t vars8;

  GPU::BaseOpHandler::~BaseOpHandler((GPU::BaseOpHandler *)this);

  JUMPOUT(0x1852FDE70);
}

void sub_1801748A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, void *__p, uint64_t a15)
{
  if (!__p)
  {

    _Unwind_Resume(a1);
  }
  operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_180174BA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24)
{
  _Unwind_Resume(a1);
}

uint64_t ZinGetString(CFStringRef theString, uint64_t a2)
{
  CFStringRef v3 = theString;
  if (*(char *)(a2 + 23) < 0)
  {
    **(unsigned char **)a2 = 0;
    *(void *)(a2 + 8) = 0;
    if (!theString) {
      return (uint64_t)v3;
    }
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 23) = 0;
    if (!theString) {
      return (uint64_t)v3;
    }
  }
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (CStringPtr)
  {
    uint64_t v5 = CStringPtr;
    size_t v6 = strlen(CStringPtr);
    if (v6 <= 0x7FFFFFFFFFFFFFF7)
    {
      std::string::size_type v7 = v6;
      if (v6 >= 0x17)
      {
        uint64_t v13 = (v6 & 0xFFFFFFFFFFFFFFF8) + 8;
        if ((v6 | 7) != 0x17) {
          uint64_t v13 = v6 | 7;
        }
        uint64_t v14 = v13 + 1;
        p_dst = (std::string *)operator new(v13 + 1);
        __dst.__r_.__value_.__l.__size_ = v7;
        __dst.__r_.__value_.__r.__words[2] = v14 | 0x8000000000000000;
        __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)p_dst;
      }
      else
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v6;
        p_dst = &__dst;
        if (!v6) {
          goto LABEL_18;
        }
      }
      memmove(p_dst, v5, v7);
LABEL_18:
      p_dst->__r_.__value_.__s.__data_[v7] = 0;
      if (*(char *)(a2 + 23) < 0) {
        operator delete(*(void **)a2);
      }
      *(std::string *)a2 = __dst;
      return 1;
    }
LABEL_44:
    std::string::__throw_length_error[abi:ne180100]();
  }
  CFIndex Length = CFStringGetLength(v3);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  std::string::size_type v11 = MaximumSizeForEncoding + 1;
  if ((unint64_t)(MaximumSizeForEncoding + 1) > 0x7FFFFFFFFFFFFFF7) {
    goto LABEL_44;
  }
  if (v11 >= 0x17)
  {
    uint64_t v15 = (v11 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v11 | 7) != 0x17) {
      uint64_t v15 = v11 | 7;
    }
    uint64_t v16 = v15 + 1;
    long long v12 = (std::string *)operator new(v15 + 1);
    __dst.__r_.__value_.__l.__size_ = v11;
    __dst.__r_.__value_.__r.__words[2] = v16 | 0x8000000000000000;
    __dst.__r_.__value_.__r.__words[0] = (std::string::size_type)v12;
    goto LABEL_24;
  }
  *((unsigned char *)&__dst.__r_.__value_.__s + 23) = MaximumSizeForEncoding + 1;
  long long v12 = &__dst;
  if (MaximumSizeForEncoding != -1) {
LABEL_24:
  }
    bzero(v12, v11);
  v12->__r_.__value_.__s.__data_[v11] = 0;
  if ((__dst.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
    id v17 = &__dst;
  }
  else {
    id v17 = (std::string *)__dst.__r_.__value_.__r.__words[0];
  }
  int CString = CFStringGetCString(v3, (char *)v17, v11, 0x8000100u);
  CFStringRef v3 = (const __CFString *)(CString != 0);
  std::string::size_type size = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  char v20 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  if (CString)
  {
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
      uint64_t v22 = (std::string *)__dst.__r_.__value_.__r.__words[0];
      size_t v21 = strlen(__dst.__r_.__value_.__l.__data_);
      std::string::size_type size = __dst.__r_.__value_.__l.__size_;
      if (__dst.__r_.__value_.__l.__size_ >= v21)
      {
        __dst.__r_.__value_.__l.__size_ = v21;
LABEL_36:
        v22->__r_.__value_.__s.__data_[v21] = 0;
        if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0) {
          goto LABEL_37;
        }
        goto LABEL_34;
      }
    }
    else
    {
      size_t v21 = strlen((const char *)&__dst);
      if (v21 <= HIBYTE(__dst.__r_.__value_.__r.__words[2]))
      {
        *((unsigned char *)&__dst.__r_.__value_.__s + 23) = v21 & 0x7F;
        uint64_t v22 = &__dst;
        goto LABEL_36;
      }
    }
    std::string::append(&__dst, v21 - size, 0);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
    {
LABEL_37:
      std::string::__init_copy_ctor_external(&v24, __dst.__r_.__value_.__l.__data_, __dst.__r_.__value_.__l.__size_);
      goto LABEL_38;
    }
LABEL_34:
    std::string v24 = __dst;
LABEL_38:
    if (*(char *)(a2 + 23) < 0) {
      operator delete(*(void **)a2);
    }
    *(std::string *)a2 = v24;
    char v20 = HIBYTE(__dst.__r_.__value_.__r.__words[2]);
  }
  if (v20 < 0) {
    operator delete(__dst.__r_.__value_.__l.__data_);
  }
  return (uint64_t)v3;
}

void sub_180174E9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

BOOL ZinCFStringEquals(const __CFString *a1, const __CFString *a2)
{
  return CFEqual(a1, a2);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  unint64_t result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E4FBA4D0] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E4FBA350], MEMORY[0x1E4FBA1F8]);
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::vector<int>::pointer end = this->__end_;
  value = this->__end_cap_.__value_;
  size_t v6 = end;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(end, 4 * __n);
      size_t v6 = &end[__n];
    }
    this->__end_ = v6;
  }
  else
  {
    std::vector<int>::pointer begin = this->__begin_;
    uint64_t v8 = (char *)end - (char *)this->__begin_;
    uint64_t v9 = v8 >> 2;
    unint64_t v10 = (v8 >> 2) + __n;
    if (v10 >> 62) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    uint64_t v11 = (char *)value - (char *)begin;
    if (v11 >> 1 > v10) {
      unint64_t v10 = v11 >> 1;
    }
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL) {
      unint64_t v12 = 0x3FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v12 = v10;
    }
    if (v12)
    {
      if (v12 >> 62) {
        std::__throw_bad_array_new_length[abi:ne180100]();
      }
      uint64_t v13 = operator new(4 * v12);
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v14 = &v13[4 * v9];
    size_t v15 = 4 * __n;
    uint64_t v16 = (int *)&v13[4 * v12];
    bzero(v14, v15);
    id v17 = (int *)&v14[v15];
    if (end != begin)
    {
      unint64_t v18 = (char *)end - (char *)begin - 4;
      if (v18 < 0x2C) {
        goto LABEL_31;
      }
      if ((unint64_t)((char *)end - v13 - v8) < 0x20) {
        goto LABEL_31;
      }
      uint64_t v19 = (v18 >> 2) + 1;
      uint64_t v20 = 4 * (v19 & 0x7FFFFFFFFFFFFFF8);
      size_t v6 = &end[v20 / 0xFFFFFFFFFFFFFFFCLL];
      v14 -= v20;
      size_t v21 = &v13[4 * v9 - 16];
      uint64_t v22 = (long long *)(end - 4);
      uint64_t v23 = v19 & 0x7FFFFFFFFFFFFFF8;
      do
      {
        long long v24 = *v22;
        *(v21 - 1) = *(v22 - 1);
        *size_t v21 = v24;
        v21 -= 2;
        v22 -= 2;
        v23 -= 8;
      }
      while (v23);
      if (v19 != (v19 & 0x7FFFFFFFFFFFFFF8))
      {
LABEL_31:
        do
        {
          int v25 = *--v6;
          *((_DWORD *)v14 - 1) = v25;
          v14 -= 4;
        }
        while (v6 != begin);
      }
    }
    this->__begin_ = (std::vector<int>::pointer)v14;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
    {
      operator delete(begin);
    }
  }
}

void std::vector<int>::__throw_length_error[abi:ne180100]()
{
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  uint64_t v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8) {
      std::string::__throw_length_error[abi:ne180100]();
    }
    std::string::size_type v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17) {
      std::string::size_type v6 = __sz | 7;
    }
    std::string::size_type v7 = v6 + 1;
    uint64_t v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    uint64_t v5 = v8;
  }
  else
  {
    *((unsigned char *)&this->__r_.__value_.__s + 23) = __sz;
  }

  memmove(v5, __s, __sz + 1);
}

void std::__tree<std::string>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::string>::destroy(a1, *(void *)a2);
    std::__tree<std::string>::destroy(a1, *((void *)a2 + 1));
    if (a2[55] < 0) {
      operator delete(*((void **)a2 + 4));
    }
    operator delete(a2);
  }
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  *((unsigned char *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      uint64_t v2 = a2[2];
      if (*(unsigned char *)(v2 + 24)) {
        break;
      }
      CFStringRef v3 = *(uint64_t **)(v2 + 16);
      uint64_t v4 = *v3;
      if (*v3 == v2)
      {
        uint64_t v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), uint64_t v5 = (unsigned char *)(v7 + 24), v8))
        {
          if (*(uint64_t **)v2 == a2)
          {
            uint64_t v9 = (uint64_t *)a2[2];
          }
          else
          {
            uint64_t v9 = *(uint64_t **)(v2 + 8);
            uint64_t v10 = *v9;
            *(void *)(v2 + 8) = *v9;
            if (v10)
            {
              *(void *)(v10 + 16) = v2;
              CFStringRef v3 = *(uint64_t **)(v2 + 16);
            }
            v9[2] = (uint64_t)v3;
            *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = v9;
            *uint64_t v9 = v2;
            *(void *)(v2 + 16) = v9;
            CFStringRef v3 = (uint64_t *)v9[2];
            uint64_t v2 = *v3;
          }
          *((unsigned char *)v9 + 24) = 1;
          *((unsigned char *)v3 + 24) = 0;
          uint64_t v14 = *(void *)(v2 + 8);
          uint64_t *v3 = v14;
          if (v14) {
            *(void *)(v14 + 16) = v3;
          }
          *(void *)(v2 + 16) = v3[2];
          *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v2;
          *(void *)(v2 + 8) = v3;
          v3[2] = v2;
          return result;
        }
      }
      else if (!v4 || (int v6 = *(unsigned __int8 *)(v4 + 24), v5 = (unsigned char *)(v4 + 24), v6))
      {
        if (*(uint64_t **)v2 == a2)
        {
          uint64_t v11 = a2[1];
          *(void *)uint64_t v2 = v11;
          if (v11)
          {
            *(void *)(v11 + 16) = v2;
            CFStringRef v3 = *(uint64_t **)(v2 + 16);
          }
          a2[2] = (uint64_t)v3;
          *(void *)(*(void *)(v2 + 16) + 8 * (**(void **)(v2 + 16) != v2)) = a2;
          a2[1] = v2;
          *(void *)(v2 + 16) = a2;
          CFStringRef v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((unsigned char *)a2 + 24) = 1;
        *((unsigned char *)v3 + 24) = 0;
        unint64_t v12 = (uint64_t *)v3[1];
        uint64_t v13 = *v12;
        v3[1] = *v12;
        if (v13) {
          *(void *)(v13 + 16) = v3;
        }
        v12[2] = v3[2];
        *(void *)(v3[2] + 8 * (*(void *)v3[2] != (void)v3)) = v12;
        uint64_t *v12 = (uint64_t)v3;
        v3[2] = (uint64_t)v12;
        return result;
      }
      *(unsigned char *)(v2 + 24) = 1;
      a2 = v3;
      *((unsigned char *)v3 + 24) = v3 == result;
      unsigned char *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

__CFString *ZinIrKernelFormatToCFString(unsigned int a1)
{
  if (a1 > 0x20) {
    return @"Int8";
  }
  else {
    return (__CFString *)qword_1E4FBE670[a1];
  }
}

uint64_t ZinKernelModeIsSparse(unsigned int a1)
{
  return (a1 < 0xF) & (0x7E04u >> a1);
}

BOOL ZinKernelModeIsPalette(int a1)
{
  return (a1 - 3) < 0xC;
}

void ZinAssertImpl(const char *__format, ...)
{
  va_start(va, __format);
  uint64_t v3 = *MEMORY[0x1E4F143B8];
  vsnprintf(__str, 0x200uLL, __format, va);
  __str[511] = 0;
  exception = (ZinException *)__cxa_allocate_exception(0x98uLL);
  ZinException::ZinException(exception, __str);
}

void sub_180175484(_Unwind_Exception *a1)
{
  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void ZinException::~ZinException(std::runtime_error *this)
{
  this->__vftable = (std::runtime_error_vtbl *)&unk_1EC9954E8;
  if (!LOBYTE(this[9].__vftable) || (SHIBYTE(this[8].__imp_.__imp_) & 0x80000000) == 0)
  {
    if (!LOBYTE(this[7].__vftable)) {
      goto LABEL_15;
    }
LABEL_4:
    if (SHIBYTE(this[6].__imp_.__imp_) < 0)
    {
      operator delete((void *)this[5].__imp_.__imp_);
      if ((SHIBYTE(this[5].__vftable) & 0x80000000) == 0)
      {
LABEL_6:
        if ((SHIBYTE(this[3].__imp_.__imp_) & 0x80000000) == 0) {
          goto LABEL_7;
        }
        goto LABEL_13;
      }
    }
    else if ((SHIBYTE(this[5].__vftable) & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(this[4].__vftable);
    if ((SHIBYTE(this[3].__imp_.__imp_) & 0x80000000) == 0)
    {
LABEL_7:
      if ((SHIBYTE(this[2].__vftable) & 0x80000000) == 0) {
        goto LABEL_15;
      }
LABEL_14:
      operator delete(this[1].__vftable);
      goto LABEL_15;
    }
LABEL_13:
    operator delete((void *)this[2].__imp_.__imp_);
    if ((SHIBYTE(this[2].__vftable) & 0x80000000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  operator delete((void *)this[7].__imp_.__imp_);
  if (LOBYTE(this[7].__vftable)) {
    goto LABEL_4;
  }
LABEL_15:

  std::runtime_error::~runtime_error(this);
}

{
  void *v2;
  uint64_t vars8;

  this->__vftable = (std::runtime_error_vtbl *)&unk_1EC9954E8;
  if (!LOBYTE(this[9].__vftable) || (SHIBYTE(this[8].__imp_.__imp_) & 0x80000000) == 0)
  {
    if (!LOBYTE(this[7].__vftable)) {
      goto LABEL_15;
    }
LABEL_4:
    if (SHIBYTE(this[6].__imp_.__imp_) < 0)
    {
      operator delete((void *)this[5].__imp_.__imp_);
      if ((SHIBYTE(this[5].__vftable) & 0x80000000) == 0)
      {
LABEL_6:
        if ((SHIBYTE(this[3].__imp_.__imp_) & 0x80000000) == 0) {
          goto LABEL_7;
        }
        goto LABEL_13;
      }
    }
    else if ((SHIBYTE(this[5].__vftable) & 0x80000000) == 0)
    {
      goto LABEL_6;
    }
    operator delete(this[4].__vftable);
    if ((SHIBYTE(this[3].__imp_.__imp_) & 0x80000000) == 0)
    {
LABEL_7:
      if ((SHIBYTE(this[2].__vftable) & 0x80000000) == 0) {
        goto LABEL_15;
      }
LABEL_14:
      operator delete(this[1].__vftable);
      goto LABEL_15;
    }
LABEL_13:
    operator delete((void *)this[2].__imp_.__imp_);
    if ((SHIBYTE(this[2].__vftable) & 0x80000000) == 0) {
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  operator delete((void *)this[7].__imp_.__imp_);
  if (LOBYTE(this[7].__vftable)) {
    goto LABEL_4;
  }
LABEL_15:
  std::runtime_error::~runtime_error(this);

  operator delete(v2);
}

void ZinException::ZinException(ZinException *this, const char *a2)
{
  uint64_t v2 = std::runtime_error::runtime_error((std::runtime_error *)this, a2);
  v2->__vftable = (std::runtime_error_vtbl *)&unk_1EC9954E8;
  LOBYTE(v2[1].__vftable) = 0;
  LOBYTE(v2[7].__vftable) = 0;
  LOBYTE(v2[7].__imp_.__imp_) = 0;
  LOBYTE(v2[9].__vftable) = 0;
}

__CFString *ZinIrPoolingTypeToCFString(unsigned int a1)
{
  if (a1 > 0xE) {
    return @"Avg";
  }
  else {
    return (__CFString *)qword_1E4FBE778[a1];
  }
}

__CFString *ZinIrConvTypeToCFString(unsigned int a1)
{
  if (a1 > 6) {
    return @"Conv";
  }
  else {
    return (__CFString *)qword_1E4FBE7F0[a1];
  }
}

__CFString *ZinIrConvKernelModeToCFString(unsigned int a1)
{
  if (a1 > 0xF) {
    return @"Dense";
  }
  else {
    return (__CFString *)qword_1E4FBE828[a1];
  }
}

__CFString *ZinIrEWTypeToCFString(unsigned int a1)
{
  if (a1 > 0x15) {
    return @"Add";
  }
  else {
    return (__CFString *)qword_1E4FBE8A8[a1];
  }
}

__CFString *ZinIrFlattenTypeToCFString(int a1)
{
  v1 = @"NCHW";
  if (a1 != 1) {
    v1 = 0;
  }
  if (a1 == 2) {
    return @"NHWC";
  }
  else {
    return v1;
  }
}

uint64_t ZinIrTEPaddingModeToCFString(int a1)
{
  if ((a1 - 1) > 6) {
    return 0;
  }
  else {
    return (uint64_t)*(&off_1E4FBE958 + a1 - 1);
  }
}

__CFString *ZinIrSamplingMethodToCFString(int a1)
{
  if (a1) {
    return @"NearestNeighbor";
  }
  else {
    return @"Linear";
  }
}

__CFString *ZinIrSamplingGridModeToCFStringRef(unsigned int a1)
{
  if (a1 > 5) {
    return @"StrictAlignedCorners";
  }
  else {
    return off_1E4FBE990[a1];
  }
}

__CFString *ZinIrNormalizedCoordinateRangeToCFString(int a1)
{
  if (a1) {
    return @"RangeMinusOneToOne";
  }
  else {
    return @"RangeZeroToOne";
  }
}

__CFString *ZinIrCoordinateModeToCFString(int a1)
{
  v1 = @"NonNormalized";
  if (a1 == 1) {
    v1 = @"NormalizedSymmetric";
  }
  if (a1 == 2) {
    return @"NormalizedReflect";
  }
  else {
    return v1;
  }
}

__CFString *ZinIrCropResizeBoxModeToCFString(unsigned int a1)
{
  if (a1 > 0xF) {
    return 0;
  }
  else {
    return off_1E4FBE9C0[a1];
  }
}

__CFString *ZinIrCoordinateToCFString(_DWORD *a1)
{
  unsigned int v1 = *a1 - 1;
  if (v1 > 4) {
    return @"Batch";
  }
  else {
    return off_1E4FBEA40[v1];
  }
}

__CFString *GlobalArgTypeToCFString(int *a1)
{
  uint64_t v1 = *a1;
  if (v1 > 6) {
    return @"Min";
  }
  else {
    return (__CFString *)qword_1E4FBEA68[v1];
  }
}

uint64_t ToCharDimension(int a1, unsigned char *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  v15[0] = xmmword_1810FDFD0;
  v15[1] = unk_1810FDFE0;
  uint64_t v16 = 0x5700000004;
  std::map<ZinIrDimension,char>::map[abi:ne180100](&v13, (int *)v15, 5);
  uint64_t v4 = (void *)v14[0];
  if (!v14[0]) {
    goto LABEL_12;
  }
  uint64_t v5 = v14;
  int v6 = (uint64_t *)v14[0];
  do
  {
    uint64_t v7 = v6;
    int v8 = v5;
    int v9 = *((_DWORD *)v6 + 7);
    if (v9 >= a1) {
      uint64_t v5 = v6;
    }
    else {
      ++v6;
    }
    int v6 = (uint64_t *)*v6;
  }
  while (v6);
  if (v5 != v14 && (v9 >= a1 ? (uint64_t v10 = v7) : (uint64_t v10 = v8), *((_DWORD *)v10 + 7) <= a1))
  {
    *a2 = *((unsigned char *)v5 + 32);
    uint64_t v11 = 1;
  }
  else
  {
LABEL_12:
    uint64_t v11 = 0;
  }
  std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v13, v4);
  return v11;
}

void **std::map<ZinIrDimension,char>::map[abi:ne180100](void **a1, int *a2, uint64_t a3)
{
  a1[1] = 0;
  uint64_t v4 = (uint64_t *)(a1 + 1);
  a1[2] = 0;
  *a1 = a1 + 1;
  if (a3)
  {
    uint64_t v6 = 8 * a3;
    do
    {
      uint64_t v7 = std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::__find_equal<ZinIrDimension>(a1, v4, &v13, &v12, a2);
      if (!*v7)
      {
        int v8 = (uint64_t *)operator new(0x28uLL);
        *(uint64_t *)((char *)v8 + 28) = *(void *)a2;
        int v9 = v13;
        uint64_t *v8 = 0;
        v8[1] = 0;
        v8[2] = (uint64_t)v9;
        *uint64_t v7 = (uint64_t)v8;
        uint64_t v10 = (void *)**a1;
        if (v10)
        {
          *a1 = v10;
          int v8 = (uint64_t *)*v7;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], v8);
        a1[2] = (void *)((char *)a1[2] + 1);
      }
      a2 += 2;
      v6 -= 8;
    }
    while (v6);
  }
  return a1;
}

void sub_180175A4C(_Unwind_Exception *a1)
{
  std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy(v1, *(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::__find_equal<ZinIrDimension>(void *a1, uint64_t *a2, uint64_t **a3, uint64_t **a4, int *a5)
{
  uint64_t v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, int v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    int v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      uint64_t v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      int v9 = (uint64_t *)*a2;
      do
      {
        uint64_t v10 = v9;
        int v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      uint64_t v14 = a2;
      do
      {
        uint64_t v10 = (uint64_t *)v14[2];
        BOOL v15 = *v10 == (void)v14;
        uint64_t v14 = v10;
      }
      while (v15);
    }
    int v16 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5) {
      goto LABEL_17;
    }
    uint64_t v18 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          uint64_t v19 = (uint64_t *)v18;
          int v20 = *(_DWORD *)(v18 + 28);
          if (v16 >= v20) {
            break;
          }
          uint64_t v18 = *v19;
          uint64_t v5 = v19;
          if (!*v19) {
            goto LABEL_25;
          }
        }
        if (v20 >= v16) {
          break;
        }
        uint64_t v5 = v19 + 1;
        uint64_t v18 = v19[1];
      }
      while (v18);
    }
    else
    {
      uint64_t v19 = a1 + 1;
    }
LABEL_25:
    *a3 = v19;
    return v5;
  }
  else if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return (uint64_t *)a4;
  }
  else
  {
    uint64_t v11 = a2[1];
    if (v11)
    {
      unint64_t v12 = (uint64_t *)a2[1];
      do
      {
        uint64_t v13 = v12;
        unint64_t v12 = (uint64_t *)*v12;
      }
      while (v12);
    }
    else
    {
      size_t v21 = a2;
      do
      {
        uint64_t v13 = (uint64_t *)v21[2];
        BOOL v15 = *v13 == (void)v21;
        size_t v21 = v13;
      }
      while (!v15);
    }
    if (v13 == v5 || v6 < *((_DWORD *)v13 + 7))
    {
      if (v11)
      {
        *a3 = v13;
        return v13;
      }
      else
      {
        *a3 = a2;
        return a2 + 1;
      }
    }
    else
    {
      uint64_t v22 = *v5;
      if (*v5)
      {
        do
        {
          while (1)
          {
            uint64_t v23 = (uint64_t *)v22;
            int v24 = *(_DWORD *)(v22 + 28);
            if (v6 >= v24) {
              break;
            }
            uint64_t v22 = *v23;
            uint64_t v5 = v23;
            if (!*v23) {
              goto LABEL_41;
            }
          }
          if (v24 >= v6) {
            break;
          }
          uint64_t v5 = v23 + 1;
          uint64_t v22 = v23[1];
        }
        while (v22);
      }
      else
      {
        uint64_t v23 = a1 + 1;
      }
LABEL_41:
      *a3 = v23;
      return v5;
    }
  }
}

void std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy(uint64_t a1, void *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

BOOL ZinIrKernelQuantizationInfo::HasDefaultQuantizationScalarScale(ZinIrKernelQuantizationInfo *this)
{
  return !*(unsigned char *)this && *((float *)this + 11) == 1.0;
}

BOOL ZinIrKernelQuantizationInfo::HasDefaultQuantizationScalarZeroPoint(ZinIrKernelQuantizationInfo *this)
{
  return !*((unsigned char *)this + 1) && *((_DWORD *)this + 12) == 0;
}

uint64_t ZinIrTextureUnitInfo::DynamicShapeOutputTensorDimensions()
{
  return 3;
}

void ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(ZinIrTextureUnitInfo *this)
{
  ZinIrTextureUnitInfo::~ZinIrTextureUnitInfo(this);

  operator delete(v1);
}

{
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(void *)this = &unk_1EC995BD0;
  uint64_t v2 = (void *)*((void *)this + 16);
  if (v2)
  {
    *((void *)this + 17) = v2;
    operator delete(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 13);
  if (v3)
  {
    *((void *)this + 14) = v3;
    operator delete(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 10);
  if (v4)
  {
    *((void *)this + 11) = v4;
    operator delete(v4);
  }
  *(void *)this = &unk_1EC995568;
  uint64_t v5 = *((void *)this + 5);
  if (v5)
  {
    int v6 = *((void *)this + 6);
    int v7 = (void *)*((void *)this + 5);
    if (v6 != v5)
    {
      do
      {
        if (*(char *)(v6 - 1) < 0) {
          operator delete(*(void **)(v6 - 24));
        }
        v6 -= 24;
      }
      while (v6 != v5);
      int v7 = (void *)*((void *)this + 5);
    }
    *((void *)this + 6) = v5;
    operator delete(v7);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

void ZinIrUnitInfo::~ZinIrUnitInfo(ZinIrUnitInfo *this)
{
  *(void *)this = &unk_1EC995568;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 6);
    uint64_t v4 = (void *)*((void *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 5);
    }
    *((void *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }
}

{
  uint64_t v2;
  uint64_t v3;
  void *v4;
  uint64_t vars8;

  *(void *)this = &unk_1EC995568;
  uint64_t v2 = *((void *)this + 5);
  if (v2)
  {
    uint64_t v3 = *((void *)this + 6);
    uint64_t v4 = (void *)*((void *)this + 5);
    if (v3 != v2)
    {
      do
      {
        if (*(char *)(v3 - 1) < 0) {
          operator delete(*(void **)(v3 - 24));
        }
        v3 -= 24;
      }
      while (v3 != v2);
      uint64_t v4 = (void *)*((void *)this + 5);
    }
    *((void *)this + 6) = v2;
    operator delete(v4);
  }
  if (*((char *)this + 31) < 0) {
    operator delete(*((void **)this + 1));
  }

  operator delete(this);
}

__CFDictionary *ZinCreateArgMinMaxUnit(const ZinIrArgMinMaxUnitInfo *a1)
{
  Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v5 = Mutable;
  uint64_t v6 = *((int *)a1 + 30);
  if (v6 > 4) {
    int v7 = @"SpatialArgMin";
  }
  else {
    int v7 = (__CFString *)qword_1E4FBEAA0[v6];
  }
  CFDictionaryAddValue(Mutable, @"Mode", v7);
  if ((*((_DWORD *)a1 + 30) | 2) == 3)
  {
    int v8 = *((_DWORD *)a1 + 21);
    int v15 = *((_DWORD *)a1 + 20);
    int valuePtr = v8;
    CFNumberRef v9 = CFNumberCreate(v3, kCFNumberSInt32Type, &valuePtr);
    CFNumberRef v10 = CFNumberCreate(v3, kCFNumberSInt32Type, &v15);
    CFDictionaryAddValue(v5, @"KernelWidth", v9);
    CFDictionaryAddValue(v5, @"KernelHeight", v10);
    CFRelease(v9);
    CFRelease(v10);
    uint64_t v11 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
    CFNumberRef v12 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 92);
    CFNumberRef v13 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 88);
    CFArrayAppendValue(v11, v12);
    CFArrayAppendValue(v11, v13);
    CFRelease(v12);
    CFRelease(v13);
    CFDictionaryAddValue(v5, @"Step", v11);
    CFRelease(v11);
    ZinAddPaddingToParamsDict(v5, (uint64_t)a1 + 96, 0);
  }
  CFDictionaryAddValue(Unit, @"Params", v5);
  CFRelease(v5);
  return Unit;
}

__CFDictionary *ZinCreateBatchToSpaceUnit(const ZinIrBatchToSpaceUnitInfo *a1)
{
  Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = 35;
  ZinAddSpaceTransformFactorToParamsDict(Mutable, &v5, (uint64_t)a1 + 80);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

CFMutableDictionaryRef ZinCreateBroadcastUnit(const ZinIrBroadcastUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  uint64_t v4 = (uint64_t *)*((void *)a1 + 12);
  if (v4)
  {
    int v5 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    uint64_t v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    do
    {
      int v7 = CFDictionaryCreateMutable(v2, 0, v5, v6);
      int valuePtr = v4[3];
      CFNumberRef v8 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
      CFNumberRef v9 = ZinIrCoordinateToCFString((_DWORD *)v4 + 4);
      CFDictionaryAddValue(v7, @"Dimension", v9);
      CFDictionaryAddValue(v7, @"Size", v8);
      CFArrayAppendValue(Mutable, v7);
      CFRelease(v8);
      CFRelease(v7);
      uint64_t v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  CFDictionaryAddValue(theDict, @"BroadcastInfo", Mutable);
  CFDictionaryAddValue(Unit, @"Params", theDict);
  CFRelease(Mutable);
  CFRelease(theDict);
  return Unit;
}

__CFDictionary *ZinCreateChannelToSpaceUnit(const ZinIrChannelToSpaceUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = 37;
  ZinAddSpaceTransformFactorToParamsDict(Mutable, &v5, (uint64_t)a1 + 80);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateConcatUnit(const ZinIrConcatUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v4 = ZinIrCoordinateToCFString((_DWORD *)a1 + 20);
  CFDictionaryAddValue(Mutable, @"Dimension", v4);
  int v5 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!*((unsigned char *)a1 + 84)) {
    int v5 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryAddValue(Mutable, @"Interleaved", *v5);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateConvUnit(const ZinIrConvUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int valuePtr = *((void *)a1 + 31);
  CFNumberRef v5 = CFNumberCreate(v3, kCFNumberSInt32Type, &valuePtr);
  CFDictionaryAddValue(Unit, @"NumGroups", v5);
  CFRelease(v5);
  uint64_t v6 = ZinIrConvTypeToCFString(*((_DWORD *)a1 + 60));
  CFDictionaryAddValue(Mutable, @"Type", v6);
  if ((*((_DWORD *)a1 + 60) - 5) <= 1) {
    ZinAddKernelDilationRateToParamsDict(Mutable, (char *)a1 + 280);
  }
  int v7 = (const void *)*MEMORY[0x1E4F1CFD0];
  CFNumberRef v8 = (const void *)*MEMORY[0x1E4F1CFC8];
  if (*((unsigned char *)a1 + 244)) {
    CFNumberRef v9 = (const void *)*MEMORY[0x1E4F1CFD0];
  }
  else {
    CFNumberRef v9 = (const void *)*MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryAddValue(Mutable, @"KernelGroupReuse", v9);
  CFNumberRef v10 = ZinIrConvKernelModeToCFString(*((_DWORD *)a1 + 20));
  if (v10) {
    CFDictionaryAddValue(Mutable, @"KernelMode", v10);
  }
  if (*((unsigned char *)a1 + 180)) {
    uint64_t v11 = v7;
  }
  else {
    uint64_t v11 = v8;
  }
  CFDictionaryAddValue(Mutable, @"KernelMutable", v11);
  CFNumberRef v12 = ZinIrKernelFormatToCFString(*((_DWORD *)a1 + 21));
  if (v12) {
    CFDictionaryAddValue(Mutable, @"KernelType", v12);
  }
  ZinAddKernelSizeToParamsDict(Mutable, (void *)a1 + 32, 1);
  if (ZinKernelModeIsPalette(*((_DWORD *)a1 + 20)))
  {
    ZinDictionaryAddVector<long long>(Mutable, @"KernelPaletteLUTOffset", (uint64_t *)a1 + 19);
    ZinDictionaryAddVector<int>(Mutable, @"KernelPaletteLUTIndex", (char **)a1 + 16);
    CFNumberRef v13 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 176);
    CFDictionaryAddValue(Mutable, @"KernelPaletteVectorSize", v13);
    CFRelease(v13);
  }
  if (ZinKernelModeIsSparse(*((_DWORD *)a1 + 20)))
  {
    CFNumberRef v14 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 112);
    CFDictionaryAddValue(Mutable, @"KernelMaskByteOffset", v14);
    CFRelease(v14);
    CFNumberRef v15 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 104);
    CFDictionaryAddValue(Mutable, @"KernelMaskIndex", v15);
    CFRelease(v15);
    CFNumberRef v16 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 120);
    CFDictionaryAddValue(Mutable, @"KernelCoeffCount", v16);
    CFRelease(v16);
  }
  if (*((_DWORD *)a1 + 20) != 15)
  {
    CFNumberRef v17 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 96);
    CFDictionaryAddValue(Mutable, @"KernelOffset", v17);
    CFRelease(v17);
    CFNumberRef v18 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 88);
    CFDictionaryAddValue(Mutable, @"KernelIndex", v18);
    CFRelease(v18);
  }
  ZinAddStepsToParamsDict(Mutable, (uint64_t)a1 + 292, 1);
  ZinAddPaddingToParamsDict(Mutable, (uint64_t)a1 + 304, 1);
  uint64_t v19 = ZinIrPaddingModeToCFString(*((_DWORD *)a1 + 82));
  CFDictionaryAddValue(Mutable, @"PaddingMode", v19);
  if (*((unsigned char *)a1 + 184))
  {
    int v20 = ZinIrKernelFormatToCFString(*((_DWORD *)a1 + 56));
    if (v20) {
      CFDictionaryAddValue(Mutable, @"KernelPerCoutScaleFormat", v20);
    }
    CFNumberRef v21 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 200);
    CFDictionaryAddValue(Mutable, @"KernelScaleByteOffset", v21);
    CFRelease(v21);
    CFNumberRef v22 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 192);
    uint64_t v23 = @"KernelScaleIndex";
  }
  else
  {
    if (ZinIrKernelQuantizationInfo::HasDefaultQuantizationScalarScale((const ZinIrConvUnitInfo *)((char *)a1 + 184))) {
      goto LABEL_26;
    }
    CFNumberRef v22 = CFNumberCreate(v3, kCFNumberFloat32Type, (char *)a1 + 228);
    uint64_t v23 = @"KernelScaleScalar";
  }
  CFDictionaryAddValue(Mutable, v23, v22);
  CFRelease(v22);
LABEL_26:
  if (*((unsigned char *)a1 + 185))
  {
    int v24 = (char *)a1 + 208;
    CFNumberRef v25 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 216);
    CFDictionaryAddValue(Mutable, @"KernelZeroPointByteOffset", v25);
    CFRelease(v25);
    CFNumberRef v26 = CFNumberCreate(v3, kCFNumberSInt32Type, v24);
    uint64_t v27 = @"KernelZeroPointIndex";
LABEL_30:
    CFDictionaryAddValue(Mutable, v27, v26);
    CFRelease(v26);
    goto LABEL_31;
  }
  if (!ZinIrKernelQuantizationInfo::HasDefaultQuantizationScalarZeroPoint((const ZinIrConvUnitInfo *)((char *)a1 + 184)))
  {
    CFNumberRef v26 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 232);
    uint64_t v27 = @"KernelZeroPointScalar";
    goto LABEL_30;
  }
LABEL_31:
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

void ZinDictionaryAddVector<long long>(__CFDictionary *a1, const void *a2, uint64_t *a3)
{
  uint64_t v6 = *a3;
  uint64_t v5 = a3[1];
  uint64_t v7 = v5 - *a3;
  if (v5 == *a3)
  {
    CFNumberRef v9 = 0;
    uint64_t v11 = 0;
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v13 = a3[1];
  }
  else
  {
    if (v7 < 0) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    CFNumberRef v9 = (CFTypeRef *)operator new(v5 - v6);
    bzero(v9, v5 - v6);
    uint64_t v10 = 0;
    uint64_t v11 = (CFTypeRef *)((char *)v9 + v7);
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    do
    {
      v9[v10] = CFNumberCreate(v12, kCFNumberSInt64Type, (const void *)(v6 + v10 * 8));
      ++v10;
    }
    while (v6 + v10 * 8 != v5);
    uint64_t v5 = *a3;
    uint64_t v13 = a3[1];
  }
  CFArrayRef v14 = CFArrayCreate(v12, v9, (v13 - v5) >> 3, MEMORY[0x1E4F1D510]);
  CFDictionaryAddValue(a1, a2, v14);
  if (v9 != v11)
  {
    CFNumberRef v15 = v9;
    do
      CFRelease(*v15++);
    while (v15 != v11);
  }
  CFRelease(v14);
  if (v9)
  {
    operator delete(v9);
  }
}

void sub_180176A70(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void ZinDictionaryAddVector<int>(__CFDictionary *a1, const void *a2, char **a3)
{
  uint64_t v5 = *a3;
  uint64_t v6 = a3[1];
  unint64_t v7 = v6 - *a3;
  if (v6 == *a3)
  {
    uint64_t v10 = 0;
    uint64_t v11 = 0;
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    CFArrayRef v14 = a3[1];
  }
  else
  {
    if (v7 >= 0x7FFFFFFFFFFFFFFDLL) {
      std::vector<int>::__throw_length_error[abi:ne180100]();
    }
    size_t v9 = 2 * v7;
    uint64_t v10 = (CFTypeRef *)operator new(2 * v7);
    bzero(v10, v9);
    uint64_t v11 = (CFTypeRef *)((char *)v10 + v9);
    CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
    uint64_t v13 = (CFNumberRef *)v10;
    do
    {
      *v13++ = CFNumberCreate(v12, kCFNumberSInt32Type, v5);
      v5 += 4;
    }
    while (v5 != v6);
    uint64_t v6 = *a3;
    CFArrayRef v14 = a3[1];
  }
  CFArrayRef v15 = CFArrayCreate(v12, v10, (v14 - v6) >> 2, MEMORY[0x1E4F1D510]);
  CFDictionaryAddValue(a1, a2, v15);
  if (v10 != v11)
  {
    CFNumberRef v16 = v10;
    do
      CFRelease(*v16++);
    while (v16 != v11);
  }
  CFRelease(v15);
  if (v10)
  {
    operator delete(v10);
  }
}

void sub_180176C24(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFDictionary *ZinCreateCropResizeUnit(const ZinIrCropResizeUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  TextureCommonCFMutableDictionaryRef Unit = ZinCreateTextureCommonUnit(a1);
  TextureUnitSamplingGridInfo = ZinCreateTextureUnitSamplingGridInfo((uint64_t)a1 + 160);
  CFDictionaryAddValue(TextureCommonUnit, @"SamplingGridInfo", TextureUnitSamplingGridInfo);
  CFRelease(TextureUnitSamplingGridInfo);
  uint64_t v5 = ZinIrCropResizeBoxModeToCFString(*((_DWORD *)a1 + 39));
  CFDictionaryAddValue(TextureCommonUnit, @"CoordinateMode", v5);
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  if ((*((_DWORD *)a1 + 39) & 0xFFFFFFF4) != 0)
  {
    CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (char *)a1 + 192);
    CFDictionaryAddValue(TextureCommonUnit, @"CropWidth", v7);
    CFRelease(v7);
    CFNumberRef v8 = CFNumberCreate(v6, kCFNumberSInt32Type, (char *)a1 + 196);
    CFDictionaryAddValue(TextureCommonUnit, @"CropHeight", v8);
    CFRelease(v8);
  }
  CFNumberRef v9 = CFNumberCreate(v6, kCFNumberSInt32Type, (char *)a1 + 184);
  CFDictionaryAddValue(TextureCommonUnit, @"OutputWidth", v9);
  CFRelease(v9);
  CFNumberRef v10 = CFNumberCreate(v6, kCFNumberSInt32Type, (char *)a1 + 188);
  CFDictionaryAddValue(TextureCommonUnit, @"OutputHeight", v10);
  CFRelease(v10);
  CFDictionaryAddValue(Unit, @"Params", TextureCommonUnit);
  CFRelease(TextureCommonUnit);
  return Unit;
}

__CFDictionary *ZinCreateDeQuantUnit(const ZinIrDeQuantUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v5 = Mutable;
  if (*((int *)a1 + 22) < 1)
  {
    CFNumberRef v6 = CFNumberCreate(v3, kCFNumberFloat32Type, (char *)a1 + 128);
    CFDictionaryAddValue(v5, @"DeQuantScale", v6);
    int v10 = 6;
    ZinSetFormat(@"DeQuantScaleType", &v10, v5);
    CFRelease(v6);
  }
  else
  {
    ZinAddWeightInfoToParamsDict(Mutable, 0, @"DeQuantScaleCount", @"DeQuantScaleIndex", @"DeQuantScaleOffset", (unsigned char *)a1 + 80);
  }
  ZinSetFormat(@"DeQuantScaleType", (_DWORD *)a1 + 34, v5);
  int v7 = *((_DWORD *)a1 + 28);
  if (v7 > 0 || *((_DWORD *)a1 + 33))
  {
    if (v7 < 1)
    {
      CFNumberRef v8 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 132);
      CFDictionaryAddValue(v5, @"DeQuantZeroPoint", v8);
      CFRelease(v8);
    }
    else
    {
      ZinAddWeightInfoToParamsDict(v5, 0, @"DeQuantZeroPointCount", @"DeQuantZeroPointIndex", @"DeQuantZeroPointOffset", (unsigned char *)a1 + 104);
    }
    ZinSetFormat(@"DeQuantZeroPointType", (_DWORD *)a1 + 35, v5);
  }
  CFDictionaryAddValue(Unit, @"Params", v5);
  CFRelease(v5);
  return Unit;
}

__CFDictionary *ZinCreateEWUnit(const ZinIrEWUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v4 = ZinIrEWTypeToCFString(*((_DWORD *)a1 + 20));
  if (v4) {
    CFDictionaryAddValue(Mutable, @"Type", v4);
  }
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateFlattenUnit(const ZinIrFlattenUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v4 = ZinIrFlattenTypeToCFString(*((_DWORD *)a1 + 20));
  CFDictionaryAddValue(Mutable, @"Mode", v4);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateGatherUnit(const ZinIrGatherUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v5 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  CFNumberRef v6 = (_DWORD *)*((void *)a1 + 20);
  for (uint64_t i = (_DWORD *)*((void *)a1 + 21); v6 != i; ++v6)
  {
    CFNumberRef v8 = ZinIrCoordinateToCFString(v6);
    CFArrayAppendValue(v5, v8);
  }
  CFDictionaryAddValue(Mutable, @"GatherNDAxes", v5);
  CFRelease(v5);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateGlobalArgMinMaxUnit(const ZinIrGlobalArgMinMaxUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v4 = GlobalArgTypeToCFString((int *)a1 + 20);
  CFDictionaryAddValue(Mutable, @"Type", v4);
  uint64_t v5 = ZinIrCoordinateToCFString((_DWORD *)a1 + 21);
  CFDictionaryAddValue(Mutable, @"Dimension", v5);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateInputViewUnit(const ZinIrInputViewUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFNumberRef v5 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 80);
  CFDictionaryAddValue(Mutable, @"Offset", v5);
  CFRelease(v5);
  CFNumberRef v6 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 84);
  CFDictionaryAddValue(Mutable, @"Size", v6);
  CFRelease(v6);
  CFNumberRef v7 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 88);
  CFDictionaryAddValue(Mutable, @"Step", v7);
  CFRelease(v7);
  CFNumberRef v8 = ZinIrCoordinateToCFString((_DWORD *)a1 + 23);
  CFDictionaryAddValue(Mutable, @"Dimension", v8);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateInstanceNormUnit(const ZinIrInstanceNormUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  _S0 = *((float *)a1 + 30);
  if (_S0 != 1.0e-12)
  {
    __asm { FCVT            H0, S0 }
    __int16 valuePtr = _H0;
    CFNumberRef v11 = CFNumberCreate(v3, kCFNumberSInt16Type, &valuePtr);
    CFDictionaryAddValue(Mutable, @"Epsilon", v11);
    CFRelease(v11);
  }
  CFAllocatorRef v12 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  for (uint64_t i = (uint64_t *)*((void *)a1 + 12); i; uint64_t i = (uint64_t *)*i)
  {
    CFArrayRef v14 = ZinIrCoordinateToCFString((_DWORD *)i + 4);
    CFArrayAppendValue(v12, v14);
  }
  CFDictionaryAddValue(Mutable, @"Dimension", v12);
  CFRelease(v12);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateLinearUnit(const ZinIrLinearUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*((_DWORD *)a1 + 60) != 5)
  {
    CFNumberRef v5 = ZinIrCoordinateToCFString((_DWORD *)a1 + 60);
    CFDictionaryAddValue(Mutable, @"GroupDimension", v5);
  }
  CFNumberRef v6 = ZinIrConvKernelModeToCFString(*((_DWORD *)a1 + 20));
  if (v6) {
    CFDictionaryAddValue(Mutable, @"KernelMode", v6);
  }
  CFNumberRef v7 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!*((unsigned char *)a1 + 180)) {
    CFNumberRef v7 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryAddValue(Mutable, @"KernelMutable", *v7);
  CFNumberRef v8 = ZinIrKernelFormatToCFString(*((_DWORD *)a1 + 21));
  if (v8) {
    CFDictionaryAddValue(Mutable, @"KernelType", v8);
  }
  if (ZinKernelModeIsPalette(*((_DWORD *)a1 + 20)))
  {
    ZinDictionaryAddVector<long long>(Mutable, @"KernelPaletteLUTOffset", (uint64_t *)a1 + 19);
    ZinDictionaryAddVector<int>(Mutable, @"KernelPaletteLUTIndex", (char **)a1 + 16);
    CFNumberRef v9 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 176);
    CFDictionaryAddValue(Mutable, @"KernelPaletteVectorSize", v9);
    CFRelease(v9);
  }
  if (ZinKernelModeIsSparse(*((_DWORD *)a1 + 20)))
  {
    CFNumberRef v10 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 112);
    CFDictionaryAddValue(Mutable, @"KernelMaskByteOffset", v10);
    CFRelease(v10);
    CFNumberRef v11 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 104);
    CFDictionaryAddValue(Mutable, @"KernelMaskIndex", v11);
    CFRelease(v11);
    CFNumberRef v12 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 120);
    CFDictionaryAddValue(Mutable, @"KernelCoeffCount", v12);
    CFRelease(v12);
  }
  if (*((_DWORD *)a1 + 20) != 15)
  {
    CFNumberRef v13 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 96);
    CFDictionaryAddValue(Mutable, @"KernelOffset", v13);
    CFRelease(v13);
    CFNumberRef v14 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 88);
    CFDictionaryAddValue(Mutable, @"KernelIndex", v14);
    CFRelease(v14);
  }
  if (*((unsigned char *)a1 + 184))
  {
    CFArrayRef v15 = ZinIrKernelFormatToCFString(*((_DWORD *)a1 + 56));
    if (v15) {
      CFDictionaryAddValue(Mutable, @"KernelPerCoutScaleFormat", v15);
    }
    CFNumberRef v16 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 200);
    CFDictionaryAddValue(Mutable, @"KernelScaleByteOffset", v16);
    CFRelease(v16);
    CFNumberRef v17 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 192);
    CFNumberRef v18 = @"KernelScaleIndex";
  }
  else
  {
    if (ZinIrKernelQuantizationInfo::HasDefaultQuantizationScalarScale((const ZinIrLinearUnitInfo *)((char *)a1 + 184))) {
      goto LABEL_22;
    }
    CFNumberRef v17 = CFNumberCreate(v3, kCFNumberFloat32Type, (char *)a1 + 228);
    CFNumberRef v18 = @"KernelScaleScalar";
  }
  CFDictionaryAddValue(Mutable, v18, v17);
  CFRelease(v17);
LABEL_22:
  if (*((unsigned char *)a1 + 185))
  {
    uint64_t v19 = (char *)a1 + 208;
    CFNumberRef v20 = CFNumberCreate(v3, kCFNumberSInt64Type, (char *)a1 + 216);
    CFDictionaryAddValue(Mutable, @"KernelZeroPointByteOffset", v20);
    CFRelease(v20);
    CFNumberRef v21 = CFNumberCreate(v3, kCFNumberSInt32Type, v19);
    CFNumberRef v22 = @"KernelZeroPointIndex";
LABEL_26:
    CFDictionaryAddValue(Mutable, v22, v21);
    CFRelease(v21);
    goto LABEL_27;
  }
  if (!ZinIrKernelQuantizationInfo::HasDefaultQuantizationScalarZeroPoint((const ZinIrLinearUnitInfo *)((char *)a1 + 184)))
  {
    CFNumberRef v21 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 232);
    CFNumberRef v22 = @"KernelZeroPointScalar";
    goto LABEL_26;
  }
LABEL_27:
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateMatrixMultUnit(const ZinIrMatrixMultUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*((unsigned char *)a1 + 80))
  {
    CFNumberRef v5 = CFNumberCreate(v3, kCFNumberShortType, (char *)a1 + 82);
    CFDictionaryAddValue(Mutable, @"Bias", v5);
    CFRelease(v5);
  }
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreatePadUnit(const ZinIrPadUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  ZinAddPaddingToParamsDict(Mutable, (uint64_t)a1 + 156, 1);
  CFNumberRef v5 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 180);
  CFDictionaryAddValue(Mutable, @"PadChannelFront", v5);
  CFRelease(v5);
  CFNumberRef v6 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 184);
  CFDictionaryAddValue(Mutable, @"PadChannelBack", v6);
  CFRelease(v6);
  CFNumberRef v7 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 188);
  CFDictionaryAddValue(Mutable, @"PadBatchFront", v7);
  CFRelease(v7);
  CFNumberRef v8 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 192);
  CFDictionaryAddValue(Mutable, @"PadBatchBack", v8);
  CFRelease(v8);
  CFNumberRef v9 = CFArrayCreateMutable(v3, 1, MEMORY[0x1E4F1D510]);
  CFNumberRef v10 = (_DWORD *)*((void *)a1 + 25);
  for (uint64_t i = (_DWORD *)*((void *)a1 + 26); v10 != i; v10 += 2)
  {
    PaddingInfo = ZinCreatePaddingInfo(v10);
    CFArrayAppendValue(v9, PaddingInfo);
    CFRelease(PaddingInfo);
  }
  CFDictionaryAddValue(Mutable, @"PaddingInfo", v9);
  CFRelease(v9);
  CFNumberRef v13 = CFNumberCreate(v3, kCFNumberSInt16Type, (char *)a1 + 224);
  CFDictionaryAddValue(Mutable, @"BackgroundValue", v13);
  CFRelease(v13);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreatePixelShuffleUnit(const ZinIrPixelShuffleUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = 31;
  ZinAddSpaceTransformFactorToParamsDict(Mutable, &v5, (uint64_t)a1 + 80);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreatePixelUnshuffleUnit(const ZinIrPixelUnshuffleUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = 32;
  ZinAddSpaceTransformFactorToParamsDict(Mutable, &v5, (uint64_t)a1 + 80);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateQuantUnit(const ZinIrQuantUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = Mutable;
  if (*((int *)a1 + 22) < 1)
  {
    CFNumberRef v6 = CFNumberCreate(v3, kCFNumberFloat32Type, (char *)a1 + 128);
    CFDictionaryAddValue(v5, @"QuantScale", v6);
    CFRelease(v6);
  }
  else
  {
    ZinAddWeightInfoToParamsDict(Mutable, 0, @"ScaleCount", @"ScaleIndex", @"ScaleOffset", (unsigned char *)a1 + 80);
  }
  int v7 = *((_DWORD *)a1 + 28);
  if (v7 > 0 || *((_DWORD *)a1 + 33) != 0)
  {
    if (v7 < 1)
    {
      CFNumberRef v9 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 132);
      CFDictionaryAddValue(v5, @"QuantZeroPoint", v9);
      CFRelease(v9);
    }
    else
    {
      ZinAddWeightInfoToParamsDict(v5, 0, @"ZeroPointCount", @"ZeroPointIndex", @"ZeroPointOffset", (unsigned char *)a1 + 104);
    }
  }
  ZinSetFormat(@"QuantScaleType", (_DWORD *)a1 + 34, v5);
  CFDictionaryAddValue(Unit, @"Params", v5);
  CFRelease(v5);
  return Unit;
}

__CFDictionary *ZinCreateReductionUnit(const ZinIrReductionUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = Mutable;
  uint64_t v6 = *((int *)a1 + 20);
  if (v6 > 6) {
    int v7 = @"Min";
  }
  else {
    int v7 = off_1E4FBEAC8[v6];
  }
  CFDictionaryAddValue(Mutable, @"Type", v7);
  unsigned int v8 = *((_DWORD *)a1 + 21) - 1;
  if (v8 <= 2) {
    CFDictionaryAddValue(v5, @"PostProcessType", off_1E4FBEB00[v8]);
  }
  CFNumberRef v9 = CFNumberCreate(v3, kCFNumberFloat32Type, (char *)a1 + 88);
  CFDictionaryAddValue(v5, @"PostScale", v9);
  CFRelease(v9);
  _S0 = *((_DWORD *)a1 + 23);
  __asm { FCVT            H0, S0 }
  __int16 valuePtr = _S0;
  CFNumberRef v15 = CFNumberCreate(v3, kCFNumberSInt16Type, &valuePtr);
  CFDictionaryAddValue(v5, @"Epsilon", v15);
  CFRelease(v15);
  CFNumberRef v16 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  CFNumberRef v17 = v16;
  uint64_t v18 = *((void *)a1 + 12);
  if ((v18 & 8) != 0)
  {
    CFArrayAppendValue(v16, @"Height");
    uint64_t v18 = *((void *)a1 + 12);
    if ((v18 & 0x10) == 0)
    {
LABEL_8:
      if ((v18 & 2) == 0) {
        goto LABEL_9;
      }
      goto LABEL_15;
    }
  }
  else if ((v18 & 0x10) == 0)
  {
    goto LABEL_8;
  }
  CFArrayAppendValue(v17, @"Width");
  uint64_t v18 = *((void *)a1 + 12);
  if ((v18 & 2) == 0)
  {
LABEL_9:
    if ((v18 & 4) == 0) {
      goto LABEL_10;
    }
LABEL_16:
    CFArrayAppendValue(v17, @"Channel");
    if ((*((void *)a1 + 12) & 1) == 0) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_15:
  CFArrayAppendValue(v17, @"Depth");
  uint64_t v18 = *((void *)a1 + 12);
  if ((v18 & 4) != 0) {
    goto LABEL_16;
  }
LABEL_10:
  if (v18) {
LABEL_11:
  }
    CFArrayAppendValue(v17, @"Batch");
LABEL_12:
  CFDictionaryAddValue(v5, @"Dimension", v17);
  CFRelease(v17);
  CFDictionaryAddValue(Unit, @"Params", v5);
  CFRelease(v5);
  return Unit;
}

__CFDictionary *ZinCreateReshapeUnit(int **a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit((const ZinIrUnitInfo *)a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = a1[10];
  *(_DWORD *)__c = a1[11];
  LODWORD(valuePtr.__r_.__value_.__l.__data_) = v5;
  uint64_t v6 = a1[12];
  unsigned int v18 = a1[13];
  int v19 = (int)v6;
  unsigned int v17 = a1[14];
  CFNumberRef v7 = CFNumberCreate(v3, kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v8 = CFNumberCreate(v3, kCFNumberSInt32Type, __c);
  CFNumberRef v9 = CFNumberCreate(v3, kCFNumberSInt32Type, &v19);
  CFNumberRef v10 = CFNumberCreate(v3, kCFNumberSInt32Type, &v18);
  CFNumberRef v11 = CFNumberCreate(v3, kCFNumberSInt32Type, &v17);
  CFDictionaryAddValue(Mutable, @"ReshapedBatch", v7);
  CFDictionaryAddValue(Mutable, @"ReshapedChannel", v8);
  CFDictionaryAddValue(Mutable, @"ReshapedHeight", v9);
  CFDictionaryAddValue(Mutable, @"ReshapedWidth", v10);
  CFDictionaryAddValue(Mutable, @"ReshapedDepth", v11);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(v9);
  CFRelease(v10);
  CFRelease(v11);
  memset(&valuePtr, 0, sizeof(valuePtr));
  CFNumberRef v13 = a1[15];
  CFNumberRef v12 = a1[16];
  if (v13 == v12)
  {
    p_std::string valuePtr = &valuePtr;
LABEL_8:
    CFStringRef v15 = CFStringCreateWithCString(v3, (const char *)p_valuePtr, 0x8000100u);
    CFDictionaryAddValue(Mutable, @"ReshapeLinearizationOrder", v15);
    CFRelease(v15);
  }
  else
  {
    while (1)
    {
      __c[0] = 0;
      if ((ToCharDimension(*v13, __c) & 1) == 0) {
        break;
      }
      std::string::push_back(&valuePtr, __c[0]);
      if (++v13 == v12)
      {
        if ((valuePtr.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0) {
          p_std::string valuePtr = &valuePtr;
        }
        else {
          p_std::string valuePtr = (std::string *)valuePtr.__r_.__value_.__r.__words[0];
        }
        goto LABEL_8;
      }
    }
  }
  if (SHIBYTE(valuePtr.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(valuePtr.__r_.__value_.__l.__data_);
  }
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

void sub_180178244(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0) {
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

__CFDictionary *ZinCreateResizeUnit(const ZinIrResizeUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*((float *)a1 + 41) == -1.0 || *((float *)a1 + 42) == -1.0)
  {
    CFNumberRef v7 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 156);
    CFDictionaryAddValue(Mutable, @"OutputHeight", v7);
    CFRelease(v7);
    CFNumberRef v6 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 160);
    CFDictionaryAddValue(Mutable, @"OutputWidth", v6);
  }
  else
  {
    CFNumberRef v5 = CFNumberCreate(v3, kCFNumberFloat32Type, (char *)a1 + 164);
    CFNumberRef v6 = CFNumberCreate(v3, kCFNumberFloat32Type, (char *)a1 + 168);
    CFDictionaryAddValue(Mutable, @"ScaleFactorX", v5);
    CFDictionaryAddValue(Mutable, @"ScaleFactorY", v6);
    CFRelease(v5);
  }
  CFRelease(v6);
  TextureUnitSamplingInfo = ZinCreateTextureUnitSamplingInfo(a1);
  CFDictionaryAddValue(Mutable, @"SamplingMethodInfo", TextureUnitSamplingInfo);
  CFRelease(TextureUnitSamplingInfo);
  TextureUnitSamplingGridInfo = ZinCreateTextureUnitSamplingGridInfo((uint64_t)a1 + 176);
  CFDictionaryAddValue(Mutable, @"SamplingGridInfo", TextureUnitSamplingGridInfo);
  CFRelease(TextureUnitSamplingGridInfo);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateSoftmaxUnit(const ZinIrSoftmaxUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFNumberRef v5 = CFArrayCreateMutable(v3, 0, MEMORY[0x1E4F1D510]);
  for (uint64_t i = (uint64_t *)*((void *)a1 + 12); i; uint64_t i = (uint64_t *)*i)
  {
    CFNumberRef v7 = ZinIrCoordinateToCFString((_DWORD *)i + 4);
    CFArrayAppendValue(v5, v7);
  }
  CFDictionaryAddValue(Mutable, @"Dimension", v5);
  CFRelease(v5);
  CFNumberRef v8 = (const void **)MEMORY[0x1E4F1CFD0];
  if (!*((unsigned char *)a1 + 120)) {
    CFNumberRef v8 = (const void **)MEMORY[0x1E4F1CFC8];
  }
  CFDictionaryAddValue(Mutable, @"SubtractMax", *v8);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateSpaceToBatchUnit(const ZinIrSpaceToBatchUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = 34;
  ZinAddSpaceTransformFactorToParamsDict(Mutable, &v5, (uint64_t)a1 + 80);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateSpaceToChannelUnit(const ZinIrSpaceToChannelUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = 36;
  ZinAddSpaceTransformFactorToParamsDict(Mutable, &v5, (uint64_t)a1 + 80);
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

__CFDictionary *ZinCreateCoordinateInfo(_DWORD *a1)
{
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFAllocatorRef v3 = ZinIrCoordinateToCFString(a1);
  CFDictionaryAddValue(Mutable, @"Coordinate", v3);
  uint64_t v4 = ZinIrCoordinateModeToCFString(a1[2]);
  CFDictionaryAddValue(Mutable, @"CoordinateMode", v4);
  if (a1[2])
  {
    int v5 = ZinIrNormalizedCoordinateRangeToCFString(a1[1]);
    CFDictionaryAddValue(Mutable, @"CoordinateRange", v5);
  }
  return Mutable;
}

__CFDictionary *ZinCreatePaddingInfo(_DWORD *a1)
{
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  CFAllocatorRef v3 = ZinIrCoordinateToCFString(a1);
  CFDictionaryAddValue(Mutable, @"Coordinate", v3);
  uint64_t v4 = (const void *)ZinIrTEPaddingModeToCFString(a1[1]);
  CFDictionaryAddValue(Mutable, @"PaddingMode", v4);
  return Mutable;
}

__CFArray *ZinCreateTextureUnitSamplingInfo(const ZinIrTextureUnitInfo *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D510]);
  uint64_t v4 = (uint64_t *)*((void *)a1 + 16);
  int v5 = (uint64_t *)*((void *)a1 + 17);
  if (v4 != v5)
  {
    CFNumberRef v6 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    CFNumberRef v7 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    do
    {
      uint64_t v8 = *v4++;
      uint64_t v13 = v8;
      CFNumberRef v9 = CFDictionaryCreateMutable(v2, 0, v6, v7);
      CFNumberRef v10 = ZinIrCoordinateToCFString(&v13);
      CFDictionaryAddValue(v9, @"Coordinate", v10);
      CFNumberRef v11 = ZinIrSamplingMethodToCFString(SHIDWORD(v13));
      CFDictionaryAddValue(v9, @"SamplingMethod", v11);
      CFArrayAppendValue(Mutable, v9);
      CFRelease(v9);
    }
    while (v4 != v5);
  }
  return Mutable;
}

__CFArray *ZinCreateTextureUnitSamplingGridInfo(uint64_t a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 1, MEMORY[0x1E4F1D510]);
  uint64_t v4 = *(_DWORD **)a1;
  int v5 = *(_DWORD **)(a1 + 8);
  if (*(_DWORD **)a1 != v5)
  {
    CFNumberRef v6 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    CFNumberRef v7 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    do
    {
      uint64_t v8 = CFDictionaryCreateMutable(v2, 0, v6, v7);
      CFNumberRef v9 = ZinIrCoordinateToCFString(v4);
      CFDictionaryAddValue(v8, @"Coordinate", v9);
      CFNumberRef v10 = ZinIrSamplingGridModeToCFStringRef(v4[1]);
      CFDictionaryAddValue(v8, @"SamplingGridMode", v10);
      CFArrayAppendValue(Mutable, v8);
      CFRelease(v8);
      v4 += 2;
    }
    while (v4 != v5);
  }
  return Mutable;
}

__CFDictionary *ZinCreateTextureCommonUnit(const ZinIrTextureUnitInfo *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  uint64_t v4 = CFArrayCreateMutable(v2, 1, MEMORY[0x1E4F1D510]);
  CFNumberRef v6 = (_DWORD *)*((void *)a1 + 10);
  for (uint64_t i = (_DWORD *)*((void *)a1 + 11); v6 != i; v6 += 3)
  {
    CoordinateInfo = ZinCreateCoordinateInfo(v6);
    CFArrayAppendValue(v4, CoordinateInfo);
    CFRelease(CoordinateInfo);
  }
  CFDictionaryAddValue(Mutable, @"CoordinateInfo", v4);
  CFRelease(v4);
  TextureUnitSamplingInfo = ZinCreateTextureUnitSamplingInfo(a1);
  theDict = Mutable;
  CFDictionaryAddValue(Mutable, @"SamplingMethodInfo", TextureUnitSamplingInfo);
  CFRelease(TextureUnitSamplingInfo);
  CFNumberRef v9 = CFArrayCreateMutable(v2, 1, MEMORY[0x1E4F1D510]);
  CFNumberRef v11 = (_DWORD *)*((void *)a1 + 13);
  CFNumberRef v10 = (_DWORD *)*((void *)a1 + 14);
  if (v11 != v10)
  {
    CFNumberRef v12 = (const CFDictionaryKeyCallBacks *)MEMORY[0x1E4F1D530];
    uint64_t v13 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    do
    {
      CFNumberRef v14 = CFDictionaryCreateMutable(v2, 0, v12, v13);
      CFStringRef v15 = ZinIrCoordinateToCFString(v11);
      CFDictionaryAddValue(v14, @"Coordinate", v15);
      CFNumberRef v16 = (const void *)ZinIrTEPaddingModeToCFString(v11[1]);
      CFDictionaryAddValue(v14, @"PaddingMode", v16);
      CFArrayAppendValue(v9, v14);
      CFRelease(v14);
      v11 += 2;
    }
    while (v11 != v10);
  }
  CFDictionaryAddValue(theDict, @"PaddingInfo", v9);
  CFRelease(v9);
  CFNumberRef v17 = CFNumberCreate(v2, kCFNumberSInt16Type, (char *)a1 + 152);
  CFDictionaryAddValue(theDict, @"BackgroundValue", v17);
  CFRelease(v17);
  return theDict;
}

__CFDictionary *ZinCreateTileUnit(const ZinIrTileUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  for (uint64_t i = (uint64_t *)*((void *)a1 + 12); i; uint64_t i = (uint64_t *)*i)
  {
    CFNumberRef v6 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)i + 20);
    CFNumberRef v7 = ZinIrCoordinateToCFString((_DWORD *)i + 4);
    CFDictionaryAddValue(Mutable, v7, v6);
    CFRelease(v6);
  }
  CFDictionaryAddValue(Unit, @"Params", Mutable);
  CFRelease(Mutable);
  return Unit;
}

CFMutableDictionaryRef ZinCreateTransposeUnit(int **a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit((const ZinIrUnitInfo *)a1);
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  theDict = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  Mutable = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  uint64_t v4 = a1[10];
  int v5 = a1[11];
  if (v4 != v5)
  {
    CFNumberRef v6 = (const CFDictionaryValueCallBacks *)MEMORY[0x1E4F1D540];
    do
    {
      int v14 = *v4;
      int v13 = v4[1];
      CFNumberRef v7 = ZinIrCoordinateToCFString(&v14);
      uint64_t v8 = ZinIrCoordinateToCFString(&v13);
      CFNumberRef v9 = CFDictionaryCreateMutable(v2, 0, MEMORY[0x1E4F1D530], v6);
      CFDictionaryAddValue(v9, @"TransposeSourceDimension", v7);
      CFDictionaryAddValue(v9, @"TransposeDestinationDimension", v8);
      CFArrayAppendValue(Mutable, v9);
      CFRelease(v9);
      v4 += 2;
    }
    while (v4 != v5);
  }
  CFDictionaryAddValue(theDict, @"TransposeDimensions", Mutable);
  CFRelease(Mutable);
  CFDictionaryAddValue(Unit, @"Params", theDict);
  CFRelease(theDict);
  return Unit;
}

__CFDictionary *ZinCreateUnflattenUnit(const ZinIrUnflattenUnitInfo *a1)
{
  CFMutableDictionaryRef Unit = ZinCreateUnit(a1);
  CFAllocatorRef v3 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  int v5 = Mutable;
  int v6 = *((_DWORD *)a1 + 20);
  CFNumberRef v7 = @"NCHW";
  if (v6 == 2) {
    CFNumberRef v7 = @"NHWC";
  }
  if (v6) {
    uint64_t v8 = v7;
  }
  else {
    uint64_t v8 = 0;
  }
  CFDictionaryAddValue(Mutable, @"Mode", v8);
  CFNumberRef v9 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 84);
  CFDictionaryAddValue(v5, @"DestinationWidth", v9);
  CFRelease(v9);
  CFNumberRef v10 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 88);
  CFDictionaryAddValue(v5, @"DestinationHeight", v10);
  CFRelease(v10);
  CFNumberRef v11 = CFNumberCreate(v3, kCFNumberSInt32Type, (char *)a1 + 92);
  CFDictionaryAddValue(v5, @"DestinationChannels", v11);
  CFRelease(v11);
  CFDictionaryAddValue(Unit, @"Params", v5);
  CFRelease(v5);
  return Unit;
}

__CFString *ZinUnitTypeToCFString(int a1)
{
  if ((a1 - 1) > 0x46) {
    return 0;
  }
  else {
    return off_1E4FBEB18[a1 - 1];
  }
}

__CFDictionary *ZinCreateUnit(const ZinIrUnitInfo *a1)
{
  CFAllocatorRef v2 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D530], MEMORY[0x1E4F1D540]);
  if (*((char *)a1 + 31) >= 0) {
    uint64_t v4 = (char *)a1 + 8;
  }
  else {
    uint64_t v4 = (const char *)*((void *)a1 + 1);
  }
  CFStringRef v5 = CFStringCreateWithCString(v2, v4, 0x8000100u);
  CFDictionaryAddValue(Mutable, @"Name", v5);
  CFRelease(v5);
  int v6 = ZinUnitTypeToCFString(*((_DWORD *)a1 + 8));
  CFDictionaryAddValue(Mutable, @"Type", v6);
  CFNumberRef v7 = CFArrayCreateMutable(v2, 0, MEMORY[0x1E4F1D510]);
  uint64_t v8 = *((void *)a1 + 5);
  if (*((void *)a1 + 6) != v8)
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    do
    {
      CFNumberRef v12 = (const char *)(v8 + v9);
      if (*(char *)(v8 + v9 + 23) < 0) {
        CFNumberRef v12 = *(const char **)v12;
      }
      CFStringRef v11 = CFStringCreateWithCString(v2, v12, 0x8000100u);
      CFArrayAppendValue(v7, v11);
      CFRelease(v11);
      ++v10;
      uint64_t v8 = *((void *)a1 + 5);
      v9 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((*((void *)a1 + 6) - v8) >> 3) > v10);
  }
  CFDictionaryAddValue(Mutable, @"Bottom", v7);
  CFRelease(v7);
  int v13 = *((_DWORD *)a1 + 16);
  if (v13)
  {
    int v14 = (const void *)ZinTensorFormatToANECFormat(v13);
    CFDictionaryAddValue(Mutable, @"InputType", v14);
  }
  CFStringRef v15 = (const void *)ZinTensorFormatToANECFormat(*((_DWORD *)a1 + 17));
  if (!v15) {
    ZinAssertImpl("Invalid or missing output format.");
  }
  CFDictionaryAddValue(Mutable, @"OutputType", v15);
  int valuePtr = *((_DWORD *)a1 + 18);
  if (valuePtr >= 1)
  {
    CFNumberRef v16 = CFNumberCreate(v2, kCFNumberSInt32Type, &valuePtr);
    CFDictionaryAddValue(Mutable, @"OutputChannels", v16);
    CFRelease(v16);
  }
  return Mutable;
}

void ZinAddKernelSizeToParamsDict(__CFDictionary *a1, void *a2, int a3)
{
  uint64_t v6 = a2[1];
  int valuePtr = *a2;
  int v13 = v6;
  CFAllocatorRef v7 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v8 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, &valuePtr);
  CFNumberRef v9 = CFNumberCreate(v7, kCFNumberSInt32Type, &v13);
  CFDictionaryAddValue(a1, @"KernelWidth", v8);
  CFDictionaryAddValue(a1, @"KernelHeight", v9);
  CFRelease(v8);
  CFRelease(v9);
  if (a3)
  {
    int v11 = a2[2];
    CFNumberRef v10 = CFNumberCreate(v7, kCFNumberSInt32Type, &v11);
    CFDictionaryAddValue(a1, @"KernelDepth", v10);
    CFRelease(v10);
  }
}

void ZinAddWeightInfoToParamsDict(__CFDictionary *a1, const void *a2, const void *a3, const void *a4, const void *a5, unsigned char *a6)
{
  CFAllocatorRef v12 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v13 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, a6 + 8);
  CFDictionaryAddValue(a1, a3, v13);
  CFRelease(v13);
  if (a2)
  {
    int v14 = (const void **)MEMORY[0x1E4F1CFD0];
    if (!*a6) {
      int v14 = (const void **)MEMORY[0x1E4F1CFC8];
    }
    CFDictionaryAddValue(a1, a2, *v14);
  }
  CFNumberRef v15 = CFNumberCreate(v12, kCFNumberSInt32Type, a6 + 4);
  CFDictionaryAddValue(a1, a4, v15);
  CFRelease(v15);
  CFNumberRef v16 = CFNumberCreate(v12, kCFNumberSInt64Type, a6 + 16);
  CFDictionaryAddValue(a1, a5, v16);

  CFRelease(v16);
}

void ZinAddStepsToParamsDict(__CFDictionary *a1, uint64_t a2, int a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)a2);
  CFNumberRef v9 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)(a2 + 4));
  CFArrayAppendValue(Mutable, v8);
  CFArrayAppendValue(Mutable, v9);
  CFRelease(v8);
  CFRelease(v9);
  if (a3)
  {
    CFNumberRef v10 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)(a2 + 8));
    CFArrayAppendValue(Mutable, v10);
    CFRelease(v10);
  }
  CFDictionaryAddValue(a1, @"Step", Mutable);

  CFRelease(Mutable);
}

void ZinAddKernelDilationRateToParamsDict(__CFDictionary *a1, char *valuePtr)
{
  CFAllocatorRef v4 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v5 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, valuePtr);
  CFNumberRef v6 = CFNumberCreate(v4, kCFNumberSInt32Type, valuePtr + 4);
  CFDictionaryAddValue(a1, @"KernelDilationX", v5);
  CFDictionaryAddValue(a1, @"KernelDilationY", v6);
  CFRelease(v5);

  CFRelease(v6);
}

void ZinAddPaddingToParamsDict(__CFDictionary *a1, uint64_t a2, int a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (const void *)(a2 + 8));
  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)(a2 + 12));
  CFNumberRef v9 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)a2);
  CFNumberRef v10 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)(a2 + 4));
  CFDictionaryAddValue(a1, @"PadTop", v7);
  CFDictionaryAddValue(a1, @"PadBot", v8);
  CFDictionaryAddValue(a1, @"PadLeft", v9);
  CFDictionaryAddValue(a1, @"PadRight", v10);
  CFRelease(v7);
  CFRelease(v8);
  CFRelease(v9);
  CFRelease(v10);
  if (a3)
  {
    CFNumberRef v11 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)(a2 + 16));
    CFNumberRef v12 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)(a2 + 20));
    CFDictionaryAddValue(a1, @"PadFront", v11);
    CFDictionaryAddValue(a1, @"PadBack", v12);
    CFRelease(v11);
    CFRelease(v12);
  }
}

__CFString *ZinIrPaddingModeToCFString(unsigned int a1)
{
  if (a1 > 9) {
    return @"Zero";
  }
  else {
    return (__CFString *)qword_1E4FBED50[a1];
  }
}

void ZinSetFormat(void *key, _DWORD *a2, CFMutableDictionaryRef theDict)
{
  int v3 = *a2 - 1;
  if (v3 >= 6 || ((0x3Bu >> v3) & 1) == 0) {
    ZinAssertImpl("Error: invalid kernel format. It should be Int8, UInt8, FP16, FP32 or E4M3");
  }
  CFAllocatorRef v6 = *(&off_1E4FBEDA0 + v3);

  CFDictionaryAddValue(theDict, key, v6);
}

void ZinAddSpaceTransformFactorToParamsDict(__CFDictionary *a1, _DWORD *a2, uint64_t a3)
{
  CFAllocatorRef v6 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFNumberRef v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E4F1CF80], kCFNumberSInt32Type, (const void *)a3);
  CFNumberRef v8 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)(a3 + 4));
  CFNumberRef v9 = CFNumberCreate(v6, kCFNumberSInt32Type, (const void *)(a3 + 8));
  if (*a2 <= 0x25u && ((1 << *a2) & 0x3D80000000) != 0)
  {
    CFDictionaryAddValue(a1, @"FactorX", v7);
    CFDictionaryAddValue(a1, @"FactorY", v8);
    CFDictionaryAddValue(a1, @"FactorZ", v9);
  }
  CFRelease(v7);
  CFRelease(v8);

  CFRelease(v9);
}

uint64_t ZinTensorFormatToANECFormat(int a1)
{
  if ((a1 - 1) > 0xF) {
    return 0;
  }
  else {
    return (uint64_t)*(&off_1E4FBEDD0 + a1 - 1);
  }
}

uint64_t mlir::MemoryMapperInterface::canMapOperands(mlir::MemoryMapperInterface *this)
{
  return (**((uint64_t (***)(void, void))this + 1))(*((void *)this + 1), *(void *)this);
}

uint64_t mlir::MemoryMapperInterface::getOperandRange(mlir::MemoryMapperInterface *this)
{
  return (*(uint64_t (**)(void, void))(*((void *)this + 1) + 8))(*((void *)this + 1), *(void *)this);
}

void mlir::detail::AllocRange::getRangeForValue(_DWORD *a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  v59[4] = *MEMORY[0x1E4F143B8];
  id v50 = a1;
  BOOL v5 = (~a1[2] & 7) == 0 && mlir::detail::AllocRange::allocBlockArgs == 0;
  if (v5
    || (std::string __p = a1, (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&__p)) != 0)
    && (uint64_t v8 = DefiningOp,
        uint64_t v9 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        (*(unsigned int (**)(void, uint64_t))(**(void **)(v8 + 48) + 32))(*(void *)(v8 + 48), v9)))
  {
    *(void *)a3 = a1;
LABEL_8:
    *(void *)&long long v10 = -1;
    *((void *)&v10 + 1) = -1;
    *(_OWORD *)(a3 + 8) = v10;
    *(_OWORD *)(a3 + 24) = v10;
    return;
  }
  if (*(_UNKNOWN **)(*(void *)(*((void *)a1 + 1) & 0xFFFFFFFFFFFFFFF8) + 136) == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    CFNumberRef v11 = (uint64_t *)(*((void *)a1 + 1) & 0xFFFFFFFFFFFFFFF8);
  }
  else {
    CFNumberRef v11 = 0;
  }
  if (!v11)
  {
    *(void *)a3 = 0;
    goto LABEL_8;
  }
  if ((unint64_t)mlir::detail::AllocRange::minimumAlignment <= 1) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = mlir::detail::AllocRange::minimumAlignment;
  }
  uint64_t v48 = 0;
  uint64_t v49 = v12;
  if (mlir::matchThrough<mlir::MinimumAlignmentInterface,mlir::MemoryMapperInterface>((uint64_t)a1, &v48))
  {
    uint64_t InterfaceFor = mlir::Value::getDefiningOp((mlir::Value *)&v48);
    int v14 = (void *)InterfaceFor;
    if (InterfaceFor)
    {
      uint64_t InterfaceFor = mlir::OpInterface<mlir::MinimumAlignmentInterface,mlir::detail::MinimumAlignmentInterfaceInterfaceTraits>::getInterfaceFor(InterfaceFor);
      if (InterfaceFor) {
        uint64_t InterfaceFor = mlir::OpInterface<mlir::MinimumAlignmentInterface,mlir::detail::MinimumAlignmentInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)v14);
      }
      else {
        int v14 = 0;
      }
    }
    std::string __p = v14;
    uint64_t v58 = InterfaceFor;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&__p);
    if (v12 >= 0) {
      uint64_t v16 = v12;
    }
    else {
      uint64_t v16 = -v12;
    }
    LODWORD(v56) = 64;
    p_p = (void *)v16;
    if (OperandRange >= 0) {
      uint64_t v17 = OperandRange;
    }
    else {
      uint64_t v17 = -OperandRange;
    }
    unsigned int v52 = 64;
    unint64_t v51 = (void *)v17;
    llvm::APIntOps::GreatestCommonDivisor((uint64_t)&p_p, (uint64_t)&v51, (uint64_t)&__p);
    if (v58 > 0x40)
    {
      unint64_t v18 = *(void *)__p;
      operator delete[](__p);
    }
    else
    {
      unint64_t v18 = (unint64_t)__p;
    }
    if (v52 >= 0x41 && v51) {
      operator delete[](v51);
    }
    if (v56 >= 0x41 && p_p) {
      operator delete[](p_p);
    }
    uint64_t v12 = v16 * v17 / v18;
    uint64_t v49 = v12;
  }
  ParentRegion = mlir::Value::getParentRegion((mlir::Value *)&v50);
  std::string __p = &v50;
  uint64_t v58 = (uint64_t)&v49;
  CFNumberRef v20 = (mlir::Block *)*((void *)ParentRegion + 1);
  if (v20 != ParentRegion)
  {
    CFNumberRef v21 = ParentRegion;
    do
    {
      CFNumberRef v22 = (void *)((char *)v20 - 8);
      if (!v20) {
        CFNumberRef v22 = 0;
      }
      uint64_t v23 = (mlir::GenericProgramPoint *)(v22 + 4);
      int v24 = (mlir::GenericProgramPoint *)v22[5];
      if (v24 != (mlir::GenericProgramPoint *)(v22 + 4))
      {
        do
        {
          CFNumberRef v25 = (mlir::GenericProgramPoint *)*((void *)v24 + 1);
          mlir::GenericProgramPoint::~GenericProgramPoint(v24);
          p_p = &__p;
          mlir::detail::walk<mlir::ForwardIterator>(v26, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZNS7_10AllocRange16getRangeForValueENS1_5ValueExE3__0NS1_25MinimumAlignmentInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESN_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)&p_p, 1);
          int v24 = v25;
        }
        while (v25 != v23);
      }
      CFNumberRef v20 = (mlir::Block *)*((void *)v20 + 1);
    }
    while (v20 != v21);
    uint64_t v12 = v49;
  }
  if (a2 == -1) {
    unint64_t v27 = 0;
  }
  else {
    unint64_t v27 = a2;
  }
  unint64_t v28 = v27;
  if (v12) {
    unint64_t v28 = (v27 + v12 - 1) / v12 * v12;
  }
  uint64_t v29 = *v11;
  unint64_t v30 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v31 = *(unsigned int *)(v29 + 16);
  if (!v31) {
    goto LABEL_60;
  }
  uint64_t v32 = *(void **)(v29 + 8);
  unint64_t v33 = &v32[2 * v31];
  do
  {
    unint64_t v34 = v31 >> 1;
    uint64_t v35 = &v32[2 * (v31 >> 1)];
    unint64_t v37 = *v35;
    unint64_t v36 = v35 + 2;
    v31 += ~(v31 >> 1);
    if (v37 < v30) {
      uint64_t v32 = v36;
    }
    else {
      unint64_t v31 = v34;
    }
  }
  while (v31);
  if (v32 != v33 && *v32 == v30) {
    uint64_t v38 = v32[1];
  }
  else {
LABEL_60:
  }
    uint64_t v38 = 0;
  p_p = v11;
  uint64_t v56 = v38;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&p_p);
  if (v39)
  {
    if (*(_UNKNOWN **)(*(void *)p_p + 136) == &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
      unint64_t v40 = p_p;
    }
    else {
      unint64_t v40 = 0;
    }
    unint64_t v51 = v40;
    if (v40)
    {
      std::string __p = v59;
      uint64_t v58 = 0x400000000;
      uint64_t v54 = 0;
      mlir::getStridesAndOffset((uint64_t)v40, (uint64_t)&__p, &v54);
      unint64_t v41 = *(void *)__p;
      unint64_t v42 = *(void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v51) * v41;
      uint64_t v53 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&p_p);
      uint64_t v43 = v42 * (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&v53) >> 3);
      if (__p != v59) {
        free(__p);
      }
    }
    else
    {
      ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&p_p);
      uint64_t NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v45);
      std::string __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&p_p);
      uint64_t v43 = NumElements * (mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p) >> 3);
    }
  }
  else
  {
    std::string __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&p_p);
    uint64_t v43 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p) >> 3;
  }
  uint64_t v47 = v49;
  *(void *)a3 = v50;
  *(void *)(a3 + 8) = v27;
  *(void *)(a3 + 16) = v28;
  *(void *)(a3 + 24) = v28 + v43 - 1;
  *(void *)(a3 + 32) = v47;
}

uint64_t mlir::matchThrough<mlir::MinimumAlignmentInterface,mlir::MemoryMapperInterface>(uint64_t a1, void *a2)
{
  uint64_t v12 = a1;
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v12);
    if (DefiningOp
      && (uint64_t v6 = DefiningOp,
          mlir::OpInterface<mlir::MinimumAlignmentInterface,mlir::detail::MinimumAlignmentInterfaceInterfaceTraits>::getInterfaceFor(DefiningOp)))
    {
      mlir::OpInterface<mlir::MinimumAlignmentInterface,mlir::detail::MinimumAlignmentInterfaceInterfaceTraits>::getInterfaceFor(v6);
      if (a2) {
        *a2 = v12;
      }
      return 1;
    }
    else
    {
      uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v12);
      if (result)
      {
        uint64_t result = mlir::OpInterface<mlir::MemoryMapperInterface,mlir::detail::MemoryMapperInterfaceInterfaceTraits>::getInterfaceFor(result);
        if (result)
        {
          if ((*(unsigned char *)(v4 + 46) & 0x80) != 0 && (uint64_t v7 = *(unsigned int *)(v4 + 68), v7))
          {
            uint64_t v8 = v7 - 1;
            uint64_t v9 = (uint64_t *)(*(void *)(v4 + 72) + 24);
            do
            {
              uint64_t v10 = v8;
              uint64_t v11 = *v9;
              v9 += 4;
              uint64_t result = mlir::matchThrough<mlir::MinimumAlignmentInterface,mlir::MemoryMapperInterface>(v11, a2);
              if (result) {
                break;
              }
              uint64_t v8 = v10 - 1;
            }
            while (v10);
          }
          else
          {
            return 0;
          }
        }
      }
    }
  }
  return result;
}

void mlir::dataflow::OffsetLatticeValue::join(unint64_t **a1@<X0>, uint64_t a2@<X1>, unint64_t **a3@<X8>)
{
  unint64_t v6 = *((unsigned int *)a1 + 2);
  unint64_t v7 = *(unsigned int *)(a2 + 8);
  if (v6 == v7)
  {
    if (!v6)
    {
      *a3 = (unint64_t *)(a3 + 2);
      a3[1] = (unint64_t *)0xA00000000;
      return;
    }
    uint64_t v8 = 0;
    uint64_t v9 = (char *)*a1;
    uint64_t v10 = *(unint64_t **)a2;
    while (*(void *)&v9[v8 * 8] == v10[v8])
    {
      v8 += 5;
      if (5 * v6 == v8)
      {
        uint64_t v11 = (unint64_t *)(a3 + 2);
        *a3 = (unint64_t *)(a3 + 2);
        a3[1] = (unint64_t *)0xA00000000;
        if (a3 == a1) {
          return;
        }
        if (v6 < 0xB)
        {
          unint64_t v12 = v6;
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a3, a3 + 2, v6, 40);
          unint64_t v12 = *((unsigned int *)a1 + 2);
          if (!v12) {
            goto LABEL_90;
          }
          uint64_t v11 = *a3;
          uint64_t v9 = (char *)*a1;
        }
        size_t v45 = 40 * v12;
        goto LABEL_89;
      }
    }
  }
  else
  {
    uint64_t v10 = *(unint64_t **)a2;
  }
  if (!v7)
  {
LABEL_21:
    if (!v6)
    {
      uint64_t v48 = 0;
      uint64_t v49 = 0;
      unsigned int v50 = 0;
      unint64_t v51 = &v53;
      uint64_t v52 = 0;
      goto LABEL_41;
    }
    uint64_t v17 = *a1;
    uint64_t v18 = 40 * v6;
    int v19 = *a1 + 3;
    while (1)
    {
      BOOL v20 = *(v19 - 2) == -1 || *(v19 - 1) == -1;
      if (v20 || *v19 == -1) {
        break;
      }
      v19 += 5;
      v18 -= 40;
      if (!v18)
      {
        uint64_t v48 = 0;
        uint64_t v49 = 0;
        unsigned int v50 = 0;
        unint64_t v51 = &v53;
        uint64_t v52 = 0;
        uint64_t v22 = 40 * v6;
        do
        {
          llvm::SetVector<mlir::detail::AllocRange,llvm::SmallVector<mlir::detail::AllocRange,0u>,llvm::DenseSet<mlir::detail::AllocRange,llvm::DenseMapInfo<mlir::detail::AllocRange,void>>,0u>::insert((uint64_t)&v48, v17);
          v17 += 5;
          v22 -= 40;
        }
        while (v22);
        uint64_t v10 = *(unint64_t **)a2;
        unint64_t v7 = *(unsigned int *)(a2 + 8);
LABEL_41:
        if (v7)
        {
          uint64_t v24 = 40 * v7;
          do
          {
            llvm::SetVector<mlir::detail::AllocRange,llvm::SmallVector<mlir::detail::AllocRange,0u>,llvm::DenseSet<mlir::detail::AllocRange,llvm::DenseMapInfo<mlir::detail::AllocRange,void>>,0u>::insert((uint64_t)&v48, v10);
            v10 += 5;
            v24 -= 40;
          }
          while (v24);
        }
        if (v49)
        {
          if (v50 <= 4 * (int)v49 || v50 < 0x41)
          {
            if (v50)
            {
              unint64_t v27 = v48;
              unint64_t v28 = (llvm *)((char *)v48 + 40 * v50);
              *(void *)&long long v29 = -1;
              *((void *)&v29 + 1) = -1;
              do
              {
                *(void *)unint64_t v27 = -4096;
                *(_OWORD *)((char *)v27 + 8) = v29;
                *(_OWORD *)((char *)v27 + 24) = v29;
                unint64_t v27 = (llvm *)((char *)v27 + 40);
              }
              while (v27 != v28);
            }
            uint64_t v49 = 0;
          }
          else
          {
            llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::shrink_and_clear((uint64_t)&v48);
          }
        }
        id v46 = &v48;
        uint64_t v47 = 0;
        if (v52)
        {
          llvm::SmallVectorImpl<mlir::detail::AllocRange>::operator=((uint64_t)&v46, (uint64_t)&v51);
          unint64_t v30 = (char *)v46;
        }
        else
        {
          unint64_t v30 = (char *)&v48;
        }
        uint64_t v31 = 0;
        for (uint64_t i = 1; ; ++i)
        {
          if (*(void *)&v30[v31 + 8] != -1 && *(void *)&v30[v31 + 16] != -1)
          {
            uint64_t v33 = (uint64_t)&v30[v31];
            if (*(void *)&v30[v31 + 24] != -1) {
              break;
            }
          }
          v31 += 40;
        }
        unint64_t v34 = v47;
        if (v47 != i)
        {
          uint64_t v36 = 0;
          do
          {
            unint64_t v37 = &v30[v36 + v31];
            if (*((void *)v37 + 6) != -1)
            {
              uint64_t v38 = *((void *)v37 + 7);
              if (v38 != -1)
              {
                uint64_t v39 = &v30[v36 + v31];
                uint64_t v40 = *((void *)v39 + 8);
                if (v40 != -1)
                {
                  uint64_t v41 = *(void *)(v33 + 24);
                  unint64_t v42 = v41 + 1;
                  *((void *)v37 + 6) = v41 + 1;
                  unint64_t v43 = *((void *)v39 + 9);
                  if (v43) {
                    unint64_t v42 = (v43 + v41) / v43 * v43;
                  }
                  uint64_t v33 = (uint64_t)&v30[v31 + 40 + v36];
                  *((void *)v37 + 7) = v42;
                  *((void *)v39 + 8) = v40 - v38 + v42;
                }
              }
            }
            v36 += 40;
          }
          while (40 * v34 - v31 - 40 != v36);
        }
        *a3 = (unint64_t *)(a3 + 2);
        a3[1] = (unint64_t *)0xA00000000;
        if (v34 >= 0xB)
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a3, a3 + 2, v34, 40);
          unsigned int v35 = *((_DWORD *)a3 + 2);
          goto LABEL_78;
        }
        if (v34)
        {
          unsigned int v35 = 0;
LABEL_78:
          memcpy(&(*a3)[5 * v35], v30, 40 * v34);
          int v44 = *((_DWORD *)a3 + 2);
        }
        else
        {
          int v44 = 0;
        }
        *((_DWORD *)a3 + 2) = v44 + v34;
        if (v46 != &v48) {
          free(v46);
        }
        if (v51 != &v53) {
          free(v51);
        }
        llvm::deallocate_buffer(v48, (void *)(40 * v50));
      }
    }
    CFNumberRef v25 = (unint64_t *)(a3 + 2);
    *a3 = (unint64_t *)(a3 + 2);
    a3[1] = (unint64_t *)0xA00000000;
    if (a3 == (unint64_t **)a2 || !v7) {
      return;
    }
    if (v7 < 0xB)
    {
      unint64_t v26 = v7;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a3, v25, v7, 40);
      unint64_t v26 = *(unsigned int *)(a2 + 8);
      if (!v26)
      {
LABEL_93:
        *((_DWORD *)a3 + 2) = v7;
        return;
      }
      CFNumberRef v25 = *a3;
      uint64_t v10 = *(unint64_t **)a2;
    }
    memcpy(v25, v10, 40 * v26);
    goto LABEL_93;
  }
  uint64_t v13 = 40 * v7;
  int v14 = v10 + 3;
  while (1)
  {
    BOOL v15 = *(v14 - 2) == -1 || *(v14 - 1) == -1;
    if (v15 || *v14 == -1) {
      break;
    }
    v14 += 5;
    v13 -= 40;
    if (!v13) {
      goto LABEL_21;
    }
  }
  uint64_t v11 = (unint64_t *)(a3 + 2);
  *a3 = (unint64_t *)(a3 + 2);
  a3[1] = (unint64_t *)0xA00000000;
  if (a3 != a1 && v6)
  {
    if (v6 < 0xB)
    {
      unsigned int v23 = v6;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a3, a3 + 2, v6, 40);
      unsigned int v23 = *((_DWORD *)a1 + 2);
      if (!v23)
      {
LABEL_90:
        *((_DWORD *)a3 + 2) = v6;
        return;
      }
      uint64_t v11 = *a3;
    }
    uint64_t v9 = (char *)*a1;
    size_t v45 = 40 * v23;
LABEL_89:
    memcpy(v11, v9, v45);
    goto LABEL_90;
  }
}

llvm::raw_ostream *mlir::dataflow::OffsetLatticeValue::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  uint64_t v3 = (uint64_t)this;
  uint64_t v4 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v4)
  {
    this = llvm::raw_ostream::write(a2, "{", 1uLL);
  }
  else
  {
    unsigned char *v4 = 123;
    ++*((void *)a2 + 4);
  }
  uint64_t v5 = *(unsigned int *)(v3 + 8);
  if (v5 == 1)
  {
    this = mlir::detail::operator<<(a2, *(unint64_t **)v3);
  }
  else if (v5)
  {
    unint64_t v6 = *(unint64_t **)v3;
    uint64_t v7 = 40 * v5;
    do
    {
      uint64_t v9 = *((void *)a2 + 4);
      if ((unint64_t)(*((void *)a2 + 3) - v9) > 2)
      {
        *(unsigned char *)(v9 + 2) = 32;
        *(_WORD *)uint64_t v9 = 11552;
        *((void *)a2 + 4) += 3;
        uint64_t v8 = a2;
      }
      else
      {
        uint64_t v8 = llvm::raw_ostream::write(a2, " - ", 3uLL);
      }
      this = mlir::detail::operator<<(v8, v6);
      v6 += 5;
      v7 -= 40;
    }
    while (v7);
  }
  uint64_t v10 = (unsigned char *)*((void *)a2 + 4);
  if (*((unsigned char **)a2 + 3) == v10)
  {
    return llvm::raw_ostream::write(a2, "}", 1uLL);
  }
  else
  {
    *uint64_t v10 = 125;
    ++*((void *)a2 + 4);
  }
  return this;
}

llvm::raw_ostream *mlir::detail::operator<<(llvm::raw_ostream *this, unint64_t *a2)
{
  CFAllocatorRef v2 = this;
  uint64_t v4 = *((void *)this + 3);
  uint64_t v3 = *((void *)this + 4);
  if (*a2)
  {
    if (v4 == v3)
    {
      this = llvm::raw_ostream::write(this, "[", 1uLL);
    }
    else
    {
      *(unsigned char *)uint64_t v3 = 91;
      ++*((void *)this + 4);
    }
    unint64_t v6 = llvm::raw_ostream::operator<<(this, a2[1]);
    uint64_t v7 = (unsigned char *)*((void *)v6 + 4);
    if (*((unsigned char **)v6 + 3) == v7)
    {
      unint64_t v6 = llvm::raw_ostream::write(v6, "/", 1uLL);
    }
    else
    {
      *uint64_t v7 = 47;
      ++*((void *)v6 + 4);
    }
    uint64_t v8 = llvm::raw_ostream::operator<<(v6, a2[2]);
    uint64_t v9 = (_WORD *)*((void *)v8 + 4);
    if (*((void *)v8 + 3) - (void)v9 > 1uLL)
    {
      *uint64_t v9 = 8236;
      *((void *)v8 + 4) += 2;
    }
    else
    {
      uint64_t v8 = llvm::raw_ostream::write(v8, ", ", 2uLL);
    }
    uint64_t v10 = llvm::raw_ostream::operator<<(v8, a2[3]);
    uint64_t v11 = (void *)*((void *)v10 + 4);
    if (*((void *)v10 + 3) - (void)v11 > 0xDuLL)
    {
      qmemcpy(v11, "] provenance: ", 14);
      *((void *)v10 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v10, "] provenance: ", 0xEuLL);
    }
    if ((~*(_DWORD *)(*a2 + 8) & 7) != 0)
    {
      unint64_t v15 = *a2;
      mlir::Value::print((mlir::Value *)&v15, v2);
    }
    else
    {
      unint64_t v12 = (_DWORD *)*((void *)v2 + 4);
      if (*((void *)v2 + 3) - (void)v12 > 3uLL)
      {
        _DWORD *v12 = 1735549221;
        *((void *)v2 + 4) += 4;
        uint64_t v13 = v2;
      }
      else
      {
        uint64_t v13 = llvm::raw_ostream::write(v2, "%arg", 4uLL);
      }
      llvm::raw_ostream::operator<<(v13, *(unsigned int *)(*a2 + 24));
    }
  }
  else if ((unint64_t)(v4 - v3) > 0xA)
  {
    *(_DWORD *)(v3 + 7) = 1046834799;
    *(void *)uint64_t v3 = *(void *)"<tombstone>";
    *((void *)this + 4) += 11;
  }
  else
  {
    llvm::raw_ostream::write(this, "<tombstone>", 0xBuLL);
  }
  return v2;
}

uint64_t mlir::dataflow::TensorAllocAnalysis::TensorAllocAnalysis(uint64_t a1, mlir::DataFlowSolver *a2, mlir::StringAttr *a3, const void *a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t a11, char a12, char a13)
{
  uint64_t v18 = mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::AbstractSparseForwardDataFlowAnalysis((mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *)a1, a2);
  unsigned int v19 = 0;
  *(void *)uint64_t v18 = &unk_1EC9CDB58;
  BOOL v20 = (char *)v18 + 80;
  *((void *)v18 + 8) = (char *)v18 + 80;
  uint64_t v21 = (uint64_t)v18 + 64;
  *(void *)(a1 + 24) = 0;
  *(void *)(a1 + 32) = 0;
  *(void *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(void *)(a1 + 48) = v21;
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 72) = 0x300000000;
  if ((unint64_t)(8 * a5) >= 0x19)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v21, v20, (8 * a5) >> 3, 8);
    unsigned int v19 = *(_DWORD *)(a1 + 72);
  }
  if (a5)
  {
    memcpy((void *)(*(void *)(a1 + 64) + 8 * v19), a4, 8 * a5);
    unsigned int v19 = *(_DWORD *)(a1 + 72);
  }
  *(void *)(a1 + 104) = a1 + 120;
  uint64_t v22 = (uint64_t **)(a1 + 104);
  *(_DWORD *)(a1 + 72) = v19 + a5;
  *(void *)(a1 + 112) = 0x300000000;
  __int16 v37 = 261;
  unsigned int v35 = a9;
  uint64_t v36 = a10;
  *(void *)(a1 + 144) = mlir::StringAttr::get(a3, (mlir::MLIRContext *)&v35);
  *(void *)(a1 + 152) = a11;
  *(unsigned char *)(a1 + 160) = a12;
  *(unsigned char *)(a1 + 161) = a13;
  uint64_t v23 = *(unsigned int *)(a1 + 72);
  uint64_t v24 = *(unsigned int *)(a1 + 112);
  if (v23 != v24)
  {
    if (v23 >= v24)
    {
      uint64_t v25 = *(unsigned int *)(a1 + 112);
      int v26 = *(_DWORD *)(a1 + 112);
      if (*(_DWORD *)(a1 + 116) < v23)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 104, (void *)(a1 + 120), *(unsigned int *)(a1 + 72), 8);
        uint64_t v25 = *(unsigned int *)(a1 + 112);
        int v26 = *(_DWORD *)(a1 + 112);
      }
      bzero(&(*v22)[v25], 8 * (v23 - v24));
      LODWORD(v23) = v26 + v23 - v24;
    }
    *(_DWORD *)(a1 + 112) = v23;
  }
  if (a7)
  {
    unint64_t v27 = *v22;
    uint64_t v28 = 24 * a7;
    do
    {
      int v29 = *((char *)a6 + 23);
      BOOL v30 = v29 < 0;
      uint64_t v31 = (uint64_t *)*a6;
      if (v29 >= 0) {
        uint64_t v31 = a6;
      }
      uint64_t v32 = *((unsigned __int8 *)a6 + 23);
      if (v30) {
        uint64_t v32 = a6[1];
      }
      __int16 v37 = 261;
      unsigned int v35 = v31;
      uint64_t v36 = v32;
      *v27++ = mlir::StringAttr::get(a3, (mlir::MLIRContext *)&v35);
      a6 += 3;
      v28 -= 24;
    }
    while (v28);
  }
  mlir::detail::AllocRange::minimumAlignment = *(void *)(a1 + 152);
  mlir::detail::AllocRange::allocBlockArgs = a13;
  return a1;
}

{
  return mlir::dataflow::TensorAllocAnalysis::TensorAllocAnalysis(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
}

void mlir::dataflow::TensorAllocAnalysis::visitOperation(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  v58[50] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
  if ((*(unsigned int (**)(void, uint64_t))(**(void **)(a2 + 48) + 32))(*(void *)(a2 + 48), v12)) {
    mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::setAllToEntryStates((uint64_t)a1, a5, a6);
  }
  if (!a4) {
    mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::setAllToEntryStates((uint64_t)a1, a5, a6);
  }
  uint64_t v56 = v58;
  uint64_t v57 = 0xA00000000;
  uint64_t v48 = a5;
  uint64_t v49 = a6;
  if (mlir::OpInterface<mlir::MemoryMapperInterface,mlir::detail::MemoryMapperInterfaceInterfaceTraits>::getInterfaceFor(a2))
  {
    uint64_t v50 = a2;
    uint64_t InterfaceFor = mlir::OpInterface<mlir::MemoryMapperInterface,mlir::detail::MemoryMapperInterfaceInterfaceTraits>::getInterfaceFor(a2);
    if (a2)
    {
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50);
      uint64_t v15 = OperandRange;
      uint64_t v16 = (void *)(a3 + 8 * OperandRange);
      if (v14 == OperandRange)
      {
        BOOL v17 = 0;
      }
      else
      {
        uint64_t v18 = a3 + 8 * OperandRange;
        while (2)
        {
          uint64_t v19 = *(unsigned int *)(*(void *)v18 + 176);
          BOOL v17 = *(_DWORD *)(*(void *)v18 + 176) == 0;
          if (v19)
          {
            uint64_t v20 = 40 * v19;
            uint64_t v21 = (void *)(*(void *)(*(void *)v18 + 168) + 24);
            do
            {
              if (*(v21 - 2) == -1 || *(v21 - 1) == -1 || *v21 == -1)
              {
                BOOL v17 = 1;
                goto LABEL_25;
              }
              v21 += 5;
              v20 -= 40;
            }
            while (v20);
            v18 += 8;
            if (v18 != a3 + 8 * v14) {
              continue;
            }
          }
          break;
        }
      }
LABEL_25:
      if ((*(unsigned char *)(a2 + 46) & 0x80) != 0) {
        uint64_t v24 = *(void *)(a2 + 72);
      }
      else {
        uint64_t v24 = 0;
      }
      uint64_t v25 = v14 - OperandRange;
      uint64_t v46 = v14;
      if (v14 == OperandRange)
      {
        int v47 = 0;
        int64_t v26 = 0;
      }
      else
      {
        uint64_t v27 = ~OperandRange + v14;
        uint64_t v28 = (void **)(v24 + 32 * OperandRange + 24);
        do
        {
          int v29 = *v28;
          v28 += 4;
          BOOL isDeadAfter = mlir::Liveness::isDeadAfter(a1[2], v29, v50);
          BOOL v32 = v27-- != 0;
        }
        while (isDeadAfter && v32);
        int64_t v26 = 0;
        int v47 = !isDeadAfter;
        uint64_t v33 = (_DWORD **)(v24 + 32 * v15 + 24);
        do
        {
          unint64_t v34 = *v33;
          v33 += 4;
          mlir::detail::AllocRange::getRangeForValue(v34, v26 + 1, (uint64_t)v52);
          if (v54 != -1) {
            int64_t v26 = v54;
          }
          --v25;
        }
        while (v25);
      }
      uint64_t v35 = *(unsigned int *)(a2 + 36);
      if (v35) {
        uint64_t v36 = a2 - 16;
      }
      else {
        uint64_t v36 = 0;
      }
      if (v35)
      {
        unint64_t v37 = 0;
        uint64_t v38 = 0;
        while (1)
        {
          uint64_t NextResultAtOffset = (_DWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset(v36, v38);
          mlir::detail::AllocRange::getRangeForValue(NextResultAtOffset, v37, (uint64_t)v52);
          if (v55) {
            unint64_t v37 = (v37 + v55 - 1) / v55 * v55;
          }
          if ((uint64_t)(v54 - v53 + v37) > v26) {
            break;
          }
          unint64_t v37 = v54 + 1;
          if (v35 == ++v38) {
            goto LABEL_48;
          }
        }
      }
      else
      {
LABEL_48:
        if (((v17 | v47) & 1) == 0
          && mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v50)
          && v46 != v15)
        {
          uint64_t v40 = 8 * v46 - 8 * v15;
          do
          {
            mlir::dataflow::OffsetLatticeValue::join((unint64_t **)&v56, *v16 + 168, (unint64_t **)v52);
            llvm::SmallVectorImpl<mlir::detail::AllocRange>::operator=((uint64_t)&v56, (uint64_t)v52);
            if (v52[0] != &v53) {
              free(v52[0]);
            }
            ++v16;
            v40 -= 8;
          }
          while (v40);
        }
      }
    }
  }
  else
  {
    uint64_t v50 = 0;
    uint64_t InterfaceFor = 0;
  }
  if (!v57) {
    mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::setAllToEntryStates((uint64_t)a1, v48, v49);
  }
  uint64_t v41 = *(unsigned int *)(a2 + 36);
  if (v41) {
    uint64_t v42 = a2 - 16;
  }
  else {
    uint64_t v42 = 0;
  }
  if (v41)
  {
    for (uint64_t i = 0; i != v41; ++i)
    {
      uint64_t v44 = mlir::detail::OpResultImpl::getNextResultAtOffset(v42, i);
      uint64_t v45 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 48))(a1, v44);
      mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>::join(v45, (uint64_t)&v56);
    }
  }
  if (v56 != v58) {
    free(v56);
  }
}

uint64_t mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>::join(uint64_t a1, uint64_t a2)
{
  v13[50] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (void **)(a1 + 168);
  mlir::dataflow::OffsetLatticeValue::join((unint64_t **)(a1 + 168), a2, (unint64_t **)&__src);
  unint64_t v4 = v12;
  uint64_t v5 = *(unsigned int *)(a1 + 176);
  if (v12 == v5)
  {
    if (!v12)
    {
LABEL_6:
      uint64_t v9 = 0;
      goto LABEL_20;
    }
    unint64_t v6 = __src;
    uint64_t v7 = *v3;
    uint64_t v8 = 40 * v12;
    while (*v6 == *v7)
    {
      v6 += 5;
      v7 += 5;
      v8 -= 40;
      if (!v8) {
        goto LABEL_6;
      }
    }
  }
  if (v3 != &__src)
  {
    if (v5 >= v12)
    {
      if (v12) {
        memmove(*v3, __src, 40 * v12);
      }
      goto LABEL_18;
    }
    if (*(_DWORD *)(a1 + 180) >= v12)
    {
      if (v5)
      {
        memmove(*v3, __src, 40 * v5);
        goto LABEL_16;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 176) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v3, (void *)(a1 + 184), v4, 40);
    }
    uint64_t v5 = 0;
LABEL_16:
    if (v5 != v12) {
      memcpy((char *)*v3 + 40 * v5, (char *)__src + 40 * v5, 40 * v12 - 40 * v5);
    }
LABEL_18:
    *(_DWORD *)(a1 + 176) = v4;
  }
  uint64_t v9 = 1;
LABEL_20:
  if (__src != v13) {
    free(__src);
  }
  return v9;
}

{
  return mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>::join(a1, a2 + 168);
}

void mlir::dataflow::TensorAllocAnalysis::buildAllocInfoMap(mlir::dataflow::TensorAllocAnalysis *this, mlir::Operation *a2)
{
  v276[21] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)((((unint64_t)a2
                   + 16 * (((unint64_t)*((unsigned int *)a2 + 11) >> 23) & 1)
                   + (((unint64_t)*((unsigned int *)a2 + 11) >> 21) & 0x7F8)
                   + 71) & 0xFFFFFFFFFFFFFFF8)
                 + 32 * *((unsigned int *)a2 + 10)
                 + 8);
  if (v3) {
    unint64_t v4 = (mlir::GenericProgramPoint **)(v3 - 8);
  }
  else {
    unint64_t v4 = 0;
  }
  id v230 = (uint64_t **)((char *)this + 64);
  if (*((_DWORD *)this + 18))
  {
    uint64_t v5 = 0;
    unint64_t v6 = (void *)*((void *)this + 8);
    uint64_t v7 = (char *)this + 104;
    id v243 = (char *)a2 + 56;
    do
    {
      if (*v6 == -3)
      {
        mlir::Block::getTerminator(v4);
        if ((*(unsigned char *)(v13 + 46) & 0x80) != 0 && *(_DWORD *)(v13 + 68))
        {
          uint64_t v14 = *((void *)this + 13);
          uint64_t v15 = v14 + 8 * v5;
          uint64_t v16 = *((unsigned int *)this + 28);
          uint64_t v17 = v14 + 8 * v16;
          if (v17 != v15 + 8)
          {
            memmove((void *)v15, (const void *)(v15 + 8), v17 - (v15 + 8));
            LODWORD(v16) = *((_DWORD *)this + 28);
            uint64_t v14 = *((void *)this + 13);
          }
          *((_DWORD *)this + 28) = v16 - 1;
          if (*((unsigned char *)a2 + 47)
            && (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)a2, (uint64_t)"output_names", 12), v19))
          {
            if (InherentAttr)
            {
LABEL_22:
              if (*(_UNKNOWN **)(*(void *)InherentAttr + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id) {
                uint64_t v20 = InherentAttr;
              }
              else {
                uint64_t v20 = 0;
              }
              goto LABEL_27;
            }
          }
          else
          {
            uint64_t InherentAttr = mlir::DictionaryAttr::get((uint64_t)v243, "output_names", 0xCuLL);
            if (InherentAttr) {
              goto LABEL_22;
            }
          }
          uint64_t v20 = 0;
LABEL_27:
          *(void *)&long long v263 = v20;
          Value = (char *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v263);
          uint64_t v22 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v263);
          llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)v7, v14 + 8 * v5, Value, (char *)(v22 + 8 * v23));
          v252 = &v254;
          uint64_t v253 = (void *)0x500000000;
          mlir::Block::getTerminator(v4);
          if ((*(unsigned char *)(v24 + 46) & 0x80) != 0 && (uint64_t v25 = *(unsigned int *)(v24 + 68), v25))
          {
            int64_t v26 = (_DWORD **)(*(void *)(v24 + 72) + 24);
            do
            {
              mlir::detail::AllocRange::getRangeForValue(*v26, 0, (uint64_t)&v271);
              unint64_t v27 = v273;
              uint64_t v28 = v272;
              uint64_t v29 = v253;
              if (v253 >= (unint64_t)HIDWORD(v253))
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v252, &v254, v253 + 1, 8);
                uint64_t v29 = v253;
              }
              *((void *)v252 + v29) = v27 - v28 + 1;
              unsigned int v30 = v253 + 1;
              LODWORD(v253) = v253 + 1;
              v26 += 4;
              --v25;
            }
            while (v25);
          }
          else
          {
            unsigned int v30 = v253;
          }
          uint64_t v31 = (char *)v252 + 8 * v30;
          BOOL v32 = (char *)v252 + 8;
          void *v6 = *(void *)v252;
          unint64_t v6 = (void *)llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)v230, (uint64_t)(v6 + 1), v32, v31);
          if (v252 != &v254) {
            free(v252);
          }
        }
      }
      else if (*v6 == -2)
      {
        mlir::Block::getTerminator(v4);
        if ((*(unsigned char *)(v8 + 46) & 0x80) != 0 && (uint64_t v9 = *(unsigned int *)(v8 + 68), v9))
        {
          unint64_t v10 = 0;
          uint64_t v11 = (_DWORD **)(*(void *)(v8 + 72) + 24);
          do
          {
            unsigned int v12 = *v11;
            v11 += 4;
            mlir::detail::AllocRange::getRangeForValue(v12, v10, (uint64_t)&v252);
            unint64_t v10 = v10 + v255[0] - (void)v253 + 1;
            --v9;
          }
          while (v9);
          void *v6 = v10;
        }
        else
        {
          void *v6 = 0;
        }
      }
      ++v5;
      ++v6;
    }
    while (v6 != (void *)(*((void *)this + 8) + 8 * *((unsigned int *)this + 18)));
  }
  mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)&v252);
  mlir::AsmState::AsmState(&v244, a2, &v252, 0, 0);
  uint64_t v33 = this;
  unint64_t v34 = (uint64_t *)*((void *)this + 8);
  unint64_t v35 = *((unsigned int *)this + 18);
  LOBYTE(v252) = *((unsigned char *)this + 160);
  uint64_t v253 = v255;
  uint64_t v254 = 0x300000000;
  if (v35)
  {
    if (v35 < 4)
    {
      unsigned int v42 = 0;
      uint64_t v36 = v255;
    }
    else
    {
      v271 = 0;
      uint64_t v36 = llvm::SmallVectorBase<unsigned int>::mallocForGrow((uint64_t)&v253, v255, v35, 1000, (unint64_t *)&v271);
      unint64_t v37 = (char *)v253;
      if (v254)
      {
        uint64_t v38 = 0;
        uint64_t v39 = (char *)v253 + 1000 * v254;
        do
        {
          uint64_t v40 = &v36[v38];
          uint64_t v41 = &v37[v38 * 8];
          void *v40 = *(void *)&v37[v38 * 8];
          v36[v38 + 1] = &v36[v38 + 3];
          v40[2] = 0xA00000000;
          if (*(_DWORD *)&v37[v38 * 8 + 16]) {
            llvm::SmallVectorImpl<mlir::detail::AllocRange>::operator=((uint64_t)&v36[v38 + 1], (uint64_t)(v41 + 8));
          }
          v40[53] = v40 + 55;
          v40[54] = 0xA00000000;
          if (*((_DWORD *)v41 + 108)) {
            llvm::SmallVectorImpl<llvm::SmallSetVector<mlir::Value,2u>>::operator=((uint64_t)(v40 + 53), (uint64_t *)&v37[v38 * 8 + 424]);
          }
          v38 += 125;
        }
        while (v41 + 1000 != v39);
        unint64_t v37 = (char *)v253;
        int v43 = v254;
      }
      else
      {
        int v43 = 0;
      }
      int v44 = (int)v271;
      if (v253 != v255) {
        free(v253);
      }
      uint64_t v253 = v36;
      HIDWORD(v254) = v44;
      unsigned int v42 = v254;
      uint64_t v33 = this;
      if (v254 == v35) {
        goto LABEL_55;
      }
    }
    uint64_t v45 = 1000 * v42;
    uint64_t v46 = 1000 * v35;
    do
    {
      int v47 = &v36[(unint64_t)v45 / 8];
      bzero(&v36[(unint64_t)v45 / 8 + 3], 0x3D0uLL);
      *int v47 = -1;
      v47[1] = &v36[(unint64_t)v45 / 8 + 3];
      v47[2] = 0xA00000000;
      v47[53] = v47 + 55;
      v46 -= 1000;
      v36 += 125;
      *((_DWORD *)v47 + 109) = 10;
    }
    while (v45 != v46);
    uint64_t v36 = v253;
    uint64_t v33 = this;
LABEL_55:
    LODWORD(v254) = v35;
    uint64_t v48 = 1000 * v35;
    do
    {
      uint64_t v49 = *v34++;
      uint64_t v50 = v49 - 1;
      if (v49 == -1) {
        uint64_t v51 = -1;
      }
      else {
        uint64_t v51 = v50;
      }
      void *v36 = v51;
      v36 += 125;
      v48 -= 1000;
    }
    while (v48);
  }
  uint64_t v52 = v4[4];
  unsigned int v229 = (mlir::GenericProgramPoint *)(v4 + 4);
  if (v52 == (mlir::GenericProgramPoint *)(v4 + 4)) {
    goto LABEL_371;
  }
  uint64_t v233 = (uint64_t)v33 + 24;
  id v228 = (char *)v33 + 80;
  while (2)
  {
    id v231 = (mlir::GenericProgramPoint **)v52;
    mlir::GenericProgramPoint::~GenericProgramPoint(v52);
    uint64_t v240 = v53;
    if ((*((unsigned char *)v53 + 46) & 0x80) == 0) {
      goto LABEL_291;
    }
    uint64_t v238 = *((unsigned int *)v53 + 17);
    if (!v238) {
      goto LABEL_218;
    }
    uint64_t v55 = 0;
    uint64_t v235 = *((void *)v53 + 9);
    do
    {
      uint64_t v56 = *(void **)(v235 + 32 * v55 + 24);
      uint64_t v57 = (*(uint64_t (**)(mlir::dataflow::TensorAllocAnalysis *, void *))(*(void *)v33 + 48))(v33, v56);
      unint64_t v58 = *(unsigned int *)(v57 + 176);
      if (!v58) {
        goto LABEL_66;
      }
      uint64_t v59 = v57;
      uint64_t v251 = v56;
      __b = v270;
      HIDWORD(v269) = 4;
      if (v58 <= 4)
      {
        memset(v270, 255, 8 * v58);
        LODWORD(v269) = v58;
        uint64_t v60 = (uint64_t **)v270;
        uint64_t v62 = *(void **)(v59 + 168);
        unint64_t v63 = &v62[5 * v58];
      }
      else
      {
        LODWORD(v269) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__b, v270, v58, 8);
        uint64_t v60 = (uint64_t **)__b;
        memset(__b, 255, 8 * v58);
        unsigned int v61 = *(_DWORD *)(v59 + 176);
        LODWORD(v269) = v58;
        if (!v61)
        {
          int v74 = 1;
          goto LABEL_93;
        }
        uint64_t v62 = *(void **)(v59 + 168);
        unint64_t v63 = &v62[5 * v61];
      }
      uint64_t v64 = 0;
      do
      {
        if (v62[1] != -1 && v62[2] != -1 && v62[3] != -1 && v254)
        {
          uint64_t v65 = 0;
          uint64_t v66 = v253;
          while (1)
          {
            uint64_t v67 = v66[1];
            uint64_t v68 = *((unsigned int *)v66 + 4);
            if (v68)
            {
              uint64_t v69 = 40 * v68;
              int64_t v70 = (void *)v66[1];
              while (*v70 != *v62)
              {
                v70 += 5;
                v69 -= 40;
                if (!v69)
                {
                  int64_t v70 = (void *)(v67 + 40 * v68);
                  break;
                }
              }
            }
            else
            {
              int64_t v70 = (void *)v66[1];
            }
            unint64_t v71 = (char *)v70 - v67;
            unint64_t v72 = 0xCCCCCCCCCCCCCCCDLL * (((uint64_t)v70 - v67) >> 3);
            BOOL v73 = v71 == (char *)-40 || v72 == v68;
            if (!v73) {
              break;
            }
            ++v65;
            v66 += 125;
            if (v66 == (void *)((char *)v253 + 1000 * v254)) {
              goto LABEL_73;
            }
          }
          v271 = v251;
          llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,2u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,2u>::insert(v66[53] + 56 * v72, (unint64_t *)&v271);
          uint64_t v60 = (uint64_t **)__b;
          *((void *)__b + v64) = v65;
        }
LABEL_73:
        ++v64;
        v62 += 5;
      }
      while (v62 != v63);
      unint64_t v58 = v269;
      int v74 = (int)v269;
      uint64_t v33 = this;
LABEL_93:
      *(void *)&long long v263 = &v264;
      *((void *)&v263 + 1) = 0x200000000;
      v266 = 0;
      unint64_t v267 = 0;
      int v265 = (unint64_t *)&v266;
      if (!v74) {
        goto LABEL_148;
      }
      uint64_t v75 = 8 * v58;
      do
      {
        llvm::SmallSet<long long,2u,std::less<long long>>::insert((uint64_t)&v263, v60++, (uint64_t)&v271);
        v75 -= 8;
      }
      while (v75);
      if (!v267)
      {
        if (DWORD2(v263) > 2)
        {
LABEL_117:
          uint64_t Loc = mlir::Value::getLoc((mlir::Value *)&v251);
          unsigned int v87 = "Cannot pack an OffsetLatticeValue that contains ranges that were already allocated to different buffers."
                " This is an invalid program state.";
          goto LABEL_124;
        }
        if (DWORD2(v263) == 1)
        {
          unint64_t v88 = (void *)v263;
          goto LABEL_128;
        }
        if (DWORD2(v263) == 2)
        {
          id v79 = (unint64_t *)v263;
          if (*(void *)v263 != -1 && *(void *)(v263 + 8) != -1) {
            goto LABEL_123;
          }
          uint8x8_t v80 = (unint64_t *)(v263 + 16);
          while (1)
          {
LABEL_133:
            uint64_t v90 = v79 + 4;
            if (!v267) {
              uint64_t v90 = v79;
            }
            unint64_t v81 = *v90;
            if (v81 != -1) {
              break;
            }
            if (v267)
            {
              uint64_t v91 = (unint64_t *)v79[1];
              if (v91)
              {
                do
                {
                  uint64_t v89 = v91;
                  uint64_t v91 = (unint64_t *)*v91;
                }
                while (v91);
              }
              else
              {
                do
                {
                  uint64_t v89 = (unint64_t *)v79[2];
                  BOOL v73 = *v89 == (void)v79;
                  id v79 = v89;
                }
                while (!v73);
              }
            }
            else
            {
              uint64_t v89 = v79 + 1;
            }
            id v79 = v89;
            if (v89 == v80) {
              goto LABEL_107;
            }
          }
LABEL_108:
          uint64_t v82 = v269;
          if (v269)
          {
            if (v269 < 4)
            {
              unint64_t v83 = (unint64_t *)__b;
              uint64_t v84 = v269;
LABEL_146:
              unint64_t v95 = v84 + 1;
              do
              {
                *v83++ = v81;
                --v95;
              }
              while (v95 > 1);
              goto LABEL_148;
            }
            unint64_t v83 = (unint64_t *)((char *)__b + 8 * (v269 & 0xFFFFFFFC));
            uint64_t v84 = v269 & 3;
            int64x2_t v92 = vdupq_n_s64(v81);
            id v93 = (int64x2_t *)((char *)__b + 16);
            uint64_t v94 = v269 & 0xFFFFFFFC;
            do
            {
              v93[-1] = v92;
              int64x2_t *v93 = v92;
              v93 += 2;
              v94 -= 4;
            }
            while (v94);
            if ((v82 & 0xFFFFFFFC) != v82) {
              goto LABEL_146;
            }
          }
        }
LABEL_148:
        uint64_t v96 = *(void *)__b;
        uint64_t v97 = *(unsigned int *)(v59 + 176);
        if (v97)
        {
          uint64_t v98 = 40 * v97;
          int v99 = *(void **)(v59 + 168);
          while (1)
          {
            BOOL v100 = v99[1] == -1 || v99[2] == -1;
            if (!v100 && v99[3] != -1) {
              break;
            }
            v99 += 5;
            v98 -= 40;
            if (!v98)
            {
              unsigned int v101 = 0;
              v271 = (char *)&v272 + 8;
              DWORD1(v272) = 4;
              goto LABEL_183;
            }
          }
        }
        else
        {
          int v99 = *(void **)(v59 + 168);
        }
        uint64_t v102 = *(void *)(v59 + 168) + 40 * v97;
        v271 = (char *)&v272 + 8;
        *(void *)&long long v272 = 0x400000000;
        if (v99 == (void *)v102)
        {
          unsigned int v101 = 0;
        }
        else
        {
          unint64_t v103 = 0;
          uint64_t v104 = v99;
LABEL_161:
          unint64_t v105 = v103++;
          while (1)
          {
            v104 += 5;
            if (v104 == (void *)v102) {
              break;
            }
            BOOL v106 = v104[1] == -1 || v104[2] == -1;
            if (!v106 && v104[3] != -1)
            {
              if (v104 != (void *)v102) {
                goto LABEL_161;
              }
              break;
            }
          }
          if (v105 < 4)
          {
            int v107 = 0;
            size_t v108 = (char *)&v272 + 8;
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v271, (char *)&v272 + 8, v103, 40);
            int v107 = v272;
            size_t v108 = (char *)v271;
          }
          int v109 = &v108[40 * v107];
LABEL_174:
          long long v110 = *(_OWORD *)v99;
          long long v111 = *((_OWORD *)v99 + 1);
          *((void *)v109 + 4) = v99[4];
          *(_OWORD *)int v109 = v110;
          *((_OWORD *)v109 + 1) = v111;
          while (1)
          {
            v99 += 5;
            if (v99 == (void *)v102) {
              break;
            }
            BOOL v112 = v99[1] == -1 || v99[2] == -1;
            if (!v112 && v99[3] != -1)
            {
              v109 += 40;
              if (v99 != (void *)v102) {
                goto LABEL_174;
              }
              break;
            }
          }
          unsigned int v101 = v272 + v103;
        }
LABEL_183:
        LODWORD(v272) = v101;
        uint64_t v260 = v262;
        uint64_t v261 = 0x400000000;
        uint64_t v113 = (char *)v253;
        if (v96 == -1)
        {
          if (v254)
          {
            uint64_t v114 = 1000 * v254;
            while (1)
            {
              LODWORD(v261) = 0;
              v113 += 1000;
              v114 -= 1000;
              if (!v114) {
                goto LABEL_190;
              }
            }
          }
          else
          {
LABEL_190:
            uint64_t v113 = 0;
          }
        }
        else
        {
          uint64_t v113 = (char *)v253 + 1000 * v96;
          {
LABEL_209:
            if (v260 != v262) {
              free(v260);
            }
            uint64_t v33 = this;
            if (v271 != (char *)&v272 + 8) {
              free(v271);
            }
            goto LABEL_213;
          }
        }
        if (*(_DWORD *)(v59 + 176)) {
          BOOL v115 = v261 == 0;
        }
        else {
          BOOL v115 = 1;
        }
        if (!v115)
        {
          uint64_t v116 = *(void *)(v59 + 168);
          unint64_t v117 = *(void *)v260;
          unint64_t v118 = *(void *)(v116 + 32);
          long long v119 = *(_OWORD *)(v116 + 16);
          *(void *)&long long v248 = *(void *)v116;
          long long v249 = v119;
          uint64_t v250 = v118;
          *((void *)&v248 + 1) = v117;
          if (v118) {
            unint64_t v117 = (v117 + v118 - 1) / v118 * v118;
          }
          *(void *)&long long v249 = v117;
          *((void *)&v249 + 1) = *((void *)&v119 + 1) - v119 + v117;
          long long v256 = 0uLL;
          LODWORD(v257) = 0;
          *((void *)&v257 + 1) = v259;
          uint64_t v258 = 0x200000000;
          llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,2u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,2u>::insert((uint64_t)&v256, (unint64_t *)&v248);
          llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,2u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,2u>::insert((uint64_t)&v256, (unint64_t *)&v251);
          uint64_t v247 = v250;
          long long v245 = v248;
          long long v246 = v249;
          uint64_t v120 = *((void *)v113 + 1);
          unint64_t v121 = *((unsigned int *)v113 + 4);
          if (!v121)
          {
            uint64_t v122 = *((void *)v113 + 1);
LABEL_206:
            uint64_t v126 = v122 - v120;
            llvm::SmallVectorImpl<llvm::SmallSetVector<mlir::Value,2u>>::insert_one_impl<llvm::SmallSetVector<mlir::Value,2u> const&>((uint64_t)(v113 + 424), *((void *)v113 + 53) - 0x3333333333333328 * ((v122 - v120) >> 3), (unint64_t)&v256);
            llvm::SmallVectorImpl<mlir::detail::AllocRange>::insert_one_impl<mlir::detail::AllocRange const&>((uint64_t)(v113 + 8), *((void *)v113 + 1) + v126, (unint64_t)&v245);
            if (*((unsigned char **)&v257 + 1) != v259) {
              free(*((void **)&v257 + 1));
            }
            llvm::deallocate_buffer((llvm *)v256, (void *)(8 * v257));
          }
          uint64_t v122 = *((void *)v113 + 1);
          while (2)
          {
            unint64_t v123 = v121 >> 1;
            uint64_t v124 = v122 + 40 * (v121 >> 1);
            uint64_t v125 = *(void *)(v124 + 8);
            if (*((void *)&v245 + 1) == v125)
            {
              if (*((void *)&v246 + 1) - *((void *)&v245 + 1) + 1 >= *(void *)(v122 + 40 * v123 + 24)
                                                                          - *((void *)&v245 + 1)
                                                                          + 1)
              {
LABEL_204:
                uint64_t v122 = v124 + 40;
                unint64_t v123 = v121 + ~v123;
              }
            }
            else if (*((uint64_t *)&v245 + 1) >= v125)
            {
              goto LABEL_204;
            }
            unint64_t v121 = v123;
            if (!v123) {
              goto LABEL_206;
            }
            continue;
          }
        }
        goto LABEL_209;
      }
      if (v267 > 2) {
        goto LABEL_117;
      }
      if (v267 == 2)
      {
        unint64_t v76 = v266;
        if (v266)
        {
          unint64_t v77 = v266;
          while (1)
          {
            uint64_t v78 = v77[4];
            if (v78 < 0)
            {
              if (v78 == -1)
              {
                id v79 = v265;
                uint8x8_t v80 = (unint64_t *)&v266;
                if (v265 != (unint64_t *)&v266) {
                  goto LABEL_133;
                }
LABEL_107:
                unint64_t v81 = -1;
                goto LABEL_108;
              }
              ++v77;
            }
            unint64_t v77 = (void *)*v77;
            if (!v77)
            {
              while (1)
              {
                uint64_t v85 = v76[4];
                if (v85 < 0)
                {
                  if (v85 == -1) {
                    goto LABEL_148;
                  }
                  ++v76;
                }
                unint64_t v76 = (void *)*v76;
                if (!v76) {
                  goto LABEL_123;
                }
              }
            }
          }
        }
LABEL_123:
        uint64_t Loc = mlir::Value::getLoc((mlir::Value *)&v251);
        unsigned int v87 = "Operands were allocated into multiple buffers. This is an invalid program state.";
LABEL_124:
        *(void *)&long long v256 = v87;
        LOWORD(v258) = 259;
        mlir::emitError(Loc, (uint64_t)&v256, (uint64_t)&v271);
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v271);
        if (v271) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v271);
        }
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v272);
        goto LABEL_213;
      }
      unint64_t v88 = v265 + 4;
LABEL_128:
      if (*v88 == -1) {
        goto LABEL_148;
      }
LABEL_213:
      std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v265, v266);
      if ((long long *)v263 != &v264) {
        free((void *)v263);
      }
      if (__b != v270) {
        free(__b);
      }
LABEL_66:
      ++v55;
    }
    while (v55 != v238);
    uint64_t v53 = v240;
    if ((*((unsigned char *)v240 + 46) & 0x80) != 0)
    {
LABEL_218:
      uint64_t v236 = *((unsigned int *)v53 + 17);
      if (v236)
      {
        uint64_t v127 = 0;
        uint64_t v234 = *((void *)v53 + 9);
        do
        {
          uint64_t v239 = v127;
          unint64_t v129 = *(_DWORD **)(v234 + 32 * v127 + 24);
          uint64_t v260 = v129;
          if (v254)
          {
            uint64_t v130 = 0;
            uint64_t v131 = (char *)v253;
            id v241 = (char *)v253 + 1000 * v254;
            while (1)
            {
              v271 = (char *)&v272 + 8;
              *(void *)&long long v272 = 0x400000000;
              unsigned int v134 = *((_DWORD *)v131 + 108);
              if (v134)
              {
                unsigned int v135 = 0;
                uint64_t v136 = 0;
                uint64_t v137 = *((void *)v131 + 53);
                uint64_t v138 = v137 + 56 * v134;
                do
                {
                  uint64_t v142 = *(void *)(v137 + 24);
                  uint64_t v143 = *(unsigned int *)(v137 + 32);
                  if (v143)
                  {
                    uint64_t v144 = 8 * v143;
                    uint64_t v145 = *(void **)(v137 + 24);
                    while ((_DWORD *)*v145 != v129)
                    {
                      ++v145;
                      v144 -= 8;
                      if (!v144)
                      {
                        uint64_t v145 = (void *)(v142 + 8 * v143);
                        break;
                      }
                    }
                  }
                  else
                  {
                    uint64_t v145 = *(void **)(v137 + 24);
                  }
                  uint64_t v146 = ((uint64_t)v145 - v142) >> 3;
                  if (v146 != v143)
                  {
                    uint64_t v147 = *((void *)v131 + 1) + 40 * v136;
                    long long v256 = *(_OWORD *)v147;
                    long long v257 = *(_OWORD *)(v147 + 16);
                    uint64_t v258 = *(void *)(v147 + 32);
                    if (v135 < DWORD1(v272))
                    {
                      int8x8_t v139 = (char *)v271 + 48 * v135;
                      __n128 v54 = *(__n128 *)v147;
                      long long v140 = *(_OWORD *)(v147 + 16);
                      uint64_t v141 = *(void *)(v147 + 32);
                      *(__n128 *)int8x8_t v139 = v54;
                      *((_OWORD *)v139 + 1) = v140;
                      *((void *)v139 + 4) = v141;
                      *((void *)v139 + 5) = v146;
                    }
                    else
                    {
                      long long v263 = v256;
                      long long v264 = v257;
                      int v265 = (unint64_t *)v258;
                      v266 = (void *)v146;
                      unint64_t v148 = v135 + 1;
                      BOOL v149 = (char *)v271 + 48 * v135 > (char *)&v263;
                      if (v271 <= &v263 && v149)
                      {
                        int64_t v154 = (char *)&v263 - (unsigned char *)v271;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v271, (char *)&v272 + 8, v148, 48);
                        uint64_t v151 = (char *)v271;
                        uint64_t v150 = (__n128 *)((char *)v271 + v154);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v271, (char *)&v272 + 8, v148, 48);
                        uint64_t v150 = (__n128 *)&v263;
                        uint64_t v151 = (char *)v271;
                      }
                      int v152 = (__n128 *)&v151[48 * v272];
                      __n128 v54 = *v150;
                      __n128 v153 = v150[2];
                      v152[1] = v150[1];
                      v152[2] = v153;
                      *int v152 = v54;
                    }
                    unsigned int v135 = v272 + 1;
                    LODWORD(v272) = v272 + 1;
                  }
                  ++v136;
                  v137 += 56;
                }
                while (v137 != v138);
                uint64_t v155 = (char *)v271;
                if (v135)
                {
                  unint64_t v156 = v135;
                  int v157 = (char *)v271 + 48 * v135;
                  unint64_t v158 = v135;
                  if (v135 < 0x81)
                  {
LABEL_255:
                  }
                  else
                  {
                    while (1)
                    {
                      unint64_t v159 = operator new(48 * v158, MEMORY[0x1E4FBA2D0]);
                      if (v159) {
                        break;
                      }
                      BOOL v160 = v158 > 1;
                      v158 >>= 1;
                      if (!v160) {
                        goto LABEL_255;
                      }
                    }
                    uint64_t v165 = v159;
                    operator delete(v165);
                  }
                  uint64_t v155 = (char *)v271;
                  uint64_t v161 = *(void **)v271;
                  uint64_t v164 = *((void *)v271 + 1);
                  uint64_t v163 = *((void *)v271 + 2);
                  uint64_t v162 = *((void *)v271 + 3);
                }
                else
                {
                  uint64_t v161 = 0;
                  uint64_t v162 = -1;
                  uint64_t v163 = -1;
                  uint64_t v164 = -1;
                }
                if (v155 != (char *)&v272 + 8) {
                  free(v155);
                }
                BOOL v132 = v164 == -1 || v163 == -1;
                if (!v132 && v162 != -1) {
                  break;
                }
              }
              ++v130;
              v131 += 1000;
              if (v131 == v241) {
                goto LABEL_278;
              }
            }
            uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v260);
            if (!DefiningOp
              || (uint64_t v167 = DefiningOp,
                  !mlir::OpInterface<mlir::MemoryMapperInterface,mlir::detail::MemoryMapperInterfaceInterfaceTraits>::getInterfaceFor(DefiningOp))
              || (mlir::OpInterface<mlir::MemoryMapperInterface,mlir::detail::MemoryMapperInterfaceInterfaceTraits>::getInterfaceFor(v167),
                  uint64_t v242 = *(unsigned int *)(v167 + 36),
                  v242 < 2)
              || v161 == v260)
            {
              uint64_t v33 = this;
LABEL_271:
              uint64_t v171 = *(void *)(*((void *)v33 + 13) + 8 * v130);
              v271 = v129;
              *(void *)&long long v272 = v163;
              *((void *)&v272 + 1) = v171;
              llvm::MapVector<mlir::Value,mlir::dataflow::TensorAllocAnalysis::AllocInfo,llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,llvm::SmallVector<std::pair<mlir::Value,mlir::dataflow::TensorAllocAnalysis::AllocInfo>,0u>>::try_emplace<mlir::dataflow::TensorAllocAnalysis::AllocInfo>(v233, (unint64_t *)&v271, &v272);
              uint64_t v172 = v239;
              goto LABEL_221;
            }
            uint64_t v168 = 0;
            uint64_t v232 = (mlir::detail::OpResultImpl *)(v167 - 16);
            unint64_t v169 = v164;
            while (1)
            {
              uint64_t NextResultAtOffset = (_DWORD *)mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v232, v168);
              mlir::detail::AllocRange::getRangeForValue(NextResultAtOffset, v169, (uint64_t)&v263);
              if (*((uint64_t *)&v264 + 1) > v162)
              {
                uint64_t v173 = mlir::Value::getLoc((mlir::Value *)&v260);
                *(void *)&long long v256 = "Attempted to subdivide a range that isn't large enough. This usually happens when the"
                                   " requested alignment is incompatible with your tensor shapes. The required alignment was: ";
                LOWORD(v258) = 259;
                mlir::emitError(v173, (uint64_t)&v256, (uint64_t)&v271);
                if (v271)
                {
                  LODWORD(__b) = 2;
                  uint64_t v269 = v265;
                  unint64_t v174 = v273;
                  if (v274 >= v275)
                  {
                    unint64_t v181 = v274 + 1;
                    if (v273 <= (unint64_t)&__b && v273 + 24 * v274 > (unint64_t)&__b)
                    {
                      uint64_t v182 = (char *)&__b - v273;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v273, v276, v181, 24);
                      unint64_t v174 = v273;
                      p_b = (void **)&v182[v273];
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v273, v276, v181, 24);
                      p_b = &__b;
                      unint64_t v174 = v273;
                    }
                  }
                  else
                  {
                    p_b = &__b;
                  }
                  unint64_t v176 = v174 + 24 * v274;
                  long long v177 = *(_OWORD *)p_b;
                  *(void *)(v176 + 16) = p_b[2];
                  *(_OWORD *)unint64_t v176 = v177;
                  ++v274;
                  if (v271) {
                    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v271);
                  }
                }
                std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v272);
                goto LABEL_278;
              }
              if (v260 == NextResultAtOffset) {
                break;
              }
              unint64_t v169 = *((void *)&v264 + 1) + 1;
              if (v242 == ++v168) {
                goto LABEL_283;
              }
            }
            uint64_t v164 = *((void *)&v263 + 1);
            uint64_t v162 = *((void *)&v264 + 1);
            uint64_t v163 = v264;
LABEL_283:
            uint64_t v33 = this;
            if (v164 != -1 && v163 != -1 && v162 != -1) {
              goto LABEL_271;
            }
          }
          else
          {
LABEL_278:
            uint64_t v33 = this;
          }
          uint64_t v172 = v239;
          if ((~v129[2] & 7) != 0)
          {
            v271 = v129;
            uint64_t v178 = mlir::Value::getDefiningOp((mlir::Value *)&v271);
            if (v178)
            {
              uint64_t v179 = v178;
              uint64_t v180 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
              (*(void (**)(void, uint64_t))(**(void **)(v179 + 48) + 32))(*(void *)(v179 + 48), v180);
            }
          }
          uint64_t v128 = *((void *)v33 + 18);
          v271 = v129;
          *(void *)&long long v272 = -1;
          *((void *)&v272 + 1) = v128;
          llvm::MapVector<mlir::Value,mlir::dataflow::TensorAllocAnalysis::AllocInfo,llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,llvm::SmallVector<std::pair<mlir::Value,mlir::dataflow::TensorAllocAnalysis::AllocInfo>,0u>>::try_emplace<mlir::dataflow::TensorAllocAnalysis::AllocInfo>(v233, (unint64_t *)&v271, &v272);
LABEL_221:
          uint64_t v127 = v172 + 1;
        }
        while (v127 != v236);
      }
    }
LABEL_291:
    uint64_t v183 = v254;
    uint64_t v184 = *((unsigned int *)v33 + 18);
    int v185 = v254 - v184;
    if (v254 == v184)
    {
      unsigned int v186 = v254;
      if (!v254) {
        goto LABEL_62;
      }
LABEL_300:
      uint64_t v192 = (char *)v253;
      int v193 = *v230;
      unint64_t v194 = (char *)v253 + 8;
      uint64_t v195 = 1000 * v183;
      while (2)
      {
        uint64_t v196 = *((void *)v194 - 1);
        if (v196 == -1)
        {
          unsigned int v198 = *((_DWORD *)v194 + 2);
          if (!v198)
          {
            uint64_t v197 = 0;
            goto LABEL_305;
          }
          uint64_t v196 = *(void *)(*(void *)v194 + 40 * v198 - 16);
        }
        if (v196) {
          uint64_t v197 = v196 + 1;
        }
        else {
          uint64_t v197 = 0;
        }
LABEL_305:
        if (*v193 > v197) {
          uint64_t v197 = *v193;
        }
        *v193++ = v197;
        v194 += 1000;
        v195 -= 1000;
        if (!v195)
        {
          if (!(_BYTE)v252) {
            goto LABEL_62;
          }
          uint64_t v199 = &v192[1000 * v186];
          while (2)
          {
            int32x4_t v202 = (void *)*((void *)v192 + 1);
            uint64_t v203 = *((unsigned int *)v192 + 4);
            long long v204 = &v202[5 * v203];
            if (v203)
            {
              uint64_t v205 = 40 * v203;
              while (1)
              {
                BOOL v206 = v202[1] == -1 || v202[2] == -1;
                if (v206 || v202[3] == -1) {
                  break;
                }
                if ((~*(_DWORD *)(*v202 + 8) & 7) != 0)
                {
                  int32x4_t v208 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v202);
                  if (mlir::Operation::isBeforeInBlock((mlir::Block **)v240, v208) || v208 == v240) {
                    break;
                  }
                }
                v202 += 5;
                v205 -= 40;
                if (!v205)
                {
                  int32x4_t v202 = v204;
                  goto LABEL_349;
                }
              }
            }
            id v209 = v202 + 5;
            if (v202 != v204 && v209 != v204)
            {
              do
              {
                if (v209[1] != -1 && v209[2] != -1 && v209[3] != -1)
                {
                  if ((~*(_DWORD *)(*v209 + 8) & 7) == 0
                    || (int8x16_t v215 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)v209),
                        !mlir::Operation::isBeforeInBlock((mlir::Block **)v240, v215))
                    && v215 != v240)
                  {
                    long long v211 = *(_OWORD *)v209;
                    long long v212 = *((_OWORD *)v209 + 1);
                    v202[4] = v209[4];
                    *(_OWORD *)int32x4_t v202 = v211;
                    *((_OWORD *)v202 + 1) = v212;
                    v202 += 5;
                  }
                }
                v209 += 5;
              }
              while (v209 != v204);
            }
LABEL_349:
            int8x16_t v216 = (void *)*((void *)v192 + 1);
            unint64_t v217 = 0xCCCCCCCCCCCCCCCDLL * (v202 - v216);
            *((_DWORD *)v192 + 4) = v217;
            uint64_t v200 = *((void *)v192 + 53);
            unsigned int v201 = *((_DWORD *)v192 + 108);
            uint64_t v218 = v200 + 56 * v201;
            uint64_t v219 = v200;
            if (v201 && (uint64_t v219 = *((void *)v192 + 53), v217))
            {
              uint64_t v219 = *((void *)v192 + 53);
              do
              {
                unint64_t v220 = 0xFFFFFFF800000008 * (v202 - v216);
                int v221 = v216;
                while (*v221 != **(void **)(v219 + 24))
                {
                  v221 += 5;
                  v220 -= 40;
                  if (!v220) {
                    goto LABEL_358;
                  }
                }
                v219 += 56;
              }
              while (v219 != v218);
LABEL_368:
              uint64_t v223 = v200 + 56 * v201;
            }
            else
            {
LABEL_358:
              if (v219 == v218) {
                goto LABEL_368;
              }
              uint64_t v222 = v219 + 56;
              if (v219 + 56 == v218)
              {
                uint64_t v223 = v219;
              }
              else
              {
                uint64_t v223 = v219;
                do
                {
                  uint64_t v224 = v219;
                  uint64_t v219 = v222;
                  uint64_t v225 = *((unsigned int *)v192 + 4);
                  if (v225)
                  {
                    id v226 = (void *)*((void *)v192 + 1);
                    uint64_t v227 = 40 * v225;
                    do
                    {
                      if (*v226 == **(void **)(v224 + 80)) {
                        llvm::deallocate_buffer(*(llvm **)v223, (void *)(8 * *(unsigned int *)(v223 + 16)));
                      }
                      v226 += 5;
                      v227 -= 40;
                    }
                    while (v227);
                  }
                  uint64_t v222 = v219 + 56;
                }
                while (v219 + 56 != v218);
                uint64_t v200 = *((void *)v192 + 53);
                unsigned int v201 = *((_DWORD *)v192 + 108);
              }
            }
            llvm::SmallVectorImpl<llvm::SmallSetVector<mlir::Value,2u>>::erase((uint64_t *)v192 + 53, v223, v200 + 56 * v201);
            v192 += 1000;
            if (v192 == v199) {
              goto LABEL_62;
            }
            continue;
          }
        }
        continue;
      }
    }
    if (v254 >= v184)
    {
      int v188 = v254;
      unsigned int v189 = *((_DWORD *)v33 + 19);
      unsigned int v186 = v254;
      uint64_t v190 = v184;
      int v191 = v184;
      if (v189 < v254)
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)v230, v228, v254, 8);
        uint64_t v190 = *((unsigned int *)this + 18);
        int v188 = v254;
        unsigned int v186 = v254;
        int v191 = *((_DWORD *)this + 18);
      }
      bzero(&(*v230)[v190], 8 * (v183 - v184));
      int v187 = v185 + v191;
      LODWORD(v183) = v188;
    }
    else
    {
      unsigned int v186 = v254;
      int v187 = v254;
    }
    *((_DWORD *)this + 18) = v187;
    if (v186) {
      goto LABEL_300;
    }
LABEL_62:
    uint64_t v52 = *v231;
    uint64_t v33 = this;
    if (*v231 != v229) {
      continue;
    }
    break;
  }
  LODWORD(v35) = v254;
LABEL_371:
  if (v253 != v255) {
    free(v253);
  }
  mlir::AsmState::~AsmState(&v244);
}

uint64_t llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>(uint64_t a1, uint64_t a2, char *__src, char *a4)
{
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 3;
  uint64_t v10 = *(unsigned int *)(a1 + 8);
  unint64_t v9 = *(unsigned int *)(a1 + 12);
  unsigned int v11 = *(_DWORD *)(a1 + 8);
  size_t v12 = a4 - __src;
  unint64_t v13 = (a4 - __src) >> 3;
  unint64_t v14 = v13 + v10;
  if (*(void *)a1 + 8 * v10 != a2)
  {
    if (v14 > v9)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v14, 8);
      uint64_t v7 = *(void *)a1;
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    uint64_t v15 = (char *)(v7 + 8 * v10);
    __srca = (char *)(v7 + 8 * v8);
    size_t v16 = v15 - __srca;
    unint64_t v17 = (v15 - __srca) >> 3;
    if (v17 < v13)
    {
      unsigned int v18 = v11 + (v12 >> 3);
      *(_DWORD *)(a1 + 8) = v18;
      if (v8 == v10)
      {
        char v19 = __src;
        uint64_t v21 = v7 + 8 * v8;
        uint64_t v20 = a4;
        goto LABEL_34;
      }
      uint64_t v21 = v7 + 8 * v8;
      memcpy((void *)(v7 + 8 * v18 - 8 * v17), __srca, v16);
      if (v16 < 0x20 || (unint64_t)(__srca - __src) < 0x20)
      {
        uint64_t v28 = (char *)(v7 + 8 * v8);
        uint64_t v29 = (v15 - __srca) >> 3;
        char v19 = __src;
        uint64_t v20 = a4;
      }
      else
      {
        unint64_t v27 = 8 * (v17 & 0xFFFFFFFFFFFFFFFCLL);
        uint64_t v28 = &__srca[v27];
        uint64_t v29 = (v16 >> 3) & 3;
        char v19 = &__src[v27];
        unsigned int v30 = (long long *)(__src + 16);
        uint64_t v31 = (_OWORD *)(v7 + 8 * v8 + 16);
        unint64_t v32 = v17 & 0xFFFFFFFFFFFFFFFCLL;
        do
        {
          long long v33 = *v30;
          *(v31 - 1) = *(v30 - 1);
          *uint64_t v31 = v33;
          v30 += 2;
          v31 += 2;
          v32 -= 4;
        }
        while (v32);
        uint64_t v20 = a4;
        if (v17 == (v17 & 0xFFFFFFFFFFFFFFFCLL))
        {
LABEL_34:
          if (v19 != v20) {
            memcpy(v15, v19, v20 - v19);
          }
          return v21;
        }
      }
      do
      {
        uint64_t v42 = *(void *)v19;
        v19 += 8;
        *(void *)uint64_t v28 = v42;
        v28 += 8;
        --v29;
      }
      while (v29);
      goto LABEL_34;
    }
    uint64_t v22 = 8 * v13;
    uint64_t v23 = v10;
    if (v13 + v10 > *(unsigned int *)(a1 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v13 + v10, 8);
      uint64_t v23 = *(unsigned int *)(a1 + 8);
      unsigned int v11 = *(_DWORD *)(a1 + 8);
    }
    uint64_t v24 = &v15[-v22];
    if (a4 == __src) {
      goto LABEL_28;
    }
    uint64_t v25 = (void *)(*(void *)a1 + 8 * v23);
    if (v12 - 8 >= 0x78)
    {
      uint64_t v34 = 8 * v23 + *(void *)a1;
      int64_t v26 = &v15[-v22];
      if ((v12 & 0xFFFFFFFFFFFFFFF8) - v7 - 8 * v10 + v34 >= 0x20)
      {
        unint64_t v35 = ((v12 - 8) >> 3) + 1;
        uint64_t v36 = 8 * (v35 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v25 = (void *)((char *)v25 + v36);
        int64_t v26 = &v24[v36];
        unint64_t v37 = (long long *)(8 * v10 - 8 * v13 + v7 + 16);
        uint64_t v38 = (_OWORD *)(v34 + 16);
        uint64_t v39 = v35 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v40 = *v37;
          *(v38 - 1) = *(v37 - 1);
          *uint64_t v38 = v40;
          v37 += 2;
          v38 += 2;
          v39 -= 4;
        }
        while (v39);
        if (v35 == (v35 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_28;
        }
      }
    }
    else
    {
      int64_t v26 = &v15[-v22];
    }
    do
    {
      uint64_t v41 = *(void *)v26;
      v26 += 8;
      *v25++ = v41;
    }
    while (v26 != v15);
LABEL_28:
    *(_DWORD *)(a1 + 8) = v11 + v13;
    uint64_t v21 = v7 + 8 * v8;
    if (v24 != __srca) {
      memmove(&__srca[v22], __srca, &v15[-v22] - __srca);
    }
    if (a4 != __src) {
      memmove(__srca, __src, v12);
    }
    return v21;
  }
  if (v14 > v9)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v14, 8);
    unsigned int v11 = *(_DWORD *)(a1 + 8);
    uint64_t v7 = *(void *)a1;
  }
  if (__src != a4)
  {
    memcpy((void *)(v7 + 8 * v11), __src, v12);
    unsigned int v11 = *(_DWORD *)(a1 + 8);
    uint64_t v7 = *(void *)a1;
  }
  *(_DWORD *)(a1 + 8) = v11 + (v12 >> 3);
  return v7 + 8 * v8;
}

void mlir::dataflow::TensorAllocAnalysis::getAnalysis(mlir::dataflow::TensorAllocAnalysis *this, mlir::DataFlowSolver *a2, mlir::Operation *a3)
{
  uint64_t v5 = (mlir::dataflow::DeadCodeAnalysis *)operator new(0x30uLL);
  unint64_t v6 = mlir::dataflow::DeadCodeAnalysis::DeadCodeAnalysis(v5, a2);
  unint64_t v9 = v6;
  uint64_t v7 = *((unsigned int *)a2 + 14);
  if (v7 >= *((_DWORD *)a2 + 15))
  {
    llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::DataFlowAnalysis>,false>::growAndEmplaceBack<mlir::dataflow::DeadCodeAnalysis *>((uint64_t)a2 + 48, &v9);
  }
  else
  {
    *(void *)(*((void *)a2 + 6) + 8 * v7) = v6;
    *((_DWORD *)a2 + 14) = v7 + 1;
  }
  uint64_t v8 = (mlir::Liveness *)operator new(0x20uLL);
  mlir::Liveness::Liveness(v8, a3);
}

void mlir::dataflow::TensorAllocAnalysis::~TensorAllocAnalysis(mlir::dataflow::TensorAllocAnalysis *this)
{
  *(void *)this = &unk_1EC9CDB58;
  CFAllocatorRef v2 = (char *)*((void *)this + 13);
  if (v2 != (char *)this + 120) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 8);
  if (v3 != (char *)this + 80) {
    free(v3);
  }
  unint64_t v4 = (char *)*((void *)this + 6);
  if (v4 != (char *)this + 64) {
    free(v4);
  }
  llvm::deallocate_buffer(*((llvm **)this + 3), (void *)(16 * *((unsigned int *)this + 10)));
}

{
  char *v2;
  char *v3;
  char *v4;

  *(void *)this = &unk_1EC9CDB58;
  CFAllocatorRef v2 = (char *)*((void *)this + 13);
  if (v2 != (char *)this + 120) {
    free(v2);
  }
  uint64_t v3 = (char *)*((void *)this + 8);
  if (v3 != (char *)this + 80) {
    free(v3);
  }
  unint64_t v4 = (char *)*((void *)this + 6);
  if (v4 != (char *)this + 64) {
    free(v4);
  }
  llvm::deallocate_buffer(*((llvm **)this + 3), (void *)(16 * *((unsigned int *)this + 10)));
}

void sub_18017C88C(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v13 = *((void *)v12 + 2);
  *((void *)v12 + 2) = 0;
  if (v13) {
    std::default_delete<mlir::Liveness>::operator()[abi:nn180100]((uint64_t)v12 + 16, v13);
  }
  mlir::GenericProgramPoint::~GenericProgramPoint(v12);
}

void sub_18017C940(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v13 = *((void *)v12 + 2);
  *((void *)v12 + 2) = 0;
  if (v13) {
    std::default_delete<mlir::Liveness>::operator()[abi:nn180100]((uint64_t)v12 + 16, v13);
  }
  mlir::GenericProgramPoint::~GenericProgramPoint(v12);
  operator delete(v14);
}

uint64_t mlir::dataflow::SparseForwardDataFlowAnalysis<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>>::visitOperationImpl(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 64))();
}

uint64_t mlir::dataflow::SparseForwardDataFlowAnalysis<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>>::visitNonControlFlowArgumentsImpl(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 72))();
}

void *mlir::dataflow::SparseForwardDataFlowAnalysis<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>>::getLatticeElement(uint64_t a1, uint64_t a2)
{
  return mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>,mlir::Value>(*(void *)(a1 + 8), a2);
}

uint64_t mlir::dataflow::SparseForwardDataFlowAnalysis<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>>::setToEntryState(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)a1 + 80))();
}

uint64_t mlir::dataflow::SparseForwardDataFlowAnalysis<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>>::visitNonControlFlowArguments(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, unint64_t a5, unsigned int a6)
{
  uint64_t v10 = a6;
  if (a5 >= a6) {
    uint64_t v11 = a6;
  }
  else {
    uint64_t v11 = a5;
  }
  mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::setAllToEntryStates(a1, a4, v11);
  uint64_t v12 = *(void *)(a3 + 16) + v10;

  return mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::setAllToEntryStates(a1, &a4[v12], a5 - v12);
}

void mlir::dataflow::TensorAllocAnalysis::setToEntryState(uint64_t a1, uint64_t a2)
{
  v6[50] = *MEMORY[0x1E4F143B8];
  mlir::detail::AllocRange::getRangeForValue((_DWORD *)(*(void *)(a2 + 8) & 0xFFFFFFFFFFFFFFF8), 0xFFFFFFFFFFFFFFFFLL, (uint64_t)v6);
  v5[0] = v6;
  v5[1] = (void *)0xA00000001;
  int v4 = mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>::join(a2, (uint64_t)v5);
  mlir::DataFlowAnalysis::propagateIfChanged(a1, a2, v4);
  if (v5[0] != v6) {
    free(v5[0]);
  }
}

uint64_t mlir::TypeID::get<mlir::ShapedType>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::ShapedType]";
      unint64_t v11 = 66;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::ShapedType,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 3720);
}

uint64_t mlir::OpInterface<mlir::MemoryMapperInterface,mlir::detail::MemoryMapperInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  int v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::MemoryMapperInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::MemoryMapperInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    uint64_t v9 = *(void **)(v6 + 32);
    uint64_t v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      uint64_t v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      uint64_t v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        uint64_t v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::MemoryMapperInterface>();
      char v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

uint64_t mlir::TypeID::get<mlir::MemoryMapperInterface>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryMapperInterface]";
      unint64_t v11 = 77;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::MemoryMapperInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 2088);
}

uint64_t llvm::SmallVectorImpl<mlir::detail::AllocRange>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = (const void *)(a2 + 16);
    unint64_t v4 = *(const void **)a2;
    if (v4 != v5)
    {
      unint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        unint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      uint64_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_17;
    }
    uint64_t v7 = (_DWORD *)(a2 + 8);
    unint64_t v8 = *(unsigned int *)(a2 + 8);
    uint64_t v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if (v8) {
        memmove(*(void **)a1, v4, 40 * v8);
      }
      goto LABEL_16;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if (v9)
      {
        memmove(*(void **)a1, v4, 40 * v9);
        goto LABEL_14;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 40);
    }
    uint64_t v9 = 0;
LABEL_14:
    uint64_t v10 = *v7;
    if (v9 != v10) {
      memcpy((void *)(*(void *)a1 + 40 * v9), (const void *)(*(void *)a2 + 40 * v9), *(void *)a2 + 40 * v10 - (*(void *)a2 + 40 * v9));
    }
LABEL_16:
    *(_DWORD *)(a1 + 8) = v8;
LABEL_17:
    *uint64_t v7 = 0;
  }
  return a1;
}

void llvm::SmallVectorTemplateBase<anonymous namespace'::CurrentlyLive::Buffer,false>::destroy_range(uint64_t a1, uint64_t a2)
{
  if (a2 != a1)
  {
    uint64_t v2 = a2;
    do
    {
      uint64_t v4 = v2 - 1000;
      uint64_t v5 = *(void *)(v2 - 576);
      uint64_t v6 = *(unsigned int *)(v2 - 568);
      if (v6)
      {
        uint64_t v7 = 56 * v6;
        unint64_t v8 = *(void **)(v5 + v7 - 32);
        if ((void *)(v5 + v7 - 16) != v8) {
          free(v8);
        }
        llvm::deallocate_buffer(*(llvm **)(v5 + v7 - 56), (void *)(8 * *(unsigned int *)(v5 + v7 - 40)));
      }
      if (v5 != v2 - 560) {
        free(*(void **)(v2 - 576));
      }
      uint64_t v9 = *(void **)(v2 - 992);
      if (v9 != (void *)(v2 - 976)) {
        free(v9);
      }
      v2 -= 1000;
    }
    while (v4 != a1);
  }
}

uint64_t llvm::SmallVectorImpl<llvm::SmallSetVector<mlir::Value,2u>>::operator=(uint64_t a1, uint64_t *a2)
{
  if ((uint64_t *)a1 != a2)
  {
    uint64_t v4 = a2 + 2;
    if ((uint64_t *)*a2 == a2 + 2)
    {
      uint64_t v9 = a2 + 1;
      unint64_t v11 = *((unsigned int *)a2 + 2);
      uint64_t v12 = *(unsigned int *)(a1 + 8);
      if (v12 >= v11)
      {
        uint64_t v16 = *(llvm ***)a1;
        if (v11) {
          llvm::deallocate_buffer(*v16, (void *)(8 * *((unsigned int *)v16 + 4)));
        }
        if (&v16[7 * v12] != v16)
        {
          uint64_t v20 = &v16[7 * v12];
          uint64_t v21 = v20 - 2;
          uint64_t v22 = (llvm **)*(v20 - 4);
          if (v21 != v22) {
            free(v22);
          }
          llvm::deallocate_buffer(*(v21 - 5), (void *)(8 * *((unsigned int *)v21 - 6)));
        }
        *(_DWORD *)(a1 + 8) = 0;
        uint64_t v23 = *((unsigned int *)a2 + 2);
        if (v23)
        {
          uint64_t v24 = *a2;
          uint64_t v25 = 56 * v23;
          int64_t v26 = *(void **)(v24 + v25 - 32);
          if ((void *)(v24 + v25 - 16) != v26) {
            free(v26);
          }
          llvm::deallocate_buffer(*(llvm **)(v24 + v25 - 56), (void *)(8 * *(unsigned int *)(v24 + v25 - 40)));
        }
      }
      else
      {
        if (*(_DWORD *)(a1 + 12) >= v11)
        {
          uint64_t v17 = *(llvm ***)a1;
          if (v12) {
            llvm::deallocate_buffer(*v17, (void *)(8 * *((unsigned int *)v17 + 4)));
          }
        }
        else
        {
          if (v12)
          {
            uint64_t v13 = *(llvm ***)a1;
            uint64_t v14 = 7 * v12;
            uint64_t v15 = (llvm **)v13[v14 - 4];
            if (&v13[v14 - 2] != v15) {
              free(v15);
            }
            llvm::deallocate_buffer(v13[v14 - 7], (void *)(8 * LODWORD(v13[v14 - 5])));
          }
          *(_DWORD *)(a1 + 8) = 0;
          unint64_t v35 = 0;
          uint64_t v18 = a1 + 16;
          uint64_t v17 = (llvm **)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v11, 56, &v35);
          llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::moveElementsForGrow(a1, (uint64_t)v17);
          int v19 = v35;
          if (*(void *)a1 != v18) {
            free(*(void **)a1);
          }
          *(void *)a1 = v17;
          *(_DWORD *)(a1 + 12) = v19;
        }
        uint64_t v27 = *a2;
        if (*((_DWORD *)a2 + 2))
        {
          uint64_t v28 = v27 + 56 * *((unsigned int *)a2 + 2);
          do
          {
            uint64_t v29 = v27;
            *uint64_t v17 = 0;
            v17[1] = 0;
            *((_DWORD *)v17 + 4) = 0;
            *uint64_t v17 = *(llvm **)v27;
            *(void *)uint64_t v27 = 0;
            *((_DWORD *)v17 + 2) = *(_DWORD *)(v27 + 8);
            *(_DWORD *)(v27 + 8) = 0;
            v17[3] = (llvm *)(v17 + 5);
            int v30 = *((_DWORD *)v17 + 3);
            *((_DWORD *)v17 + 3) = *(_DWORD *)(v27 + 12);
            *(_DWORD *)(v27 + 12) = v30;
            int v31 = *((_DWORD *)v17 + 4);
            *((_DWORD *)v17 + 4) = *(_DWORD *)(v27 + 16);
            *(_DWORD *)(v27 + 16) = v31;
            v17[4] = (llvm *)0x200000000;
            if (*(_DWORD *)(v27 + 32)) {
              llvm::SmallVectorImpl<mlir::Value>::operator=((uint64_t)(v17 + 3), v27 + 24);
            }
            v17 += 7;
            v27 += 56;
          }
          while (v29 + 56 != v28);
          uint64_t v27 = *a2;
        }
        *(_DWORD *)(a1 + 8) = v11;
        uint64_t v32 = *v9;
        if (v32)
        {
          uint64_t v33 = 56 * v32;
          uint64_t v34 = *(void **)(v27 + v33 - 32);
          if ((void *)(v27 + v33 - 16) != v34) {
            free(v34);
          }
          llvm::deallocate_buffer(*(llvm **)(v27 + v33 - 56), (void *)(8 * *(unsigned int *)(v27 + v33 - 40)));
        }
      }
    }
    else
    {
      uint64_t v5 = *(char **)a1;
      uint64_t v6 = *(unsigned int *)(a1 + 8);
      if (v6)
      {
        uint64_t v7 = 56 * v6;
        unint64_t v8 = *(char **)&v5[v7 - 32];
        if (&v5[v7 - 16] != v8) {
          free(v8);
        }
        llvm::deallocate_buffer(*(llvm **)&v5[v7 - 56], (void *)(8 * *(unsigned int *)&v5[v7 - 40]));
      }
      if (v5 != (char *)(a1 + 16)) {
        free(*(void **)a1);
      }
      *(void *)a1 = *a2;
      uint64_t v9 = a2 + 1;
      *(void *)(a1 + 8) = a2[1];
      *a2 = (uint64_t)v4;
      *((_DWORD *)a2 + 3) = 0;
    }
    *uint64_t v9 = 0;
  }
  return a1;
}

uint64_t llvm::SmallVectorImpl<mlir::Value>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    uint64_t v5 = (const void *)(a2 + 16);
    uint64_t v4 = *(const void **)a2;
    if (v4 != v5)
    {
      uint64_t v6 = *(void **)a1;
      if (*(void *)a1 != a1 + 16)
      {
        free(v6);
        uint64_t v4 = *(const void **)a2;
      }
      *(void *)a1 = v4;
      uint64_t v7 = (_DWORD *)(a2 + 8);
      *(void *)(a1 + 8) = *(void *)(a2 + 8);
      *(void *)a2 = v5;
      *(_DWORD *)(a2 + 12) = 0;
      goto LABEL_17;
    }
    uint64_t v7 = (_DWORD *)(a2 + 8);
    unint64_t v8 = *(unsigned int *)(a2 + 8);
    uint64_t v9 = *(unsigned int *)(a1 + 8);
    if (v9 >= v8)
    {
      if (v8) {
        memmove(*(void **)a1, v4, 8 * v8);
      }
      goto LABEL_16;
    }
    if (*(_DWORD *)(a1 + 12) >= v8)
    {
      if (v9)
      {
        memmove(*(void **)a1, v4, 8 * v9);
        goto LABEL_14;
      }
    }
    else
    {
      *(_DWORD *)(a1 + 8) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v8, 8);
    }
    uint64_t v9 = 0;
LABEL_14:
    uint64_t v10 = *v7;
    if (v9 != v10) {
      memcpy((void *)(*(void *)a1 + 8 * v9), (const void *)(*(void *)a2 + 8 * v9), *(void *)a2 + 8 * v10 - (*(void *)a2 + 8 * v9));
    }
LABEL_16:
    *(_DWORD *)(a1 + 8) = v8;
LABEL_17:
    *uint64_t v7 = 0;
  }
  return a1;
}

uint64_t llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::moveElementsForGrow(uint64_t result, uint64_t a2)
{
  unsigned int v2 = *(_DWORD *)(result + 8);
  if (v2)
  {
    uint64_t v4 = result;
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)result;
    uint64_t v7 = *(void *)result + 56 * v2;
    do
    {
      uint64_t v8 = v6 + v5;
      uint64_t v9 = a2 + v5;
      *(void *)uint64_t v9 = 0;
      *(void *)(v9 + 8) = 0;
      *(_DWORD *)(v9 + 16) = 0;
      *(void *)uint64_t v9 = *(void *)(v6 + v5);
      *(void *)uint64_t v8 = 0;
      *(_DWORD *)(v9 + 8) = *(_DWORD *)(v6 + v5 + 8);
      *(_DWORD *)(v8 + 8) = 0;
      *(void *)(a2 + v5 + 24) = a2 + v5 + 40;
      uint64_t result = a2 + v5 + 24;
      int v10 = *(_DWORD *)(a2 + v5 + 12);
      *(_DWORD *)(result - 12) = *(_DWORD *)(v6 + v5 + 12);
      *(_DWORD *)(v8 + 12) = v10;
      int v11 = *(_DWORD *)(a2 + v5 + 16);
      *(_DWORD *)(v9 + 16) = *(_DWORD *)(v6 + v5 + 16);
      *(_DWORD *)(v8 + 16) = v11;
      *(void *)(result + 8) = 0x200000000;
      if (*(_DWORD *)(v6 + v5 + 32)) {
        uint64_t result = llvm::SmallVectorImpl<mlir::Value>::operator=(result, v8 + 24);
      }
      v5 += 56;
    }
    while (v8 + 56 != v7);
    uint64_t v12 = *(unsigned int *)(v4 + 8);
    if (v12)
    {
      uint64_t v13 = *(void *)v4;
      uint64_t v14 = 56 * v12;
      uint64_t v15 = *(void **)(v13 + v14 - 32);
      if ((void *)(v13 + v14 - 16) != v15) {
        free(v15);
      }
      llvm::deallocate_buffer(*(llvm **)(v13 + v14 - 56), (void *)(8 * *(unsigned int *)(v13 + v14 - 40)));
    }
  }
  return result;
}

uint64_t anonymous namespace'::CurrentlyLive::Buffer::findSlotsFor(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  v46[70] = *MEMORY[0x1E4F143B8];
  if (!a3) {
    return 0;
  }
  if (a3 != 1)
  {
    uint64_t v41 = -1;
    uint64_t v42 = &v44;
    uint64_t v43 = 0xA00000000;
    v45[0] = v46;
    v45[1] = (void *)0xA00000000;
    uint64_t v10 = *(void *)(a1 + 8);
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11)
    {
      uint64_t v12 = 40 * v11;
      uint64_t v13 = *(void **)(a1 + 8);
      do
      {
        if (*v13 == *a2) {
          goto LABEL_16;
        }
        v13 += 5;
        v12 -= 40;
      }
      while (v12);
      uint64_t v13 = (void *)(v10 + 40 * v11);
    }
    else
    {
      uint64_t v13 = *(void **)(a1 + 8);
    }
LABEL_16:
    uint64_t v14 = (uint64_t)v13 - v10;
    if (v14 != -40 && 0xCCCCCCCCCCCCCCCDLL * (v14 >> 3) != v11)
    {
      int64_t v26 = (long long *)(v10 + 8 * (v14 >> 3));
      long long v27 = *v26;
      long long v28 = v26[1];
      uint64_t v36 = *((void *)v26 + 4);
      v35[0] = v27;
      v35[1] = v28;
      v38[0] = 0;
      long long v39 = 0u;
      uint64_t v40 = 0;
      *(_OWORD *)unint64_t v37 = 0u;
      v38[1] = (char *)&v39 + 8;
      DWORD1(v39) = 2;
      uint64_t v30 = 40 * v43;
      llvm::SmallVectorImpl<llvm::SmallSetVector<mlir::Value,2u>>::insert_one_impl<llvm::SmallSetVector<mlir::Value,2u> const&>((uint64_t)v45, (uint64_t)v45[0] - 0x3333333333333328 * (v30 >> 3), (unint64_t)v37);
      int v31 = (char *)v42 + v30;
      uint64_t v32 = v35;
      goto LABEL_33;
    }
    unint64_t v17 = a2[4];
    unint64_t v18 = FirstSlotFor;
    if (v17) {
      unint64_t v18 = (FirstSlotFor + v17 - 1) / v17 * v17;
    }
    unint64_t v19 = a2[3] - a2[2] + v18;
    v34[0] = *a2;
    v34[1] = FirstSlotFor;
    v34[2] = v18;
    v34[3] = v19;
    v34[4] = v17;
    v38[0] = 0;
    long long v39 = 0u;
    uint64_t v40 = 0;
    *(_OWORD *)unint64_t v37 = 0u;
    v38[1] = (char *)&v39 + 8;
    DWORD1(v39) = 2;
    unint64_t v20 = v43;
    if (!v43)
    {
      uint64_t v22 = (char *)v42 + 40 * v43;
LABEL_32:
      uint64_t v29 = v22 - (unsigned char *)v42;
      llvm::SmallVectorImpl<llvm::SmallSetVector<mlir::Value,2u>>::insert_one_impl<llvm::SmallSetVector<mlir::Value,2u> const&>((uint64_t)v45, (uint64_t)v45[0] - 0x3333333333333328 * ((v22 - (unsigned char *)v42) >> 3), (unint64_t)v37);
      int v31 = (char *)v42 + v29;
      uint64_t v32 = v34;
LABEL_33:
      llvm::SmallVectorImpl<mlir::detail::AllocRange>::insert_one_impl<mlir::detail::AllocRange const&>((uint64_t)&v42, (unint64_t)v31, (unint64_t)v32);
      if (v38[1] != (char *)&v39 + 8) {
        free(v38[1]);
      }
      llvm::deallocate_buffer(v37[0], (void *)(8 * LODWORD(v38[0])));
    }
    uint64_t v21 = v19 - FirstSlotFor + 1;
    uint64_t v22 = (char *)v42;
    while (1)
    {
      unint64_t v23 = v20 >> 1;
      uint64_t v24 = &v22[40 * (v20 >> 1)];
      uint64_t v25 = *((void *)v24 + 1);
      if (FirstSlotFor == v25)
      {
        if (v21 >= *(void *)&v22[40 * v23 + 24] - FirstSlotFor + 1) {
          goto LABEL_30;
        }
      }
      else if (FirstSlotFor >= v25)
      {
LABEL_30:
        uint64_t v22 = v24 + 40;
        unint64_t v23 = v20 + ~v23;
      }
      unint64_t v20 = v23;
      if (!v23) {
        goto LABEL_32;
      }
    }
  }
  if (v6 == -1) {
    return 0;
  }
  uint64_t v7 = v6;
  uint64_t v8 = *(unsigned int *)(a4 + 8);
  if (v8 >= *(_DWORD *)(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v8 + 1, 8);
    LODWORD(v8) = *(_DWORD *)(a4 + 8);
  }
  *(void *)(*(void *)a4 + 8 * v8) = v7;
  ++*(_DWORD *)(a4 + 8);
  return 1;
}

uint64_t llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,2u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,2u>::insert(uint64_t a1, unint64_t *a2)
{
  if (!*(_DWORD *)(a1 + 8))
  {
    uint64_t v6 = (void **)(a1 + 24);
    uint64_t v7 = *(void **)(a1 + 24);
    uint64_t v8 = *(unsigned int *)(a1 + 32);
    uint64_t v9 = v7;
    if (v8)
    {
      uint64_t v10 = 8 * v8;
      uint64_t v9 = *(void **)(a1 + 24);
      while (*v9 != *a2)
      {
        ++v9;
        v10 -= 8;
        if (!v10)
        {
          uint64_t v9 = &v7[v8];
          break;
        }
      }
    }
    if (v8 == v9 - v7)
    {
      unint64_t v11 = *a2;
      if (v8 >= *(_DWORD *)(a1 + 36))
      {
        uint64_t v16 = (void **)(a1 + 24);
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v8 + 1, 8);
        uint64_t v6 = v16;
        uint64_t v8 = *(unsigned int *)(a1 + 32);
        uint64_t v7 = *(void **)(a1 + 24);
      }
      v7[v8] = v11;
      unsigned int v12 = *(_DWORD *)(a1 + 32) + 1;
      *(_DWORD *)(a1 + 32) = v12;
      if (v12 >= 3)
      {
        uint64_t v13 = *v6;
        uint64_t v14 = 8 * v12;
        do
        {
          unint64_t v17 = 0;
          if ((llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, v13, &v17) & 1) == 0)*llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a1, (uint64_t)v13, v13, v17) = *v13; {
          ++v13;
          }
          v14 -= 8;
        }
        while (v14);
      }
      return 1;
    }
    return 0;
  }
  unint64_t v17 = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, a2, &v17))return 0; {
  *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(a1, (uint64_t)a2, a2, v17) = *a2;
  }
  unint64_t v4 = *a2;
  uint64_t v5 = *(unsigned int *)(a1 + 32);
  if (v5 >= *(_DWORD *)(a1 + 36))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v5 + 1, 8);
    LODWORD(v5) = *(_DWORD *)(a1 + 32);
  }
  *(void *)(*(void *)(a1 + 24) + 8 * v5) = v4;
  ++*(_DWORD *)(a1 + 32);
  return 1;
}

void llvm::SmallSet<long long,2u,std::less<long long>>::insert(uint64_t a1@<X0>, uint64_t **a2@<X1>, uint64_t a3@<X8>)
{
  if (!*(void *)(a1 + 48))
  {
    uint64_t v15 = *(uint64_t ***)a1;
    uint64_t v16 = *(unsigned int *)(a1 + 8);
    unint64_t v17 = *a2;
    if (!v16) {
      goto LABEL_21;
    }
    uint64_t v18 = 8 * v16;
    uint64_t v9 = *(uint64_t ***)a1;
    while (*v9 != v17)
    {
      ++v9;
      v18 -= 8;
      if (!v18) {
        goto LABEL_20;
      }
    }
    if (v18)
    {
      char v19 = 0;
      char v14 = 1;
      goto LABEL_25;
    }
LABEL_20:
    if (v16 <= 1)
    {
LABEL_21:
      if (v16 >= *(_DWORD *)(a1 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v16 + 1, 8);
        uint64_t v16 = *(unsigned int *)(a1 + 8);
        uint64_t v15 = *(uint64_t ***)a1;
      }
      v15[v16] = v17;
      unsigned int v20 = *(_DWORD *)(a1 + 8) + 1;
      *(_DWORD *)(a1 + 8) = v20;
      uint64_t v9 = (uint64_t **)(*(void *)a1 + 8 * v20 - 8);
      char v14 = 1;
      goto LABEL_24;
    }
    uint64_t v7 = (uint64_t **)(a1 + 40);
    do
    {
      uint64_t v22 = *(uint64_t **)(a1 + 40);
      uint64_t v23 = *(void *)(*(void *)a1 + 8 * v16 - 8);
      uint64_t v24 = (uint64_t **)(a1 + 40);
      uint64_t v25 = (uint64_t **)(a1 + 40);
      if (v22)
      {
        while (1)
        {
          while (1)
          {
            uint64_t v25 = (uint64_t **)v22;
            uint64_t v26 = v22[4];
            if (v23 >= v26) {
              break;
            }
            uint64_t v22 = *v25;
            uint64_t v24 = v25;
            if (!*v25) {
              goto LABEL_37;
            }
          }
          if (v26 >= v23) {
            break;
          }
          uint64_t v22 = v25[1];
          if (!v22)
          {
            uint64_t v24 = v25 + 1;
            goto LABEL_37;
          }
        }
      }
      else
      {
LABEL_37:
        long long v27 = (uint64_t *)operator new(0x28uLL);
        v27[4] = v23;
        *long long v27 = 0;
        v27[1] = 0;
        v27[2] = (uint64_t)v25;
        *uint64_t v24 = v27;
        uint64_t v28 = **(void **)(a1 + 32);
        if (v28)
        {
          *(void *)(a1 + 32) = v28;
          uint64_t v21 = *v24;
        }
        else
        {
          uint64_t v21 = v27;
        }
        std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 40), v21);
        ++*(void *)(a1 + 48);
        LODWORD(v16) = *(_DWORD *)(a1 + 8);
      }
      LODWORD(v16) = v16 - 1;
      *(_DWORD *)(a1 + 8) = v16;
    }
    while (v16);
    uint64_t v8 = *a2;
    uint64_t v29 = *v7;
    uint64_t v9 = (uint64_t **)(a1 + 40);
    if (*v7)
    {
      while (1)
      {
        while (1)
        {
          uint64_t v9 = (uint64_t **)v29;
          uint64_t v30 = v29[4];
          if ((uint64_t)v8 >= v30) {
            break;
          }
          uint64_t v29 = *v9;
          uint64_t v7 = v9;
          if (!*v9) {
            goto LABEL_9;
          }
        }
        if (v30 >= (uint64_t)v8) {
          break;
        }
        uint64_t v29 = v9[1];
        if (!v29)
        {
LABEL_8:
          uint64_t v7 = v9 + 1;
          goto LABEL_9;
        }
      }
      char v14 = 0;
      goto LABEL_24;
    }
LABEL_9:
    unint64_t v11 = (uint64_t *)v9;
    uint64_t v9 = (uint64_t **)operator new(0x28uLL);
    v9[4] = v8;
    *uint64_t v9 = 0;
    v9[1] = 0;
    v9[2] = v11;
    *uint64_t v7 = (uint64_t *)v9;
    uint64_t v12 = **(void **)(a1 + 32);
    uint64_t v13 = (uint64_t *)v9;
    if (v12)
    {
      *(void *)(a1 + 32) = v12;
      uint64_t v13 = *v7;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(a1 + 40), v13);
    char v14 = 0;
    ++*(void *)(a1 + 48);
LABEL_24:
    char v19 = 1;
    goto LABEL_25;
  }
  uint64_t v7 = (uint64_t **)(a1 + 40);
  uint64_t v6 = *(uint64_t **)(a1 + 40);
  uint64_t v8 = *a2;
  if (!v6)
  {
    uint64_t v9 = (uint64_t **)(a1 + 40);
    goto LABEL_9;
  }
  while (1)
  {
    while (1)
    {
      uint64_t v9 = (uint64_t **)v6;
      uint64_t v10 = (uint64_t *)v6[4];
      if ((uint64_t)v8 >= (uint64_t)v10) {
        break;
      }
      uint64_t v6 = *v9;
      uint64_t v7 = v9;
      if (!*v9) {
        goto LABEL_9;
      }
    }
    if ((uint64_t)v10 >= (uint64_t)v8) {
      break;
    }
    uint64_t v6 = v9[1];
    if (!v6) {
      goto LABEL_8;
    }
  }
  char v14 = 0;
  char v19 = 0;
LABEL_25:
  *(unsigned char *)(a3 + 8) = v14;
  *(void *)a3 = v9;
  *(unsigned char *)(a3 + 16) = v19;
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
}

uint64_t std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100](uint64_t a1)
{
  if (*(unsigned char *)(a1 + 176))
  {
    unsigned int v2 = *(void ***)(a1 + 152);
    if (v2)
    {
      unint64_t v3 = *(void ***)(a1 + 160);
      unint64_t v4 = *(void **)(a1 + 152);
      if (v3 != v2)
      {
        do
          unint64_t v3 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v3 - 1);
        while (v3 != v2);
        unint64_t v4 = *(void **)(a1 + 152);
      }
      *(void *)(a1 + 160) = v2;
      operator delete(v4);
    }
    uint64_t v5 = *(void **)(a1 + 128);
    if (v5)
    {
      uint64_t v6 = *(void **)(a1 + 136);
      uint64_t v7 = *(void **)(a1 + 128);
      if (v6 != v5)
      {
        do
        {
          uint64_t v9 = (void *)*--v6;
          uint64_t v8 = v9;
          void *v6 = 0;
          if (v9) {
            operator delete[](v8);
          }
        }
        while (v6 != v5);
        uint64_t v7 = *(void **)(a1 + 128);
      }
      *(void *)(a1 + 136) = v5;
      operator delete(v7);
    }
    uint64_t v10 = *(void **)(a1 + 16);
    if (v10 != (void *)(a1 + 32)) {
      free(v10);
    }
  }
  return a1;
}

void **std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](void **a1)
{
  unsigned int v2 = *a1;
  *a1 = 0;
  if (v2)
  {
    uint64_t v3 = v2[19];
    if (v3)
    {
      uint64_t v4 = v2[20];
      uint64_t v5 = (void *)v2[19];
      if (v4 != v3)
      {
        do
          uint64_t v4 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v4 - 8);
        while (v4 != v3);
        uint64_t v5 = (void *)v2[19];
      }
      v2[20] = v3;
      operator delete(v5);
    }
    uint64_t v6 = (void *)v2[16];
    if (v6)
    {
      uint64_t v7 = (void *)v2[17];
      uint64_t v8 = (void *)v2[16];
      if (v7 != v6)
      {
        do
        {
          uint64_t v10 = (void *)*--v7;
          uint64_t v9 = v10;
          *uint64_t v7 = 0;
          if (v10) {
            operator delete[](v9);
          }
        }
        while (v7 != v6);
        uint64_t v8 = (void *)v2[16];
      }
      v2[17] = v6;
      operator delete(v8);
    }
    unint64_t v11 = (void *)v2[2];
    if (v11 != v2 + 4) {
      free(v11);
    }
    operator delete(v2);
  }
  return a1;
}

uint64_t anonymous namespace'::CurrentlyLive::Buffer::findFirstSlotFor(uint64_t a1, void *a2)
{
  int64_t v2 = *(void *)a1;
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  if (*(void *)a1 == -1)
  {
    if (v3)
    {
      uint64_t v4 = a1 + 8;
      if (v3 != 1) {
        goto LABEL_26;
      }
      return *(void *)(*(void *)v4 + 24) + 1;
    }
    return 0;
  }
  if (!v3)
  {
    unint64_t v9 = a2[4];
    if (v9) {
      unint64_t v10 = (v9 - 1) / v9 * v9;
    }
    else {
      unint64_t v10 = 0;
    }
    uint64_t v14 = a2[3] - a2[2];
    if ((uint64_t)(v14 + v10) > v2) {
      return -1;
    }
    if (v9) {
      v9 *= (v9 - 1) / v9;
    }
    if ((uint64_t)(v14 + v9) > v2) {
      return 0;
    }
    return 0;
  }
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v4 = a1 + 8;
  uint64_t v6 = *(void *)(v5 + 40 * v3 - 16);
  unint64_t v7 = a2[4];
  if (v7) {
    unint64_t v8 = (v7 + v6) / v7 * v7;
  }
  else {
    unint64_t v8 = v6 + 1;
  }
  uint64_t v11 = a2[3] - a2[2];
  if ((uint64_t)(v11 + v8) > v2) {
    return -1;
  }
  if (v3 != 1) {
    goto LABEL_26;
  }
  uint64_t v12 = *(void *)(*(void *)v4 + 24);
  if (v7) {
    unint64_t v13 = (v7 + v12) / v7 * v7;
  }
  else {
    unint64_t v13 = v12 + 1;
  }
  if ((uint64_t)(v11 + v13) <= v2) {
    return *(void *)(*(void *)v4 + 24) + 1;
  }
  unsigned int v3 = 1;
LABEL_26:
  unint64_t v16 = a2[4];
  uint64_t v17 = 40 * v3;
  uint64_t v18 = (uint64_t *)(*(void *)v4 + 24);
  uint64_t v19 = -1;
  do
  {
    uint64_t v20 = *(v18 - 2);
    uint64_t v21 = *v18;
    uint64_t v22 = v19 + 1;
    if (v20 > v19 + 1)
    {
      if (v16) {
        uint64_t v22 = (v16 + v19) / v16 * v16;
      }
      if (a2[3] - a2[2] + v22 < v20) {
        break;
      }
    }
    v18 += 5;
    uint64_t v19 = v21;
    v17 -= 40;
  }
  while (v17);
  return v19 + 1;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>(uint64_t *a1, unint64_t *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    unint64_t v5 = *a2;
    unint64_t v6 = 0x1E8EB8000uLL;
    {
      uint64_t v23 = a3;
      uint64_t v21 = a2;
      uint64_t v24 = v4;
      int v22 = v3;
      unint64_t v25 = v5;
      unint64_t v6 = 0x1E8EB8000uLL;
      uint64_t v4 = v24;
      unint64_t v5 = v25;
      int v3 = v22;
      a2 = v21;
      a3 = v23;
      if (v19)
      {
        unint64_t v20 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v20 = 0xFF51AFD7ED558CCDLL;
        }
        llvm::hashing::detail::get_execution_seed(void)::seed = v20;
        unint64_t v6 = 0x1E8EB8000;
        uint64_t v4 = v24;
        unint64_t v5 = v25;
        int v3 = v22;
        a2 = v21;
        a3 = v23;
      }
    }
    uint64_t v7 = (*(void *)(v6 + 3024) + 8 * v5) ^ HIDWORD(v5);
    unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(v5) ^ ((0x9DDFEA08EB382D69 * v7) >> 47) ^ (0x9DDFEA08EB382D69 * v7));
    int v9 = -348639895 * ((v8 >> 47) ^ v8);
    int v10 = v3 - 1;
    unsigned int v11 = v9 & (v3 - 1);
    uint64_t v12 = (void *)(v4 + 8 * v11);
    uint64_t v13 = *v12;
    if (*a2 == *v12)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      uint64_t result = 1;
      while (v13 != -4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v13 == -8192;
        }
        if (v17) {
          uint64_t v15 = v12;
        }
        unsigned int v18 = v11 + v16++;
        unsigned int v11 = v18 & v10;
        uint64_t v12 = (void *)(v4 + 8 * (v18 & v10));
        uint64_t v13 = *v12;
        if (*a2 == *v12) {
          goto LABEL_6;
        }
      }
      uint64_t result = 0;
      if (v15) {
        uint64_t v12 = v15;
      }
    }
  }
  else
  {
    uint64_t v12 = 0;
    uint64_t result = 0;
  }
LABEL_6:
  *a3 = v12;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::InsertIntoBucketImpl<mlir::Value>(uint64_t a1, uint64_t a2, unint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::grow(a1, v7);
  int v9 = 0;
  llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

int64x2_t *llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (int64x2_t *)llvm::allocate_buffer(8 * v8, (std::align_val_t)8uLL);
  int v10 = (char *)result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11)
    {
      unint64_t v12 = (v11 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v12 < 3) {
        goto LABEL_10;
      }
      unint64_t v13 = v12 + 1;
      int v10 = &result->i8[8 * (v13 & 0x3FFFFFFFFFFFFFFCLL)];
      uint64_t v14 = result + 1;
      int64x2_t v15 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      uint64_t v16 = v13 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v14[-1] = v15;
        *uint64_t v14 = v15;
        v14 += 2;
        v16 -= 4;
      }
      while (v16);
      if (v13 != (v13 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_10:
        BOOL v17 = &result->i8[8 * v11];
        do
        {
          *(void *)int v10 = -4096;
          v10 += 8;
        }
        while (v10 != v17);
      }
    }
    unsigned int v18 = (void *)(8 * v3);
    if (v3)
    {
      uint64_t v19 = 8 * v3;
      unint64_t v20 = (unint64_t *)v4;
      do
      {
        if ((*v20 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v28 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>,mlir::Value,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseSetPair<mlir::Value>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, v20, &v28);
          *uint64_t v28 = *v20;
          ++*(_DWORD *)(a1 + 8);
        }
        ++v20;
        v19 -= 8;
      }
      while (v19);
    }
    llvm::deallocate_buffer(v4, v18);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v21 = *(unsigned int *)(a1 + 16);
  if (v21)
  {
    unint64_t v22 = (v21 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v22 < 3) {
      goto LABEL_23;
    }
    unint64_t v23 = v22 + 1;
    int v10 = &result->i8[8 * (v23 & 0x3FFFFFFFFFFFFFFCLL)];
    uint64_t v24 = result + 1;
    int64x2_t v25 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    uint64_t v26 = v23 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v24[-1] = v25;
      *uint64_t v24 = v25;
      v24 += 2;
      v26 -= 4;
    }
    while (v26);
    if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_23:
      long long v27 = &result->i8[8 * v21];
      do
      {
        *(void *)int v10 = -4096;
        v10 += 8;
      }
      while (v10 != v27);
    }
  }
  return result;
}

unint64_t llvm::SmallVectorImpl<llvm::SmallSetVector<mlir::Value,2u>>::insert_one_impl<llvm::SmallSetVector<mlir::Value,2u> const&>(uint64_t a1, uint64_t a2, unint64_t a3)
{
  if (*(void *)a1 + 56 * *(unsigned int *)(a1 + 8) == a2) {
    llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::push_back(a1, a3);
  }
  uint64_t v4 = a2 - *(void *)a1;
  Address = llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::reserveForParamAndGetAddress(a1, a3, 1);
  unint64_t v6 = *(void *)a1 + v4;
  uint64_t v7 = *(void *)a1 + 56 * *(unsigned int *)(a1 + 8);
  *(void *)uint64_t v7 = *(void *)(v7 - 56);
  *(void *)(v7 + 8) = *(void *)(v7 - 48);
  *(void *)(v7 - 56) = 0;
  *(void *)(v7 - 48) = 0;
  *(_DWORD *)(v7 + 16) = *(_DWORD *)(v7 - 40);
  *(_DWORD *)(v7 - 40) = 0;
  *(void *)(v7 + 24) = v7 + 40;
  *(void *)(v7 + 32) = 0x200000000;
  if (*(_DWORD *)(v7 - 24)) {
    llvm::SmallVectorImpl<mlir::Value>::operator=(v7 + 24, v7 - 32);
  }
  uint64_t v8 = *(void *)a1;
  unsigned int v9 = *(_DWORD *)(a1 + 8);
  int v10 = (llvm **)(*(void *)a1 + 56 * v9 - 56);
  if (v10 != (llvm **)v6) {
    llvm::deallocate_buffer(*v10, (void *)(8 * *(unsigned int *)(*(void *)a1 + 56 * v9 - 40)));
  }
  unsigned int v11 = v9 + 1;
  *(_DWORD *)(a1 + 8) = v11;
  unint64_t v12 = v8 + 56 * v11;
  BOOL v14 = (unint64_t)Address >= v6 && (unint64_t)Address < v12;
  llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,2u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,2u>::operator=(v6, (uint64_t)&Address[56 * v14]);
  return v6;
}

void llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::push_back(uint64_t a1, unint64_t a2)
{
  llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::reserveForParamAndGetAddress(a1, a2, 1);
  uint64_t v3 = *(void *)a1 + 56 * *(unsigned int *)(a1 + 8);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  llvm::deallocate_buffer(0, 0);
}

void sub_18017E924()
{
  uint64_t v3 = *(unsigned int *)(v1 + 16);
  *(_DWORD *)(v2 + 16) = v3;
  if (v3)
  {
    buffer = llvm::allocate_buffer(8 * v3, (std::align_val_t)8uLL);
    *(void *)uint64_t v2 = buffer;
    *(void *)(v2 + 8) = *(void *)(v1 + 8);
    memcpy(buffer, *(const void **)v1, 8 * *(unsigned int *)(v2 + 16));
  }
  else
  {
    *(void *)uint64_t v2 = 0;
    *(void *)(v2 + 8) = 0;
  }
  unint64_t v5 = (void *)(v2 + 40);
  *(void *)(v2 + 24) = v2 + 40;
  *(void *)(v2 + 32) = 0x200000000;
  unsigned int v6 = *(_DWORD *)(v1 + 32);
  if (v2 != v1 && v6 != 0)
  {
    if (v6 < 3)
    {
      unsigned int v8 = *(_DWORD *)(v1 + 32);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v2 + 24, (void *)(v2 + 40), *(unsigned int *)(v1 + 32), 8);
      unsigned int v8 = *(_DWORD *)(v1 + 32);
      if (!v8)
      {
LABEL_13:
        *(_DWORD *)(v2 + 32) = v6;
        goto LABEL_14;
      }
      unint64_t v5 = *(void **)(v2 + 24);
    }
    memcpy(v5, *(const void **)(v1 + 24), 8 * v8);
    goto LABEL_13;
  }
LABEL_14:
  ++*(_DWORD *)(v0 + 8);
}

char *llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::reserveForParamAndGetAddress(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v3 = a2;
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  unint64_t v5 = v4 + a3;
  if (v5 > *(unsigned int *)(a1 + 12))
  {
    unint64_t v8 = *(void *)a1 + 56 * v4;
    if (*(void *)a1 <= a2 && v8 > a2)
    {
      uint64_t v13 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(a2 - *(void *)a1) >> 3);
      unint64_t v17 = 0;
      uint64_t v14 = a1 + 16;
      int64x2_t v15 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 56, &v17);
      llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::moveElementsForGrow(a1, (uint64_t)v15);
      int v16 = v17;
      if (*(void *)a1 != v14) {
        free(*(void **)a1);
      }
      *(void *)a1 = v15;
      *(_DWORD *)(a1 + 12) = v16;
      return &v15[56 * v13];
    }
    else
    {
      unint64_t v17 = 0;
      uint64_t v10 = a1 + 16;
      unsigned int v11 = llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), v5, 56, &v17);
      llvm::SmallVectorTemplateBase<llvm::SmallSetVector<mlir::Value,2u>,false>::moveElementsForGrow(a1, (uint64_t)v11);
      int v12 = v17;
      if (*(void *)a1 != v10) {
        free(*(void **)a1);
      }
      *(void *)a1 = v11;
      *(_DWORD *)(a1 + 12) = v12;
    }
  }
  return (char *)v3;
}

uint64_t llvm::SetVector<mlir::Value,llvm::SmallVector<mlir::Value,2u>,llvm::DenseSet<mlir::Value,llvm::DenseMapInfo<mlir::Value,void>>,2u>::operator=(uint64_t result, uint64_t a2)
{
  if (a2 != result) {
    llvm::deallocate_buffer(*(llvm **)result, (void *)(8 * *(unsigned int *)(result + 16)));
  }
  return result;
}

uint64_t llvm::SmallVectorImpl<mlir::detail::AllocRange>::insert_one_impl<mlir::detail::AllocRange const&>(uint64_t a1, unint64_t a2, unint64_t a3)
{
  unint64_t v5 = *(void *)a1;
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  unint64_t v7 = *(void *)a1 + 40 * v6;
  if (v7 == a2)
  {
    if (v6 >= *(_DWORD *)(a1 + 12))
    {
      unint64_t v28 = v6 + 1;
      if (v5 <= a3 && a2 > a3)
      {
        unint64_t v31 = a3 - v5;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v28, 40);
        unint64_t v5 = *(void *)a1;
        a3 = *(void *)a1 + v31;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v28, 40);
        unint64_t v5 = *(void *)a1;
      }
    }
    unint64_t v22 = v5 + 40 * *(unsigned int *)(a1 + 8);
    long long v23 = *(_OWORD *)a3;
    long long v24 = *(_OWORD *)(a3 + 16);
    *(void *)(v22 + 32) = *(void *)(a3 + 32);
    *(_OWORD *)unint64_t v22 = v23;
    *(_OWORD *)(v22 + 16) = v24;
    LODWORD(v22) = *(_DWORD *)(a1 + 8) + 1;
    *(_DWORD *)(a1 + 8) = v22;
    return *(void *)a1 + 40 * v22 - 40;
  }
  else
  {
    unint64_t v8 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v5) >> 3);
    if (v6 >= *(_DWORD *)(a1 + 12))
    {
      unint64_t v26 = v6 + 1;
      if (v5 <= a3 && v7 > a3)
      {
        unint64_t v30 = a3 - v5;
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v26, 40);
        unint64_t v5 = *(void *)a1;
        a3 = *(void *)a1 + v30;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v26, 40);
        unint64_t v5 = *(void *)a1;
      }
    }
    unsigned int v9 = (_OWORD *)(v5 + 40 * v8);
    unint64_t v10 = v5 + 40 * *(unsigned int *)(a1 + 8);
    long long v11 = *(_OWORD *)(v10 - 24);
    *(_OWORD *)unint64_t v10 = *(_OWORD *)(v10 - 40);
    *(_OWORD *)(v10 + 16) = v11;
    *(void *)(v10 + 32) = *(void *)(v10 - 8);
    unint64_t v12 = *(void *)a1;
    unsigned int v13 = *(_DWORD *)(a1 + 8);
    uint64_t v14 = *(void *)a1 + 40 * v13 - 40;
    if ((_OWORD *)v14 != v9)
    {
      memmove((char *)v9 + 40, v9, v14 - (void)v9);
      unsigned int v13 = *(_DWORD *)(a1 + 8);
      unint64_t v12 = *(void *)a1;
    }
    unsigned int v15 = v13 + 1;
    *(_DWORD *)(a1 + 8) = v15;
    unint64_t v16 = v12 + 40 * v15;
    BOOL v18 = a3 >= (unint64_t)v9 && a3 < v16;
    unint64_t v19 = a3 + 40 * v18;
    long long v20 = *(_OWORD *)v19;
    long long v21 = *(_OWORD *)(v19 + 16);
    *((void *)v9 + 4) = *(void *)(v19 + 32);
    *unsigned int v9 = v20;
    v9[1] = v21;
  }
  return (uint64_t)v9;
}

__n128 std::__stable_sort<std::_ClassicAlgPolicy,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::{lambda(anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match const&,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match const&)#1} &,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match*>(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5, __n128 result)
{
  if (a3 >= 2)
  {
    uint64_t v7 = a1;
    if (a3 == 2)
    {
      if (*((void *)a2 - 1) < *(void *)(a1 + 40))
      {
        uint64_t result = *(__n128 *)a1;
        long long v8 = *(_OWORD *)(a1 + 16);
        long long v9 = *(_OWORD *)(a1 + 32);
        long long v11 = *((_OWORD *)a2 - 2);
        long long v10 = *((_OWORD *)a2 - 1);
        *(_OWORD *)a1 = *((_OWORD *)a2 - 3);
        *(_OWORD *)(a1 + 16) = v11;
        *(_OWORD *)(a1 + 32) = v10;
        *((_OWORD *)a2 - 2) = v8;
        *((_OWORD *)a2 - 1) = v9;
        *((__n128 *)a2 - 3) = result;
      }
    }
    else if ((uint64_t)a3 > 128)
    {
      uint64_t v23 = a4;
      unint64_t v24 = a3 >> 1;
      uint64_t v25 = a1 + 48 * (a3 >> 1);
      unint64_t v26 = a3 >> 1;
      if ((uint64_t)a3 <= a5)
      {
        uint64_t v28 = v23 + 48 * v24;
        unint64_t v29 = v23 + 48 * a3;
        uint64_t v30 = v28;
        while (v30 != v29)
        {
          if (*(void *)(v30 + 40) >= *(void *)(v23 + 40))
          {
            uint64_t result = *(__n128 *)v23;
            long long v31 = *(_OWORD *)(v23 + 32);
            *(_OWORD *)(v7 + 16) = *(_OWORD *)(v23 + 16);
            *(_OWORD *)(v7 + 32) = v31;
            *(__n128 *)uint64_t v7 = result;
            v23 += 48;
          }
          else
          {
            uint64_t result = *(__n128 *)v30;
            long long v32 = *(_OWORD *)(v30 + 32);
            *(_OWORD *)(v7 + 16) = *(_OWORD *)(v30 + 16);
            *(_OWORD *)(v7 + 32) = v32;
            *(__n128 *)uint64_t v7 = result;
            v30 += 48;
          }
          v7 += 48;
          if (v23 == v28)
          {
            if (v30 != v29)
            {
              uint64_t v36 = 0;
              do
              {
                uint64_t v37 = v7 + v36;
                uint64_t result = *(__n128 *)(v30 + v36);
                long long v38 = *(_OWORD *)(v30 + v36 + 32);
                *(_OWORD *)(v37 + 16) = *(_OWORD *)(v30 + v36 + 16);
                *(_OWORD *)(v37 + 32) = v38;
                *(__n128 *)uint64_t v37 = result;
                v36 += 48;
              }
              while (v30 + v36 != v29);
            }
            return result;
          }
        }
        if (v23 != v28)
        {
          uint64_t v33 = 0;
          do
          {
            uint64_t v34 = v7 + v33;
            uint64_t result = *(__n128 *)(v23 + v33);
            long long v35 = *(_OWORD *)(v23 + v33 + 32);
            *(_OWORD *)(v34 + 16) = *(_OWORD *)(v23 + v33 + 16);
            *(_OWORD *)(v34 + 32) = v35;
            *(__n128 *)uint64_t v34 = result;
            v33 += 48;
          }
          while (v23 + v33 != v28);
        }
      }
      else
      {
      }
    }
    else if ((char *)a1 != a2)
    {
      uint64_t v13 = a1 + 48;
      if ((char *)(a1 + 48) != a2)
      {
        uint64_t v14 = 0;
        uint64_t v15 = a1;
        do
        {
          unint64_t v17 = *(void *)(v15 + 88);
          unint64_t v18 = *(void *)(v15 + 40);
          uint64_t v15 = v13;
          if (v17 < v18)
          {
            __n128 v39 = *(__n128 *)v13;
            long long v40 = *(_OWORD *)(v13 + 16);
            uint64_t v41 = *(void *)(v13 + 32);
            uint64_t v19 = v14;
            do
            {
              long long v20 = (_OWORD *)(a1 + v19);
              long long v21 = *(_OWORD *)(a1 + v19 + 16);
              v20[3] = *(_OWORD *)(a1 + v19);
              v20[4] = v21;
              v20[5] = *(_OWORD *)(a1 + v19 + 32);
              if (!v19)
              {
                uint64_t v16 = a1;
                goto LABEL_10;
              }
              v19 -= 48;
            }
            while (v17 < *((void *)v20 - 1));
            uint64_t v16 = a1 + v19 + 48;
LABEL_10:
            uint64_t result = v39;
            *(__n128 *)uint64_t v16 = v39;
            *(_OWORD *)(v16 + 16) = v40;
            *(void *)(v16 + 32) = v41;
            *(void *)(v16 + 40) = v17;
          }
          uint64_t v13 = v15 + 48;
          v14 += 48;
        }
        while ((char *)(v15 + 48) != a2);
      }
    }
  }
  return result;
}

__n128 std::__stable_sort_move<std::_ClassicAlgPolicy,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::{lambda(anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match const&,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match const&)#1} &,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match*>(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, __n128 result)
{
  if (a3)
  {
    uint64_t v5 = a4;
    uint64_t v8 = a1;
    if (a3 == 2)
    {
      long long v10 = (__n128 *)(a2 - 48);
      if (*(void *)(a2 - 8) >= *(void *)(a1 + 40))
      {
        __n128 v26 = *(__n128 *)a1;
        long long v27 = *(_OWORD *)(a1 + 32);
        *(_OWORD *)(a4 + 16) = *(_OWORD *)(a1 + 16);
        *(_OWORD *)(a4 + 32) = v27;
        *(__n128 *)a4 = v26;
        uint64_t result = *v10;
        long long v13 = *(_OWORD *)(a2 - 32);
        long long v14 = *(_OWORD *)(a2 - 16);
      }
      else
      {
        __n128 v11 = *v10;
        long long v12 = *(_OWORD *)(a2 - 16);
        *(_OWORD *)(a4 + 16) = *(_OWORD *)(a2 - 32);
        *(_OWORD *)(a4 + 32) = v12;
        *(__n128 *)a4 = v11;
        uint64_t result = *(__n128 *)a1;
        long long v13 = *(_OWORD *)(a1 + 16);
        long long v14 = *(_OWORD *)(a1 + 32);
      }
      *(_OWORD *)(a4 + 64) = v13;
      *(_OWORD *)(a4 + 80) = v14;
      *(__n128 *)(a4 + 48) = result;
    }
    else if (a3 == 1)
    {
      uint64_t result = *(__n128 *)a1;
      long long v9 = *(_OWORD *)(a1 + 32);
      *(_OWORD *)(a4 + 16) = *(_OWORD *)(a1 + 16);
      *(_OWORD *)(a4 + 32) = v9;
      *(__n128 *)a4 = result;
    }
    else if ((uint64_t)a3 > 8)
    {
      unint64_t v28 = a3 >> 1;
      uint64_t v29 = 48 * (a3 >> 1);
      uint64_t v30 = a1 + v29;
      uint64_t v31 = v8 + v29;
      while (v31 != a2)
      {
        if (*(void *)(v31 + 40) >= *(void *)(v8 + 40))
        {
          uint64_t result = *(__n128 *)v8;
          long long v32 = *(_OWORD *)(v8 + 32);
          *(_OWORD *)(v5 + 16) = *(_OWORD *)(v8 + 16);
          *(_OWORD *)(v5 + 32) = v32;
          *(__n128 *)uint64_t v5 = result;
          v8 += 48;
        }
        else
        {
          uint64_t result = *(__n128 *)v31;
          long long v33 = *(_OWORD *)(v31 + 32);
          *(_OWORD *)(v5 + 16) = *(_OWORD *)(v31 + 16);
          *(_OWORD *)(v5 + 32) = v33;
          *(__n128 *)uint64_t v5 = result;
          v31 += 48;
        }
        v5 += 48;
        if (v8 == v30)
        {
          if (v31 != a2)
          {
            uint64_t v37 = 0;
            do
            {
              uint64_t v38 = v5 + v37;
              uint64_t result = *(__n128 *)(v31 + v37);
              long long v39 = *(_OWORD *)(v31 + v37 + 32);
              *(_OWORD *)(v38 + 16) = *(_OWORD *)(v31 + v37 + 16);
              *(_OWORD *)(v38 + 32) = v39;
              *(__n128 *)uint64_t v38 = result;
              v37 += 48;
            }
            while (v31 + v37 != a2);
          }
          return result;
        }
      }
      if (v8 != v30)
      {
        uint64_t v34 = 0;
        do
        {
          uint64_t v35 = v5 + v34;
          uint64_t result = *(__n128 *)(v8 + v34);
          long long v36 = *(_OWORD *)(v8 + v34 + 32);
          *(_OWORD *)(v35 + 16) = *(_OWORD *)(v8 + v34 + 16);
          *(_OWORD *)(v35 + 32) = v36;
          *(__n128 *)uint64_t v35 = result;
          v34 += 48;
        }
        while (v8 + v34 != v30);
      }
    }
    else if (a1 != a2)
    {
      uint64_t result = *(__n128 *)a1;
      long long v15 = *(_OWORD *)(a1 + 32);
      *(_OWORD *)(a4 + 16) = *(_OWORD *)(a1 + 16);
      *(_OWORD *)(a4 + 32) = v15;
      *(__n128 *)a4 = result;
      uint64_t v16 = a1 + 48;
      if (a1 + 48 != a2)
      {
        uint64_t v17 = 0;
        unint64_t v18 = (_OWORD *)a4;
        do
        {
          uint64_t v20 = v8;
          long long v21 = v18;
          uint64_t v8 = v16;
          v18 += 3;
          unint64_t v22 = v18;
          if (*(void *)(v20 + 88) < *((void *)v21 + 5))
          {
            long long v23 = v21[1];
            *unint64_t v18 = *v21;
            v18[1] = v23;
            v18[2] = v21[2];
            unint64_t v22 = (_OWORD *)a4;
            if (v21 != (_OWORD *)a4)
            {
              uint64_t v24 = v17;
              while (1)
              {
                unint64_t v22 = (_OWORD *)(a4 + v24);
                if (*(void *)(v20 + 88) >= *(void *)(a4 + v24 - 8)) {
                  break;
                }
                long long v25 = *(v22 - 2);
                *unint64_t v22 = *(v22 - 3);
                v22[1] = v25;
                v22[2] = *(v22 - 1);
                v24 -= 48;
                if (!v24)
                {
                  unint64_t v22 = (_OWORD *)a4;
                  break;
                }
              }
            }
          }
          uint64_t result = *(__n128 *)v8;
          long long v19 = *(_OWORD *)(v8 + 32);
          v22[1] = *(_OWORD *)(v8 + 16);
          v22[2] = v19;
          *unint64_t v22 = result;
          uint64_t v16 = v8 + 48;
          v17 += 48;
        }
        while (v8 + 48 != a2);
      }
    }
  }
  return result;
}

char *std::__inplace_merge<std::_ClassicAlgPolicy,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::{lambda(anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match const&,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match const&)#1} &,anonymous namespace'::CurrentlyLive::Buffer::lookupRangeForValue(mlir::Value)::Match*>(char *result, char *a2, char *a3, uint64_t a4, uint64_t a5, char *a6, uint64_t a7)
{
  if (a5)
  {
    uint64_t v7 = a5;
    while (v7 > a7 && a4 > a7)
    {
      if (!a4) {
        return result;
      }
      uint64_t v10 = 0;
      uint64_t v11 = -a4;
      while (1)
      {
        long long v12 = &result[v10];
        if (*((void *)a2 + 5) < *(void *)&result[v10 + 40]) {
          break;
        }
        v10 += 48;
        BOOL v71 = __CFADD__(v11++, 1);
        if (v71) {
          return result;
        }
      }
      uint64_t v13 = -v11;
      if (-v11 >= v7)
      {
        if (v11 == -1)
        {
          uint64_t v84 = (long long *)&result[v10];
          long long v105 = v84[1];
          long long v110 = v84[2];
          long long v101 = *v84;
          long long v85 = *(_OWORD *)a2;
          long long v86 = *((_OWORD *)a2 + 2);
          v84[1] = *((_OWORD *)a2 + 1);
          v84[2] = v86;
          *uint64_t v84 = v85;
          *((_OWORD *)a2 + 1) = v105;
          *((_OWORD *)a2 + 2) = v110;
          *(_OWORD *)a2 = v101;
          return result;
        }
        if (v11 > 0) {
          uint64_t v13 = 1 - v11;
        }
        uint64_t v23 = v13 >> 1;
        if (a3 == a2)
        {
          long long v25 = a3;
        }
        else
        {
          unint64_t v24 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 4);
          long long v25 = a2;
          do
          {
            unint64_t v26 = v24 >> 1;
            long long v27 = &v25[48 * (v24 >> 1)];
            unint64_t v28 = *((void *)v27 + 5);
            uint64_t v29 = v27 + 48;
            v24 += ~(v24 >> 1);
            if (v28 < *(void *)&result[48 * v23 + 40 + v10]) {
              long long v25 = v29;
            }
            else {
              unint64_t v24 = v26;
            }
          }
          while (v24);
        }
        unint64_t v18 = &result[48 * v23 + v10];
        uint64_t v15 = 0xAAAAAAAAAAAAAAABLL * ((v25 - a2) >> 4);
      }
      else
      {
        if (v7 >= 0) {
          uint64_t v14 = v7;
        }
        else {
          uint64_t v14 = v7 + 1;
        }
        uint64_t v15 = v14 >> 1;
        if (v12 == a2)
        {
          uint64_t v16 = &result[v10];
          unint64_t v18 = a2;
        }
        else
        {
          uint64_t v16 = &result[v10];
          unint64_t v17 = 0xAAAAAAAAAAAAAAABLL * ((a2 - result - v10) >> 4);
          unint64_t v18 = &result[v10];
          do
          {
            unint64_t v19 = v17 >> 1;
            uint64_t v20 = &v18[48 * (v17 >> 1)];
            unint64_t v21 = *((void *)v20 + 5);
            unint64_t v22 = v20 + 48;
            v17 += ~(v17 >> 1);
            if (*(void *)&a2[48 * v15 + 40] < v21) {
              unint64_t v17 = v19;
            }
            else {
              unint64_t v18 = v22;
            }
          }
          while (v17);
        }
        long long v25 = &a2[48 * v15];
        uint64_t v23 = 0xAAAAAAAAAAAAAAABLL * ((v18 - v16) >> 4);
      }
      uint64_t v30 = v25;
      uint64_t v96 = a6;
      if (v18 != a2)
      {
        uint64_t v30 = v18;
        if (a2 != v25)
        {
          if (v18 + 48 == a2)
          {
            long long v103 = *((_OWORD *)v18 + 1);
            long long v107 = *((_OWORD *)v18 + 2);
            long long v98 = *(_OWORD *)v18;
            uint64_t v37 = (char *)(v25 - a2);
            uint64_t v38 = a3;
            uint64_t v91 = a7;
            uint64_t v93 = v23;
            uint64_t v39 = v15;
            memmove(v18, a2, v25 - a2);
            a7 = v91;
            uint64_t v23 = v93;
            uint64_t v15 = v39;
            a3 = v38;
            uint64_t v30 = &v37[(void)v18];
            *(_OWORD *)uint64_t v30 = v98;
            *((_OWORD *)v30 + 1) = v103;
            *((_OWORD *)v30 + 2) = v107;
          }
          else if (a2 + 48 == v25)
          {
            uint64_t v30 = v18 + 48;
            long long v104 = *((_OWORD *)v25 - 2);
            long long v108 = *((_OWORD *)v25 - 1);
            long long v99 = *((_OWORD *)v25 - 3);
            if (v25 - 48 != v18)
            {
              long long v40 = a3;
              uint64_t v92 = a7;
              uint64_t v94 = v23;
              uint64_t v41 = v15;
              memmove(v18 + 48, v18, v25 - 48 - v18);
              a7 = v92;
              uint64_t v23 = v94;
              uint64_t v15 = v41;
              a3 = v40;
            }
            *((_OWORD *)v18 + 1) = v104;
            *((_OWORD *)v18 + 2) = v108;
            *(_OWORD *)unint64_t v18 = v99;
          }
          else
          {
            unint64_t v31 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v18) >> 4);
            if (v31 == 0xAAAAAAAAAAAAAAABLL * ((v25 - a2) >> 4))
            {
              uint64_t v32 = 0;
              do
              {
                long long v33 = &a2[v32];
                uint64_t v34 = &v18[v32];
                long long v102 = *(_OWORD *)&v18[v32 + 16];
                long long v106 = *(_OWORD *)&v18[v32 + 32];
                long long v97 = *(_OWORD *)&v18[v32];
                long long v35 = *(_OWORD *)&a2[v32];
                long long v36 = *(_OWORD *)&a2[v32 + 32];
                *((_OWORD *)v34 + 1) = *(_OWORD *)&a2[v32 + 16];
                *((_OWORD *)v34 + 2) = v36;
                *(_OWORD *)uint64_t v34 = v35;
                *((_OWORD *)v33 + 1) = v102;
                *((_OWORD *)v33 + 2) = v106;
                *(_OWORD *)long long v33 = v97;
                if (&v18[v32 + 48] == a2) {
                  break;
                }
                v32 += 48;
              }
              while (v33 + 48 != v25);
              uint64_t v30 = a2;
            }
            else
            {
              uint64_t v42 = 0xAAAAAAAAAAAAAAABLL * ((v25 - a2) >> 4);
              unint64_t v43 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v18) >> 4);
              do
              {
                uint64_t v44 = v43;
                unint64_t v43 = v42;
                uint64_t v42 = v44 % v42;
              }
              while (v42);
              if (v43)
              {
                uint64_t v45 = &v18[48 * v43];
                do
                {
                  long long v46 = *((_OWORD *)v45 - 3);
                  long long v47 = *((_OWORD *)v45 - 2);
                  long long v48 = *((_OWORD *)v45 - 1);
                  v45 -= 48;
                  long long v109 = v48;
                  long long v100 = v46;
                  uint64_t v49 = &v45[16 * ((a2 - v18) >> 4)];
                  uint64_t v50 = v45;
                  do
                  {
                    uint64_t v51 = v50;
                    uint64_t v50 = v49;
                    long long v52 = *(_OWORD *)v49;
                    long long v53 = *((_OWORD *)v49 + 2);
                    *((_OWORD *)v51 + 1) = *((_OWORD *)v49 + 1);
                    *((_OWORD *)v51 + 2) = v53;
                    *(_OWORD *)uint64_t v51 = v52;
                    unint64_t v54 = 0xAAAAAAAAAAAAAAABLL * ((v25 - v49) >> 4);
                    BOOL v55 = __OFSUB__(v31, v54);
                    uint64_t v57 = v31 - v54;
                    char v56 = (v57 < 0) ^ v55;
                    uint64_t v49 = &v18[48 * v57];
                    if (v56) {
                      uint64_t v49 = &v50[16 * ((a2 - v18) >> 4)];
                    }
                  }
                  while (v49 != v45);
                  *((_OWORD *)v50 + 1) = v47;
                  *((_OWORD *)v50 + 2) = v109;
                  *(_OWORD *)uint64_t v50 = v100;
                }
                while (v45 != v18);
              }
              uint64_t v30 = &v18[16 * ((v25 - a2) >> 4)];
            }
          }
        }
      }
      a4 = -(v23 + v11);
      uint64_t v58 = v7 - v15;
      if (v23 + v15 >= v7 - (v23 + v15) - v11)
      {
        uint64_t v95 = v23;
        uint64_t v61 = -(v23 + v11);
        uint64_t v62 = v15;
        uint64_t v59 = a7;
        long long v25 = v18;
        uint64_t v58 = v62;
        a4 = v95;
        a3 = v30;
      }
      else
      {
        uint64_t v59 = a7;
        uint64_t v60 = a3;
        a3 = v60;
        long long v12 = v30;
      }
      uint64_t v7 = v58;
      uint64_t result = v12;
      a2 = v25;
      a6 = v96;
      a7 = v59;
      if (!v58) {
        return result;
      }
    }
    if (a4 <= v7)
    {
      if (result != a2)
      {
        uint64_t v75 = 0;
        do
        {
          unint64_t v76 = &a6[v75];
          long long v77 = *(_OWORD *)&result[v75];
          long long v78 = *(_OWORD *)&result[v75 + 32];
          *((_OWORD *)v76 + 1) = *(_OWORD *)&result[v75 + 16];
          *((_OWORD *)v76 + 2) = v78;
          *(_OWORD *)unint64_t v76 = v77;
          v75 += 48;
        }
        while (&result[v75] != a2);
        if (v75)
        {
          id v79 = a6;
          while (a2 != a3)
          {
            if (*((void *)a2 + 5) >= *((void *)v79 + 5))
            {
              long long v80 = *(_OWORD *)v79;
              long long v81 = *((_OWORD *)v79 + 2);
              *((_OWORD *)result + 1) = *((_OWORD *)v79 + 1);
              *((_OWORD *)result + 2) = v81;
              *(_OWORD *)uint64_t result = v80;
              v79 += 48;
            }
            else
            {
              long long v82 = *(_OWORD *)a2;
              long long v83 = *((_OWORD *)a2 + 2);
              *((_OWORD *)result + 1) = *((_OWORD *)a2 + 1);
              *((_OWORD *)result + 2) = v83;
              *(_OWORD *)uint64_t result = v82;
              a2 += 48;
            }
            result += 48;
            if (&a6[v75] == v79) {
              return result;
            }
          }
          return (char *)memmove(result, v79, a6 - v79 + v75);
        }
      }
    }
    else if (a2 != a3)
    {
      uint64_t v63 = 0;
      do
      {
        uint64_t v64 = &a6[v63];
        long long v65 = *(_OWORD *)&a2[v63];
        long long v66 = *(_OWORD *)&a2[v63 + 32];
        *((_OWORD *)v64 + 1) = *(_OWORD *)&a2[v63 + 16];
        *((_OWORD *)v64 + 2) = v66;
        *(_OWORD *)uint64_t v64 = v65;
        v63 += 48;
      }
      while (&a2[v63] != a3);
      if (v63)
      {
        uint64_t v67 = &a6[v63];
        uint64_t v68 = a3 - 48;
        while (a2 != result)
        {
          unint64_t v69 = *((void *)v67 - 1);
          unint64_t v70 = *((void *)a2 - 1);
          BOOL v71 = v69 >= v70;
          if (v69 >= v70) {
            unint64_t v72 = v67 - 48;
          }
          else {
            unint64_t v72 = a2 - 48;
          }
          if (v71) {
            v67 -= 48;
          }
          else {
            a2 -= 48;
          }
          long long v73 = *(_OWORD *)v72;
          long long v74 = *((_OWORD *)v72 + 2);
          *((_OWORD *)v68 + 1) = *((_OWORD *)v72 + 1);
          *((_OWORD *)v68 + 2) = v74;
          *(_OWORD *)uint64_t v68 = v73;
          v68 -= 48;
          if (v67 == a6) {
            return result;
          }
        }
        unint64_t v87 = 0;
        do
        {
          unint64_t v88 = &v68[v87];
          long long v89 = *(_OWORD *)&v67[v87 - 48];
          long long v90 = *(_OWORD *)&v67[v87 - 16];
          *((_OWORD *)v88 + 1) = *(_OWORD *)&v67[v87 - 32];
          *((_OWORD *)v88 + 2) = v90;
          *(_OWORD *)unint64_t v88 = v89;
          v87 -= 48;
        }
        while (&v67[v87] != a6);
      }
    }
  }
  return result;
}

uint64_t llvm::SmallVectorImpl<llvm::SmallSetVector<mlir::Value,2u>>::erase(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = *a1;
  unsigned int v4 = *((_DWORD *)a1 + 2);
  if (*a1 + 56 * v4 != a3) {
    llvm::deallocate_buffer(*(llvm **)a2, (void *)(8 * *(unsigned int *)(a2 + 16)));
  }
  if (v3 + 56 * v4 != a2)
  {
    uint64_t v5 = v3 + 56 * v4;
    uint64_t v6 = (llvm **)(v5 - 16);
    uint64_t v7 = *(llvm ***)(v5 - 32);
    if (v6 != v7) {
      free(v7);
    }
    llvm::deallocate_buffer(*(v6 - 5), (void *)(8 * *((unsigned int *)v6 - 6)));
  }
  *((_DWORD *)a1 + 2) = -1227133513 * ((unint64_t)(a2 - v3) >> 3);
  return a2;
}

uint64_t mlir::OpInterface<mlir::MinimumAlignmentInterface,mlir::detail::MinimumAlignmentInterfaceInterfaceTraits>::getInterfaceFor(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  uint64_t v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v22 = *(void *)(v1 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v22);
    if (result)
    {
      uint64_t v20 = result;
      uint64_t v21 = mlir::TypeID::get<mlir::MinimumAlignmentInterface>();
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v20 + 104))(v20, v21, v1);
    }
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    unint64_t v7 = mlir::TypeID::get<mlir::MinimumAlignmentInterface>();
    unint64_t v8 = *(unsigned int *)(v6 + 40);
    if (!v8) {
      goto LABEL_14;
    }
    long long v9 = *(void **)(v6 + 32);
    uint64_t v10 = &v9[2 * v8];
    do
    {
      unint64_t v11 = v8 >> 1;
      long long v12 = &v9[2 * (v8 >> 1)];
      unint64_t v14 = *v12;
      uint64_t v13 = v12 + 2;
      v8 += ~(v8 >> 1);
      if (v14 < v7) {
        long long v9 = v13;
      }
      else {
        unint64_t v8 = v11;
      }
    }
    while (v8);
    if (v9 == v10 || *v9 != v7 || (uint64_t result = v9[1]) == 0)
    {
LABEL_14:
      uint64_t v16 = *(void *)(v6 + 24);
      uint64_t v17 = *(void *)(a1 + 48);
      uint64_t v18 = mlir::TypeID::get<mlir::MinimumAlignmentInterface>();
      unint64_t v19 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v16 + 104);
      return v19(v16, v18, v17);
    }
  }
  return result;
}

uint64_t mlir::TypeID::get<mlir::MinimumAlignmentInterface>()
{
  unint64_t v0 = 0x1E8EB8000uLL;
  {
    unint64_t v0 = 0x1E8EB8000;
    if (v2)
    {
      uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MinimumAlignmentInterface]";
      unint64_t v11 = 81;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::MinimumAlignmentInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = 0x1E8EB8000;
    }
  }
  return *(void *)(v0 + 3968);
}

mlir::GenericProgramPoint *mlir::detail::walk<mlir::ForwardIterator>(mlir::ForwardIterator *a1, mlir::Operation *a2, uint64_t a3, int a4)
{
  if (!a4) {
    ((void (*)(uint64_t, mlir::ForwardIterator *))a2)(a3, a1);
  }
  uint64_t result = (mlir::GenericProgramPoint *)mlir::ForwardIterator::makeIterable(a1, a2);
  if (v8)
  {
    uint64_t v9 = result;
    uint64_t v10 = (mlir::GenericProgramPoint *)((char *)result + 24 * v8);
    do
    {
      for (uint64_t i = (mlir::GenericProgramPoint *)*((void *)v9 + 1);
            i != v9;
            uint64_t i = (mlir::GenericProgramPoint *)*((void *)i + 1))
      {
        long long v12 = (void *)((char *)i - 8);
        if (!i) {
          long long v12 = 0;
        }
        uint64_t v13 = (mlir::GenericProgramPoint *)(v12 + 4);
        uint64_t result = (mlir::GenericProgramPoint *)v12[5];
        if (result != (mlir::GenericProgramPoint *)(v12 + 4))
        {
          do
          {
            unint64_t v14 = (mlir::GenericProgramPoint *)*((void *)result + 1);
            mlir::GenericProgramPoint::~GenericProgramPoint(result);
            mlir::detail::walk<mlir::ForwardIterator>();
            uint64_t result = v14;
          }
          while (v14 != v13);
        }
      }
      uint64_t v9 = (mlir::GenericProgramPoint *)((char *)v9 + 24);
    }
    while (v9 != v10);
  }
  if (a4 == 1)
  {
    return (mlir::GenericProgramPoint *)((uint64_t (*)(uint64_t, mlir::ForwardIterator *))a2)(a3, a1);
  }
  return result;
}

void _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorERZNS7_10AllocRange16getRangeForValueENS1_5ValueExE3__0NS1_25MinimumAlignmentInterfaceEvEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESN_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t ***a1, uint64_t a2)
{
  if (mlir::OpInterface<mlir::MinimumAlignmentInterface,mlir::detail::MinimumAlignmentInterfaceInterfaceTraits>::getInterfaceFor(a2))
  {
    if (a2)
    {
      uint64_t InterfaceFor = mlir::OpInterface<mlir::MinimumAlignmentInterface,mlir::detail::MinimumAlignmentInterfaceInterfaceTraits>::getInterfaceFor(a2);
      uint64_t v5 = *a1;
      v12[0] = a2;
      v12[1] = InterfaceFor;
      if ((*(unsigned char *)(a2 + 46) & 0x80) != 0)
      {
        uint64_t v6 = *(unsigned int *)(a2 + 68);
        if (v6)
        {
          uint64_t v7 = (uint64_t *)(*(void *)(a2 + 72) + 24);
          do
          {
            if (mlir::matchValueThrough<mlir::MemoryMapperInterface>(*v7, **v5))
            {
              uint64_t v8 = *v5[1];
              uint64_t canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)v12);
              if (v8 < 0) {
                uint64_t v8 = -v8;
              }
              unsigned int v16 = 64;
              uint64_t v15 = (void *)v8;
              if (canMapOperands >= 0) {
                uint64_t v10 = canMapOperands;
              }
              else {
                uint64_t v10 = -canMapOperands;
              }
              unsigned int v14 = 64;
              uint64_t v13 = (void *)v10;
              llvm::APIntOps::GreatestCommonDivisor((uint64_t)&v15, (uint64_t)&v13, (uint64_t)&__p);
              if (v18 > 0x40)
              {
                unint64_t v11 = *(void *)__p;
                operator delete[](__p);
              }
              else
              {
                unint64_t v11 = (unint64_t)__p;
              }
              if (v14 >= 0x41 && v13) {
                operator delete[](v13);
              }
              if (v16 >= 0x41)
              {
                if (v15) {
                  operator delete[](v15);
                }
              }
              *v5[1] = v10 * v8 / v11;
            }
            v7 += 4;
            --v6;
          }
          while (v6);
        }
      }
    }
  }
}

uint64_t mlir::matchValueThrough<mlir::MemoryMapperInterface>(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = a1;
  if (a1 == a2) {
    return 1;
  }
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v10);
  if (result)
  {
    uint64_t v4 = result;
    uint64_t result = mlir::OpInterface<mlir::MemoryMapperInterface,mlir::detail::MemoryMapperInterfaceInterfaceTraits>::getInterfaceFor(result);
    if (result)
    {
      if ((*(unsigned char *)(v4 + 46) & 0x80) != 0 && (uint64_t v5 = *(unsigned int *)(v4 + 68), v5))
      {
        uint64_t v6 = v5 - 1;
        uint64_t v7 = (uint64_t *)(*(void *)(v4 + 72) + 24);
        do
        {
          uint64_t v8 = v6;
          uint64_t v9 = *v7;
          v7 += 4;
          uint64_t result = mlir::matchValueThrough<mlir::MemoryMapperInterface>(v9, a2);
          if (result) {
            break;
          }
          uint64_t v6 = v8 - 1;
        }
        while (v8);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t llvm::SetVector<mlir::detail::AllocRange,llvm::SmallVector<mlir::detail::AllocRange,0u>,llvm::DenseSet<mlir::detail::AllocRange,llvm::DenseMapInfo<mlir::detail::AllocRange,void>>,0u>::insert(uint64_t a1, unint64_t *a2)
{
  unint64_t v2 = (unint64_t)a2;
  uint64_t v17 = 0;
  int v4 = llvm::DenseMapBase<llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>,mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::LookupBucketFor<mlir::detail::AllocRange>((uint64_t *)a1, a2, &v17);
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = llvm::DenseMapBase<llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>,mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::InsertIntoBucketImpl<mlir::detail::AllocRange>(a1, v2, (unint64_t *)v2, v17);
    long long v6 = *(_OWORD *)v2;
    long long v7 = *(_OWORD *)(v2 + 16);
    v5[4] = *(void *)(v2 + 32);
    *(_OWORD *)uint64_t v5 = v6;
    *((_OWORD *)v5 + 1) = v7;
    uint64_t v8 = a1 + 24;
    unint64_t v9 = *(void *)(a1 + 24);
    uint64_t v10 = *(unsigned int *)(a1 + 32);
    if (v10 >= *(_DWORD *)(a1 + 36))
    {
      unint64_t v15 = v10 + 1;
      if (v9 <= v2 && v9 + 40 * v10 > v2)
      {
        unint64_t v16 = v2 - v9;
        llvm::SmallVectorBase<unsigned int>::grow_pod(v8, (void *)(a1 + 40), v15, 40);
        unint64_t v9 = *(void *)(a1 + 24);
        unint64_t v2 = v9 + v16;
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(v8, (void *)(a1 + 40), v15, 40);
        unint64_t v9 = *(void *)(a1 + 24);
      }
    }
    unint64_t v11 = v9 + 40 * *(unsigned int *)(a1 + 32);
    long long v12 = *(_OWORD *)v2;
    long long v13 = *(_OWORD *)(v2 + 16);
    *(void *)(v11 + 32) = *(void *)(v2 + 32);
    *(_OWORD *)unint64_t v11 = v12;
    *(_OWORD *)(v11 + 16) = v13;
    ++*(_DWORD *)(a1 + 32);
  }
  return v4 ^ 1u;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>,mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::LookupBucketFor<mlir::detail::AllocRange>(uint64_t *a1, unint64_t *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    unint64_t v5 = *a2;
    unint64_t v6 = 0x1E8EB8000uLL;
    {
      uint64_t v23 = a3;
      uint64_t v21 = a2;
      uint64_t v24 = v4;
      int v22 = v3;
      unint64_t v25 = v5;
      unint64_t v6 = 0x1E8EB8000uLL;
      uint64_t v4 = v24;
      unint64_t v5 = v25;
      int v3 = v22;
      a2 = v21;
      a3 = v23;
      if (v19)
      {
        unint64_t v20 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v20 = 0xFF51AFD7ED558CCDLL;
        }
        llvm::hashing::detail::get_execution_seed(void)::seed = v20;
        unint64_t v6 = 0x1E8EB8000;
        uint64_t v4 = v24;
        unint64_t v5 = v25;
        int v3 = v22;
        a2 = v21;
        a3 = v23;
      }
    }
    uint64_t v7 = (*(void *)(v6 + 3024) + 8 * v5) ^ HIDWORD(v5);
    unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(v5) ^ ((0x9DDFEA08EB382D69 * v7) >> 47) ^ (0x9DDFEA08EB382D69 * v7));
    int v9 = -348639895 * ((v8 >> 47) ^ v8);
    int v10 = v3 - 1;
    unsigned int v11 = v9 & (v3 - 1);
    long long v12 = (void *)(v4 + 40 * v11);
    uint64_t v13 = *v12;
    if (*a2 == *v12)
    {
      uint64_t result = 1;
    }
    else
    {
      unint64_t v15 = 0;
      int v16 = 1;
      uint64_t result = 1;
      while (v13 != -4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v13 == -8192;
        }
        if (v17) {
          unint64_t v15 = v12;
        }
        unsigned int v18 = v11 + v16++;
        unsigned int v11 = v18 & v10;
        long long v12 = (void *)(v4 + 40 * (v18 & v10));
        uint64_t v13 = *v12;
        if (*a2 == *v12) {
          goto LABEL_6;
        }
      }
      uint64_t result = 0;
      if (v15) {
        long long v12 = v15;
      }
    }
  }
  else
  {
    long long v12 = 0;
    uint64_t result = 0;
  }
LABEL_6:
  *a3 = v12;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>,mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::InsertIntoBucketImpl<mlir::detail::AllocRange>(uint64_t a1, uint64_t a2, unint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::grow(a1, v7);
  int v9 = 0;
  llvm::DenseMapBase<llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>,mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::LookupBucketFor<mlir::detail::AllocRange>((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

char *llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (char *)llvm::allocate_buffer(40 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    int v10 = *(_DWORD *)(a1 + 16);
    if (v10)
    {
      unsigned int v11 = &result[40 * v10];
      *(void *)&long long v12 = -1;
      *((void *)&v12 + 1) = -1;
      do
      {
        *(void *)uint64_t result = -4096;
        *(_OWORD *)(result + 8) = v12;
        *(_OWORD *)(result + 24) = v12;
        result += 40;
      }
      while (result != v11);
    }
    if (v3)
    {
      uint64_t v13 = 40 * v3;
      unsigned int v14 = v4;
      do
      {
        if ((*(void *)v14 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v21 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>,mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::LookupBucketFor<mlir::detail::AllocRange>((uint64_t *)a1, (unint64_t *)v14, &v21);
          unint64_t v15 = (_OWORD *)v21;
          long long v16 = *(_OWORD *)v14;
          long long v17 = *((_OWORD *)v14 + 1);
          *(void *)(v21 + 32) = *((void *)v14 + 4);
          *unint64_t v15 = v16;
          v15[1] = v17;
          ++*(_DWORD *)(a1 + 8);
        }
        unsigned int v14 = (llvm *)((char *)v14 + 40);
        v13 -= 40;
      }
      while (v13);
    }
    llvm::deallocate_buffer(v4, (void *)(40 * v3));
  }
  *(void *)(a1 + 8) = 0;
  int v18 = *(_DWORD *)(a1 + 16);
  if (v18)
  {
    int v19 = &result[40 * v18];
    *(void *)&long long v20 = -1;
    *((void *)&v20 + 1) = -1;
    do
    {
      *(void *)uint64_t result = -4096;
      *(_OWORD *)(result + 8) = v20;
      *(_OWORD *)(result + 24) = v20;
      result += 40;
    }
    while (result != v19);
  }
  return result;
}

uint64_t llvm::DenseMap<mlir::detail::AllocRange,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::detail::AllocRange,void>,llvm::detail::DenseSetPair<mlir::detail::AllocRange>>::shrink_and_clear(uint64_t result)
{
  uint64_t v1 = *(unsigned int *)(result + 16);
  int v2 = *(_DWORD *)(result + 8);
  int v3 = 1 << (33 - __clz(v2 - 1));
  if (v3 <= 64) {
    int v3 = 64;
  }
  if (v2) {
    int v4 = v3;
  }
  else {
    int v4 = 0;
  }
  if (v4 != v1) {
    llvm::deallocate_buffer(*(llvm **)result, (void *)(40 * v1));
  }
  *(void *)(result + 8) = 0;
  if (v1)
  {
    unint64_t v5 = *(llvm **)result;
    uint64_t v6 = *(void *)result + 40 * v1;
    *(void *)&long long v7 = -1;
    *((void *)&v7 + 1) = -1;
    do
    {
      *(void *)unint64_t v5 = -4096;
      *(_OWORD *)((char *)v5 + 8) = v7;
      *(_OWORD *)((char *)v5 + 24) = v7;
      unint64_t v5 = (llvm *)((char *)v5 + 40);
    }
    while (v5 != (llvm *)v6);
  }
  return result;
}

void std::default_delete<mlir::Liveness>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    unsigned int v3 = *(_DWORD *)(a2 + 24);
    int v4 = *(llvm **)(a2 + 8);
    if (v3)
    {
      uint64_t v5 = 336 * v3;
      do
      {
        if ((*(void *)v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          uint64_t v6 = (void *)*((void *)v4 + 23);
          if (v6 != *((void **)v4 + 22)) {
            free(v6);
          }
          long long v7 = (void *)*((void *)v4 + 3);
          if (v7 != *((void **)v4 + 2)) {
            free(v7);
          }
        }
        int v4 = (llvm *)((char *)v4 + 336);
        v5 -= 336;
      }
      while (v5);
      int v4 = *(llvm **)(a2 + 8);
      uint64_t v8 = 336 * *(unsigned int *)(a2 + 24);
    }
    else
    {
      uint64_t v8 = 0;
    }
    llvm::deallocate_buffer(v4, (void *)v8);
  }
}

void sub_180180630()
{
  operator delete(v0);
}

void *mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>,mlir::Value>(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  int v2 = (uint64_t *)(a1 + 120);
  unint64_t v3 = a2 & 0xFFFFFFFFFFFFFFF9 | 4;
  unint64_t v9 = v3;
  uint64_t v10 = mlir::TypeID::get<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>>();
  uint64_t v8 = 0;
  char v4 = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::LookupBucketFor<std::pair<mlir::ProgramPoint,mlir::TypeID>>(v2, (uint64_t *)&v9, &v8);
  uint64_t v5 = v8;
  if (v4)
  {
    uint64_t result = (void *)v8[2];
    if (result) {
      return result;
    }
  }
  else
  {
    uint64_t v5 = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>((uint64_t)v2, (uint64_t)&v9, (uint64_t *)&v9, v8);
    void *v5 = v9;
    v5[1] = v10;
    v5[2] = 0;
  }
  uint64_t result = operator new(0x248uLL);
  result[2] = 0;
  result[3] = 0;
  result[7] = result + 11;
  *((_DWORD *)result + 8) = 0;
  result[5] = result + 7;
  result[6] = 0;
  result[8] = result + 11;
  result[9] = 4;
  *((_DWORD *)result + 20) = 0;
  result[15] = result + 17;
  result[16] = 0x400000000;
  *uint64_t result = &unk_1EC9CDCC0;
  result[1] = v3;
  result[21] = result + 23;
  result[22] = 0xA00000000;
  uint64_t v7 = v5[2];
  v5[2] = result;
  if (v7)
  {
    (*(void (**)(uint64_t))(*(void *)v7 + 8))(v7);
    return (void *)v5[2];
  }
  return result;
}

uint64_t mlir::TypeID::get<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>>()
{
  unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    if (v2)
    {
      uint64_t v10 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>]";
      unint64_t v11 = 109;
      unint64_t v3 = llvm::StringRef::find((uint64_t *)&v10, "DesiredTypeName = ", 0x12uLL, 0);
      if (v11 >= v3) {
        unint64_t v4 = v3;
      }
      else {
        unint64_t v4 = v11;
      }
      uint64_t v5 = &v10[v4];
      unint64_t v6 = v11 - v4;
      if (v11 - v4 >= 0x12) {
        uint64_t v7 = 18;
      }
      else {
        uint64_t v7 = v11 - v4;
      }
      unint64_t v8 = v6 - v7;
      if (v8 >= v8 - 1) {
        uint64_t v9 = v8 - 1;
      }
      else {
        uint64_t v9 = v8;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v5[v7], v9);
      unint64_t v0 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    }
  }
  return v0[29];
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::LookupBucketFor<std::pair<mlir::ProgramPoint,mlir::TypeID>>(uint64_t *a1, uint64_t *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    uint64_t v5 = *a2;
    uint64_t v6 = a2[1];
    unint64_t v7 = ((0x2500000000 * *a2) | (v6 >> 4) ^ (v6 >> 9))
       + ~((unint64_t)((v6 >> 4) ^ (v6 >> 9)) << 32);
    unint64_t v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
    unint64_t v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
    int v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~(v9 << 27));
    int v11 = v3 - 1;
    unsigned int v12 = (v3 - 1) & v10;
    uint64_t v13 = (void *)(*a1 + 24 * v12);
    uint64_t v15 = *v13;
    uint64_t v14 = v13[1];
    if (v5 == *v13 && v6 == v14)
    {
      uint64_t result = 1;
      *a3 = v13;
    }
    else
    {
      long long v17 = 0;
      int v18 = 1;
      uint64_t result = 1;
      while (v15 != -4096 || v14 != -4096)
      {
        if (v17) {
          BOOL v20 = 0;
        }
        else {
          BOOL v20 = v14 == -8192;
        }
        if (v20 && v15 == -8192) {
          long long v17 = v13;
        }
        unsigned int v22 = v12 + v18++;
        unsigned int v12 = v22 & v11;
        uint64_t v13 = (void *)(v4 + 24 * (v22 & v11));
        uint64_t v15 = *v13;
        uint64_t v14 = v13[1];
        if (v5 == *v13 && v6 == v14)
        {
          *a3 = v13;
          return result;
        }
      }
      uint64_t result = 0;
      if (v17) {
        uint64_t v13 = v17;
      }
      *a3 = v13;
    }
  }
  else
  {
    uint64_t result = 0;
    *a3 = 0;
  }
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>(uint64_t a1, uint64_t a2, uint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
    goto LABEL_8;
  }
  if (v7 + ~v6 - *(_DWORD *)(a1 + 12) <= v7 >> 3)
  {
LABEL_8:
    llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::grow(a1, v7);
    unint64_t v9 = 0;
    llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::LookupBucketFor<std::pair<mlir::ProgramPoint,mlir::TypeID>>((uint64_t *)a1, a3, &v9);
    a4 = v9;
  }
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096 || a4[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

int64x2_t *llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (int64x2_t *)llvm::allocate_buffer(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    uint64_t v10 = 3 * v3;
    llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::moveFromOldBuckets(a1, v4, &v4[v10]);
    llvm::deallocate_buffer((llvm *)v4, (void *)(v10 * 8));
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v11 = *(_DWORD *)(a1 + 16);
  if (v11)
  {
    unint64_t v12 = 24 * v11 - 24;
    if (v12 < 0x18)
    {
      uint64_t v13 = result;
LABEL_14:
      int v18 = (int64x2_t *)((char *)result + 24 * v11);
      int64x2_t v19 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      do
      {
        *uint64_t v13 = v19;
        uint64_t v13 = (int64x2_t *)((char *)v13 + 24);
      }
      while (v13 != v18);
      return result;
    }
    unint64_t v14 = v12 / 0x18 + 1;
    uint64_t v13 = (int64x2_t *)((char *)result + 24 * (v14 & 0x1FFFFFFFFFFFFFFELL));
    int64x2_t v15 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    uint64_t v16 = v14 & 0x1FFFFFFFFFFFFFFELL;
    long long v17 = result;
    do
    {
      *long long v17 = v15;
      *(int64x2_t *)((char *)v17 + 24) = v15;
      v17 += 3;
      v16 -= 2;
    }
    while (v16);
    if (v14 != (v14 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_14;
    }
  }
  return result;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::moveFromOldBuckets(uint64_t result, uint64_t *a2, uint64_t *a3)
{
  uint64_t v5 = result;
  *(void *)(result + 8) = 0;
  unsigned int v6 = *(_DWORD *)(result + 16);
  if (v6)
  {
    int v7 = *(int64x2_t **)result;
    unint64_t v8 = 24 * v6 - 24;
    if (v8 < 0x18)
    {
      unint64_t v9 = *(int64x2_t **)result;
LABEL_7:
      unint64_t v14 = (int64x2_t *)((char *)v7 + 24 * v6);
      int64x2_t v15 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      do
      {
        *unint64_t v9 = v15;
        unint64_t v9 = (int64x2_t *)((char *)v9 + 24);
      }
      while (v9 != v14);
      goto LABEL_11;
    }
    unint64_t v10 = v8 / 0x18 + 1;
    unint64_t v9 = (int64x2_t *)((char *)v7 + 24 * (v10 & 0x1FFFFFFFFFFFFFFELL));
    int64x2_t v11 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    uint64_t v12 = v10 & 0x1FFFFFFFFFFFFFFELL;
    uint64_t v13 = *(int64x2_t **)result;
    do
    {
      *uint64_t v13 = v11;
      *(int64x2_t *)((char *)v13 + 24) = v11;
      v13 += 3;
      v12 -= 2;
    }
    while (v12);
    if (v10 != (v10 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_7;
    }
  }
LABEL_11:
  while (a2 != a3)
  {
    uint64_t v16 = a2[1];
    if ((*a2 != -4096 || v16 != -4096) && (*a2 != -8192 || v16 != -8192))
    {
      int64x2_t v19 = 0;
      llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::LookupBucketFor<std::pair<mlir::ProgramPoint,mlir::TypeID>>((uint64_t *)v5, a2, &v19);
      long long v17 = v19;
      *int64x2_t v19 = *a2;
      v17[1] = a2[1];
      uint64_t v18 = a2[2];
      a2[2] = 0;
      v17[2] = v18;
      ++*(_DWORD *)(v5 + 8);
      uint64_t result = a2[2];
      a2[2] = 0;
      if (result) {
        uint64_t result = (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
      }
    }
    a2 += 3;
  }
  return result;
}

void mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>::~Lattice(mlir::AnalysisState *this)
{
  *(void *)this = &unk_1EC9CDCC0;
  int v2 = (char *)*((void *)this + 21);
  if (v2 != (char *)this + 184) {
    free(v2);
  }
  *(void *)this = &unk_1EC9CDBC0;
  uint64_t v3 = (char *)*((void *)this + 15);
  if (v3 != (char *)this + 136) {
    free(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 8);
  if (v4 != *((void **)this + 7)) {
    free(v4);
  }

  mlir::AnalysisState::~AnalysisState(this);
}

{
  char *v2;
  char *v3;
  void *v4;

  *(void *)this = &unk_1EC9CDCC0;
  int v2 = (char *)*((void *)this + 21);
  if (v2 != (char *)this + 184) {
    free(v2);
  }
  *(void *)this = &unk_1EC9CDBC0;
  uint64_t v3 = (char *)*((void *)this + 15);
  if (v3 != (char *)this + 136) {
    free(v3);
  }
  uint64_t v4 = (void *)*((void *)this + 8);
  if (v4 != *((void **)this + 7)) {
    free(v4);
  }
  mlir::AnalysisState::~AnalysisState(this);
}

void sub_180180E34(void *__p)
{
  operator delete(__p);
}

llvm::raw_ostream *mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  return mlir::dataflow::OffsetLatticeValue::print((llvm::raw_ostream *)(a1 + 168), a2);
}

uint64_t mlir::dataflow::Lattice<mlir::dataflow::OffsetLatticeValue>::meet()
{
  return 0;
}

uint64_t llvm::MapVector<mlir::Value,mlir::dataflow::TensorAllocAnalysis::AllocInfo,llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,llvm::SmallVector<std::pair<mlir::Value,mlir::dataflow::TensorAllocAnalysis::AllocInfo>,0u>>::try_emplace<mlir::dataflow::TensorAllocAnalysis::AllocInfo>(uint64_t a1, unint64_t *a2, long long *a3)
{
  unint64_t v6 = *a2;
  BOOL v20 = 0;
  unint64_t v21 = v6;
  LODWORD(v22) = 0;
  if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, &v21, &v20))return *(void *)(a1 + 24) + 24 * *((unsigned int *)v20 + 2); {
  unint64_t v8 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::InsertIntoBucketImpl<mlir::Value>(a1, (uint64_t)&v21, &v21, v20);
  }
  void *v8 = v21;
  *((_DWORD *)v8 + 2) = v22;
  unint64_t v9 = (void *)(a1 + 24);
  uint64_t v10 = *(unsigned int *)(a1 + 32);
  *((_DWORD *)v8 + 2) = v10;
  if (v10 >= *(_DWORD *)(a1 + 36))
  {
    unint64_t v21 = *a2;
    long long v22 = *a3;
    unint64_t v13 = v10 + 1;
    BOOL v14 = *v9 + 24 * (unint64_t)v10 > (unint64_t)&v21;
    if (*v9 <= (unint64_t)&v21 && v14)
    {
      int64x2_t v19 = (char *)&v21 - *v9;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v13, 24);
      uint64_t v15 = *(void *)(a1 + 24);
      uint64_t v16 = (unint64_t *)&v19[v15];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 24, (void *)(a1 + 40), v13, 24);
      uint64_t v15 = *(void *)(a1 + 24);
      uint64_t v16 = &v21;
    }
    uint64_t v17 = v15 + 24 * *(unsigned int *)(a1 + 32);
    long long v18 = *(_OWORD *)v16;
    *(void *)(v17 + 16) = v16[2];
    *(_OWORD *)uint64_t v17 = v18;
  }
  else
  {
    uint64_t v11 = *(void *)(a1 + 24) + 24 * v10;
    *(void *)uint64_t v11 = *a2;
    *(_OWORD *)(v11 + 8) = *a3;
  }
  unsigned int v12 = *(_DWORD *)(a1 + 32) + 1;
  *(_DWORD *)(a1 + 32) = v12;
  return *v9 + 24 * v12 - 24;
}

uint64_t llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(uint64_t *a1, unint64_t *a2, void *a3)
{
  int v3 = *((_DWORD *)a1 + 4);
  if (v3)
  {
    uint64_t v4 = *a1;
    unint64_t v5 = *a2;
    unint64_t v6 = 0x1E8EB8000uLL;
    {
      uint64_t v23 = a3;
      unint64_t v21 = a2;
      uint64_t v24 = v4;
      int v22 = v3;
      unint64_t v25 = v5;
      unint64_t v6 = 0x1E8EB8000uLL;
      uint64_t v4 = v24;
      unint64_t v5 = v25;
      int v3 = v22;
      a2 = v21;
      a3 = v23;
      if (v19)
      {
        unint64_t v20 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override) {
          unint64_t v20 = 0xFF51AFD7ED558CCDLL;
        }
        llvm::hashing::detail::get_execution_seed(void)::seed = v20;
        unint64_t v6 = 0x1E8EB8000;
        uint64_t v4 = v24;
        unint64_t v5 = v25;
        int v3 = v22;
        a2 = v21;
        a3 = v23;
      }
    }
    uint64_t v7 = (*(void *)(v6 + 3024) + 8 * v5) ^ HIDWORD(v5);
    unint64_t v8 = 0x9DDFEA08EB382D69 * (HIDWORD(v5) ^ ((0x9DDFEA08EB382D69 * v7) >> 47) ^ (0x9DDFEA08EB382D69 * v7));
    int v9 = -348639895 * ((v8 >> 47) ^ v8);
    int v10 = v3 - 1;
    unsigned int v11 = v9 & (v3 - 1);
    unsigned int v12 = (void *)(v4 + 16 * v11);
    uint64_t v13 = *v12;
    if (*a2 == *v12)
    {
      uint64_t result = 1;
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = 1;
      uint64_t result = 1;
      while (v13 != -4096)
      {
        if (v15) {
          BOOL v17 = 0;
        }
        else {
          BOOL v17 = v13 == -8192;
        }
        if (v17) {
          uint64_t v15 = v12;
        }
        unsigned int v18 = v11 + v16++;
        unsigned int v11 = v18 & v10;
        unsigned int v12 = (void *)(v4 + 16 * (v18 & v10));
        uint64_t v13 = *v12;
        if (*a2 == *v12) {
          goto LABEL_6;
        }
      }
      uint64_t result = 0;
      if (v15) {
        unsigned int v12 = v15;
      }
    }
  }
  else
  {
    unsigned int v12 = 0;
    uint64_t result = 0;
  }
LABEL_6:
  *a3 = v12;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::InsertIntoBucketImpl<mlir::Value>(uint64_t a1, uint64_t a2, unint64_t *a3, void *a4)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::grow(a1, v7);
  int v9 = 0;
  llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, a3, &v9);
  a4 = v9;
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a4 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  return a4;
}

void *llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  int v10 = result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
        goto LABEL_10;
      }
      uint64_t v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      int v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      uint64_t v13 = result + 2;
      uint64_t v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -4096;
        *uint64_t v13 = -4096;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_10:
        uint64_t v15 = &result[2 * v11];
        do
        {
          *int v10 = -4096;
          v10 += 2;
        }
        while (v10 != v15);
      }
    }
    int v16 = (void *)(16 * v3);
    if (v3)
    {
      uint64_t v17 = 16 * v3;
      unsigned int v18 = v4;
      do
      {
        if ((*(void *)v18 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unint64_t v25 = 0;
          llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>((uint64_t *)a1, (unint64_t *)v18, &v25);
          int v19 = v25;
          *unint64_t v25 = *(void *)v18;
          *((_DWORD *)v19 + 2) = *((_DWORD *)v18 + 2);
          ++*(_DWORD *)(a1 + 8);
        }
        unsigned int v18 = (llvm *)((char *)v18 + 16);
        v17 -= 16;
      }
      while (v17);
    }
    llvm::deallocate_buffer(v4, v16);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v20 = *(unsigned int *)(a1 + 16);
  if (v20)
  {
    if (((v20 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_23;
    }
    uint64_t v21 = ((v20 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    int v10 = &result[2 * (v21 & 0x1FFFFFFFFFFFFFFELL)];
    int v22 = result + 2;
    uint64_t v23 = v21 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v22 - 2) = -4096;
      *int v22 = -4096;
      v22 += 4;
      v23 -= 2;
    }
    while (v23);
    if (v21 != (v21 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_23:
      uint64_t v24 = &result[2 * v20];
      do
      {
        *int v10 = -4096;
        v10 += 2;
      }
      while (v10 != v24);
    }
  }
  return result;
}

uint64_t llvm::SmallVectorTemplateBase<std::unique_ptr<mlir::DataFlowAnalysis>,false>::growAndEmplaceBack<mlir::dataflow::DeadCodeAnalysis *>(uint64_t a1, void *a2)
{
  unint64_t v27 = 0;
  uint64_t v4 = (char *)(a1 + 16);
  unint64_t v5 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), 0, 8, &v27);
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  uint64_t v7 = 8 * v6;
  *(void *)&v5[8 * v6] = *a2;
  unsigned int v8 = *(char **)a1;
  int v9 = *(char **)a1;
  if (!v6) {
    goto LABEL_19;
  }
  unint64_t v10 = (v6 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v10 < 0xB)
  {
    uint64_t v11 = v5;
LABEL_12:
    uint64_t v20 = &v8[v7];
    do
    {
      uint64_t v21 = *(void *)v9;
      *(void *)int v9 = 0;
      v9 += 8;
      *(void *)uint64_t v11 = v21;
      v11 += 8;
    }
    while (v9 != v20);
    goto LABEL_14;
  }
  BOOL v12 = v8 >= &v5[v7] || v5 >= &v8[v7];
  uint64_t v11 = v5;
  if (!v12) {
    goto LABEL_12;
  }
  unint64_t v13 = v10 + 1;
  uint64_t v14 = 8 * (v13 & 0x3FFFFFFFFFFFFFFCLL);
  uint64_t v11 = &v5[v14];
  int v9 = &v8[v14];
  uint64_t v15 = (long long *)(v8 + 16);
  int v16 = v5 + 16;
  uint64_t v17 = v13 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v18 = *(v15 - 1);
    long long v19 = *v15;
    *(v15 - 1) = 0uLL;
    *uint64_t v15 = 0uLL;
    *(v16 - 1) = v18;
    _OWORD *v16 = v19;
    v15 += 2;
    v16 += 2;
    v17 -= 4;
  }
  while (v17);
  if (v13 != (v13 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_12;
  }
LABEL_14:
  uint64_t v22 = *(void *)a1 - 8;
  do
  {
    uint64_t v23 = *(void *)(v22 + v7);
    *(void *)(v22 + v7) = 0;
    if (v23) {
      (*(void (**)(uint64_t))(*(void *)v23 + 8))(v23);
    }
    v7 -= 8;
  }
  while (v7);
  int v9 = *(char **)a1;
LABEL_19:
  int v24 = v27;
  if (v9 != v4) {
    free(v9);
  }
  *(void *)a1 = v5;
  unsigned int v25 = *(_DWORD *)(a1 + 8) + 1;
  *(_DWORD *)(a1 + 8) = v25;
  *(_DWORD *)(a1 + 12) = v24;
  return (uint64_t)&v5[8 * v25 - 8];
}

uint64_t mlir::Pass::initialize(mlir::Pass *this, MLIRContext *a2)
{
  return 1;
}

BOOL mlir::OperationPass<mlir::func::FuncOp>::canScheduleOn(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t AttrData = (const void *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v6);
  if (!*(unsigned char *)(a1 + 32) || v4 != *(void *)(a1 + 24)) {
    return 0;
  }
  if (v4) {
    return memcmp(AttrData, *(const void **)(a1 + 16), v4) == 0;
  }
  return 1;
}

BOOL llvm::cl::OptionValueCopy<long long>::compare(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 16) && *(unsigned char *)(a1 + 16) && *(void *)(a1 + 8) == *(void *)(a2 + 8);
}

uint64_t std::__throw_bad_function_call[abi:nn180100]()
{
  return mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::handleOccurrence();
}

BOOL mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::handleOccurrence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6)
{
  if (*(unsigned char *)(a1 + 176))
  {
    *(void *)(a1 + 192) = *(void *)(a1 + 184);
    uint64_t v11 = *(void *)(a1 + 128);
    for (uint64_t i = *(void *)(a1 + 136); i != v11; i -= 24)
    {
      if (*(char *)(i - 1) < 0) {
        operator delete(*(void **)(i - 24));
      }
    }
    *(void *)(a1 + 136) = v11;
    *(unsigned char *)(a1 + 176) = 0;
  }
  *(unsigned char *)(a1 + 256) = 1;
  uint64_t v14 = a1;
  v15[0] = a1 + 264;
  v16[0] = a3;
  v16[1] = a4;
  v15[1] = a1;
  _OWORD v15[2] = v16;
  v15[3] = &v14;
  return mlir::detail::pass_options::parseCommaSeparatedList(a1, a3, a4, a5, a6, (uint64_t (*)(uint64_t, uint64_t, unint64_t))llvm::function_ref<mlir::LogicalResult ()(llvm::StringRef)>::callback_fn<mlir::LogicalResult mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<std::string>,mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(std::string const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<std::string> &,mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(std::string const&)#1} &&)::{lambda(llvm::StringRef)#1}>, (uint64_t)v15) == 0;
}

uint64_t llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::getValueExpectedFlagDefault()
{
  return 2;
}

void mlir::Pass::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(void *a1)
{
  uint64_t v1 = llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list(a1);

  operator delete(v1);
}

uint64_t llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::getOptionWidth(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 208, a1);
}

llvm::raw_ostream *llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::printOptionInfo(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 208), (const llvm::cl::Option *)a1, a2);
}

void llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::setDefault(void *a1)
{
  uint64_t v2 = (uint64_t)(a1 + 16);
  uint64_t v3 = (std::string *)a1[16];
  a1[24] = a1[23];
  for (uint64_t i = (std::string *)a1[17]; i != v3; --i)
  {
    if (SHIBYTE(i[-1].__r_.__value_.__r.__words[2]) < 0) {
      operator delete(i[-1].__r_.__value_.__l.__data_);
    }
  }
  a1[17] = v3;
  uint64_t v5 = a1[19];
  uint64_t v6 = a1[20];
  while (v5 != v6)
  {
    uint64_t v7 = (long long *)(v5 + 8);
    if ((unint64_t)v3 >= a1[18])
    {
      uint64_t v3 = std::vector<std::string>::__push_back_slow_path<std::string const&>(v2, (uint64_t)v7);
    }
    else
    {
      if (*(char *)(v5 + 31) < 0)
      {
        std::string::__init_copy_ctor_external(v3, *(const std::string::value_type **)(v5 + 8), *(void *)(v5 + 16));
      }
      else
      {
        long long v8 = *v7;
        v3->__r_.__value_.__r.__words[2] = *(void *)(v5 + 24);
        *(_OWORD *)&v3->__r_.__value_.__l.__data_ = v8;
      }
      ++v3;
    }
    a1[17] = v3;
    v5 += 40;
  }
}

llvm::raw_ostream *mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::print(llvm::raw_ostream *result, llvm::raw_ostream *this)
{
  if (*((void *)result + 17) != *((void *)result + 16))
  {
    uint64_t v3 = result;
    size_t v4 = (const void *)*((void *)result + 2);
    size_t v5 = *((void *)result + 3);
    uint64_t result = (llvm::raw_ostream *)*((void *)this + 4);
    if (v5 <= *((void *)this + 3) - (void)result)
    {
      if (v5)
      {
        memcpy(result, v4, v5);
        uint64_t result = (llvm::raw_ostream *)(*((void *)this + 4) + v5);
        *((void *)this + 4) = result;
      }
      uint64_t v6 = this;
    }
    else
    {
      uint64_t v6 = llvm::raw_ostream::write(this, (const char *)v4, v5);
      uint64_t result = (llvm::raw_ostream *)*((void *)v6 + 4);
    }
    if ((unint64_t)result >= *((void *)v6 + 3))
    {
      uint64_t result = llvm::raw_ostream::write(v6, 61);
    }
    else
    {
      *((void *)v6 + 4) = (char *)result + 1;
      *(unsigned char *)uint64_t result = 61;
    }
    uint64_t v8 = *((void *)v3 + 16);
    uint64_t v7 = *((void *)v3 + 17);
    if (v8 != v7)
    {
      int v9 = *(char *)(v8 + 23);
      unint64_t v10 = v9 >= 0 ? (const char *)*((void *)v3 + 16) : *(const char **)v8;
      size_t v11 = v9 >= 0 ? *(unsigned __int8 *)(v8 + 23) : *(void *)(v8 + 8);
      uint64_t result = llvm::raw_ostream::write(this, v10, v11);
      for (uint64_t i = v8 + 24; i != v7; i += 24)
      {
        int v16 = (unsigned char *)*((void *)this + 4);
        if (*((unsigned char **)this + 3) == v16)
        {
          llvm::raw_ostream::write(this, ",", 1uLL);
        }
        else
        {
          unsigned char *v16 = 44;
          ++*((void *)this + 4);
        }
        int v13 = *(char *)(i + 23);
        if (v13 >= 0) {
          uint64_t v14 = (const char *)i;
        }
        else {
          uint64_t v14 = *(const char **)i;
        }
        if (v13 >= 0) {
          size_t v15 = *(unsigned __int8 *)(i + 23);
        }
        else {
          size_t v15 = *(void *)(i + 8);
        }
        uint64_t result = llvm::raw_ostream::write(this, v14, v15);
      }
    }
  }
  return result;
}

void mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 256) = 1;
  *(unsigned char *)(a1 + 256) = *(unsigned char *)(a2 + 8);
}

void *non-virtual thunk to'mlir::Pass::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(uint64_t a1)
{
  return llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list((void *)(a1 - 248));
}

void non-virtual thunk to'mlir::Pass::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(uint64_t a1)
{
  uint64_t v1 = llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list((void *)(a1 - 248));

  operator delete(v1);
}

llvm::raw_ostream *non-virtual thunk to'mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  return mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::print((llvm::raw_ostream *)(a1 - 248), a2);
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::getOption(uint64_t a1)
{
  return a1 - 248;
}

void non-virtual thunk to'mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::copyValueFrom(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a1 + 8) = 1;
  *(unsigned char *)(a1 + 8) = *(unsigned char *)(a2 + 8);
}

void mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(void *a1)
{
  uint64_t v1 = llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list(a1);

  operator delete(v1);
}

void *non-virtual thunk to'mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(uint64_t a1)
{
  return llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list((void *)(a1 - 248));
}

void non-virtual thunk to'mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::~ListOption(uint64_t a1)
{
  uint64_t v1 = llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list((void *)(a1 - 248));

  operator delete(v1);
}

uint64_t llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::handleOccurrence(uint64_t a1, int a2, int a3, int a4, void *__src, size_t __len)
{
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v41 = 0;
  if (*(unsigned char *)(a1 + 176))
  {
    *(void *)(a1 + 192) = *(void *)(a1 + 184);
    uint64_t v10 = *(void *)(a1 + 128);
    for (uint64_t i = *(void *)(a1 + 136); i != v10; i -= 24)
    {
      if (*(char *)(i - 1) < 0) {
        operator delete(*(void **)(i - 24));
      }
    }
    *(void *)(a1 + 136) = v10;
    *(unsigned char *)(a1 + 176) = 0;
  }
  if (!__src)
  {
    long long __dst = 0uLL;
    unint64_t v43 = 0;
    goto LABEL_20;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    goto LABEL_51;
  }
  if (__len >= 0x17)
  {
    size_t v13 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v13 = __len | 7;
    }
    size_t v14 = v13 + 1;
    p_dst = (long long *)operator new(v13 + 1);
    *((void *)&__dst + 1) = __len;
    unint64_t v43 = v14 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_17;
  }
  HIBYTE(v43) = __len;
  p_dst = &__dst;
  if (__len) {
LABEL_17:
  }
    memmove(p_dst, __src, __len);
  *((unsigned char *)p_dst + __len) = 0;
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[0]);
  }
LABEL_20:
  *(_OWORD *)std::string __p = __dst;
  unint64_t v41 = v43;
  unint64_t v15 = *(void *)(a1 + 136);
  if (v15 >= *(void *)(a1 + 144))
  {
    uint64_t v17 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a1 + 128, (uint64_t)__p);
  }
  else
  {
    if (SHIBYTE(v41) < 0)
    {
      std::string::__init_copy_ctor_external(*(std::string **)(a1 + 136), (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
    }
    else
    {
      long long v16 = *(_OWORD *)__p;
      *(void *)(v15 + 16) = v41;
      *(_OWORD *)unint64_t v15 = v16;
    }
    uint64_t v17 = (std::string *)(v15 + 24);
  }
  *(void *)(a1 + 136) = v17;
  *(_WORD *)(a1 + 12) = a2;
  long long v19 = *(char **)(a1 + 192);
  unint64_t v18 = *(void *)(a1 + 200);
  if ((unint64_t)v19 >= v18)
  {
    uint64_t v21 = *(char **)(a1 + 184);
    uint64_t v22 = (v19 - v21) >> 2;
    unint64_t v23 = v22 + 1;
    if (!((unint64_t)(v22 + 1) >> 62))
    {
      uint64_t v24 = v18 - (void)v21;
      if (v24 >> 1 > v23) {
        unint64_t v23 = v24 >> 1;
      }
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL) {
        unint64_t v25 = 0x3FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v25 = v23;
      }
      if (v25)
      {
        if (v25 >> 62) {
          goto LABEL_53;
        }
        unint64_t v26 = operator new(4 * v25);
      }
      else
      {
        unint64_t v26 = 0;
      }
      unint64_t v27 = &v26[4 * v22];
      unint64_t v28 = &v26[4 * v25];
      *unint64_t v27 = a2;
      uint64_t v20 = v27 + 1;
      if (v19 != v21)
      {
        unint64_t v29 = v19 - v21 - 4;
        if (v29 < 0x2C) {
          goto LABEL_56;
        }
        if ((unint64_t)(v21 - v26) < 0x20) {
          goto LABEL_56;
        }
        uint64_t v30 = (v29 >> 2) + 1;
        uint64_t v31 = 4 * (v30 & 0x7FFFFFFFFFFFFFF8);
        uint64_t v32 = &v19[-v31];
        unint64_t v27 = (_DWORD *)((char *)v27 - v31);
        long long v33 = &v26[4 * v22 - 16];
        uint64_t v34 = v19 - 16;
        uint64_t v35 = v30 & 0x7FFFFFFFFFFFFFF8;
        do
        {
          long long v36 = *(_OWORD *)v34;
          *(v33 - 1) = *((_OWORD *)v34 - 1);
          _OWORD *v33 = v36;
          v33 -= 2;
          v34 -= 32;
          v35 -= 8;
        }
        while (v35);
        long long v19 = v32;
        if (v30 != (v30 & 0x7FFFFFFFFFFFFFF8))
        {
LABEL_56:
          do
          {
            int v37 = *((_DWORD *)v19 - 1);
            v19 -= 4;
            *--unint64_t v27 = v37;
          }
          while (v19 != v21);
        }
      }
      *(void *)(a1 + 184) = v27;
      *(void *)(a1 + 192) = v20;
      *(void *)(a1 + 200) = v28;
      if (v21) {
        operator delete(v21);
      }
      goto LABEL_47;
    }
LABEL_51:
    abort();
  }
  *(_DWORD *)long long v19 = a2;
  uint64_t v20 = v19 + 4;
LABEL_47:
  *(void *)(a1 + 192) = v20;
  uint64_t v38 = *(void *)(a1 + 240);
  if (!v38)
  {
    std::__throw_bad_function_call[abi:nn180100]();
LABEL_53:
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  (*(void (**)(uint64_t, void **))(*(void *)v38 + 48))(v38, __p);
  if (SHIBYTE(v41) < 0) {
    operator delete(__p[0]);
  }
  return 0;
}

void llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list(void *a1)
{
  uint64_t v1 = llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list(a1);

  operator delete(v1);
}

void *std::__function::__func<llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::__clone()
{
  uint64_t result = operator new(0x10uLL);
  *uint64_t result = &unk_1EC9CE8A8;
  return result;
}

void std::__function::__func<llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1},std::allocator<llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::{lambda(std::string const&)#1}>,void ()(std::string const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9CE8A8;
}

std::string *std::vector<std::string>::__push_back_slow_path<std::string const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void ***)a1;
  uint64_t v3 = *(void ***)(a1 + 8);
  unint64_t v4 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v3 - *(void *)a1) >> 3);
  unint64_t v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL) {
    abort();
  }
  if (0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3) > v5) {
    unint64_t v5 = 0x5555555555555556 * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3);
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(void *)(a1 + 16) - (void)v2) >> 3) >= 0x555555555555555) {
    unint64_t v8 = 0xAAAAAAAAAAAAAAALL;
  }
  else {
    unint64_t v8 = v5;
  }
  if (v8)
  {
    if (v8 > 0xAAAAAAAAAAAAAAALL) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int v9 = (char *)operator new(24 * v8);
  }
  else
  {
    int v9 = 0;
  }
  uint64_t v10 = (std::string *)&v9[24 * v4];
  if (*(char *)(a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v10, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
    uint64_t v2 = *(void ***)a1;
    uint64_t v3 = *(void ***)(a1 + 8);
  }
  else
  {
    *(_OWORD *)&v10->__r_.__value_.__l.__data_ = *(_OWORD *)a2;
    v10->__r_.__value_.__r.__words[2] = *(void *)(a2 + 16);
  }
  size_t v11 = &v9[24 * v8];
  BOOL v12 = v10 + 1;
  if (v3 == v2)
  {
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
  }
  else
  {
    do
    {
      long long v13 = *(_OWORD *)(v3 - 3);
      v10[-1].__r_.__value_.__r.__words[2] = (std::string::size_type)*(v3 - 1);
      *(_OWORD *)&v10[-1].__r_.__value_.__l.__data_ = v13;
      --v10;
      *(v3 - 2) = 0;
      *(v3 - 1) = 0;
      *(v3 - 3) = 0;
      v3 -= 3;
    }
    while (v3 != v2);
    uint64_t v2 = *(void ***)a1;
    size_t v14 = *(void ***)(a1 + 8);
    *(void *)a1 = v10;
    *(void *)(a1 + 8) = v12;
    *(void *)(a1 + 16) = v11;
    while (v14 != v2)
    {
      if (*((char *)v14 - 1) < 0) {
        operator delete(*(v14 - 3));
      }
      v14 -= 3;
    }
  }
  if (v2) {
    operator delete(v2);
  }
  return v12;
}

uint64_t llvm::cl::OptionValueCopy<std::string>::compare(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(a2 + 32) || !*(unsigned char *)(a1 + 32)) {
    return 0;
  }
  uint64_t v2 = *(unsigned __int8 *)(a1 + 31);
  if ((v2 & 0x80u) == 0) {
    uint64_t v3 = *(unsigned __int8 *)(a1 + 31);
  }
  else {
    uint64_t v3 = *(void *)(a1 + 16);
  }
  uint64_t v4 = *(unsigned __int8 *)(a2 + 31);
  int v5 = (char)v4;
  if ((v4 & 0x80u) != 0) {
    uint64_t v4 = *(void *)(a2 + 16);
  }
  if (v3 != v4) {
    return 0;
  }
  uint64_t v6 = (const void **)(a1 + 8);
  if (v5 >= 0) {
    uint64_t v7 = (unsigned __int8 *)(a2 + 8);
  }
  else {
    uint64_t v7 = *(unsigned __int8 **)(a2 + 8);
  }
  if ((v2 & 0x80) != 0) {
    return memcmp(*v6, v7, *(void *)(a1 + 16)) == 0;
  }
  if (!*(unsigned char *)(a1 + 31)) {
    return 1;
  }
  uint64_t v8 = v2 - 1;
  do
  {
    int v10 = *(unsigned __int8 *)v6;
    uint64_t v6 = (const void **)((char *)v6 + 1);
    int v9 = v10;
    int v12 = *v7++;
    int v11 = v12;
    BOOL v14 = v8-- != 0;
    uint64_t result = v9 == v11;
  }
  while (v9 == v11 && v14);
  return result;
}

void *llvm::cl::list<std::string,BOOL,llvm::cl::parser<std::string>>::~list(void *a1)
{
  *a1 = &unk_1EC9A41D8;
  uint64_t v2 = a1 + 27;
  uint64_t v3 = (void *)a1[30];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
    uint64_t v4 = (void *)a1[23];
    if (v4)
    {
LABEL_5:
      a1[24] = v4;
      operator delete(v4);
    }
  }
  else
  {
    if (v3) {
      (*(void (**)(void *))(*v3 + 40))(v3);
    }
    uint64_t v4 = (void *)a1[23];
    if (v4) {
      goto LABEL_5;
    }
  }
  uint64_t v5 = a1[19];
  if (v5)
  {
    uint64_t v6 = a1[20];
    uint64_t v7 = (void *)a1[19];
    if (v6 != v5)
    {
      uint64_t v8 = v6 - 40;
      uint64_t v9 = a1[20];
      do
      {
        *(void *)(v9 - 40) = &unk_1EC9A3BA0;
        v9 -= 40;
        if (*(char *)(v9 + 31) < 0) {
          operator delete(*(void **)(v6 - 32));
        }
        v8 -= 40;
        uint64_t v6 = v9;
      }
      while (v9 != v5);
      uint64_t v7 = (void *)a1[19];
    }
    a1[20] = v5;
    operator delete(v7);
  }
  uint64_t v10 = a1[16];
  if (v10)
  {
    uint64_t v11 = a1[17];
    int v12 = (void *)a1[16];
    if (v11 != v10)
    {
      do
      {
        if (*(char *)(v11 - 1) < 0) {
          operator delete(*(void **)(v11 - 24));
        }
        v11 -= 24;
      }
      while (v11 != v10);
      int v12 = (void *)a1[16];
    }
    a1[17] = v10;
    operator delete(v12);
  }
  *a1 = &unk_1EC9A42A8;
  long long v13 = (void *)a1[12];
  if (v13 != (void *)a1[11]) {
    free(v13);
  }
  BOOL v14 = (void *)a1[8];
  if (v14 != a1 + 10) {
    free(v14);
  }
  return a1;
}

uint64_t mlir::detail::pass_options::parseCommaSeparatedList<llvm::cl::parser<std::string>,mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(std::string const&)#1}>(llvm::cl::Option &,llvm::StringRef,llvm::StringRef,llvm::cl::parser<std::string> &,mlir::detail::PassOptions::ListOption<std::string,llvm::cl::parser<std::string>>::handleOccurrence(unsigned int,llvm::StringRef,llvm::StringRef)::{lambda(std::string const&)#1} &&)::{lambda(llvm::StringRef)#1}::operator()(uint64_t a1, void *__src, size_t __len)
{
  __p[0] = 0;
  __p[1] = 0;
  unint64_t v17 = 0;
  if (!__src)
  {
    long long __dst = 0uLL;
    unint64_t v19 = 0;
    goto LABEL_13;
  }
  if (__len >= 0x7FFFFFFFFFFFFFF8) {
    abort();
  }
  if (__len >= 0x17)
  {
    size_t v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17) {
      size_t v7 = __len | 7;
    }
    size_t v8 = v7 + 1;
    p_dst = (long long *)operator new(v7 + 1);
    *((void *)&__dst + 1) = __len;
    unint64_t v19 = v8 | 0x8000000000000000;
    *(void *)&long long __dst = p_dst;
    goto LABEL_10;
  }
  HIBYTE(v19) = __len;
  p_dst = &__dst;
  if (__len) {
LABEL_10:
  }
    memmove(p_dst, __src, __len);
  *((unsigned char *)p_dst + __len) = 0;
  if (SHIBYTE(v17) < 0) {
    operator delete(__p[0]);
  }
LABEL_13:
  *(_OWORD *)std::string __p = __dst;
  unint64_t v17 = v19;
  uint64_t v9 = **(void **)(a1 + 24);
  unint64_t v10 = *(void *)(v9 + 136);
  if (v10 >= *(void *)(v9 + 144))
  {
    long long v13 = std::vector<std::string>::__push_back_slow_path<std::string const&>(v9 + 128, (uint64_t)__p);
    char v14 = HIBYTE(v17);
    *(void *)(v9 + 136) = v13;
    if (v14 < 0) {
LABEL_17:
    }
      operator delete(__p[0]);
  }
  else
  {
    char v11 = HIBYTE(v17);
    if (SHIBYTE(v17) < 0)
    {
      std::string::__init_copy_ctor_external(*(std::string **)(v9 + 136), (const std::string::value_type *)__p[0], (std::string::size_type)__p[1]);
    }
    else
    {
      long long v12 = *(_OWORD *)__p;
      *(void *)(v10 + 16) = v17;
      *(_OWORD *)unint64_t v10 = v12;
    }
    *(void *)(v9 + 136) = v10 + 24;
    if (v11 < 0) {
      goto LABEL_17;
    }
  }
  return 1;
}

void std::vector<std::string>::__assign_with_size[abi:nn180100]<std::string const*,std::string const*>(uint64_t a1, std::string *__str, std::string *a3, size_t __sz)
{
  uint64_t v6 = __str;
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(std::string **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(void *)a1) >> 3) >= __sz)
  {
    long long v12 = *(std::string **)(a1 + 8);
    if (0xAAAAAAAAAAAAAAABLL * (((char *)v12 - (char *)v9) >> 3) >= __sz)
    {
      if (__str == a3)
      {
        unint64_t v18 = *(std::string **)a1;
      }
      else
      {
        unint64_t v18 = *(std::string **)a1;
        do
        {
          std::string::operator=(v9++, v6++);
          ++v18;
        }
        while (v6 != a3);
        long long v12 = *(std::string **)(a1 + 8);
      }
      while (v12 != v18)
      {
        if (SHIBYTE(v12[-1].__r_.__value_.__r.__words[2]) < 0) {
          operator delete(v12[-1].__r_.__value_.__l.__data_);
        }
        --v12;
      }
      *(void *)(a1 + 8) = v18;
    }
    else
    {
      long long v13 = (std::string *)((char *)__str + 8 * (((char *)v12 - (char *)v9) >> 3));
      if (v12 != v9)
      {
        uint64_t v14 = 8 * (((char *)v12 - (char *)v9) >> 3);
        do
        {
          std::string::operator=(v9++, v6++);
          v14 -= 24;
        }
        while (v14);
        uint64_t v9 = *(std::string **)(a1 + 8);
      }
      unint64_t v15 = v9;
      if (v13 != a3)
      {
        unint64_t v15 = v9;
        long long v16 = v9;
        do
        {
          if (SHIBYTE(v13->__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::__init_copy_ctor_external(v16, v13->__r_.__value_.__l.__data_, v13->__r_.__value_.__l.__size_);
          }
          else
          {
            long long v17 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
            v16->__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v16->__r_.__value_.__l.__data_ = v17;
          }
          ++v13;
          ++v16;
          ++v15;
        }
        while (v13 != a3);
      }
      *(void *)(a1 + 8) = v15;
    }
  }
  else
  {
    if (v9)
    {
      unint64_t v10 = *(std::string **)(a1 + 8);
      char v11 = *(std::string **)a1;
      if (v10 != v9)
      {
        do
        {
          if (SHIBYTE(v10[-1].__r_.__value_.__r.__words[2]) < 0) {
            operator delete(v10[-1].__r_.__value_.__l.__data_);
          }
          --v10;
        }
        while (v10 != v9);
        char v11 = *(std::string **)a1;
      }
      *(void *)(a1 + 8) = v9;
      operator delete(v11);
      uint64_t v8 = 0;
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
    }
    if (__sz > 0xAAAAAAAAAAAAAAALL) {
      goto LABEL_46;
    }
    unint64_t v19 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 3);
    uint64_t v20 = 2 * v19;
    if (2 * v19 <= __sz) {
      uint64_t v20 = __sz;
    }
    unint64_t v21 = v19 >= 0x555555555555555 ? 0xAAAAAAAAAAAAAAALL : v20;
    if (v21 > 0xAAAAAAAAAAAAAAALL) {
LABEL_46:
    }
      abort();
    uint64_t v22 = v21;
    unint64_t v23 = (std::string *)operator new(24 * v21);
    *(void *)a1 = v23;
    *(void *)(a1 + 8) = v23;
    *(void *)(a1 + 16) = &v23[v22];
    while (v6 != a3)
    {
      if (SHIBYTE(v6->__r_.__value_.__r.__words[2]) < 0)
      {
        std::string::__init_copy_ctor_external(v23, v6->__r_.__value_.__l.__data_, v6->__r_.__value_.__l.__size_);
      }
      else
      {
        *(_OWORD *)&v23->__r_.__value_.__l.__data_ = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
        v23->__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
      }
      ++v6;
      ++v23;
    }
    *(void *)(a1 + 8) = v23;
  }
}

void *mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::Option<llvm::cl::desc,llvm::cl::initializer<int>>(void *a1, void *a2, uint64_t a3, uint64_t a4, __n128 *a5, int **a6)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  v31[0] = a3;
  v31[1] = a4;
  v34[0] = a2;
  uint64_t v8 = llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>((uint64_t)a1, (uint64_t)v31, v34, a5, a6);
  uint64_t v9 = v8 + 200;
  *(unsigned char *)(v8 + 208) = 0;
  *(void *)uint64_t v8 = &unk_1EC9CCF88;
  *(void *)(v8 + 200) = &unk_1EC9CD008;
  char v11 = (uint64_t *)a2[21];
  unint64_t v10 = a2[22];
  long long v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v14 = (uint64_t *)a2[20];
    uint64_t v15 = v11 - v14;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      abort();
    }
    uint64_t v17 = v10 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v19 = (char *)operator new(8 * v18);
    }
    else
    {
      unint64_t v19 = 0;
    }
    uint64_t v20 = (uint64_t *)&v19[8 * v15];
    unint64_t v21 = &v19[8 * v18];
    *uint64_t v20 = v9;
    long long v13 = v20 + 1;
    if (v11 != v14)
    {
      unint64_t v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v14 - v19) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      long long v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      uint64_t v20 = (uint64_t *)((char *)v20 - v24);
      unint64_t v25 = &v19[8 * v15 - 16];
      unint64_t v26 = v11 - 2;
      uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)unint64_t v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v29 = *--v12;
          *--uint64_t v20 = v29;
        }
        while (v12 != v14);
      }
      long long v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    *char v11 = v9;
    long long v13 = v11 + 1;
  }
  a2[21] = v13;
  v32[0] = &unk_1EC9CFA18;
  v32[1] = a1;
  uint64_t v35 = v34;
  long long v33 = v32;
  v34[0] = &unk_1EC9CFA18;
  v34[1] = a1;
  std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](v34, a1 + 21);
  if (v35 == v34)
  {
    (*((void (**)(const void **))v34[0] + 4))(v34);
  }
  else if (v35)
  {
    (*((void (**)(void))*v35 + 5))();
  }
  if (v33 == v32)
  {
    (*(void (**)(void *))(v32[0] + 32))(v32);
  }
  else if (v33)
  {
    (*(void (**)(void))(*v33 + 40))();
  }
  return a1;
}

uint64_t llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::handleOccurrence(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4, char *a5, uint64_t a6)
{
  uint64_t v11 = 0;
  uint64_t v8 = llvm::cl::parser<long long>::parse(a1 + 160, (void *)a1, a3, a4, a5, a6, &v11);
  if (v8) {
    return v8;
  }
  *(void *)(a1 + 128) = v11;
  *(_WORD *)(a1 + 12) = a2;
  uint64_t v9 = *(void *)(a1 + 192);
  if (v9)
  {
    (*(void (**)(uint64_t, uint64_t *))(*(void *)v9 + 48))(v9, &v11);
    return v8;
  }
  std::__throw_bad_function_call[abi:nn180100]();
  return llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::getValueExpectedFlagDefault();
}

uint64_t llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::getValueExpectedFlagDefault()
{
  return 2;
}

void *mlir::Pass::Option<long long,llvm::cl::parser<long long>>::~Option(void *a1)
{
  *a1 = &unk_1EC9A4038;
  uint64_t v2 = a1 + 21;
  uint64_t v3 = (void *)a1[24];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_1EC9A42A8;
  uint64_t v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  uint64_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void mlir::Pass::Option<long long,llvm::cl::parser<long long>>::~Option(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A4038;
  uint64_t v2 = __p + 168;
  uint64_t v3 = (char *)*((void *)__p + 24);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)std::string __p = &unk_1EC9A42A8;
  uint64_t v4 = (void *)*((void *)__p + 12);
  if (v4 != *((void **)__p + 11)) {
    free(v4);
  }
  uint64_t v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

uint64_t llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::getOptionWidth(uint64_t a1)
{
  return llvm::cl::basic_parser_impl::getOptionWidth(a1 + 160, a1);
}

llvm::raw_ostream *llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::printOptionInfo(uint64_t a1, unsigned int a2)
{
  return llvm::cl::basic_parser_impl::printOptionInfo((llvm::cl::basic_parser_impl *)(a1 + 160), (const llvm::cl::Option *)a1, a2);
}

void llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::printOptionValue(uint64_t a1, int a2, char a3)
{
  if ((a3 & 1) != 0 || !*(unsigned char *)(a1 + 152) || *(void *)(a1 + 144) != *(void *)(a1 + 128))
  {
    unint64_t v3 = *(void *)(a1 + 128);
    uint64_t v4 = *(void *)(a1 + 144);
    char v6 = *(unsigned char *)(a1 + 152);
    v5[0] = &unk_1EC9A3B20;
    v5[1] = v4;
    llvm::cl::parser<long long>::printOptionDiff((llvm *)(a1 + 160), a1, v3, (uint64_t)v5, a2);
  }
}

uint64_t llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::setDefault(uint64_t result)
{
  if (*(unsigned char *)(result + 152)) {
    *(void *)(result + 128) = *(void *)(result + 144);
  }
  else {
    *(void *)(result + 128) = 0;
  }
  return result;
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::print(void *a1, llvm::raw_ostream *this)
{
  uint64_t v4 = (const void *)a1[2];
  size_t v5 = a1[3];
  char v6 = (unsigned char *)*((void *)this + 4);
  if (v5 <= *((void *)this + 3) - (void)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      char v6 = (unsigned char *)(*((void *)this + 4) + v5);
      *((void *)this + 4) = v6;
    }
    size_t v7 = this;
  }
  else
  {
    size_t v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    char v6 = (unsigned char *)*((void *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((void *)v7 + 4) = v6 + 1;
    unsigned char *v6 = 61;
  }
  unint64_t v8 = a1[16];

  return llvm::raw_ostream::operator<<(this, v8);
}

uint64_t mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(void *)(result + 128) = *(void *)(a2 - 72);
  *(unsigned char *)(result + 208) = *(unsigned char *)(a2 + 8);
  return result;
}

void non-virtual thunk to'mlir::Pass::Option<long long,llvm::cl::parser<long long>>::~Option(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EC9A4038;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 200) = &unk_1EC9A42A8;
  uint64_t v4 = *(void **)(a1 - 104);
  if (v4 != *(void **)(a1 - 112)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 136);
  if (v5 != (void *)(a1 - 120)) {
    free(v5);
  }
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t vars8;

  uint64_t v2 = (void *)(a1 - 200);
  *(void *)(a1 - 200) = &unk_1EC9A4038;
  uint64_t v3 = a1 - 32;
  uint64_t v4 = *(void *)(a1 - 8);
  if (v4 == v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  *(void *)(a1 - 200) = &unk_1EC9A42A8;
  size_t v5 = *(void **)(a1 - 104);
  if (v5 != *(void **)(a1 - 112)) {
    free(v5);
  }
  char v6 = *(void **)(a1 - 136);
  if (v6 != (void *)(a1 - 120)) {
    free(v6);
  }

  operator delete(v2);
}

llvm::raw_ostream *non-virtual thunk to'mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  uint64_t v4 = *(const void **)(a1 - 184);
  size_t v5 = *(void *)(a1 - 176);
  char v6 = (unsigned char *)*((void *)this + 4);
  if (v5 <= *((void *)this + 3) - (void)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      char v6 = (unsigned char *)(*((void *)this + 4) + v5);
      *((void *)this + 4) = v6;
    }
    size_t v7 = this;
  }
  else
  {
    size_t v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    char v6 = (unsigned char *)*((void *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((void *)v7 + 4) = v6 + 1;
    unsigned char *v6 = 61;
  }
  unint64_t v8 = *(void *)(a1 - 72);

  return llvm::raw_ostream::operator<<(this, v8);
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::getOption(uint64_t a1)
{
  return a1 - 200;
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(void *)(result - 72) = *(void *)(a2 - 72);
  *(unsigned char *)(result + 8) = *(unsigned char *)(a2 + 8);
  return result;
}

uint64_t llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  unint64_t v10 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(void *)(a1 + 136) = &unk_1EC9A3B20;
  *(void *)a1 = &unk_1EC9A4038;
  *(void *)(a1 + 160) = &unk_1EC9A44A0;
  *(void *)(a1 + 168) = &unk_1EC9CE768;
  *(void *)(a1 + 192) = a1 + 168;
  llvm::cl::apply<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void *mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::~Option(void *a1)
{
  *a1 = &unk_1EC9A4038;
  uint64_t v2 = a1 + 21;
  uint64_t v3 = (void *)a1[24];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_1EC9A42A8;
  uint64_t v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  size_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::~Option(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A4038;
  uint64_t v2 = __p + 168;
  uint64_t v3 = (char *)*((void *)__p + 24);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)std::string __p = &unk_1EC9A42A8;
  uint64_t v4 = (void *)*((void *)__p + 12);
  if (v4 != *((void **)__p + 11)) {
    free(v4);
  }
  size_t v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

void non-virtual thunk to'mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::~Option(uint64_t a1)
{
  *(void *)(a1 - 200) = &unk_1EC9A4038;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 200) = &unk_1EC9A42A8;
  uint64_t v4 = *(void **)(a1 - 104);
  if (v4 != *(void **)(a1 - 112)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 136);
  if (v5 != (void *)(a1 - 120)) {
    free(v5);
  }
}

{
  mlir::detail::PassOptions::Option<long long,llvm::cl::parser<long long>>::~Option((char *)(a1 - 200));
}

__n128 llvm::cl::apply<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<int>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, int **a5)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  uint64_t v9 = *a3;
  uint64_t v10 = *(void *)(a1 + 96);
  if (v10 != *(void *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v9);
    goto LABEL_3;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 108);
  if (!v13)
  {
LABEL_12:
    if (v13 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v13 + 1;
      *(void *)(v10 + 8 * v13) = v9;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 8 * v13;
  unint64_t v16 = *(void **)(a1 + 96);
  while ((const void *)*v16 != v9)
  {
    if (*v16 == -2) {
      uint64_t v14 = v16;
    }
    ++v16;
    v15 -= 8;
    if (!v15)
    {
      if (!v14) {
        goto LABEL_12;
      }
      *uint64_t v14 = v9;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  uint64_t v12 = **a5;
  *(void *)(a1 + 128) = v12;
  *(unsigned char *)(a1 + 152) = 1;
  *(void *)(a1 + 144) = v12;
  return result;
}

void *llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::~opt(void *a1)
{
  *a1 = &unk_1EC9A4038;
  uint64_t v2 = a1 + 21;
  uint64_t v3 = (void *)a1[24];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_1EC9A42A8;
  uint64_t v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  size_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::~opt(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A4038;
  uint64_t v2 = __p + 168;
  uint64_t v3 = (char *)*((void *)__p + 24);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)std::string __p = &unk_1EC9A42A8;
  uint64_t v4 = (void *)*((void *)__p + 12);
  if (v4 != *((void **)__p + 11)) {
    free(v4);
  }
  size_t v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

void *std::__function::__func<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::{lambda(long long const&)#1},std::allocator<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::{lambda(long long const&)#1}>,void ()(long long const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EC9CE768;
  return result;
}

void std::__function::__func<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::{lambda(long long const&)#1},std::allocator<llvm::cl::opt<long long,false,llvm::cl::parser<long long>>::{lambda(long long const&)#1}>,void ()(long long const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9CE768;
}

void *std::__function::__value_func<void ()(long long const&)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    size_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EC9CFA18;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CFA18;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIxN4llvm2cl6parserIxEEEC1IJNS7_4descENS7_11initializerIiEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKxEEclESR_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 208) = 1;
  return result;
}

void *mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::Option<llvm::cl::desc,llvm::cl::initializer<BOOL>>(void *a1, void *a2, uint64_t a3, uint64_t a4, __n128 *a5, unsigned char **a6)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  v31[0] = a3;
  v31[1] = a4;
  v34[0] = a2;
  uint64_t v8 = llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<BOOL>>((uint64_t)a1, (uint64_t)v31, v34, a5, a6);
  uint64_t v9 = v8 + 192;
  *(unsigned char *)(v8 + 200) = 0;
  *(void *)uint64_t v8 = &unk_1EC9CCE08;
  *(void *)(v8 + 192) = &unk_1EC9CCE88;
  uint64_t v11 = (uint64_t *)a2[21];
  unint64_t v10 = a2[22];
  uint64_t v12 = v11;
  if ((unint64_t)v11 >= v10)
  {
    uint64_t v14 = (uint64_t *)a2[20];
    uint64_t v15 = v11 - v14;
    unint64_t v16 = v15 + 1;
    if ((unint64_t)(v15 + 1) >> 61) {
      abort();
    }
    uint64_t v17 = v10 - (void)v14;
    if (v17 >> 2 > v16) {
      unint64_t v16 = v17 >> 2;
    }
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v18 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v18 = v16;
    }
    if (v18)
    {
      if (v18 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v19 = (char *)operator new(8 * v18);
    }
    else
    {
      unint64_t v19 = 0;
    }
    uint64_t v20 = (uint64_t *)&v19[8 * v15];
    unint64_t v21 = &v19[8 * v18];
    *uint64_t v20 = v9;
    uint64_t v13 = v20 + 1;
    if (v11 != v14)
    {
      unint64_t v22 = (char *)v11 - (char *)v14 - 8;
      if (v22 < 0x58) {
        goto LABEL_36;
      }
      if ((unint64_t)((char *)v14 - v19) < 0x20) {
        goto LABEL_36;
      }
      uint64_t v23 = (v22 >> 3) + 1;
      uint64_t v24 = 8 * (v23 & 0x3FFFFFFFFFFFFFFCLL);
      uint64_t v12 = &v11[v24 / 0xFFFFFFFFFFFFFFF8];
      uint64_t v20 = (uint64_t *)((char *)v20 - v24);
      unint64_t v25 = &v19[8 * v15 - 16];
      unint64_t v26 = v11 - 2;
      uint64_t v27 = v23 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        long long v28 = *(_OWORD *)v26;
        *((_OWORD *)v25 - 1) = *((_OWORD *)v26 - 1);
        *(_OWORD *)unint64_t v25 = v28;
        v25 -= 32;
        v26 -= 4;
        v27 -= 4;
      }
      while (v27);
      if (v23 != (v23 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_36:
        do
        {
          uint64_t v29 = *--v12;
          *--uint64_t v20 = v29;
        }
        while (v12 != v14);
      }
      uint64_t v12 = (uint64_t *)a2[20];
    }
    a2[20] = v20;
    a2[21] = v13;
    a2[22] = v21;
    if (v12) {
      operator delete(v12);
    }
  }
  else
  {
    *uint64_t v11 = v9;
    uint64_t v13 = v11 + 1;
  }
  a2[21] = v13;
  v32[0] = &unk_1EC9CF8F8;
  v32[1] = a1;
  uint64_t v35 = v34;
  long long v33 = v32;
  v34[0] = &unk_1EC9CF8F8;
  v34[1] = a1;
  std::__function::__value_func<void ()(BOOL const&)>::swap[abi:nn180100](v34, a1 + 20);
  if (v35 == v34)
  {
    (*((void (**)(const void **))v34[0] + 4))(v34);
  }
  else if (v35)
  {
    (*((void (**)(void))*v35 + 5))();
  }
  if (v33 == v32)
  {
    (*(void (**)(void *))(v32[0] + 32))(v32);
  }
  else if (v33)
  {
    (*(void (**)(void))(*v33 + 40))();
  }
  return a1;
}

void *mlir::Pass::Option<BOOL,llvm::cl::parser<BOOL>>::~Option(void *a1)
{
  *a1 = &unk_1EC9A3F00;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_1EC9A42A8;
  uint64_t v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  size_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void mlir::Pass::Option<BOOL,llvm::cl::parser<BOOL>>::~Option(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A3F00;
  uint64_t v2 = __p + 160;
  uint64_t v3 = (char *)*((void *)__p + 23);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)std::string __p = &unk_1EC9A42A8;
  uint64_t v4 = (void *)*((void *)__p + 12);
  if (v4 != *((void **)__p + 11)) {
    free(v4);
  }
  size_t v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

llvm::raw_ostream *mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::print(uint64_t a1, llvm::raw_ostream *this)
{
  uint64_t v4 = *(const void **)(a1 + 16);
  size_t v5 = *(void *)(a1 + 24);
  char v6 = (unsigned char *)*((void *)this + 4);
  if (v5 <= *((void *)this + 3) - (void)v6)
  {
    if (v5)
    {
      memcpy(v6, v4, v5);
      char v6 = (unsigned char *)(*((void *)this + 4) + v5);
      *((void *)this + 4) = v6;
    }
    size_t v7 = this;
  }
  else
  {
    size_t v7 = llvm::raw_ostream::write(this, (const char *)v4, v5);
    char v6 = (unsigned char *)*((void *)v7 + 4);
  }
  if ((unint64_t)v6 >= *((void *)v7 + 3))
  {
    llvm::raw_ostream::write(v7, 61);
  }
  else
  {
    *((void *)v7 + 4) = v6 + 1;
    unsigned char *v6 = 61;
  }
  BOOL v8 = *(unsigned char *)(a1 + 128) == 0;
  if (*(unsigned char *)(a1 + 128)) {
    size_t v9 = 4;
  }
  else {
    size_t v9 = 5;
  }
  if (v8) {
    unint64_t v10 = "false";
  }
  else {
    unint64_t v10 = "true";
  }
  uint64_t v11 = (void *)*((void *)this + 4);
  if (v9 <= *((void *)this + 3) - (void)v11)
  {
    __n128 result = (llvm::raw_ostream *)memcpy(v11, v10, v9);
    *((void *)this + 4) += v9;
  }
  else
  {
    return llvm::raw_ostream::write(this, v10, v9);
  }
  return result;
}

uint64_t mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(result + 128) = *(unsigned char *)(a2 - 64);
  *(unsigned char *)(result + 200) = *(unsigned char *)(a2 + 8);
  return result;
}

void non-virtual thunk to'mlir::Pass::Option<BOOL,llvm::cl::parser<BOOL>>::~Option(uint64_t a1)
{
  *(void *)(a1 - 192) = &unk_1EC9A3F00;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 192) = &unk_1EC9A42A8;
  uint64_t v4 = *(void **)(a1 - 96);
  if (v4 != *(void **)(a1 - 104)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 128);
  if (v5 != (void *)(a1 - 112)) {
    free(v5);
  }
}

{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t vars8;

  uint64_t v2 = (void *)(a1 - 192);
  *(void *)(a1 - 192) = &unk_1EC9A3F00;
  uint64_t v3 = a1 - 32;
  uint64_t v4 = *(void *)(a1 - 8);
  if (v4 == v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 32))(v3);
  }
  else if (v4)
  {
    (*(void (**)(uint64_t))(*(void *)v4 + 40))(v4);
  }
  *(void *)(a1 - 192) = &unk_1EC9A42A8;
  size_t v5 = *(void **)(a1 - 96);
  if (v5 != *(void **)(a1 - 104)) {
    free(v5);
  }
  char v6 = *(void **)(a1 - 128);
  if (v6 != (void *)(a1 - 112)) {
    free(v6);
  }

  operator delete(v2);
}

llvm::raw_ostream *non-virtual thunk to'mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::print(uint64_t a1, llvm::raw_ostream *a2)
{
  return mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::print(a1 - 192, a2);
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::getOption(uint64_t a1)
{
  return a1 - 192;
}

uint64_t non-virtual thunk to'mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::copyValueFrom(uint64_t result, uint64_t a2)
{
  *(unsigned char *)(result - 64) = *(unsigned char *)(a2 - 64);
  *(unsigned char *)(result + 8) = *(unsigned char *)(a2 + 8);
  return result;
}

uint64_t llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::opt<llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<BOOL>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, unsigned char **a5)
{
  *(void *)a1 = &unk_1EC9A42A8;
  *(_WORD *)(a1 + 8) = 0;
  *(_WORD *)(a1 + 10) &= 0x8000u;
  unint64_t v10 = (void *)(a1 + 80);
  *(void *)(a1 + 64) = a1 + 80;
  uint64_t v11 = a1 + 64;
  *(_OWORD *)(a1 + 12) = 0u;
  *(_OWORD *)(a1 + 28) = 0u;
  *(_OWORD *)(a1 + 44) = 0u;
  *(_DWORD *)(a1 + 60) = 0;
  *(void *)(a1 + 72) = 0x100000000;
  *(void *)(a1 + 88) = a1 + 120;
  *(void *)(a1 + 96) = a1 + 120;
  *(void *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 112) = 0;
  GeneralCategory = llvm::cl::getGeneralCategory((llvm::cl *)a1);
  uint64_t v13 = *(unsigned int *)(a1 + 72);
  if (v13 >= *(_DWORD *)(a1 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v11, v10, v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 72);
  }
  *(void *)(*(void *)(a1 + 64) + 8 * v13) = GeneralCategory;
  ++*(_DWORD *)(a1 + 72);
  *(unsigned char *)(a1 + 128) = 0;
  *(void *)(a1 + 136) = &unk_1EC9A3AE0;
  *(void *)(a1 + 144) = 0;
  *(void *)a1 = &unk_1EC9A3F00;
  *(void *)(a1 + 152) = &unk_1EC9A4440;
  *(void *)(a1 + 160) = &unk_1EC9CE680;
  *(void *)(a1 + 184) = a1 + 160;
  llvm::cl::apply<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<BOOL>>(a1, a2, a3, a4, a5);
  llvm::cl::Option::addArgument((llvm::cl::Option *)a1);
  return a1;
}

void *mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::~Option(void *a1)
{
  *a1 = &unk_1EC9A3F00;
  uint64_t v2 = a1 + 20;
  uint64_t v3 = (void *)a1[23];
  if (v3 == v2)
  {
    (*(void (**)(void *))(*v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(void *))(*v3 + 40))(v3);
  }
  *a1 = &unk_1EC9A42A8;
  uint64_t v4 = (void *)a1[12];
  if (v4 != (void *)a1[11]) {
    free(v4);
  }
  size_t v5 = (void *)a1[8];
  if (v5 != a1 + 10) {
    free(v5);
  }
  return a1;
}

void mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::~Option(char *__p)
{
  *(void *)std::string __p = &unk_1EC9A3F00;
  uint64_t v2 = __p + 160;
  uint64_t v3 = (char *)*((void *)__p + 23);
  if (v3 == v2)
  {
    (*(void (**)(char *))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(char *))(*(void *)v3 + 40))(v3);
  }
  *(void *)std::string __p = &unk_1EC9A42A8;
  uint64_t v4 = (void *)*((void *)__p + 12);
  if (v4 != *((void **)__p + 11)) {
    free(v4);
  }
  size_t v5 = (char *)*((void *)__p + 8);
  if (v5 != __p + 80) {
    free(v5);
  }

  operator delete(__p);
}

void non-virtual thunk to'mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::~Option(uint64_t a1)
{
  *(void *)(a1 - 192) = &unk_1EC9A3F00;
  uint64_t v2 = a1 - 32;
  uint64_t v3 = *(void *)(a1 - 8);
  if (v3 == v2)
  {
    (*(void (**)(uint64_t))(*(void *)v2 + 32))(v2);
  }
  else if (v3)
  {
    (*(void (**)(uint64_t))(*(void *)v3 + 40))(v3);
  }
  *(void *)(a1 - 192) = &unk_1EC9A42A8;
  uint64_t v4 = *(void **)(a1 - 96);
  if (v4 != *(void **)(a1 - 104)) {
    free(v4);
  }
  size_t v5 = *(void **)(a1 - 128);
  if (v5 != (void *)(a1 - 112)) {
    free(v5);
  }
}

{
  mlir::detail::PassOptions::Option<BOOL,llvm::cl::parser<BOOL>>::~Option((char *)(a1 - 192));
}

__n128 llvm::cl::apply<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>,llvm::StringRef,llvm::cl::sub,llvm::cl::desc,llvm::cl::initializer<BOOL>>(uint64_t a1, uint64_t a2, const void **a3, __n128 *a4, unsigned char **a5)
{
  llvm::cl::Option::setArgStr(a1, *(int8x16_t **)a2, *(const unsigned __int8 **)(a2 + 8));
  size_t v9 = *a3;
  uint64_t v10 = *(void *)(a1 + 96);
  if (v10 != *(void *)(a1 + 88))
  {
LABEL_2:
    llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(a1 + 88), v9);
    goto LABEL_3;
  }
  uint64_t v13 = *(unsigned int *)(a1 + 108);
  if (!v13)
  {
LABEL_12:
    if (v13 < *(_DWORD *)(a1 + 104))
    {
      *(_DWORD *)(a1 + 108) = v13 + 1;
      *(void *)(v10 + 8 * v13) = v9;
      goto LABEL_3;
    }
    goto LABEL_2;
  }
  uint64_t v14 = 0;
  uint64_t v15 = 8 * v13;
  unint64_t v16 = *(void **)(a1 + 96);
  while ((const void *)*v16 != v9)
  {
    if (*v16 == -2) {
      uint64_t v14 = v16;
    }
    ++v16;
    v15 -= 8;
    if (!v15)
    {
      if (!v14) {
        goto LABEL_12;
      }
      *uint64_t v14 = v9;
      --*(_DWORD *)(a1 + 112);
      break;
    }
  }
LABEL_3:
  __n128 result = *a4;
  *(__n128 *)(a1 + 32) = *a4;
  uint64_t v12 = *a5;
  *(unsigned char *)(a1 + 128) = **a5;
  *(unsigned char *)(a1 + 145) = 1;
  *(unsigned char *)(a1 + 144) = *v12;
  return result;
}

BOOL llvm::cl::OptionValueCopy<BOOL>::compare(uint64_t a1, uint64_t a2)
{
  return *(unsigned char *)(a2 + 9) && *(unsigned char *)(a1 + 9) && *(unsigned __int8 *)(a1 + 8) == *(unsigned __int8 *)(a2 + 8);
}

void *std::__function::__func<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::{lambda(BOOL const&)#1},std::allocator<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::{lambda(BOOL const&)#1}>,void ()(BOOL const&)>::__clone()
{
  __n128 result = operator new(0x10uLL);
  *__n128 result = &unk_1EC9CE680;
  return result;
}

void std::__function::__func<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::{lambda(BOOL const&)#1},std::allocator<llvm::cl::opt<BOOL,false,llvm::cl::parser<BOOL>>::{lambda(BOOL const&)#1}>,void ()(BOOL const&)>::__clone(uint64_t a1, void *a2)
{
  *a2 = &unk_1EC9CE680;
}

void *std::__function::__value_func<void ()(BOOL const&)>::swap[abi:nn180100](void *result, void *a2)
{
  v6[3] = *MEMORY[0x1E4F143B8];
  if (a2 != result)
  {
    uint64_t v3 = result;
    uint64_t v4 = (void *)result[3];
    size_t v5 = (void *)a2[3];
    if (v4 == result)
    {
      if (v5 == a2)
      {
        (*(void (**)(void *, void *))(*result + 24))(result, v6);
        (*(void (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = 0;
        (*(void (**)(void, void *))(*(void *)a2[3] + 24))(a2[3], v3);
        (*(void (**)(void))(*(void *)a2[3] + 32))(a2[3]);
        a2[3] = 0;
        v3[3] = v3;
        (*(void (**)(void *, void *))(v6[0] + 24))(v6, a2);
        __n128 result = (void *)(*(uint64_t (**)(void *))(v6[0] + 32))(v6);
      }
      else
      {
        (*(void (**)(void *, void *))(*result + 24))(result, a2);
        __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)v3[3] + 32))(v3[3]);
        v3[3] = a2[3];
      }
      a2[3] = a2;
    }
    else if (v5 == a2)
    {
      (*(void (**)(void *, void *))(*a2 + 24))(a2, result);
      __n128 result = (void *)(*(uint64_t (**)(void))(*(void *)a2[3] + 32))(a2[3]);
      a2[3] = v3[3];
      v3[3] = v3;
    }
    else
    {
      result[3] = v5;
      a2[3] = v4;
    }
  }
  return result;
}

void *_ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIbN4llvm2cl6parserIbEEEC1IJNS7_4descENS7_11initializerIbEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKbEE7__cloneEv(uint64_t a1)
{
  __n128 result = operator new(0x10uLL);
  uint64_t v3 = *(void *)(a1 + 8);
  *__n128 result = &unk_1EC9CF8F8;
  result[1] = v3;
  return result;
}

uint64_t _ZNKSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIbN4llvm2cl6parserIbEEEC1IJNS7_4descENS7_11initializerIbEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKbEE7__cloneEPNS0_6__baseISS_EE(uint64_t result, void *a2)
{
  uint64_t v2 = *(void *)(result + 8);
  *a2 = &unk_1EC9CF8F8;
  a2[1] = v2;
  return result;
}

uint64_t _ZNSt3__110__function6__funcIZN4mlir6detail11PassOptions6OptionIbN4llvm2cl6parserIbEEEC1IJNS7_4descENS7_11initializerIbEEEEERS4_NS6_9StringRefEDpOT_EUlRKT_E_NS_9allocatorISN_EEFvRKbEEclESR_(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 8) + 200) = 1;
  return result;
}

void mlir::Pass::~Pass(mlir::Pass *this)
{
  *(void *)this = &unk_1EC9CB2A0;
  uint64_t v2 = (void *)*((void *)this + 39);
  if (v2)
  {
    *((void *)this + 40) = v2;
    operator delete(v2);
  }
  if (*((_DWORD *)this + 73))
  {
    uint64_t v3 = *((unsigned int *)this + 72);
    if (v3)
    {
      uint64_t v4 = 0;
      do
      {
        size_t v5 = *(llvm **)(*((void *)this + 35) + v4);
        if (v5 != (llvm *)-8 && v5 != 0) {
          llvm::deallocate_buffer(v5, (void *)(*(void *)v5 + 17));
        }
        v4 += 8;
      }
      while (8 * v3 != v4);
    }
  }
  free(*((void **)this + 35));
  size_t v7 = (char *)*((void *)this + 29);
  if (v7 != (char *)this + 248) {
    free(v7);
  }
  BOOL v8 = (char *)*((void *)this + 23);
  if (v8 != (char *)this + 200) {
    free(v8);
  }
  size_t v9 = (void *)*((void *)this + 16);
  if (v9)
  {
    *((void *)this + 17) = v9;
    operator delete(v9);
  }
  if (*((unsigned char *)this + 120))
  {
    uint64_t v10 = (void *)*((void *)this + 8);
    if (v10 != *((void **)this + 7)) {
      free(v10);
    }
  }
}

void mlir::Operation::setAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v11[9] = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a2;
  if (*(unsigned char *)(a1 + 47)
    && (uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9),
        mlir::Operation::getInherentAttr(a1, AttrData, v6),
        v7))
  {
    mlir::Operation::setInherentAttr(a1, v9, a3);
  }
  else
  {
    mlir::NamedAttrList::NamedAttrList(v10, *(void *)(a1 + 56));
    if (mlir::NamedAttrList::set((uint64_t)v10, v9, a3) != a3)
    {
      Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
      *(void *)(a1 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v10, Context);
    }
    if (v10[0] != v11) {
      free(v10[0]);
    }
  }
}

void mlir::DataFlowSolver::~DataFlowSolver(mlir::DataFlowSolver *this)
{
  unsigned int v2 = *((_DWORD *)this + 34);
  uint64_t v3 = (llvm *)*((void *)this + 15);
  if (v2)
  {
    uint64_t v4 = (char *)v3 + 24 * v2;
    size_t v5 = (uint64_t *)((char *)v3 + 16);
    do
    {
      uint64_t v7 = *(v5 - 2);
      uint64_t v6 = *(v5 - 1);
      BOOL v8 = v5 - 2;
      if ((v7 != -4096 || v6 != -4096) && (v7 != -8192 || v6 != -8192))
      {
        uint64_t v9 = *v5;
        uint64_t *v5 = 0;
        if (v9) {
          (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
        }
      }
      v5 += 3;
    }
    while (v8 + 3 != (uint64_t *)v4);
    uint64_t v3 = (llvm *)*((void *)this + 15);
    uint64_t v10 = 24 * *((unsigned int *)this + 34);
  }
  else
  {
    uint64_t v10 = 0;
  }
  llvm::deallocate_buffer(v3, (void *)v10);
}

uint64_t std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::~deque[abi:nn180100](uint64_t a1)
{
  unsigned int v2 = *(void ***)(a1 + 8);
  uint64_t v3 = *(void ***)(a1 + 16);
  *(void *)(a1 + 40) = 0;
  unint64_t v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      uint64_t v3 = *(void ***)(a1 + 16);
      unsigned int v2 = (void **)(*(void *)(a1 + 8) + 8);
      *(void *)(a1 + 8) = v2;
      unint64_t v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  unint64_t v5 = v4 >> 3;
  if (v5 == 1)
  {
    uint64_t v6 = 128;
    goto LABEL_7;
  }
  if (v5 == 2)
  {
    uint64_t v6 = 256;
LABEL_7:
    *(void *)(a1 + 32) = v6;
  }
  if (v2 != v3)
  {
    do
    {
      uint64_t v7 = *v2++;
      operator delete(v7);
    }
    while (v2 != v3);
    uint64_t v9 = *(void *)(a1 + 8);
    uint64_t v8 = *(void *)(a1 + 16);
    if (v8 != v9) {
      *(void *)(a1 + 16) = v8 + ((v9 - v8 + 7) & 0xFFFFFFFFFFFFFFF8);
    }
  }
  if (*(void *)a1) {
    operator delete(*(void **)a1);
  }
  return a1;
}

BOOL mlir::CallGraphNode::isExternal(mlir::CallGraphNode *this)
{
  return *(void *)this == 0;
}

BOOL mlir::CallGraphNode::hasChildren(mlir::CallGraphNode *this)
{
  uint64_t v1 = *((unsigned int *)this + 14);
  if (!v1) {
    return 0;
  }
  unsigned int v2 = (uint64_t *)*((void *)this + 6);
  uint64_t v3 = 8 * v1 - 8;
  do
  {
    uint64_t v4 = *v2++;
    uint64_t v5 = v4 & 6;
    BOOL result = v5 == 4;
    BOOL v7 = v5 == 4 || v3 == 0;
    v3 -= 8;
  }
  while (!v7);
  return result;
}

uint64_t llvm::SetVector<mlir::CallGraphNode::Edge,llvm::SmallVector<mlir::CallGraphNode::Edge,4u>,llvm::SmallDenseSet<mlir::CallGraphNode::Edge,4u,mlir::CallGraphNode::EdgeKeyInfo>,0u>::insert(uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = a1 + 8;
  if (*(unsigned char *)a1)
  {
    int v5 = 4;
  }
  else
  {
    int v5 = *(_DWORD *)(a1 + 16);
    if (!v5)
    {
      uint64_t v11 = 0;
      goto LABEL_8;
    }
    uint64_t v4 = *(void *)(a1 + 8);
  }
  int v6 = v5 - 1;
  unsigned int v7 = v6 & (((unint64_t)*a2 >> 9) ^ *a2);
  uint64_t v8 = (void *)(v4 + 8 * v7);
  uint64_t v9 = *v8;
  if (*a2 == *v8) {
    return 0;
  }
  uint64_t v14 = 0;
  int v15 = 1;
  while (v9 != -2)
  {
    if (v14) {
      BOOL v16 = 0;
    }
    else {
      BOOL v16 = v9 == -16;
    }
    if (v16) {
      uint64_t v14 = v8;
    }
    unsigned int v17 = v7 + v15++;
    unsigned int v7 = v17 & v6;
    uint64_t v8 = (void *)(v4 + 8 * v7);
    uint64_t v9 = *v8;
    if (*a2 == *v8) {
      return 0;
    }
  }
  if (v14) {
    uint64_t v11 = v14;
  }
  else {
    uint64_t v11 = v8;
  }
LABEL_8:
  llvm::DenseMapBase<llvm::SmallDenseMap<mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,4u,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>,mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>::InsertIntoBucket<mlir::CallGraphNode::Edge const&,llvm::detail::DenseSetEmpty&>(a1, v11, a2);
  uint64_t v12 = *a2;
  uint64_t v13 = *(unsigned int *)(a1 + 48);
  if (v13 >= *(_DWORD *)(a1 + 52))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 40, (void *)(a1 + 56), v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a1 + 48);
  }
  *(void *)(*(void *)(a1 + 40) + 8 * v13) = v12;
  ++*(_DWORD *)(a1 + 48);
  return 1;
}

void mlir::CallGraph::CallGraph(mlir::CallGraph *this, mlir::Operation *a2)
{
  *(void *)this = 0;
  *((void *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *((void *)this + 5) = 0;
  *((void *)this + 3) = (char *)this + 40;
  *((void *)this + 4) = 0;
  *((void *)this + 6) = 1;
  memset_pattern16((char *)this + 56, &unk_1810FE080, 0x20uLL);
  *((void *)this + 11) = (char *)this + 104;
  *((void *)this + 12) = 0x400000000;
  *((void *)this + 17) = 0;
  *((void *)this + 18) = 1;
  memset_pattern16((char *)this + 152, &unk_1810FE080, 0x20uLL);
  *((void *)this + 23) = (char *)this + 200;
  *((void *)this + 24) = 0x400000000;
  v9[0] = 0;
  v9[1] = 0;
  unsigned int v10 = 0;
  computeCallGraph((uint64_t)a2, (uint64_t *)this, (mlir::SymbolTableCollection *)v9, 0, 0);
  computeCallGraph((uint64_t)a2, (uint64_t *)this, (mlir::SymbolTableCollection *)v9, 0, 1);
  uint64_t v4 = v9[0];
  if (v10)
  {
    int v5 = (uint64_t *)((char *)v9[0] + 8);
    uint64_t v6 = 16 * v10;
    do
    {
      if ((*(v5 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v7 = *v5;
        uint64_t *v5 = 0;
        if (v7) {
          llvm::deallocate_buffer(*(llvm **)(v7 + 8), (void *)(16 * *(unsigned int *)(v7 + 24)));
        }
      }
      v5 += 2;
      v6 -= 16;
    }
    while (v6);
    uint64_t v4 = v9[0];
    uint64_t v8 = (void *)(16 * v10);
  }
  else
  {
    uint64_t v8 = 0;
  }
  llvm::deallocate_buffer(v4, v8);
}

uint64_t sub_180185218()
{
  return v0;
}

mlir::Region *computeCallGraph(uint64_t a1, uint64_t *a2, mlir::SymbolTableCollection *a3, mlir::CallGraphNode *a4, BOOL a5)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  BOOL result = (mlir::Region *)llvm::DefaultDoCastIfPossible<mlir::CallOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallOpInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
  if (a4 && a5 && result)
  {
    *(void *)&long long v20 = (unint64_t)mlir::CallGraph::resolveCallable(a2, (uint64_t)result, v11, (uint64_t)a3) & 0xFFFFFFFFFFFFFFF9 | 2;
    return (mlir::Region *)llvm::SetVector<mlir::CallGraphNode::Edge,llvm::SmallVector<mlir::CallGraphNode::Edge,4u>,llvm::SmallDenseSet<mlir::CallGraphNode::Edge,4u,mlir::CallGraphNode::EdgeKeyInfo>,0u>::insert((uint64_t)a4 + 8, (uint64_t *)&v20);
  }
  if (!result)
  {
    BOOL result = (mlir::Region *)llvm::DefaultDoCastIfPossible<mlir::CallableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallableOpInterface,mlir::Operation *,void>>::doCastIfPossible(a1);
    *(void *)&long long v20 = result;
    *((void *)&v20 + 1) = v12;
    if (result)
    {
      BOOL result = (mlir::Region *)mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v20);
      if (!result) {
        return result;
      }
      BOOL result = (mlir::Region *)mlir::CallGraph::getOrAddNode((mlir::CallGraph *)a2, result, a4);
      a4 = result;
    }
    unint64_t v13 = *(unsigned int *)(a1 + 44);
    if ((v13 & 0x7FFFFF) != 0)
    {
      uint64_t v14 = (mlir::Region *)(((a1 + 16 * ((v13 >> 23) & 1) + ((v13 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                           + 32 * *(unsigned int *)(a1 + 40));
      int v15 = (mlir::Region *)((char *)v14 + 24 * (v13 & 0x7FFFFF));
      do
      {
        mlir::Region::OpIterator::OpIterator(&v18, v14, 0);
        mlir::Region::OpIterator::OpIterator(&v22, v14, 1);
        BOOL result = v19;
        unint64_t v21 = v19;
        long long v20 = v18;
        for (uint64_t i = v23; v19 != i; result = v19)
        {
          mlir::GenericProgramPoint::~GenericProgramPoint(result);
          computeCallGraph(v17, (mlir::CallGraph *)a2, a3, a4, a5);
          mlir::Region::OpIterator::operator++((uint64_t *)&v18);
        }
        uint64_t v14 = (mlir::Region *)((char *)v14 + 24);
      }
      while (v14 != v15);
    }
  }
  return result;
}

uint64_t mlir::CallGraph::getOrAddNode(mlir::CallGraph *this, mlir::Region *a2, mlir::CallGraphNode *a3)
{
  v11[1] = *MEMORY[0x1E4F143B8];
  unsigned int v10 = a2;
  uint64_t v5 = llvm::MapVector<mlir::Region *,std::unique_ptr<mlir::CallGraphNode>,llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>,llvm::SmallVector<std::pair<mlir::Region *,std::unique_ptr<mlir::CallGraphNode>>,0u>>::operator[]((uint64_t)this, (uint64_t *)&v10);
  if (!*(void *)v5)
  {
    unint64_t v6 = (unint64_t)operator new(0x60uLL);
    *(void *)unint64_t v6 = v10;
    *(void *)(v6 + 8) = 1;
    memset_pattern16((void *)(v6 + 16), &unk_1810FE080, 0x20uLL);
    *(void *)(v6 + 48) = v6 + 64;
    *(void *)(v6 + 56) = 0x400000000;
    *(void *)uint64_t v5 = v6;
    unint64_t v7 = v6 & 0xFFFFFFFFFFFFFFF9;
    if (a3)
    {
      uint64_t v8 = (char *)a3 + 8;
      v7 |= 4uLL;
    }
    else
    {
      uint64_t v8 = (char *)this + 48;
    }
    v11[0] = v7;
    llvm::SetVector<mlir::CallGraphNode::Edge,llvm::SmallVector<mlir::CallGraphNode::Edge,4u>,llvm::SmallDenseSet<mlir::CallGraphNode::Edge,4u,mlir::CallGraphNode::EdgeKeyInfo>,0u>::insert((uint64_t)v8, v11);
  }
  return *(void *)v5;
}

uint64_t llvm::MapVector<mlir::Region *,std::unique_ptr<mlir::CallGraphNode>,llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>,llvm::SmallVector<std::pair<mlir::Region *,std::unique_ptr<mlir::CallGraphNode>>,0u>>::operator[](uint64_t a1, uint64_t *a2)
{
  uint64_t v4 = *a2;
  unsigned int v5 = *(_DWORD *)(a1 + 16);
  if (!v5) {
    goto LABEL_30;
  }
  uint64_t v6 = *(void *)a1;
  uint64_t v7 = ((v4 >> 4) ^ (v4 >> 9)) & (v5 - 1);
  uint64_t v8 = (void *)(*(void *)a1 + 16 * v7);
  uint64_t v9 = *v8;
  if (v4 == *v8)
  {
LABEL_3:
    LODWORD(v6) = *(_DWORD *)(v6 + 16 * v7 + 8);
    return *(void *)(a1 + 24) + 16 * v6 + 8;
  }
  unint64_t v19 = 0;
  int v20 = 1;
  while (v9 != -4096)
  {
    if (v19) {
      BOOL v21 = 0;
    }
    else {
      BOOL v21 = v9 == -8192;
    }
    if (v21) {
      unint64_t v19 = v8;
    }
    int v22 = v7 + v20++;
    uint64_t v7 = v22 & (v5 - 1);
    uint64_t v8 = (void *)(v6 + 16 * v7);
    uint64_t v9 = *v8;
    if (v4 == *v8) {
      goto LABEL_3;
    }
  }
  uint64_t v23 = (uint64_t)(v19 ? v19 : v8);
  int v24 = *(_DWORD *)(a1 + 8);
  if (4 * v24 + 4 < 3 * v5)
  {
    if (v5 + ~v24 - *(_DWORD *)(a1 + 12) > v5 >> 3) {
      goto LABEL_6;
    }
  }
  else
  {
LABEL_30:
    v5 *= 2;
  }
  llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>::grow(a1, v5);
  int v25 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v26 = v25 & ((v4 >> 4) ^ (v4 >> 9));
  uint64_t v23 = *(void *)a1 + 16 * v26;
  uint64_t v27 = *(void *)v23;
  if (v4 == *(void *)v23)
  {
LABEL_32:
    ++*(_DWORD *)(a1 + 8);
    if (v4 == -4096) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  uint64_t v30 = 0;
  int v31 = 1;
  while (v27 != -4096)
  {
    if (v30) {
      BOOL v32 = 0;
    }
    else {
      BOOL v32 = v27 == -8192;
    }
    if (v32) {
      uint64_t v30 = v23;
    }
    unsigned int v33 = v26 + v31++;
    unsigned int v26 = v33 & v25;
    uint64_t v23 = *(void *)a1 + 16 * v26;
    uint64_t v27 = *(void *)v23;
    if (v4 == *(void *)v23) {
      goto LABEL_32;
    }
  }
  if (v30) {
    uint64_t v23 = v30;
  }
LABEL_6:
  uint64_t v10 = *(void *)v23;
  ++*(_DWORD *)(a1 + 8);
  if (v10 != -4096) {
LABEL_7:
  }
    --*(_DWORD *)(a1 + 12);
LABEL_8:
  *(void *)uint64_t v23 = v4;
  *(_DWORD *)(v23 + 8) = 0;
  unint64_t v11 = *(void *)(a1 + 24);
  uint64_t v35 = *a2;
  std::string __p = 0;
  uint64_t v12 = *(unsigned int *)(a1 + 32);
  unint64_t v13 = (char *)&v35;
  if (v12 >= *(_DWORD *)(a1 + 36))
  {
    unint64_t v28 = v12 + 1;
    BOOL v29 = v11 + 16 * v12 > (unint64_t)&v35;
    if (v11 <= (unint64_t)&v35 && v29)
    {
      uint64_t v34 = (char *)&v35 - v11;
      llvm::SmallVectorTemplateBase<std::pair<mlir::Region *,std::unique_ptr<mlir::CallGraphNode>>,false>::grow(a1 + 24, v28);
      unint64_t v11 = *(void *)(a1 + 24);
      unint64_t v13 = &v34[v11];
    }
    else
    {
      llvm::SmallVectorTemplateBase<std::pair<mlir::Region *,std::unique_ptr<mlir::CallGraphNode>>,false>::grow(a1 + 24, v28);
      unint64_t v11 = *(void *)(a1 + 24);
      unint64_t v13 = (char *)&v35;
    }
  }
  uint64_t v6 = *(unsigned int *)(a1 + 32);
  uint64_t v14 = (void *)(v11 + 16 * v6);
  *uint64_t v14 = *(void *)v13;
  uint64_t v15 = *((void *)v13 + 1);
  *((void *)v13 + 1) = 0;
  v14[1] = v15;
  *(_DWORD *)(a1 + 32) = v6 + 1;
  BOOL v16 = (char *)__p;
  std::string __p = 0;
  if (v16)
  {
    unsigned int v17 = (char *)*((void *)v16 + 6);
    if (v17 != v16 + 64) {
      free(v17);
    }
    if ((v16[8] & 1) == 0) {
      llvm::deallocate_buffer(*((llvm **)v16 + 2), (void *)(8 * *((unsigned int *)v16 + 6)));
    }
    operator delete(v16);
    LODWORD(v6) = *(_DWORD *)(a1 + 32) - 1;
  }
  *(_DWORD *)(v23 + 8) = v6;
  return *(void *)(a1 + 24) + 16 * v6 + 8;
}

uint64_t mlir::CallGraph::lookupNode(uint64_t *a1, uint64_t a2)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *((unsigned int *)a1 + 4);
  if (v3)
  {
    LODWORD(v4) = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
    unsigned int v5 = (void *)(v2 + 16 * v4);
    uint64_t v6 = *v5;
    if (*v5 == a2) {
      goto LABEL_8;
    }
    int v7 = 1;
    while (v6 != -4096)
    {
      int v8 = v4 + v7++;
      uint64_t v4 = v8 & (v3 - 1);
      uint64_t v6 = *(void *)(v2 + 16 * v4);
      if (v6 == a2)
      {
        unsigned int v5 = (void *)(v2 + 16 * v4);
        goto LABEL_8;
      }
    }
  }
  unsigned int v5 = (void *)(v2 + 16 * v3);
LABEL_8:
  BOOL v9 = v5 == (void *)(v2 + 16 * v3);
  uint64_t v10 = (unsigned int *)(a1 + 4);
  if (!v9) {
    uint64_t v10 = (unsigned int *)(v5 + 1);
  }
  uint64_t v11 = *v10;
  if (v11 == *((_DWORD *)a1 + 8)) {
    return 0;
  }
  else {
    return *(void *)(a1[3] + 16 * v11 + 8);
  }
}

uint64_t *mlir::CallGraph::resolveCallable(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  v21[0] = a2;
  v21[1] = a3;
  uint64_t v5 = mlir::CallOpInterface::resolveCallable((uint64_t)v21, a4);
  if (!v5)
  {
    uint64_t v19 = 0;
    uint64_t v20 = 0;
    return a1 + 17;
  }
  uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::CallableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallableOpInterface,mlir::Operation *,void>>::doCastIfPossible(v5);
  uint64_t v20 = v6;
  if (!v19) {
    return a1 + 17;
  }
  uint64_t canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v19);
  uint64_t v8 = *a1;
  uint64_t v9 = *((unsigned int *)a1 + 4);
  if (v9)
  {
    LODWORD(v10) = ((canMapOperands >> 4) ^ (canMapOperands >> 9)) & (v9 - 1);
    uint64_t v11 = (void *)(v8 + 16 * v10);
    uint64_t v12 = *v11;
    if (*v11 == canMapOperands) {
      goto LABEL_12;
    }
    int v13 = 1;
    while (v12 != -4096)
    {
      int v14 = v10 + v13++;
      uint64_t v10 = v14 & (v9 - 1);
      uint64_t v12 = *(void *)(v8 + 16 * v10);
      if (v12 == canMapOperands)
      {
        uint64_t v11 = (void *)(v8 + 16 * v10);
        goto LABEL_12;
      }
    }
  }
  uint64_t v11 = (void *)(v8 + 16 * v9);
LABEL_12:
  BOOL v15 = v11 == (void *)(v8 + 16 * v9);
  BOOL v16 = (unsigned int *)(a1 + 4);
  if (!v15) {
    BOOL v16 = (unsigned int *)(v11 + 1);
  }
  uint64_t v17 = *v16;
  if (v17 == *((_DWORD *)a1 + 8)) {
    return a1 + 17;
  }
  BOOL result = *(uint64_t **)(a1[3] + 16 * v17 + 8);
  if (!result) {
    return a1 + 17;
  }
  return result;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::CallOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallOpInterface,mlir::Operation *,void>>::doCastIfPossible(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 48);
  uint64_t v3 = *(void **)(v2 + 16);
  BOOL v4 = v3 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 48);
  }
  if (v4)
  {
    uint64_t v16 = *(void *)(v2 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!Values || !mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(Values, v2)) {
      return 0;
    }
  }
  else
  {
    unint64_t v6 = v5 | v2 & 0xFFFFFFFFFFFFFF00;
    if (!mlir::detail::InterfaceMap::lookup<mlir::CallOpInterface>(v6 + 32)
      && !mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(*(void *)(v6 + 24), *(void *)(v1 + 48)))
    {
      return 0;
    }
  }
  uint64_t v8 = *(void *)(v1 + 48);
  uint64_t v9 = *(void **)(v8 + 16);
  BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *(void *)(v1 + 48);
  }
  if (v10)
  {
    uint64_t v16 = *(void *)(v8 + 8);
    uint64_t v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!v14) {
      return v1;
    }
    uint64_t v15 = v8;
  }
  else
  {
    unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
    if (mlir::detail::InterfaceMap::lookup<mlir::CallOpInterface>(v12 + 32)) {
      return v1;
    }
    uint64_t v14 = *(void *)(v12 + 24);
    uint64_t v15 = *(void *)(v1 + 48);
  }
  mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(v14, v15);
  return v1;
}

uint64_t mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v15 = a1;
    unint64_t v3 = 0x1E8EB8000;
    int v6 = v5;
    uint64_t v2 = a2;
    a1 = v15;
    if (v6)
    {
      uint64_t v16 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface]";
      unint64_t v17 = 71;
      unint64_t v7 = llvm::StringRef::find((uint64_t *)&v16, "DesiredTypeName = ", 0x12uLL, 0);
      if (v17 >= v7) {
        unint64_t v8 = v7;
      }
      else {
        unint64_t v8 = v17;
      }
      uint64_t v9 = &v16[v8];
      unint64_t v10 = v17 - v8;
      if (v17 - v8 >= 0x12) {
        uint64_t v11 = 18;
      }
      else {
        uint64_t v11 = v17 - v8;
      }
      unint64_t v12 = v10 - v11;
      if (v12 >= v12 - 1) {
        uint64_t v13 = v12 - 1;
      }
      else {
        uint64_t v13 = v12;
      }
      mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = a2;
      a1 = v15;
    }
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, *(void *)(v3 + 3736), v2);
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::CallOpInterface>(uint64_t a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    uint64_t v20 = a1;
    unint64_t v1 = 0x1E8EB8000;
    int v12 = v11;
    a1 = v20;
    if (v12)
    {
      BOOL v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallOpInterface]";
      unint64_t v22 = 71;
      unint64_t v13 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
      if (v22 >= v13) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = v22;
      }
      uint64_t v15 = &v21[v14];
      unint64_t v16 = v22 - v14;
      if (v22 - v14 >= 0x12) {
        uint64_t v17 = 18;
      }
      else {
        uint64_t v17 = v22 - v14;
      }
      unint64_t v18 = v16 - v17;
      if (v18 >= v18 - 1) {
        uint64_t v19 = v18 - 1;
      }
      else {
        uint64_t v19 = v18;
      }
      mlir::detail::TypeIDResolver<mlir::CallOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v15[v17], v19);
      unint64_t v1 = 0x1E8EB8000;
      a1 = v20;
    }
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *(void *)(v1 + 3736);
  BOOL v4 = *(void **)a1;
  uint64_t v5 = *(void *)a1 + 16 * v2;
  do
  {
    unint64_t v6 = v2 >> 1;
    unint64_t v7 = &v4[2 * (v2 >> 1)];
    unint64_t v9 = *v7;
    unint64_t v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3) {
      BOOL v4 = v8;
    }
    else {
      unint64_t v2 = v6;
    }
  }
  while (v2);
  if (v4 != (void *)v5 && *v4 == v3) {
    return v4[1];
  }
  else {
    return 0;
  }
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::CallableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallableOpInterface,mlir::Operation *,void>>::doCastIfPossible(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void **)(v2 + 16);
  BOOL v4 = v3 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 48);
  }
  if (v4)
  {
    uint64_t v16 = *(void *)(v2 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!Values || !mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(Values, v2)) {
      return 0;
    }
  }
  else
  {
    unint64_t v6 = v5 | v2 & 0xFFFFFFFFFFFFFF00;
    if (!mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(v6 + 32)
      && !mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(*(void *)(v6 + 24), *(void *)(v1 + 48)))
    {
      return 0;
    }
  }
  uint64_t v8 = *(void *)(v1 + 48);
  unint64_t v9 = *(void **)(v8 + 16);
  BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *(void *)(v1 + 48);
  }
  if (v10)
  {
    uint64_t v16 = *(void *)(v8 + 8);
    uint64_t v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!v14) {
      return v1;
    }
    uint64_t v15 = v8;
  }
  else
  {
    unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
    if (mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(v12 + 32)) {
      return v1;
    }
    uint64_t v14 = *(void *)(v12 + 24);
    uint64_t v15 = *(void *)(v1 + 48);
  }
  mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(v14, v15);
  return v1;
}

uint64_t mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v15 = a1;
    unint64_t v3 = 0x1E8EB8000;
    int v6 = v5;
    uint64_t v2 = a2;
    a1 = v15;
    if (v6)
    {
      uint64_t v16 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallableOpInterface]";
      unint64_t v17 = 75;
      unint64_t v7 = llvm::StringRef::find((uint64_t *)&v16, "DesiredTypeName = ", 0x12uLL, 0);
      if (v17 >= v7) {
        unint64_t v8 = v7;
      }
      else {
        unint64_t v8 = v17;
      }
      unint64_t v9 = &v16[v8];
      unint64_t v10 = v17 - v8;
      if (v17 - v8 >= 0x12) {
        uint64_t v11 = 18;
      }
      else {
        uint64_t v11 = v17 - v8;
      }
      unint64_t v12 = v10 - v11;
      if (v12 >= v12 - 1) {
        uint64_t v13 = v12 - 1;
      }
      else {
        uint64_t v13 = v12;
      }
      mlir::detail::TypeIDResolver<mlir::CallableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = a2;
      a1 = v15;
    }
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, *(void *)(v3 + 3800), v2);
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(uint64_t a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    uint64_t v20 = a1;
    unint64_t v1 = 0x1E8EB8000;
    int v12 = v11;
    a1 = v20;
    if (v12)
    {
      BOOL v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CallableOpInterface]";
      unint64_t v22 = 75;
      unint64_t v13 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
      if (v22 >= v13) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = v22;
      }
      uint64_t v15 = &v21[v14];
      unint64_t v16 = v22 - v14;
      if (v22 - v14 >= 0x12) {
        uint64_t v17 = 18;
      }
      else {
        uint64_t v17 = v22 - v14;
      }
      unint64_t v18 = v16 - v17;
      if (v18 >= v18 - 1) {
        uint64_t v19 = v18 - 1;
      }
      else {
        uint64_t v19 = v18;
      }
      mlir::detail::TypeIDResolver<mlir::CallableOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v15[v17], v19);
      unint64_t v1 = 0x1E8EB8000;
      a1 = v20;
    }
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *(void *)(v1 + 3800);
  BOOL v4 = *(void **)a1;
  uint64_t v5 = *(void *)a1 + 16 * v2;
  do
  {
    unint64_t v6 = v2 >> 1;
    unint64_t v7 = &v4[2 * (v2 >> 1)];
    unint64_t v9 = *v7;
    unint64_t v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3) {
      BOOL v4 = v8;
    }
    else {
      unint64_t v2 = v6;
    }
  }
  while (v2);
  if (v4 != (void *)v5 && *v4 == v3) {
    return v4[1];
  }
  else {
    return 0;
  }
}

void *llvm::DenseMapBase<llvm::SmallDenseMap<mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,4u,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>,mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>::InsertIntoBucket<mlir::CallGraphNode::Edge const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, void *a2, void *a3)
{
  int v6 = *(_DWORD *)a1;
  int v7 = *(_DWORD *)a1 >> 1;
  if (*(_DWORD *)a1) {
    unsigned int v8 = 4;
  }
  else {
    unsigned int v8 = *(_DWORD *)(a1 + 16);
  }
  if (4 * v7 + 4 >= 3 * v8)
  {
    v8 *= 2;
  }
  else if (v8 + ~v7 - *(_DWORD *)(a1 + 4) > v8 >> 3)
  {
    int v9 = *(_DWORD *)a1 & 1;
    goto LABEL_7;
  }
  llvm::SmallDenseMap<mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,4u,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>::grow(a1, v8);
  uint64_t v11 = a1 + 8;
  int v6 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v12 = 4;
  }
  else
  {
    int v12 = *(_DWORD *)(a1 + 16);
    if (!v12)
    {
      int v9 = 0;
      a2 = 0;
      goto LABEL_7;
    }
    uint64_t v11 = *(void *)(a1 + 8);
  }
  int v9 = *(_DWORD *)a1 & 1;
  int v13 = v12 - 1;
  unsigned int v14 = (v12 - 1) & ((*a3 >> 9) ^ *a3);
  a2 = (void *)(v11 + 8 * v14);
  uint64_t v15 = *a2;
  if (*a3 != *a2)
  {
    unint64_t v16 = 0;
    int v17 = 1;
    while (v15 != -2)
    {
      if (v16) {
        BOOL v18 = 0;
      }
      else {
        BOOL v18 = v15 == -16;
      }
      if (v18) {
        unint64_t v16 = a2;
      }
      unsigned int v19 = v14 + v17++;
      unsigned int v14 = v19 & v13;
      a2 = (void *)(v11 + 8 * (v19 & v13));
      uint64_t v15 = *a2;
      if (*a3 == *a2) {
        goto LABEL_7;
      }
    }
    if (v16) {
      a2 = v16;
    }
  }
LABEL_7:
  *(_DWORD *)a1 = (v6 & 0xFFFFFFFE | v9) + 2;
  if (*a2 != -2) {
    --*(_DWORD *)(a1 + 4);
  }
  *a2 = *a3;
  return a2;
}

void llvm::SmallDenseMap<mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,4u,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>::grow(uint64_t a1, unsigned int a2)
{
  v20[3] = *MEMORY[0x1E4F143B8];
  if (a2 >= 5)
  {
    unint64_t v3 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
    unint64_t v4 = v3 | (v3 >> 2) | ((v3 | (v3 >> 2)) >> 4);
    int v5 = ((v4 | (v4 >> 8)) >> 16) | v4 | (v4 >> 8);
    if ((v5 + 1) > 0x40) {
      a2 = v5 + 1;
    }
    else {
      a2 = 64;
    }
  }
  if ((*(_DWORD *)a1 & 1) == 0)
  {
    int v6 = *(unint64_t **)(a1 + 8);
    uint64_t v7 = *(unsigned int *)(a1 + 16);
    if (a2 > 4)
    {
      uint64_t v14 = a2;
      *(void *)(a1 + 8) = llvm::allocate_buffer(8 * a2, (std::align_val_t)8uLL);
      *(void *)(a1 + 16) = v14;
    }
    else
    {
      *(_DWORD *)a1 |= 1u;
    }
    uint64_t v15 = (char *)(8 * v7);
    llvm::DenseMapBase<llvm::SmallDenseMap<mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,4u,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>,mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>::moveFromOldBuckets((_DWORD *)a1, v6, (unint64_t *)&v15[(void)v6]);
    llvm::deallocate_buffer((llvm *)v6, v15);
  }
  uint64_t v8 = *(void *)(a1 + 8);
  int v9 = &v19;
  if (v8 == -16 || v8 == -2)
  {
    unint64_t v11 = *(void *)(a1 + 16);
    if (v11 != -16 && v11 != -2)
    {
LABEL_28:
      *v9++ = v11;
      unint64_t v13 = *(void *)(a1 + 24);
      if (v13 == -16) {
        goto LABEL_31;
      }
      goto LABEL_29;
    }
  }
  else
  {
    unint64_t v19 = *(void *)(a1 + 8);
    int v9 = v20;
    unint64_t v11 = *(void *)(a1 + 16);
    if (v11 != -16 && v11 != -2) {
      goto LABEL_28;
    }
  }
  unint64_t v13 = *(void *)(a1 + 24);
  if (v13 == -16) {
    goto LABEL_31;
  }
LABEL_29:
  if (v13 != -2) {
    *v9++ = v13;
  }
LABEL_31:
  unint64_t v17 = *(void *)(a1 + 32);
  if (v17 != -16 && v17 != -2) {
    *v9++ = v17;
  }
  if (a2 >= 5)
  {
    *(_DWORD *)a1 &= ~1u;
    uint64_t v18 = a2;
    *(void *)(a1 + 8) = llvm::allocate_buffer(8 * a2, (std::align_val_t)8uLL);
    *(void *)(a1 + 16) = v18;
  }
  llvm::DenseMapBase<llvm::SmallDenseMap<mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,4u,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>,mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>::moveFromOldBuckets((_DWORD *)a1, &v19, v9);
}

void llvm::DenseMapBase<llvm::SmallDenseMap<mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,4u,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>,mlir::CallGraphNode::Edge,llvm::detail::DenseSetEmpty,mlir::CallGraphNode::EdgeKeyInfo,llvm::detail::DenseSetPair<mlir::CallGraphNode::Edge>>::moveFromOldBuckets(_DWORD *a1, unint64_t *a2, unint64_t *a3)
{
  int v6 = *a1;
  *(void *)a1 = *a1 & 1;
  uint64_t v7 = a1 + 2;
  if (v6)
  {
    uint64_t v8 = 4;
    int v9 = a1 + 2;
  }
  else
  {
    uint64_t v8 = a1[4];
    if (!v8) {
      goto LABEL_6;
    }
    int v9 = (void *)*((void *)a1 + 1);
  }
  memset_pattern16(v9, &unk_1810FE080, 8 * v8);
LABEL_6:
  while (a2 != a3)
  {
    unint64_t v16 = *a2;
    if (*a2 != -16 && v16 != -2)
    {
      if (*(unsigned char *)a1)
      {
        int v11 = 4;
        unint64_t v10 = v7;
      }
      else
      {
        unint64_t v10 = (_DWORD *)*((void *)a1 + 1);
        int v11 = a1[4];
      }
      int v12 = v11 - 1;
      unsigned int v13 = (v11 - 1) & ((v16 >> 9) ^ v16);
      uint64_t v14 = (unint64_t *)&v10[2 * v13];
      unint64_t v15 = *v14;
      if (v16 != *v14)
      {
        uint64_t v18 = 0;
        int v19 = 1;
        while (v15 != -2)
        {
          if (v18) {
            BOOL v20 = 0;
          }
          else {
            BOOL v20 = v15 == -16;
          }
          if (v20) {
            uint64_t v18 = v14;
          }
          unsigned int v21 = v13 + v19++;
          unsigned int v13 = v21 & v12;
          uint64_t v14 = (unint64_t *)&v10[2 * (v21 & v12)];
          unint64_t v15 = *v14;
          if (v16 == *v14) {
            goto LABEL_10;
          }
        }
        if (v18) {
          uint64_t v14 = v18;
        }
      }
LABEL_10:
      *uint64_t v14 = v16;
      *a1 += 2;
    }
    ++a2;
  }
}

void *llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  BOOL result = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  unint64_t v10 = result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11)
    {
      if (((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
        goto LABEL_10;
      }
      uint64_t v12 = ((v11 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
      unint64_t v10 = &result[2 * (v12 & 0x1FFFFFFFFFFFFFFELL)];
      unsigned int v13 = result + 2;
      uint64_t v14 = v12 & 0x1FFFFFFFFFFFFFFELL;
      do
      {
        *(v13 - 2) = -4096;
        *unsigned int v13 = -4096;
        v13 += 4;
        v14 -= 2;
      }
      while (v14);
      if (v12 != (v12 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_10:
        unint64_t v15 = &result[2 * v11];
        do
        {
          *unint64_t v10 = -4096;
          v10 += 2;
        }
        while (v10 != v15);
      }
    }
    if (v3)
    {
      unint64_t v16 = v4;
      do
      {
        uint64_t v23 = *(void *)v16;
        if ((*(void *)v16 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          int v24 = *(_DWORD *)(a1 + 16) - 1;
          unsigned int v25 = v24 & ((v23 >> 4) ^ (v23 >> 9));
          uint64_t v22 = *(void *)a1 + 16 * v25;
          uint64_t v26 = *(void *)v22;
          if (v23 != *(void *)v22)
          {
            uint64_t v27 = 0;
            int v28 = 1;
            while (v26 != -4096)
            {
              if (v27) {
                BOOL v29 = 0;
              }
              else {
                BOOL v29 = v26 == -8192;
              }
              if (v29) {
                uint64_t v27 = v22;
              }
              unsigned int v30 = v25 + v28++;
              unsigned int v25 = v30 & v24;
              uint64_t v22 = *(void *)a1 + 16 * (v30 & v24);
              uint64_t v26 = *(void *)v22;
              if (v23 == *(void *)v22) {
                goto LABEL_24;
              }
            }
            if (v27) {
              uint64_t v22 = v27;
            }
          }
LABEL_24:
          *(void *)uint64_t v22 = v23;
          *(_DWORD *)(v22 + 8) = *((_DWORD *)v16 + 2);
          ++*(_DWORD *)(a1 + 8);
        }
        unint64_t v16 = (llvm *)((char *)v16 + 16);
      }
      while (v16 != (llvm *)((char *)v4 + 16 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(16 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v17 = *(unsigned int *)(a1 + 16);
  if (v17)
  {
    if (((v17 - 1) & 0xFFFFFFFFFFFFFFFLL) == 0) {
      goto LABEL_19;
    }
    uint64_t v18 = ((v17 - 1) & 0xFFFFFFFFFFFFFFFLL) + 1;
    unint64_t v10 = &result[2 * (v18 & 0x1FFFFFFFFFFFFFFELL)];
    int v19 = result + 2;
    uint64_t v20 = v18 & 0x1FFFFFFFFFFFFFFELL;
    do
    {
      *(v19 - 2) = -4096;
      *int v19 = -4096;
      v19 += 4;
      v20 -= 2;
    }
    while (v20);
    if (v18 != (v18 & 0x1FFFFFFFFFFFFFFELL))
    {
LABEL_19:
      unsigned int v21 = &result[2 * v17];
      do
      {
        *unint64_t v10 = -4096;
        v10 += 2;
      }
      while (v10 != v21);
    }
  }
  return result;
}

void llvm::SmallVectorTemplateBase<std::pair<mlir::Region *,std::unique_ptr<mlir::CallGraphNode>>,false>::grow(uint64_t a1, unint64_t a2)
{
  unint64_t v25 = 0;
  uint64_t v3 = (char *)(a1 + 16);
  unint64_t v4 = (char *)llvm::SmallVectorBase<unsigned int>::mallocForGrow(a1, (void *)(a1 + 16), a2, 16, &v25);
  unint64_t v5 = *(char **)a1;
  uint64_t v6 = *(unsigned int *)(a1 + 8);
  if (!v6) {
    goto LABEL_24;
  }
  unint64_t v7 = (v6 - 1) & 0xFFFFFFFFFFFFFFFLL;
  uint64_t v8 = 16 * v6;
  if (v7 < 7 || (v4 < &v5[v8] ? (BOOL v9 = v5 >= &v4[v8]) : (BOOL v9 = 1), !v9))
  {
    uint64_t v12 = v4;
    unsigned int v13 = *(char **)a1;
LABEL_13:
    int v19 = &v5[16 * v6];
    do
    {
      *(void *)uint64_t v12 = *(void *)v13;
      uint64_t v20 = *((void *)v13 + 1);
      *((void *)v13 + 1) = 0;
      *((void *)v12 + 1) = v20;
      v13 += 16;
      v12 += 16;
    }
    while (v13 != v19);
    goto LABEL_15;
  }
  unint64_t v10 = v7 + 1;
  uint64_t v11 = (v7 + 1) & 0x1FFFFFFFFFFFFFFELL;
  uint64_t v12 = &v4[16 * v11];
  unsigned int v13 = &v5[16 * v11];
  uint64_t v14 = v11;
  unint64_t v15 = v4;
  unint64_t v16 = *(char **)a1;
  do
  {
    long long v17 = *(_OWORD *)v16;
    long long v18 = *((_OWORD *)v16 + 1);
    *((void *)v16 + 1) = 0;
    *((void *)v16 + 3) = 0;
    *(_OWORD *)unint64_t v15 = v17;
    *((_OWORD *)v15 + 1) = v18;
    v15 += 32;
    v16 += 32;
    v14 -= 2;
  }
  while (v14);
  if (v10 != v11) {
    goto LABEL_13;
  }
LABEL_15:
  uint64_t v21 = *(void *)a1 - 8;
  do
  {
    uint64_t v22 = *(void *)(v21 + v8);
    *(void *)(v21 + v8) = 0;
    if (v22)
    {
      uint64_t v23 = *(void **)(v22 + 48);
      if (v23 != (void *)(v22 + 64)) {
        free(v23);
      }
      if ((*(unsigned char *)(v22 + 8) & 1) == 0) {
        llvm::deallocate_buffer(*(llvm **)(v22 + 16), (void *)(8 * *(unsigned int *)(v22 + 24)));
      }
      operator delete((void *)v22);
    }
    v8 -= 16;
  }
  while (v8);
  unint64_t v5 = *(char **)a1;
LABEL_24:
  int v24 = v25;
  if (v5 != v3) {
    free(v5);
  }
  *(void *)a1 = v4;
  *(_DWORD *)(a1 + 12) = v24;
}

void llvm::scc_iterator<mlir::CallGraph const*,llvm::GraphTraits<mlir::CallGraph const*>>::DFSVisitOne(int *a1, uint64_t a2)
{
  int v4 = *a1 + 1;
  *a1 = v4;
  uint64_t v7 = *((void *)a1 + 1);
  uint64_t v5 = (uint64_t)(a1 + 2);
  uint64_t v6 = v7;
  unsigned int v8 = a1[6];
  if (!v8) {
    goto LABEL_60;
  }
  unsigned int v9 = v8 - 1;
  unsigned int v10 = (v8 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v11 = (uint64_t *)(v6 + 16 * v10);
  uint64_t v12 = *v11;
  if (*v11 == a2) {
    goto LABEL_17;
  }
  unsigned int v13 = 0;
  int v14 = 1;
  while (v12 != -4096)
  {
    if (v13) {
      BOOL v15 = 0;
    }
    else {
      BOOL v15 = v12 == -8192;
    }
    if (v15) {
      unsigned int v13 = v11;
    }
    unsigned int v16 = v10 + v14++;
    unsigned int v10 = v16 & v9;
    uint64_t v11 = (uint64_t *)(v6 + 16 * (v16 & v9));
    uint64_t v12 = *v11;
    if (*v11 == a2) {
      goto LABEL_17;
    }
  }
  if (v13) {
    uint64_t v11 = v13;
  }
  int v52 = a1[4];
  if (4 * v52 + 4 < 3 * v8)
  {
    if (v8 + ~v52 - a1[5] > v8 >> 3) {
      goto LABEL_14;
    }
  }
  else
  {
LABEL_60:
    v8 *= 2;
  }
  llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>::grow(v5, v8);
  uint64_t v53 = *((void *)a1 + 1);
  int v54 = a1[6] - 1;
  unsigned int v55 = v54 & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v11 = (uint64_t *)(v53 + 16 * v55);
  uint64_t v56 = *v11;
  if (*v11 == a2)
  {
LABEL_62:
    ++a1[4];
    if (a2 == -4096) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v57 = 0;
  int v58 = 1;
  while (v56 != -4096)
  {
    if (v57) {
      BOOL v59 = 0;
    }
    else {
      BOOL v59 = v56 == -8192;
    }
    if (v59) {
      uint64_t v57 = v11;
    }
    unsigned int v60 = v55 + v58++;
    unsigned int v55 = v60 & v54;
    uint64_t v11 = (uint64_t *)(v53 + 16 * (v60 & v54));
    uint64_t v56 = *v11;
    if (*v11 == a2) {
      goto LABEL_62;
    }
  }
  if (v57) {
    uint64_t v11 = v57;
  }
LABEL_14:
  uint64_t v17 = *v11;
  ++a1[4];
  if (v17 != -4096) {
LABEL_15:
  }
    --a1[5];
LABEL_16:
  *uint64_t v11 = a2;
  *((_DWORD *)v11 + 2) = 0;
LABEL_17:
  *((_DWORD *)v11 + 2) = v4;
  int v19 = (char *)*((void *)a1 + 5);
  unint64_t v18 = *((void *)a1 + 6);
  if ((unint64_t)v19 < v18)
  {
    *(void *)int v19 = a2;
    uint64_t v20 = (uint64_t)(v19 + 8);
    goto LABEL_39;
  }
  uint64_t v21 = (char *)*((void *)a1 + 4);
  uint64_t v22 = (v19 - v21) >> 3;
  unint64_t v23 = v22 + 1;
  if ((unint64_t)(v22 + 1) >> 61) {
    goto LABEL_64;
  }
  uint64_t v24 = v18 - (void)v21;
  if (v24 >> 2 > v23) {
    unint64_t v23 = v24 >> 2;
  }
  if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v25 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v25 = v23;
  }
  if (v25)
  {
    if (v25 >> 61) {
      goto LABEL_65;
    }
    uint64_t v26 = (char *)operator new(8 * v25);
    uint64_t v27 = &v26[8 * v22];
    int v28 = &v26[8 * v25];
    *(void *)uint64_t v27 = a2;
    uint64_t v20 = (uint64_t)(v27 + 8);
    BOOL v29 = (char *)(v19 - v21);
    if (v19 == v21) {
      goto LABEL_37;
    }
    goto LABEL_30;
  }
  uint64_t v26 = 0;
  uint64_t v27 = (char *)(8 * v22);
  int v28 = 0;
  *(void *)(8 * v22) = a2;
  uint64_t v20 = 8 * v22 + 8;
  BOOL v29 = (char *)(v19 - v21);
  if (v19 != v21)
  {
LABEL_30:
    unint64_t v30 = (unint64_t)(v29 - 8);
    if (v30 < 0x58) {
      goto LABEL_80;
    }
    if ((unint64_t)(v21 - v26) < 0x20) {
      goto LABEL_80;
    }
    uint64_t v31 = (v30 >> 3) + 1;
    uint64_t v32 = 8 * (v31 & 0x3FFFFFFFFFFFFFFCLL);
    unsigned int v33 = &v19[-v32];
    v27 -= v32;
    uint64_t v34 = &v26[8 * v22 - 16];
    uint64_t v35 = v19 - 16;
    uint64_t v36 = v31 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v37 = *(_OWORD *)v35;
      *((_OWORD *)v34 - 1) = *((_OWORD *)v35 - 1);
      *(_OWORD *)uint64_t v34 = v37;
      v34 -= 32;
      v35 -= 32;
      v36 -= 4;
    }
    while (v36);
    int v19 = v33;
    if (v31 != (v31 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_80:
      do
      {
        uint64_t v38 = *((void *)v19 - 1);
        v19 -= 8;
        *((void *)v27 - 1) = v38;
        v27 -= 8;
      }
      while (v19 != v21);
    }
    int v19 = (char *)*((void *)a1 + 4);
  }
LABEL_37:
  *((void *)a1 + 4) = v27;
  *((void *)a1 + 5) = v20;
  *((void *)a1 + 6) = v28;
  if (v19) {
    operator delete(v19);
  }
LABEL_39:
  *((void *)a1 + 5) = v20;
  uint64_t v39 = *(void *)(a2 + 48);
  int v40 = *a1;
  uint64_t v42 = (char *)*((void *)a1 + 11);
  unint64_t v41 = *((void *)a1 + 12);
  if ((unint64_t)v42 < v41)
  {
    *(void *)uint64_t v42 = a2;
    *((void *)v42 + 1) = v39;
    *((void *)v42 + 2) = llvm::GraphTraits<mlir::CallGraphNode const*>::unwrap;
    *((_DWORD *)v42 + 6) = v40;
    unint64_t v43 = v42 + 32;
    goto LABEL_56;
  }
  uint64_t v44 = (unsigned char *)*((void *)a1 + 10);
  uint64_t v45 = (v42 - v44) >> 5;
  unint64_t v46 = v45 + 1;
  if ((unint64_t)(v45 + 1) >> 59) {
LABEL_64:
  }
    abort();
  uint64_t v47 = v41 - (void)v44;
  if (v47 >> 4 > v46) {
    unint64_t v46 = v47 >> 4;
  }
  if ((unint64_t)v47 >= 0x7FFFFFFFFFFFFFE0) {
    unint64_t v48 = 0x7FFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v48 = v46;
  }
  if (!v48)
  {
    uint64_t v49 = 0;
    goto LABEL_51;
  }
  if (v48 >> 59) {
LABEL_65:
  }
    std::__throw_bad_array_new_length[abi:nn180100]();
  uint64_t v49 = (char *)operator new(32 * v48);
LABEL_51:
  uint64_t v50 = &v49[32 * v45];
  *(void *)uint64_t v50 = a2;
  *((void *)v50 + 1) = v39;
  *((void *)v50 + 2) = llvm::GraphTraits<mlir::CallGraphNode const*>::unwrap;
  *((_DWORD *)v50 + 6) = v40;
  unint64_t v43 = v50 + 32;
  if (v42 != v44)
  {
    do
    {
      long long v51 = *((_OWORD *)v42 - 2);
      *(_OWORD *)(v50 - 20) = *(_OWORD *)(v42 - 20);
      *((_OWORD *)v50 - 2) = v51;
      v50 -= 32;
      v42 -= 32;
    }
    while (v42 != v44);
    uint64_t v42 = (char *)*((void *)a1 + 10);
  }
  *((void *)a1 + 10) = v50;
  *((void *)a1 + 11) = v43;
  *((void *)a1 + 12) = &v49[32 * v48];
  if (v42) {
    operator delete(v42);
  }
LABEL_56:
  *((void *)a1 + 11) = v43;
}

void llvm::scc_iterator<mlir::CallGraph const*,llvm::GraphTraits<mlir::CallGraph const*>>::GetNextSCC(uint64_t a1)
{
  *(void *)(a1 + 64) = *(void *)(a1 + 56);
  uint64_t v79 = a1 + 8;
  while (1)
  {
    uint64_t v9 = *(void *)(a1 + 80);
    uint64_t v8 = *(void *)(a1 + 88);
    if (v9 == v8) {
      break;
    }
    uint64_t v11 = *(void *)(v8 - 32);
    uint64_t v10 = *(void *)(v8 - 24);
    if (v10 != *(void *)(v11 + 48) + 8 * *(unsigned int *)(v11 + 56))
    {
      while (1)
      {
        unsigned int v13 = *(uint64_t (**)(void))(v8 - 16);
        *(void *)(v8 - 24) = v10 + 8;
        uint64_t v14 = v13();
        uint64_t v15 = *(void *)(a1 + 8);
        uint64_t v16 = *(unsigned int *)(a1 + 24);
        if (!v16) {
          goto LABEL_17;
        }
        LODWORD(v17) = ((v14 >> 4) ^ (v14 >> 9)) & (v16 - 1);
        unint64_t v18 = (uint64_t *)(v15 + 16 * v17);
        uint64_t v19 = *v18;
        if (*v18 != v14) {
          break;
        }
LABEL_18:
        if (v18 == (uint64_t *)(v15 + 16 * v16))
        {
          llvm::scc_iterator<mlir::CallGraph const*,llvm::GraphTraits<mlir::CallGraph const*>>::DFSVisitOne((int *)a1, v14);
          uint64_t v8 = *(void *)(a1 + 88);
        }
        else
        {
          unsigned int v22 = *((_DWORD *)v18 + 2);
          uint64_t v8 = *(void *)(a1 + 88);
          if (*(_DWORD *)(v8 - 8) > v22) {
            *(_DWORD *)(v8 - 8) = v22;
          }
        }
        uint64_t v11 = *(void *)(v8 - 32);
        uint64_t v10 = *(void *)(v8 - 24);
        if (v10 == *(void *)(v11 + 48) + 8 * *(unsigned int *)(v11 + 56))
        {
          uint64_t v23 = *(void *)(a1 + 80);
          unsigned int v12 = *(_DWORD *)(v8 - 8);
          *(void *)(a1 + 88) = v8 - 32;
          if (v23 != v8 - 32) {
            goto LABEL_22;
          }
          goto LABEL_2;
        }
      }
      int v20 = 1;
      while (v19 != -4096)
      {
        int v21 = v17 + v20++;
        uint64_t v17 = v21 & (v16 - 1);
        uint64_t v19 = *(void *)(v15 + 16 * v17);
        if (v19 == v14)
        {
          unint64_t v18 = (uint64_t *)(v15 + 16 * v17);
          goto LABEL_18;
        }
      }
LABEL_17:
      unint64_t v18 = (uint64_t *)(v15 + 16 * v16);
      goto LABEL_18;
    }
    unsigned int v12 = *(_DWORD *)(v8 - 8);
    *(void *)(a1 + 88) = v8 - 32;
    if (v9 != v8 - 32)
    {
LABEL_22:
      if (*(_DWORD *)(v8 - 40) > v12) {
        *(_DWORD *)(v8 - 40) = v12;
      }
    }
LABEL_2:
    unsigned int v2 = *(_DWORD *)(a1 + 24);
    if (!v2) {
      goto LABEL_41;
    }
    uint64_t v3 = *(void *)(a1 + 8);
    unsigned int v4 = v2 - 1;
    unsigned int v5 = (v2 - 1) & ((v11 >> 4) ^ (v11 >> 9));
    uint64_t v6 = (uint64_t *)(v3 + 16 * v5);
    uint64_t v7 = *v6;
    if (v11 != *v6)
    {
      unint64_t v25 = 0;
      int v26 = 1;
      while (v7 != -4096)
      {
        if (v25) {
          BOOL v27 = 0;
        }
        else {
          BOOL v27 = v7 == -8192;
        }
        if (v27) {
          unint64_t v25 = v6;
        }
        unsigned int v28 = v5 + v26++;
        unsigned int v5 = v28 & v4;
        uint64_t v6 = (uint64_t *)(v3 + 16 * (v28 & v4));
        uint64_t v7 = *v6;
        if (v11 == *v6) {
          goto LABEL_4;
        }
      }
      if (v25) {
        uint64_t v6 = v25;
      }
      int v29 = *(_DWORD *)(a1 + 16);
      if (4 * v29 + 4 < 3 * v2)
      {
        if (v2 + ~v29 - *(_DWORD *)(a1 + 20) > v2 >> 3) {
          goto LABEL_26;
        }
        goto LABEL_42;
      }
LABEL_41:
      v2 *= 2;
LABEL_42:
      llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>::grow(v79, v2);
      uint64_t v30 = *(void *)(a1 + 8);
      int v31 = *(_DWORD *)(a1 + 24) - 1;
      unsigned int v32 = v31 & ((v11 >> 4) ^ (v11 >> 9));
      uint64_t v6 = (uint64_t *)(v30 + 16 * v32);
      uint64_t v33 = *v6;
      if (v11 == *v6)
      {
LABEL_43:
        ++*(_DWORD *)(a1 + 16);
        if (v11 == -4096) {
          goto LABEL_28;
        }
        goto LABEL_27;
      }
      uint64_t v34 = 0;
      int v35 = 1;
      while (v33 != -4096)
      {
        if (v34) {
          BOOL v36 = 0;
        }
        else {
          BOOL v36 = v33 == -8192;
        }
        if (v36) {
          uint64_t v34 = v6;
        }
        unsigned int v37 = v32 + v35++;
        unsigned int v32 = v37 & v31;
        uint64_t v6 = (uint64_t *)(v30 + 16 * (v37 & v31));
        uint64_t v33 = *v6;
        if (v11 == *v6) {
          goto LABEL_43;
        }
      }
      if (v34) {
        uint64_t v6 = v34;
      }
LABEL_26:
      uint64_t v24 = *v6;
      ++*(_DWORD *)(a1 + 16);
      if (v24 == -4096)
      {
LABEL_28:
        uint64_t *v6 = v11;
        *((_DWORD *)v6 + 2) = 0;
        goto LABEL_4;
      }
LABEL_27:
      --*(_DWORD *)(a1 + 20);
      goto LABEL_28;
    }
LABEL_4:
    if (v12 == *((_DWORD *)v6 + 2))
    {
      uint64_t v38 = *(char **)(a1 + 64);
      while (1)
      {
        uint64_t v45 = *(void *)(a1 + 40);
        unint64_t v46 = *(void *)(a1 + 72);
        if ((unint64_t)v38 < v46)
        {
          *(void *)uint64_t v38 = *(void *)(v45 - 8);
          uint64_t v47 = (uint64_t)(v38 + 8);
          goto LABEL_79;
        }
        unint64_t v48 = *(char **)(a1 + 56);
        uint64_t v49 = (v38 - v48) >> 3;
        unint64_t v50 = v49 + 1;
        if ((unint64_t)(v49 + 1) >> 61) {
          abort();
        }
        uint64_t v51 = v46 - (void)v48;
        if (v51 >> 2 > v50) {
          unint64_t v50 = v51 >> 2;
        }
        if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v52 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v52 = v50;
        }
        if (v52)
        {
          if (v52 >> 61) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v53 = (char *)operator new(8 * v52);
          int v54 = &v53[8 * v49];
          *(void *)int v54 = *(void *)(v45 - 8);
          uint64_t v47 = (uint64_t)(v54 + 8);
          if (v38 == v48) {
            goto LABEL_77;
          }
        }
        else
        {
          uint64_t v53 = 0;
          int v54 = (char *)(8 * v49);
          *(void *)(8 * v49) = *(void *)(v45 - 8);
          uint64_t v47 = 8 * v49 + 8;
          if (v38 == v48) {
            goto LABEL_77;
          }
        }
        unint64_t v55 = v38 - 8 - v48;
        if (v55 >= 0x168)
        {
          if (&v53[v38 - v48 - 8 - (v55 & 0xFFFFFFFFFFFFFFF8)] > &v53[v38 - v48 - 8])
          {
            uint64_t v56 = v38;
          }
          else if (&v38[-(v55 & 0xFFFFFFFFFFFFFFF8) - 8] > v38 - 8)
          {
            uint64_t v56 = v38;
          }
          else if ((unint64_t)(v48 - v53) >= 0x20)
          {
            uint64_t v60 = (v55 >> 3) + 1;
            uint64_t v61 = 8 * (v60 & 0x3FFFFFFFFFFFFFFCLL);
            uint64_t v56 = &v38[-v61];
            v54 -= v61;
            uint64_t v62 = &v53[8 * v49 - 16];
            uint64_t v63 = (long long *)(v38 - 16);
            uint64_t v64 = v60 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v65 = *v63;
              *((_OWORD *)v62 - 1) = *(v63 - 1);
              *(_OWORD *)uint64_t v62 = v65;
              v62 -= 32;
              v63 -= 2;
              v64 -= 4;
            }
            while (v64);
            if (v60 == (v60 & 0x3FFFFFFFFFFFFFFCLL)) {
              goto LABEL_76;
            }
          }
          else
          {
            uint64_t v56 = v38;
          }
        }
        else
        {
          uint64_t v56 = v38;
        }
        do
        {
          uint64_t v57 = *((void *)v56 - 1);
          v56 -= 8;
          *((void *)v54 - 1) = v57;
          v54 -= 8;
        }
        while (v56 != v48);
LABEL_76:
        uint64_t v38 = *(char **)(a1 + 56);
LABEL_77:
        *(void *)(a1 + 56) = v54;
        *(void *)(a1 + 64) = v47;
        *(void *)(a1 + 72) = &v53[8 * v52];
        if (v38) {
          operator delete(v38);
        }
LABEL_79:
        *(void *)(a1 + 64) = v47;
        *(void *)(a1 + 40) -= 8;
        unsigned int v58 = *(_DWORD *)(a1 + 24);
        if (!v58) {
          goto LABEL_108;
        }
        uint64_t v39 = *(void *)(a1 + 8);
        uint64_t v40 = *(void *)(v47 - 8);
        unsigned int v41 = v58 - 1;
        unsigned int v42 = ((v40 >> 4) ^ (v40 >> 9)) & (v58 - 1);
        unint64_t v43 = (uint64_t *)(v39 + 16 * v42);
        uint64_t v44 = *v43;
        if (v40 != *v43)
        {
          long long v66 = 0;
          int v67 = 1;
          while (v44 != -4096)
          {
            if (v66) {
              BOOL v68 = 0;
            }
            else {
              BOOL v68 = v44 == -8192;
            }
            if (v68) {
              long long v66 = v43;
            }
            unsigned int v69 = v42 + v67++;
            unsigned int v42 = v69 & v41;
            unint64_t v43 = (uint64_t *)(v39 + 16 * (v69 & v41));
            uint64_t v44 = *v43;
            if (v40 == *v43) {
              goto LABEL_59;
            }
          }
          if (v66) {
            unint64_t v43 = v66;
          }
          int v70 = *(_DWORD *)(a1 + 16);
          if (4 * v70 + 4 < 3 * v58)
          {
            if (v58 + ~v70 - *(_DWORD *)(a1 + 20) <= v58 >> 3) {
              goto LABEL_109;
            }
LABEL_82:
            uint64_t v59 = *v43;
          }
          else
          {
LABEL_108:
            v58 *= 2;
LABEL_109:
            llvm::DenseMap<mlir::Region *,unsigned int,llvm::DenseMapInfo<mlir::Region *,void>,llvm::detail::DenseMapPair<mlir::Region *,unsigned int>>::grow(v79, v58);
            uint64_t v71 = *(void *)(a1 + 8);
            uint64_t v59 = *(void *)(v47 - 8);
            int v72 = *(_DWORD *)(a1 + 24) - 1;
            unsigned int v73 = ((v59 >> 4) ^ (v59 >> 9)) & v72;
            unint64_t v43 = (uint64_t *)(v71 + 16 * v73);
            uint64_t v74 = *v43;
            if (v59 != *v43)
            {
              uint64_t v75 = 0;
              int v76 = 1;
              while (v74 != -4096)
              {
                if (v75) {
                  BOOL v77 = 0;
                }
                else {
                  BOOL v77 = v74 == -8192;
                }
                if (v77) {
                  uint64_t v75 = v43;
                }
                unsigned int v78 = v73 + v76++;
                unsigned int v73 = v78 & v72;
                unint64_t v43 = (uint64_t *)(v71 + 16 * (v78 & v72));
                uint64_t v74 = *v43;
                if (v59 == *v43) {
                  goto LABEL_83;
                }
              }
              if (v75) {
                unint64_t v43 = v75;
              }
              goto LABEL_82;
            }
          }
LABEL_83:
          ++*(_DWORD *)(a1 + 16);
          if (v59 != -4096) {
            --*(_DWORD *)(a1 + 20);
          }
          *unint64_t v43 = *(void *)(v47 - 8);
          *((_DWORD *)v43 + 2) = 0;
          uint64_t v47 = *(void *)(a1 + 64);
          uint64_t v40 = *(void *)(v47 - 8);
        }
LABEL_59:
        *((_DWORD *)v43 + 2) = -1;
        uint64_t v38 = (char *)v47;
        if (v40 == v11) {
          return;
        }
      }
    }
  }
}

unint64_t llvm::GraphTraits<mlir::CallGraphNode const*>::unwrap(void *a1)
{
  return *a1 & 0xFFFFFFFFFFFFFFF8;
}

void mlir::AnalysisState::~AnalysisState(mlir::AnalysisState *this)
{
  *(void *)this = &unk_1EC9AA3F8;
  unsigned int v2 = (char *)*((void *)this + 5);
  if (v2 != (char *)this + 56) {
    free(v2);
  }
  llvm::deallocate_buffer(*((llvm **)this + 2), (void *)(16 * *((unsigned int *)this + 8)));
}

uint64_t sub_1801872D0()
{
  return v0;
}

uint64_t mlir::ProgramPoint::getLoc(mlir::ProgramPoint *this)
{
  uint64_t v1 = *(void *)this & 6;
  unsigned int v2 = (mlir::Block *)(*(void *)this & 0xFFFFFFFFFFFFFFF8);
  if (v1) {
    BOOL v3 = 1;
  }
  else {
    BOOL v3 = v2 == 0;
  }
  if (v3)
  {
    if (v1 != 2 || v2 == 0)
    {
      if (v1 == 4) {
        unsigned int v5 = v2;
      }
      else {
        unsigned int v5 = 0;
      }
      uint64_t v9 = v5;
      if (v5)
      {
        return mlir::Value::getLoc((mlir::Value *)&v9);
      }
      else
      {
        Parent = (mlir::Region *)mlir::Block::getParent(v2);
        return mlir::Region::getLoc(Parent);
      }
    }
    else
    {
      return *((void *)v2 + 3);
    }
  }
  else
  {
    uint64_t v6 = *(uint64_t (**)(void))(*(void *)v2 + 16);
    return v6();
  }
}

uint64_t mlir::DataFlowSolver::initializeAndRun(mlir::DataFlowSolver *this, Operation *a2)
{
  uint64_t v3 = *((unsigned int *)this + 14);
  if (v3)
  {
    unsigned int v5 = (void *)*((void *)this + 6);
    uint64_t v6 = 8 * v3;
    while ((*(unsigned __int8 (**)(void, Operation *))(*(void *)*v5 + 16))(*v5, a2))
    {
      ++v5;
      v6 -= 8;
      if (!v6) {
        goto LABEL_7;
      }
    }
    return 0;
  }
  else
  {
LABEL_7:
    while (1)
    {
      uint64_t v7 = *((void *)this + 5);
      if (!v7) {
        break;
      }
      uint64_t v8 = (void **)*((void *)this + 1);
      unint64_t v9 = *((void *)this + 4);
      uint64_t v10 = (uint64_t *)(*(char **)((char *)v8 + ((v9 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v9);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      *((void *)this + 4) = ++v9;
      *((void *)this + 5) = v7 - 1;
      if (v9 >= 0x200)
      {
        operator delete(*v8);
        *((void *)this + 1) += 8;
        *((void *)this + 4) -= 256;
      }
      if (!(*(unsigned __int8 (**)(uint64_t, uint64_t))(*(void *)v12 + 24))(v12, v11)) {
        return 0;
      }
    }
    return 1;
  }
}

void *mlir::DataFlowAnalysis::DataFlowAnalysis(void *this, mlir::DataFlowSolver *a2)
{
  *this = &unk_1EC9AA768;
  this[1] = a2;
  return this;
}

void mlir::DataFlowAnalysis::addDependency(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  v8[0] = a3;
  v8[1] = a1;
  llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>,std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>::try_emplace<llvm::detail::DenseSetEmpty&>(a2 + 16, v8, (uint64_t)v7);
  if (v7[16])
  {
    long long v4 = *(_OWORD *)v8;
    uint64_t v5 = *(unsigned int *)(a2 + 48);
    if (v5 >= *(_DWORD *)(a2 + 52))
    {
      long long v6 = *(_OWORD *)v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 40, (void *)(a2 + 56), v5 + 1, 16);
      long long v4 = v6;
      LODWORD(v5) = *(_DWORD *)(a2 + 48);
    }
    *(_OWORD *)(*(void *)(a2 + 40) + 16 * v5) = v4;
    ++*(_DWORD *)(a2 + 48);
  }
}

uint64_t mlir::DataFlowAnalysis::propagateIfChanged(uint64_t result, uint64_t a2, int a3)
{
  if (a3 == 1) {
    return (*(uint64_t (**)(uint64_t, void))(*(void *)a2 + 24))(a2, *(void *)(result + 8));
  }
  return result;
}

void mlir::AnalysisState::onUpdate(mlir::AnalysisState *this, mlir::DataFlowSolver *a2)
{
  uint64_t v2 = *((unsigned int *)this + 12);
  if (v2)
  {
    long long v4 = (long long *)*((void *)this + 5);
    uint64_t v5 = *((void *)a2 + 5);
    uint64_t v6 = 16 * v2;
    do
    {
      uint64_t v7 = *((void *)a2 + 2);
      uint64_t v8 = *((void *)a2 + 1);
      long long v9 = *v4;
      if (v7 == v8) {
        uint64_t v10 = 0;
      }
      else {
        uint64_t v10 = 32 * (v7 - v8) - 1;
      }
      unint64_t v11 = v5 + *((void *)a2 + 4);
      if (v10 == v11)
      {
        long long v12 = *v4;
        std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::__add_back_capacity((uint64_t)a2);
        long long v9 = v12;
        uint64_t v8 = *((void *)a2 + 1);
        unint64_t v11 = *((void *)a2 + 5) + *((void *)a2 + 4);
      }
      *(_OWORD *)(*(void *)(v8 + ((v11 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v11) = v9;
      uint64_t v5 = *((void *)a2 + 5) + 1;
      *((void *)a2 + 5) = v5;
      ++v4;
      v6 -= 16;
    }
    while (v6);
  }
}

void std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::__add_back_capacity(uint64_t a1)
{
  unint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = v2 >= 0x100;
  unint64_t v4 = v2 - 256;
  if (v3)
  {
    *(void *)(a1 + 32) = v4;
    uint64_t v6 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v6 + 1);
    uint64_t v8 = *v6;
    *(void *)(a1 + 8) = v6 + 1;
    if (v5 != *(char **)(a1 + 24))
    {
LABEL_78:
      *(void *)uint64_t v5 = v8;
      *(void *)(a1 + 16) += 8;
      return;
    }
    long long v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v34 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v34 = 1;
      }
      if (!(v34 >> 61))
      {
        unint64_t v35 = v34 >> 2;
        uint64_t v36 = 8 * v34;
        unsigned int v37 = (char *)operator new(8 * v34);
        uint64_t v38 = &v37[8 * v35];
        uint64_t v39 = &v37[v36];
        int64_t v41 = v5 - v7;
        BOOL v40 = v5 == v7;
        uint64_t v5 = v38;
        if (!v40)
        {
          uint64_t v5 = &v38[v41 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v42 = v41 - 8;
          if ((unint64_t)(v41 - 8) >= 0x38)
          {
            int v76 = &v37[8 * v35];
            unint64_t v43 = v76;
            if ((unint64_t)(v76 - v7) >= 0x20)
            {
              uint64_t v77 = (v42 >> 3) + 1;
              uint64_t v78 = 8 * (v77 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v43 = &v38[v78];
              v7 += v78;
              uint64_t v79 = (long long *)(v6 + 3);
              long long v80 = v76 + 16;
              uint64_t v81 = v77 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v82 = *v79;
                *(v80 - 1) = *(v79 - 1);
                *long long v80 = v82;
                v79 += 2;
                v80 += 2;
                v81 -= 4;
              }
              while (v81);
              if (v77 == (v77 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_76;
              }
            }
          }
          else
          {
            unint64_t v43 = &v37[8 * v35];
          }
          do
          {
            uint64_t v83 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v43 = v83;
            v43 += 8;
          }
          while (v43 != v5);
        }
        goto LABEL_76;
      }
LABEL_86:
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
LABEL_5:
    uint64_t v11 = v10 >> 3;
    if (v11 >= -1) {
      uint64_t v12 = v11 + 1;
    }
    else {
      uint64_t v12 = v11 + 2;
    }
    uint64_t v13 = v12 >> 1;
    uint64_t v14 = -v13;
    uint64_t v15 = &v7[-8 * v13];
    int64_t v16 = v5 - v7;
    if (v5 != v7)
    {
      memmove(&v7[-8 * v13], v7, v5 - v7);
      uint64_t v7 = *(char **)(a1 + 8);
    }
    uint64_t v5 = &v15[v16];
    *(void *)(a1 + 8) = &v7[8 * v14];
    *(void *)(a1 + 16) = &v15[v16];
    goto LABEL_78;
  }
  uint64_t v18 = *(void *)(a1 + 16);
  uint64_t v17 = *(void *)(a1 + 24);
  uint64_t v19 = *(void *)(a1 + 8);
  uint64_t v20 = v18 - v19;
  uint64_t v21 = (v18 - v19) >> 3;
  uint64_t v22 = v17 - *(void *)a1;
  if (v21 < (unint64_t)(v22 >> 3))
  {
    if (v17 != v18)
    {
      uint64_t v92 = operator new(0x1000uLL);
      std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_back((char **)a1, &v92);
      return;
    }
    uint64_t v92 = operator new(0x1000uLL);
    std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front((void **)a1, &v92);
    uint64_t v44 = *(void **)(a1 + 8);
    uint64_t v5 = *(char **)(a1 + 16);
    uint64_t v7 = (char *)(v44 + 1);
    uint64_t v8 = *v44;
    *(void *)(a1 + 8) = v44 + 1;
    if (v5 != *(char **)(a1 + 24)) {
      goto LABEL_78;
    }
    long long v9 = *(char **)a1;
    uint64_t v10 = (uint64_t)&v7[-*(void *)a1];
    if ((unint64_t)v7 <= *(void *)a1)
    {
      unint64_t v45 = (v5 - v9) >> 2;
      if (v5 == v9) {
        unint64_t v45 = 1;
      }
      if (!(v45 >> 61))
      {
        unint64_t v46 = v45 >> 2;
        uint64_t v47 = 8 * v45;
        unsigned int v37 = (char *)operator new(8 * v45);
        uint64_t v38 = &v37[8 * v46];
        uint64_t v39 = &v37[v47];
        int64_t v48 = v5 - v7;
        BOOL v40 = v5 == v7;
        uint64_t v5 = v38;
        if (!v40)
        {
          uint64_t v5 = &v38[v48 & 0xFFFFFFFFFFFFFFF8];
          unint64_t v49 = v48 - 8;
          if ((unint64_t)(v48 - 8) >= 0x38)
          {
            uint64_t v84 = &v37[8 * v46];
            unint64_t v50 = v84;
            if ((unint64_t)(v84 - v7) >= 0x20)
            {
              uint64_t v85 = (v49 >> 3) + 1;
              uint64_t v86 = 8 * (v85 & 0x3FFFFFFFFFFFFFFCLL);
              unint64_t v50 = &v38[v86];
              v7 += v86;
              unint64_t v87 = (long long *)(v44 + 3);
              unint64_t v88 = v84 + 16;
              uint64_t v89 = v85 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v90 = *v87;
                *(v88 - 1) = *(v87 - 1);
                *unint64_t v88 = v90;
                v87 += 2;
                v88 += 2;
                v89 -= 4;
              }
              while (v89);
              if (v85 == (v85 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_76;
              }
            }
          }
          else
          {
            unint64_t v50 = &v37[8 * v46];
          }
          do
          {
            uint64_t v91 = *(void *)v7;
            v7 += 8;
            *(void *)unint64_t v50 = v91;
            v50 += 8;
          }
          while (v50 != v5);
        }
LABEL_76:
        *(void *)a1 = v37;
        *(void *)(a1 + 8) = v38;
        *(void *)(a1 + 16) = v5;
        *(void *)(a1 + 24) = v39;
        if (v9)
        {
          operator delete(v9);
          uint64_t v5 = *(char **)(a1 + 16);
        }
        goto LABEL_78;
      }
      goto LABEL_86;
    }
    goto LABEL_5;
  }
  uint64_t v23 = v22 >> 2;
  if (v17 == *(void *)a1) {
    unint64_t v24 = 1;
  }
  else {
    unint64_t v24 = v23;
  }
  if (v24 >> 61) {
    goto LABEL_86;
  }
  unint64_t v25 = (char *)operator new(8 * v24);
  int v26 = &v25[8 * v21];
  BOOL v27 = &v25[8 * v24];
  unsigned int v28 = operator new(0x1000uLL);
  int v29 = v28;
  if (v21 != v24) {
    goto LABEL_23;
  }
  if (v20 >= 1)
  {
    unint64_t v30 = v21 + 2;
    if (v21 >= -1) {
      unint64_t v30 = v21 + 1;
    }
    v26 -= 8 * (v30 >> 1);
LABEL_23:
    *(void *)int v26 = v28;
    int v31 = v26 + 8;
    if (v18 != v19) {
      goto LABEL_51;
    }
    goto LABEL_24;
  }
  if (v18 == v19) {
    unint64_t v51 = 1;
  }
  else {
    unint64_t v51 = v20 >> 2;
  }
  if (v51 >> 61) {
    goto LABEL_86;
  }
  uint64_t v52 = 8 * v51;
  uint64_t v53 = (char *)operator new(8 * v51);
  int v26 = &v53[8 * (v51 >> 2)];
  BOOL v27 = &v53[v52];
  operator delete(v25);
  uint64_t v54 = *(void *)(a1 + 8);
  uint64_t v18 = *(void *)(a1 + 16);
  unint64_t v25 = v53;
  *(void *)int v26 = v29;
  int v31 = v26 + 8;
  if (v18 != v54)
  {
    while (1)
    {
LABEL_51:
      if (v26 == v25)
      {
        if (v31 >= v27)
        {
          unint64_t v61 = (v27 - v26) >> 2;
          if (v27 == v26) {
            unint64_t v61 = 1;
          }
          if (v61 >> 61) {
            goto LABEL_86;
          }
          unint64_t v62 = (v61 + 3) >> 2;
          uint64_t v63 = 8 * v61;
          uint64_t v64 = (char *)operator new(8 * v61);
          unint64_t v25 = v64;
          unint64_t v55 = &v64[8 * v62];
          int64_t v65 = v31 - v26;
          BOOL v40 = v31 == v26;
          int v31 = v55;
          if (!v40)
          {
            int v31 = &v55[v65 & 0xFFFFFFFFFFFFFFF8];
            unint64_t v66 = v65 - 8;
            int v67 = &v64[8 * v62];
            BOOL v68 = v26;
            if (v66 < 0x38) {
              goto LABEL_89;
            }
            int v67 = &v64[8 * v62];
            BOOL v68 = v26;
            if ((unint64_t)(v67 - v26) < 0x20) {
              goto LABEL_89;
            }
            uint64_t v69 = (v66 >> 3) + 1;
            uint64_t v70 = 8 * (v69 & 0x3FFFFFFFFFFFFFFCLL);
            int v67 = &v55[v70];
            BOOL v68 = &v26[v70];
            uint64_t v71 = (long long *)(v26 + 16);
            int v72 = &v64[8 * v62 + 16];
            uint64_t v73 = v69 & 0x3FFFFFFFFFFFFFFCLL;
            do
            {
              long long v74 = *v71;
              *((_OWORD *)v72 - 1) = *(v71 - 1);
              *(_OWORD *)int v72 = v74;
              v71 += 2;
              v72 += 32;
              v73 -= 4;
            }
            while (v73);
            if (v69 != (v69 & 0x3FFFFFFFFFFFFFFCLL))
            {
LABEL_89:
              do
              {
                uint64_t v75 = *(void *)v68;
                v68 += 8;
                *(void *)int v67 = v75;
                v67 += 8;
              }
              while (v67 != v31);
            }
          }
          BOOL v27 = &v64[v63];
          operator delete(v26);
        }
        else
        {
          uint64_t v57 = (v27 - v31) >> 3;
          if (v57 >= -1) {
            unint64_t v58 = v57 + 1;
          }
          else {
            unint64_t v58 = v57 + 2;
          }
          uint64_t v59 = &v31[8 * (v58 >> 1)];
          unint64_t v55 = &v59[-(v31 - v26)];
          size_t v60 = v31 - v26;
          BOOL v40 = v31 == v26;
          int v31 = v59;
          if (!v40) {
            memmove(v55, v26, v60);
          }
          unint64_t v25 = v26;
        }
      }
      else
      {
        unint64_t v55 = v26;
      }
      uint64_t v56 = *(void *)(v18 - 8);
      v18 -= 8;
      *((void *)v55 - 1) = v56;
      unsigned int v32 = v55 - 8;
      int v26 = v32;
      if (v18 == *(void *)(a1 + 8)) {
        goto LABEL_25;
      }
    }
  }
LABEL_24:
  unsigned int v32 = v26;
LABEL_25:
  uint64_t v33 = *(char **)a1;
  *(void *)a1 = v25;
  *(void *)(a1 + 8) = v32;
  *(void *)(a1 + 16) = v31;
  *(void *)(a1 + 24) = v27;
  if (v33)
  {
    operator delete(v33);
  }
}

void std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_back(char **a1, void *a2)
{
  unint64_t v4 = a1[2];
  if (v4 != a1[3]) {
    goto LABEL_22;
  }
  uint64_t v5 = *a1;
  uint64_t v6 = a1[1];
  if (v6 > *a1)
  {
    uint64_t v7 = (v6 - *a1) >> 3;
    if (v7 >= -1) {
      uint64_t v8 = v7 + 1;
    }
    else {
      uint64_t v8 = v7 + 2;
    }
    uint64_t v9 = v8 >> 1;
    uint64_t v10 = -v9;
    uint64_t v11 = &v6[-8 * v9];
    int64_t v12 = v4 - v6;
    if (v4 != v6)
    {
      memmove(&v6[-8 * v9], a1[1], v4 - v6);
      unint64_t v4 = a1[1];
    }
    uint64_t v13 = &v4[8 * v10];
    unint64_t v4 = &v11[v12];
    a1[1] = v13;
    a1[2] = &v11[v12];
    goto LABEL_22;
  }
  unint64_t v14 = (v4 - v5) >> 2;
  if (v4 == v5) {
    unint64_t v14 = 1;
  }
  if (v14 >> 61) {
    std::__throw_bad_array_new_length[abi:nn180100]();
  }
  unint64_t v15 = v14 >> 2;
  uint64_t v16 = 8 * v14;
  uint64_t v17 = (char *)operator new(8 * v14);
  uint64_t v18 = &v17[8 * v15];
  int64_t v20 = v4 - v6;
  BOOL v19 = v4 == v6;
  unint64_t v4 = v18;
  if (!v19)
  {
    unint64_t v4 = &v18[v20 & 0xFFFFFFFFFFFFFFF8];
    unint64_t v21 = v20 - 8;
    if ((unint64_t)(v20 - 8) < 0x38)
    {
      uint64_t v22 = &v17[8 * v15];
      do
      {
LABEL_19:
        uint64_t v31 = *(void *)v6;
        v6 += 8;
        *(void *)uint64_t v22 = v31;
        v22 += 8;
      }
      while (v22 != v4);
      goto LABEL_20;
    }
    uint64_t v23 = &v17[8 * v15];
    uint64_t v22 = v23;
    if ((unint64_t)(v23 - v6) < 0x20) {
      goto LABEL_19;
    }
    uint64_t v24 = (v21 >> 3) + 1;
    uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v22 = &v18[v25];
    int v26 = &v6[v25];
    BOOL v27 = (long long *)(v6 + 16);
    unsigned int v28 = v23 + 16;
    uint64_t v29 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v30 = *v27;
      *(v28 - 1) = *(v27 - 1);
      *unsigned int v28 = v30;
      v27 += 2;
      v28 += 2;
      v29 -= 4;
    }
    while (v29);
    uint64_t v6 = v26;
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_19;
    }
  }
LABEL_20:
  *a1 = v17;
  a1[1] = v18;
  a1[2] = v4;
  a1[3] = &v17[v16];
  if (v5)
  {
    operator delete(v5);
    unint64_t v4 = a1[2];
  }
LABEL_22:
  *(void *)unint64_t v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *,std::allocator<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> *>>::push_front(void **a1, void *a2)
{
  unint64_t v4 = (char *)a1[1];
  if (v4 == *a1)
  {
    uint64_t v7 = a1[2];
    uint64_t v6 = a1[3];
    if (v7 >= v6)
    {
      uint64_t v13 = v6 - v4;
      BOOL v12 = v13 == 0;
      unint64_t v14 = v13 >> 2;
      if (v12) {
        unint64_t v14 = 1;
      }
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v15 = (v14 + 3) >> 2;
      uint64_t v16 = 8 * v14;
      uint64_t v17 = (char *)operator new(8 * v14);
      uint64_t v5 = &v17[8 * v15];
      uint64_t v18 = v5;
      uint64_t v19 = v7 - v4;
      if (v7 != v4)
      {
        uint64_t v18 = &v5[v19 & 0xFFFFFFFFFFFFFFF8];
        unint64_t v20 = v19 - 8;
        unint64_t v21 = &v17[8 * v15];
        uint64_t v22 = v4;
        if (v20 < 0x38) {
          goto LABEL_27;
        }
        uint64_t v23 = &v17[8 * v15];
        unint64_t v21 = v23;
        uint64_t v22 = v4;
        if ((unint64_t)(v23 - v4) < 0x20) {
          goto LABEL_27;
        }
        uint64_t v24 = (v20 >> 3) + 1;
        uint64_t v25 = 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v21 = &v5[v25];
        uint64_t v22 = &v4[v25];
        int v26 = (long long *)(v4 + 16);
        BOOL v27 = v23 + 16;
        uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v29 = *v26;
          *(v27 - 1) = *(v26 - 1);
          *BOOL v27 = v29;
          v26 += 2;
          v27 += 2;
          v28 -= 4;
        }
        while (v28);
        if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_27:
          do
          {
            uint64_t v30 = *(void *)v22;
            v22 += 8;
            *(void *)unint64_t v21 = v30;
            v21 += 8;
          }
          while (v21 != v18);
        }
      }
      *a1 = v17;
      a1[1] = v5;
      a1[2] = v18;
      a1[3] = &v17[v16];
      if (v4)
      {
        operator delete(v4);
        uint64_t v5 = (char *)a1[1];
      }
    }
    else
    {
      uint64_t v8 = (v6 - v7) >> 3;
      if (v8 >= -1) {
        uint64_t v9 = v8 + 1;
      }
      else {
        uint64_t v9 = v8 + 2;
      }
      uint64_t v10 = v9 >> 1;
      uint64_t v11 = &v7[8 * (v9 >> 1)];
      uint64_t v5 = &v11[-(v7 - v4)];
      if (v7 != v4)
      {
        memmove(&v11[-(v7 - v4)], v4, v7 - v4);
        unint64_t v4 = (char *)a1[2];
      }
      a1[1] = v5;
      a1[2] = &v4[8 * v10];
    }
  }
  else
  {
    uint64_t v5 = (char *)a1[1];
  }
  *((void *)v5 - 1) = *a2;
  a1[1] = (char *)a1[1] - 8;
}

void *llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>,std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>::try_emplace<llvm::detail::DenseSetEmpty&>@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(void *)a1;
    uint64_t v8 = *a2;
    uint64_t v9 = a2[1];
    unint64_t v10 = ((0x2500000000 * *a2) | (v9 >> 4) ^ (v9 >> 9))
        + ~((unint64_t)((v9 >> 4) ^ (v9 >> 9)) << 32);
    unint64_t v11 = (v10 ^ (v10 >> 22)) + ~((v10 ^ (v10 >> 22)) << 13);
    unint64_t v12 = (9 * (v11 ^ (v11 >> 8))) ^ ((9 * (v11 ^ (v11 >> 8))) >> 15);
    unsigned int v13 = (v6 - 1) & (((v12 + ~(v12 << 27)) >> 31) ^ (v12 + ~(v12 << 27)));
    BOOL result = (void *)(*(void *)a1 + 16 * v13);
    uint64_t v15 = *result;
    uint64_t v16 = result[1];
    if (*a2 == *result && v9 == v16)
    {
LABEL_7:
      *(void *)a3 = result;
      *(void *)(a3 + 8) = v7 + 16 * v6;
      *(unsigned char *)(a3 + 16) = 0;
      return result;
    }
    unint64_t v20 = 0;
    int v21 = 1;
    while (v15 != -4096 || v16 != -4096)
    {
      if (v20) {
        BOOL v22 = 0;
      }
      else {
        BOOL v22 = v16 == -8192;
      }
      if (v22 && v15 == -8192) {
        unint64_t v20 = result;
      }
      unsigned int v24 = v13 + v21++;
      unsigned int v13 = v24 & (v6 - 1);
      BOOL result = (void *)(v7 + 16 * v13);
      uint64_t v15 = *result;
      uint64_t v16 = result[1];
      if (v8 == *result && v9 == v16) {
        goto LABEL_7;
      }
    }
    if (v20) {
      uint64_t v18 = v20;
    }
    else {
      uint64_t v18 = result;
    }
  }
  else
  {
    uint64_t v18 = 0;
  }
  BOOL result = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>,std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>::InsertIntoBucket<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> const&,llvm::detail::DenseSetEmpty&>(a1, v18, a2);
  uint64_t v19 = *(void *)a1 + 16 * *(unsigned int *)(a1 + 16);
  *(void *)a3 = result;
  *(void *)(a3 + 8) = v19;
  *(unsigned char *)(a3 + 16) = 1;
  return result;
}

void *llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>,std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>::InsertIntoBucket<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *> const&,llvm::detail::DenseSetEmpty&>(uint64_t a1, void *a2, void *a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
    goto LABEL_3;
  }
  llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>::grow(a1, v7);
  int v9 = *(_DWORD *)(a1 + 16);
  if (v9)
  {
    uint64_t v10 = a3[1];
    unint64_t v11 = ((0x2500000000 * *a3) | (v10 >> 4) ^ (v10 >> 9))
        + ~((unint64_t)((v10 >> 4) ^ (v10 >> 9)) << 32);
    unint64_t v12 = (v11 ^ (v11 >> 22)) + ~((v11 ^ (v11 >> 22)) << 13);
    unint64_t v13 = (9 * (v12 ^ (v12 >> 8))) ^ ((9 * (v12 ^ (v12 >> 8))) >> 15);
    int v14 = ((v13 + ~(v13 << 27)) >> 31) ^ (v13 + ~(v13 << 27));
    int v15 = v9 - 1;
    unsigned int v16 = (v9 - 1) & v14;
    a2 = (void *)(*(void *)a1 + 16 * v16);
    uint64_t v17 = *a2;
    uint64_t v18 = a2[1];
    if (*a3 != *a2 || v10 != v18)
    {
      unint64_t v20 = 0;
      int v21 = 1;
      while (v17 != -4096 || v18 != -4096)
      {
        if (v20) {
          BOOL v22 = 0;
        }
        else {
          BOOL v22 = v18 == -8192;
        }
        if (v22 && v17 == -8192) {
          unint64_t v20 = a2;
        }
        unsigned int v24 = v16 + v21++;
        unsigned int v16 = v24 & v15;
        a2 = (void *)(*(void *)a1 + 16 * (v24 & v15));
        uint64_t v17 = *a2;
        uint64_t v18 = a2[1];
        if (*a3 == *a2 && v10 == v18) {
          goto LABEL_3;
        }
      }
      if (v20) {
        a2 = v20;
      }
    }
  }
  else
  {
    a2 = 0;
  }
LABEL_3:
  ++*(_DWORD *)(a1 + 8);
  if (*a2 != -4096 || a2[1] != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *a2 = *a3;
  a2[1] = a3[1];
  return a2;
}

void llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  unint64_t v4 = *(uint64_t **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  buffer = llvm::allocate_buffer(16 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = buffer;
  if (v4)
  {
    uint64_t v10 = (char *)(16 * v3);
    llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>,std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>::moveFromOldBuckets(a1, v4, (uint64_t *)&v10[(void)v4]);
    llvm::deallocate_buffer((llvm *)v4, v10);
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v11 = *(unsigned int *)(a1 + 16);
  if (v11)
  {
    memset_pattern16(buffer, &unk_1810FE110, 16 * v11);
  }
}

void llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>,std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>,void>,llvm::detail::DenseSetPair<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>>::moveFromOldBuckets(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  *(void *)(a1 + 8) = 0;
  uint64_t v6 = *(unsigned int *)(a1 + 16);
  if (v6) {
    memset_pattern16(*(void **)a1, &unk_1810FE110, 16 * v6);
  }
  for (; a2 != a3; a2 += 2)
  {
    uint64_t v17 = *a2;
    uint64_t v18 = a2[1];
    if ((*a2 != -4096 || v18 != -4096) && (v17 != -8192 || v18 != -8192))
    {
      unint64_t v7 = ((0x2500000000 * v17) | (v18 >> 4) ^ (v18 >> 9))
         + ~((unint64_t)((v18 >> 4) ^ (v18 >> 9)) << 32);
      unint64_t v8 = (v7 ^ (v7 >> 22)) + ~((v7 ^ (v7 >> 22)) << 13);
      unint64_t v9 = (9 * (v8 ^ (v8 >> 8))) ^ ((9 * (v8 ^ (v8 >> 8))) >> 15);
      int v10 = ((v9 + ~(v9 << 27)) >> 31) ^ (v9 + ~(v9 << 27));
      int v11 = *(_DWORD *)(a1 + 16) - 1;
      unsigned int v12 = v11 & v10;
      unint64_t v13 = (void *)(*(void *)a1 + 16 * v12);
      uint64_t v14 = *v13;
      uint64_t v15 = v13[1];
      if (v17 != *v13 || v18 != v15)
      {
        uint64_t v19 = 0;
        int v20 = 1;
        while (v14 != -4096 || v15 != -4096)
        {
          if (v19) {
            BOOL v21 = 0;
          }
          else {
            BOOL v21 = v15 == -8192;
          }
          if (v21 && v14 == -8192) {
            uint64_t v19 = v13;
          }
          unsigned int v23 = v12 + v20++;
          unsigned int v12 = v23 & v11;
          unint64_t v13 = (void *)(*(void *)a1 + 16 * (v23 & v11));
          uint64_t v14 = *v13;
          uint64_t v15 = v13[1];
          if (v17 == *v13 && v18 == v15) {
            goto LABEL_10;
          }
        }
        if (v19) {
          unint64_t v13 = v19;
        }
      }
LABEL_10:
      *unint64_t v13 = v17;
      v13[1] = a2[1];
      ++*(_DWORD *)(a1 + 8);
    }
  }
}

void mlir::Liveness::build(mlir::ForwardIterator **this)
{
  uint64_t v70 = 0;
  uint64_t v71 = 0;
  unsigned int v72 = 0;
  uint64_t v1 = *this;
  uint64_t v73 = 0;
  int32x2_t v74 = 0;
  unsigned int v75 = 0;
  int v76 = &v78;
  uint64_t v77 = 0;
  uint64_t v78 = &v70;
  uint64_t v79 = &v73;
  unsigned int v2 = v77;
  if (!v77)
  {
LABEL_133:
    if (v76 != &v78) {
      free(v76);
    }
    llvm::deallocate_buffer(v73, (void *)(8 * v75));
  }
  while (1)
  {
    uint64_t v3 = (void **)*((void *)v76 + v2 - 1);
    unsigned int v4 = v3 >> 4;
    if (v75)
    {
      LODWORD(v5) = (v4 ^ (v3 >> 9)) & (v75 - 1);
      uint64_t v6 = (char *)v73 + 8 * v5;
      unint64_t v7 = *(void ***)v6;
      if (v3 != *(void ***)v6)
      {
        int v62 = 1;
        do
        {
          if (v7 == (void **)-4096) {
            goto LABEL_7;
          }
          int v63 = v5 + v62++;
          uint64_t v5 = v63 & (v75 - 1);
          unint64_t v7 = (void **)*((void *)v73 + v5);
        }
        while (v3 != v7);
        uint64_t v6 = (char *)v73 + 8 * v5;
      }
      *(void *)uint64_t v6 = -8192;
      int32x2_t v74 = vadd_s32(v74, (int32x2_t)0x1FFFFFFFFLL);
    }
LABEL_7:
    LODWORD(v77) = v2 - 1;
    int v8 = v72;
    if (!v72) {
      goto LABEL_117;
    }
    unsigned int v9 = (v72 - 1) & (v4 ^ (v3 >> 9));
    int v10 = (char *)v70 + 656 * v9;
    uint64_t v11 = *(void *)v10;
    if (*(void ***)v10 == v3) {
      goto LABEL_23;
    }
    unsigned int v12 = 0;
    int v13 = 1;
    while (v11 != -4096)
    {
      if (v12) {
        BOOL v14 = 0;
      }
      else {
        BOOL v14 = v11 == -8192;
      }
      if (v14) {
        unsigned int v12 = v10;
      }
      unsigned int v15 = v9 + v13++;
      unsigned int v9 = v15 & (v72 - 1);
      int v10 = (char *)v70 + 656 * v9;
      uint64_t v11 = *(void *)v10;
      if (*(void ***)v10 == v3) {
        goto LABEL_23;
      }
    }
    if (v12) {
      int v10 = v12;
    }
    if (4 * (int)v71 + 4 < 3 * v72)
    {
      if (v72 + ~v71 - HIDWORD(v71) > v72 >> 3) {
        goto LABEL_20;
      }
    }
    else
    {
LABEL_117:
      int v8 = 2 * v72;
    }
    unsigned int v64 = (v72 - 1) & (v4 ^ (v3 >> 9));
    int v10 = (char *)v70 + 656 * v64;
    uint64_t v65 = *(void *)v10;
    if (*(void ***)v10 == v3)
    {
LABEL_119:
      LODWORD(v71) = v71 + 1;
      if (v3 == (void **)-4096) {
        goto LABEL_22;
      }
LABEL_21:
      --HIDWORD(v71);
      goto LABEL_22;
    }
    unint64_t v66 = 0;
    int v67 = 1;
    while (v65 != -4096)
    {
      if (v66) {
        BOOL v68 = 0;
      }
      else {
        BOOL v68 = v65 == -8192;
      }
      if (v68) {
        unint64_t v66 = v10;
      }
      unsigned int v69 = v64 + v67++;
      unsigned int v64 = v69 & (v72 - 1);
      int v10 = (char *)v70 + 656 * v64;
      uint64_t v65 = *(void *)v10;
      if (*(void ***)v10 == v3) {
        goto LABEL_119;
      }
    }
    if (v66) {
      int v10 = v66;
    }
LABEL_20:
    uint64_t v16 = *(void *)v10;
    LODWORD(v71) = v71 + 1;
    if (v16 != -4096) {
      goto LABEL_21;
    }
LABEL_22:
    *(void *)int v10 = v3;
    bzero(v10 + 8, 0x288uLL);
    *((void *)v10 + 2) = v10 + 48;
    *((void *)v10 + 3) = v10 + 48;
    *((_DWORD *)v10 + 8) = 16;
    *((void *)v10 + 22) = v10 + 208;
    *((void *)v10 + 23) = v10 + 208;
    *((_DWORD *)v10 + 48) = 16;
    *((void *)v10 + 42) = v10 + 368;
    *((void *)v10 + 43) = v10 + 368;
    *((_DWORD *)v10 + 88) = 16;
    *((void *)v10 + 62) = v10 + 528;
    *((void *)v10 + 63) = v10 + 528;
    *((_DWORD *)v10 + 128) = 16;
LABEL_23:
    mlir::SuccessorRange::SuccessorRange((mlir::SuccessorRange *)&v78, *((mlir::Block **)v10 + 1));
    uint64_t v17 = v79;
    if (v79)
    {
      uint64_t v18 = 0;
      uint64_t v19 = v78;
      do
      {
        if (v72)
        {
          int v20 = v19[4 * (void)v18 + 3];
          unsigned int v21 = ((v20 >> 4) ^ (v20 >> 9)) & (v72 - 1);
          BOOL v22 = (void *)((char *)v70 + 656 * v21);
          unsigned int v23 = (llvm *)*v22;
          if ((llvm *)*v22 == v20) {
            goto LABEL_33;
          }
          int v24 = 1;
          while (v23 != (llvm *)-4096)
          {
            unsigned int v25 = v21 + v24++;
            unsigned int v21 = v25 & (v72 - 1);
            BOOL v22 = (void *)((char *)v70 + 656 * v21);
            unsigned int v23 = (llvm *)*v22;
            if ((llvm *)*v22 == v20) {
              goto LABEL_33;
            }
          }
        }
        BOOL v22 = (void *)((char *)v70 + 656 * v72);
LABEL_33:
        uint64_t v26 = v22[3];
        if (v26 == v22[2]) {
          BOOL v27 = (unsigned int *)v22 + 9;
        }
        else {
          BOOL v27 = (unsigned int *)(v22 + 4);
        }
        uint64_t v28 = *v27;
        if (v28)
        {
          uint64_t v29 = 8 * v28;
          uint64_t v30 = (const void **)v22[3];
          while ((unint64_t)*v30 >= 0xFFFFFFFFFFFFFFFELL)
          {
            ++v30;
            v29 -= 8;
            if (!v29) {
              goto LABEL_25;
            }
          }
        }
        else
        {
          uint64_t v30 = (const void **)v22[3];
        }
        uint64_t v31 = (const void **)(v26 + 8 * v28);
        if (v30 != v31)
        {
          unsigned int v32 = (void *)*((void *)v10 + 22);
          uint64_t v33 = (void *)*((void *)v10 + 23);
          unint64_t v34 = *v30;
          while (v33 == v32)
          {
            uint64_t v35 = *((unsigned int *)v10 + 49);
            if (!v35) {
              goto LABEL_61;
            }
            uint64_t v36 = 0;
            uint64_t v37 = 8 * v35;
            uint64_t v38 = v32;
            do
            {
              if ((const void *)*v38 == v34) {
                goto LABEL_46;
              }
              if (*v38 == -2) {
                uint64_t v36 = v38;
              }
              ++v38;
              v37 -= 8;
            }
            while (v37);
            if (v36)
            {
              void *v36 = v34;
              --*((_DWORD *)v10 + 50);
            }
            else
            {
LABEL_61:
              if (v35 >= *((_DWORD *)v10 + 48)) {
                break;
              }
              *((_DWORD *)v10 + 49) = v35 + 1;
              v32[v35] = v34;
            }
LABEL_46:
            if (++v30 != v31)
            {
              unsigned int v32 = (void *)*((void *)v10 + 22);
              uint64_t v33 = (void *)*((void *)v10 + 23);
              while (1)
              {
                unint64_t v34 = *v30;
                if ((unint64_t)*v30 < 0xFFFFFFFFFFFFFFFELL) {
                  break;
                }
                if (++v30 == v31) {
                  goto LABEL_25;
                }
              }
              if (v30 != v31) {
                continue;
              }
            }
            goto LABEL_25;
          }
          llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(v10 + 176), v34);
          goto LABEL_46;
        }
LABEL_25:
        uint64_t v18 = (llvm **)((char *)v18 + 1);
      }
      while (v18 != v17);
    }
    llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v78, &v82, (const llvm::SmallPtrSetImplBase *)(v10 + 496));
    llvm::set_union<llvm::SmallPtrSet<mlir::Value,16u>,llvm::SmallPtrSet<mlir::Value,16u>>((llvm::SmallPtrSetImplBase *)&v78, (void *)v10 + 22);
    llvm::set_subtract<llvm::SmallPtrSet<mlir::Value,16u>,llvm::SmallPtrSet<mlir::Value,16u>>((const void **)&v78, (void *)v10 + 42);
    int v39 = v80 - v81;
    int v40 = *((_DWORD *)v10 + 9) - *((_DWORD *)v10 + 10);
    if (&v78 != (llvm ***)(v10 + 16) && v39 != v40) {
      llvm::SmallPtrSetImplBase::MoveFrom((uint64_t)(v10 + 16), 16, (double *)&v78);
    }
    if (v79 != v78) {
      free(v79);
    }
    if (v39 != v40)
    {
      int64_t v41 = *v3;
      if (*v3)
      {
        while (1)
        {
          uint64_t v45 = mlir::PredecessorIterator::unwrap((uint64_t)v41);
          uint64_t v46 = v45;
          int v47 = v75;
          if (!v75) {
            goto LABEL_94;
          }
          unsigned int v42 = ((v45 >> 4) ^ (v45 >> 9)) & (v75 - 1);
          unint64_t v43 = (char *)v73 + 8 * v42;
          uint64_t v44 = *(void *)v43;
          if (v45 != *(void *)v43) {
            break;
          }
LABEL_72:
          int64_t v41 = (void *)*v41;
          if (!v41) {
            goto LABEL_3;
          }
        }
        unint64_t v50 = 0;
        int v51 = 1;
        while (v44 != -4096)
        {
          if (v50) {
            BOOL v52 = 0;
          }
          else {
            BOOL v52 = v44 == -8192;
          }
          if (v52) {
            unint64_t v50 = v43;
          }
          unsigned int v53 = v42 + v51++;
          unsigned int v42 = v53 & (v75 - 1);
          unint64_t v43 = (char *)v73 + 8 * v42;
          uint64_t v44 = *(void *)v43;
          if (v45 == *(void *)v43) {
            goto LABEL_72;
          }
        }
        if (v50) {
          uint64_t v54 = v50;
        }
        else {
          uint64_t v54 = v43;
        }
        if (4 * v74.i32[0] + 4 < 3 * v75)
        {
          if (v75 + ~v74.i32[0] - v74.i32[1] <= v75 >> 3) {
            goto LABEL_95;
          }
        }
        else
        {
LABEL_94:
          int v47 = 2 * v75;
LABEL_95:
          llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::grow((uint64_t)&v73, v47);
          unsigned int v55 = v75 - 1;
          unsigned int v56 = (v75 - 1) & ((v46 >> 4) ^ (v46 >> 9));
          uint64_t v54 = (char *)v73 + 8 * v56;
          uint64_t v57 = *(void *)v54;
          if (v46 == *(void *)v54)
          {
LABEL_96:
            ++v74.i32[0];
            if (v46 == -4096) {
              goto LABEL_78;
            }
LABEL_77:
            --v74.i32[1];
LABEL_78:
            *(void *)uint64_t v54 = v46;
            uint64_t v49 = v77;
            if (v77 >= (unint64_t)HIDWORD(v77))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, &v78, v77 + 1, 8);
              uint64_t v49 = v77;
            }
            *((void *)v76 + v49) = v46;
            LODWORD(v77) = v77 + 1;
            goto LABEL_72;
          }
          unint64_t v58 = 0;
          int v59 = 1;
          while (v57 != -4096)
          {
            if (v58) {
              BOOL v60 = 0;
            }
            else {
              BOOL v60 = v57 == -8192;
            }
            if (v60) {
              unint64_t v58 = v54;
            }
            unsigned int v61 = v56 + v59++;
            unsigned int v56 = v61 & v55;
            uint64_t v54 = (char *)v73 + 8 * (v61 & v55);
            uint64_t v57 = *(void *)v54;
            if (v46 == *(void *)v54) {
              goto LABEL_96;
            }
          }
          if (v58) {
            uint64_t v54 = v58;
          }
        }
        uint64_t v48 = *(void *)v54;
        ++v74.i32[0];
        if (v48 != -4096) {
          goto LABEL_77;
        }
        goto LABEL_78;
      }
    }
LABEL_3:
    unsigned int v2 = v77;
    if (!v77) {
      goto LABEL_133;
    }
  }
}

void mlir::Liveness::Liveness(mlir::Liveness *this, mlir::Operation *a2)
{
  *((void *)this + 1) = 0;
  *((void *)this + 2) = 0;
  *(void *)this = a2;
  *((_DWORD *)this + 6) = 0;
  mlir::Liveness::build((mlir::ForwardIterator **)this);
}

uint64_t sub_180188D88()
{
  return v0;
}

uint64_t *mlir::Liveness::getLiveness(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 8);
  unsigned int v3 = *(_DWORD *)(a1 + 24);
  if (!v3) {
    return 0;
  }
  unsigned int v4 = (v3 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v5 = (uint64_t *)(v2 + 336 * v4);
  uint64_t v6 = *v5;
  if (*v5 != a2)
  {
    int v8 = 1;
    while (v6 != -4096)
    {
      unsigned int v9 = v4 + v8++;
      unsigned int v4 = v9 & (v3 - 1);
      uint64_t v5 = (uint64_t *)(v2 + 336 * v4);
      uint64_t v6 = *v5;
      if (*v5 == a2) {
        goto LABEL_3;
      }
    }
    return 0;
  }
LABEL_3:
  if (v5 == (uint64_t *)(v2 + 336 * v3)) {
    return 0;
  }
  else {
    return v5 + 1;
  }
}

void mlir::LivenessBlockInfo::getEndOperation(uint64_t a1, uint64_t **a2, mlir::Block **a3)
{
  uint64_t v8 = *(void *)(a1 + 168);
  uint64_t v7 = *(void *)(a1 + 176);
  uint64_t v6 = (llvm::SmallPtrSetImplBase *)(a1 + 168);
  if (v7 == v8)
  {
    uint64_t v12 = *(unsigned int *)(a1 + 188);
    BucketFor = (const void **)(v7 + 8 * v12);
    if (v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = 8 * v12;
      while (*(uint64_t ***)(v7 + v13) != a2)
      {
        v13 += 8;
        if (v14 == v13) {
          goto LABEL_12;
        }
      }
      BucketFor = (const void **)(v7 + v13);
    }
LABEL_12:
    uint64_t v10 = v7;
  }
  else
  {
    BucketFor = llvm::SmallPtrSetImplBase::FindBucketFor(v6, a2);
    uint64_t v7 = *(void *)(a1 + 168);
    uint64_t v10 = *(void *)(a1 + 176);
    if (*BucketFor != a2)
    {
      uint64_t v11 = 184;
      if (v10 == v7) {
        uint64_t v11 = 188;
      }
      BucketFor = (const void **)(v10 + 8 * *(unsigned int *)(a1 + v11));
    }
  }
  BOOL v15 = v10 == v7;
  uint64_t v16 = 184;
  if (v15) {
    uint64_t v16 = 188;
  }
  if (BucketFor == (const void **)(v10 + 8 * *(unsigned int *)(a1 + v16)))
  {
    uint64_t v18 = (uint64_t **)*a2;
    if (*a2)
    {
      do
      {
        AncestorOpInBlock = mlir::Block::findAncestorOpInBlock(*(mlir::Block **)a1, (Operation *)v18[2]);
        if (AncestorOpInBlock)
        {
          int v20 = (mlir::Block **)AncestorOpInBlock;
          if (mlir::Operation::isBeforeInBlock(a3, AncestorOpInBlock)) {
            a3 = v20;
          }
        }
        uint64_t v18 = (uint64_t **)*v18;
      }
      while (v18);
    }
  }
  else
  {
    uint64_t v17 = *(mlir::GenericProgramPoint **)(*(void *)a1 + 32);
    mlir::GenericProgramPoint::~GenericProgramPoint(v17);
  }
}

BOOL mlir::Liveness::isDeadAfter(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 24);
  if (v6)
  {
    uint64_t v7 = *(void *)(a3 + 16);
    unsigned int v8 = ((v7 >> 4) ^ (v7 >> 9)) & (v6 - 1);
    unsigned int v9 = (uint64_t *)(v5 + 336 * v8);
    uint64_t v10 = *v9;
    if (*v9 == v7) {
      goto LABEL_8;
    }
    int v11 = 1;
    while (v10 != -4096)
    {
      unsigned int v12 = v8 + v11++;
      unsigned int v8 = v12 & (v6 - 1);
      unsigned int v9 = (uint64_t *)(v5 + 336 * v8);
      uint64_t v10 = *v9;
      if (*v9 == v7) {
        goto LABEL_8;
      }
    }
  }
  unsigned int v9 = (uint64_t *)(v5 + 336 * v6);
LABEL_8:
  if (v9 == (uint64_t *)(v5 + 336 * v6)) {
    uint64_t v13 = 0;
  }
  else {
    uint64_t v13 = (uint64_t)(v9 + 1);
  }
  uint64_t v14 = *(void *)(v13 + 176);
  if (v14 == *(void *)(v13 + 168))
  {
    uint64_t v18 = *(unsigned int *)(v13 + 188);
    BucketFor = (const void **)(v14 + 8 * v18);
    if (v18)
    {
      uint64_t v19 = 0;
      uint64_t v20 = 8 * v18;
      while (*(void **)(v14 + v19) != a2)
      {
        v19 += 8;
        if (v20 == v19) {
          goto LABEL_22;
        }
      }
      BucketFor = (const void **)(v14 + v19);
    }
LABEL_22:
    uint64_t v16 = *(void *)(v13 + 176);
  }
  else
  {
    BucketFor = llvm::SmallPtrSetImplBase::FindBucketFor((llvm::SmallPtrSetImplBase *)(v13 + 168), a2);
    uint64_t v14 = *(void *)(v13 + 168);
    uint64_t v16 = *(void *)(v13 + 176);
    if (*BucketFor != a2)
    {
      uint64_t v17 = 184;
      if (v16 == v14) {
        uint64_t v17 = 188;
      }
      BucketFor = (const void **)(v16 + 8 * *(unsigned int *)(v13 + v17));
    }
  }
  BOOL v21 = v16 == v14;
  uint64_t v22 = 184;
  if (v21) {
    uint64_t v22 = 188;
  }
  if (BucketFor != (const void **)(v16 + 8 * *(unsigned int *)(v13 + v22))) {
    return 0;
  }
  mlir::LivenessBlockInfo::getEndOperation(v13, (uint64_t **)a2, (mlir::Block **)a3);
  if (v24 == (mlir::Block **)a3) {
    return 1;
  }

  return mlir::Operation::isBeforeInBlock(v24, (mlir::Operation *)a3);
}

uint64_t mlir::detail::walk<mlir::ForwardIterator>(mlir::ForwardIterator *a1, mlir::Operation *a2, uint64_t a3, int a4)
{
  uint64_t result = mlir::ForwardIterator::makeIterable(a1, a2);
  if (v8)
  {
    uint64_t v9 = result;
    uint64_t v10 = result + 24 * v8;
    if (a4)
    {
      if (a4 == 1)
      {
        do
        {
          uint64_t v16 = *(void *)(v9 + 8);
          if (v16 != v9)
          {
            do
            {
              uint64_t v17 = *(void *)(v16 + 8);
              if (v16) {
                uint64_t v18 = v16 - 8;
              }
              else {
                uint64_t v18 = 0;
              }
              for (uint64_t i = *(mlir::GenericProgramPoint **)(v18 + 40);
                    i != (mlir::GenericProgramPoint *)(v18 + 32);
                    uint64_t i = (mlir::GenericProgramPoint *)*((void *)i + 1))
              {
                mlir::GenericProgramPoint::~GenericProgramPoint(i);
                mlir::detail::walk<mlir::ForwardIterator>();
              }
              uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2)(a3, v18);
              uint64_t v16 = v17;
            }
            while (v17 != v9);
          }
          v9 += 24;
        }
        while (v9 != v10);
      }
      else
      {
        do
        {
          uint64_t v20 = *(void *)(v9 + 8);
          if (v20 != v9)
          {
            do
            {
              uint64_t v21 = *(void *)(v20 + 8);
              if (v20) {
                uint64_t v22 = v20 - 8;
              }
              else {
                uint64_t v22 = 0;
              }
              unsigned int v23 = (mlir::GenericProgramPoint *)(v22 + 32);
              int v24 = *(mlir::GenericProgramPoint **)(v22 + 40);
              if (v24 != (mlir::GenericProgramPoint *)(v22 + 32))
              {
                do
                {
                  mlir::GenericProgramPoint::~GenericProgramPoint(v24);
                  uint64_t result = mlir::detail::walk<mlir::ForwardIterator>();
                  int v24 = (mlir::GenericProgramPoint *)*((void *)v24 + 1);
                }
                while (v24 != v23);
              }
              uint64_t v20 = v21;
            }
            while (v21 != v9);
          }
          v9 += 24;
        }
        while (v9 != v10);
      }
    }
    else
    {
      do
      {
        uint64_t v11 = *(void *)(v9 + 8);
        if (v11 != v9)
        {
          do
          {
            uint64_t v12 = *(void *)(v11 + 8);
            if (v11) {
              uint64_t v13 = v11 - 8;
            }
            else {
              uint64_t v13 = 0;
            }
            uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2)(a3, v13);
            uint64_t v14 = (mlir::GenericProgramPoint *)(v13 + 32);
            for (uint64_t j = *(mlir::GenericProgramPoint **)(v13 + 40);
                  j != v14;
                  uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
            {
              mlir::GenericProgramPoint::~GenericProgramPoint(j);
              uint64_t result = mlir::detail::walk<mlir::ForwardIterator>();
            }
            uint64_t v11 = v12;
          }
          while (v12 != v9);
        }
        v9 += 24;
      }
      while (v9 != v10);
    }
  }
  return result;
}

{
  uint64_t Iterable;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  mlir::GenericProgramPoint *v13;
  mlir::GenericProgramPoint *v14;
  mlir::GenericProgramPoint *v15;
  int v16;
  uint64_t result;
  uint64_t vars8;

  if (!a4)
  {
    uint64_t result = ((uint64_t (*)(uint64_t, mlir::ForwardIterator *))a2)(a3, a1);
    if (!result) {
      return result;
    }
    if (result == 2) {
      return 1;
    }
  }
  Iterable = mlir::ForwardIterator::makeIterable(a1, a2);
  if (v8)
  {
    uint64_t v9 = Iterable;
    uint64_t v10 = Iterable + 24 * v8;
    do
    {
      for (uint64_t i = *(void *)(v9 + 8); i != v9; uint64_t i = *(void *)(i + 8))
      {
        uint64_t v12 = i - 8;
        if (!i) {
          uint64_t v12 = 0;
        }
        uint64_t v13 = (mlir::GenericProgramPoint *)(v12 + 32);
        uint64_t v14 = *(mlir::GenericProgramPoint **)(v12 + 40);
        while (v14 != v13)
        {
          BOOL v15 = (mlir::GenericProgramPoint *)*((void *)v14 + 1);
          mlir::GenericProgramPoint::~GenericProgramPoint(v14);
          uint64_t v16 = mlir::detail::walk<mlir::ForwardIterator>();
          uint64_t v14 = v15;
          if (!v16) {
            return 0;
          }
        }
      }
      v9 += 24;
    }
    while (v9 != v10);
  }
  if (a4 != 1) {
    return 1;
  }

  return ((uint64_t (*)(uint64_t, mlir::ForwardIterator *))a2)(a3, a1);
}

{
  uint64_t Iterable;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  uint64_t v14;
  uint64_t result;
  mlir::GenericProgramPoint *v16;
  mlir::GenericProgramPoint *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  mlir::GenericProgramPoint *v21;
  mlir::GenericProgramPoint *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  mlir::GenericProgramPoint *v26;

  Iterable = mlir::ForwardIterator::makeIterable(a1, a2);
  if (!v8) {
    return 1;
  }
  uint64_t v9 = Iterable;
  uint64_t v10 = Iterable + 24 * v8;
  if (a4 == 1)
  {
    while (1)
    {
      unsigned int v23 = *(void *)(v9 + 8);
      if (v23 != v9) {
        break;
      }
LABEL_30:
      v9 += 24;
      uint64_t result = 1;
      if (v9 == v10) {
        return result;
      }
    }
    while (1)
    {
      int v24 = *(void *)(v23 + 8);
      unsigned int v25 = v23 ? v23 - 8 : 0;
      uint64_t v26 = *(mlir::GenericProgramPoint **)(v25 + 40);
      if (v26 != (mlir::GenericProgramPoint *)(v25 + 32)) {
        break;
      }
LABEL_38:
      uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2)(a3, v25);
      if (!result) {
        return result;
      }
      unsigned int v23 = v24;
      if (v24 == v9) {
        goto LABEL_30;
      }
    }
    while (1)
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(v26);
      uint64_t result = mlir::detail::walk<mlir::ForwardIterator>();
      if (!result) {
        break;
      }
      uint64_t v26 = (mlir::GenericProgramPoint *)*((void *)v26 + 1);
      if (v26 == (mlir::GenericProgramPoint *)(v25 + 32)) {
        goto LABEL_38;
      }
    }
  }
  else if (a4)
  {
    while (1)
    {
      uint64_t v18 = *(void *)(v9 + 8);
      if (v18 != v9) {
        break;
      }
LABEL_26:
      v9 += 24;
      uint64_t result = 1;
      if (v9 == v10) {
        return result;
      }
    }
    while (1)
    {
      uint64_t v19 = *(void *)(v18 + 8);
      uint64_t v20 = v18 ? v18 - 8 : 0;
      uint64_t v21 = (mlir::GenericProgramPoint *)(v20 + 32);
      uint64_t v22 = *(mlir::GenericProgramPoint **)(v20 + 40);
      if (v22 != (mlir::GenericProgramPoint *)(v20 + 32)) {
        break;
      }
LABEL_17:
      uint64_t v18 = v19;
      if (v19 == v9) {
        goto LABEL_26;
      }
    }
    while (1)
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(v22);
      uint64_t result = mlir::detail::walk<mlir::ForwardIterator>();
      if (!result) {
        break;
      }
      uint64_t v22 = (mlir::GenericProgramPoint *)*((void *)v22 + 1);
      if (v22 == v21) {
        goto LABEL_17;
      }
    }
  }
  else
  {
    while (2)
    {
      uint64_t v11 = *(void *)(v9 + 8);
LABEL_5:
      while (v11 != v9)
      {
        uint64_t v12 = v11 - 8;
        uint64_t v13 = v11 == 0;
        uint64_t v11 = *(void *)(v11 + 8);
        if (v13) {
          uint64_t v14 = 0;
        }
        else {
          uint64_t v14 = v12;
        }
        uint64_t result = ((uint64_t (*)(uint64_t, uint64_t))a2)(a3, v14);
        if (result != 2)
        {
          if (!result) {
            return result;
          }
          uint64_t v16 = (mlir::GenericProgramPoint *)(v14 + 32);
          uint64_t v17 = *(mlir::GenericProgramPoint **)(v14 + 40);
          if (v17 != v16)
          {
            while (1)
            {
              mlir::GenericProgramPoint::~GenericProgramPoint(v17);
              uint64_t result = mlir::detail::walk<mlir::ForwardIterator>();
              if (!result) {
                return result;
              }
              uint64_t v17 = (mlir::GenericProgramPoint *)*((void *)v17 + 1);
              if (v17 == v16) {
                goto LABEL_5;
              }
            }
          }
        }
      }
      v9 += 24;
      uint64_t result = 1;
      if (v9 != v10) {
        continue;
      }
      break;
    }
  }
  return result;
}

void llvm::function_ref<void ()(mlir::Block *)>::callback_fn<buildBlockMapping(mlir::Operation *,llvm::DenseMap<mlir::Block *,anonymous namespace'::BlockInfoBuilder,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,anonymous namespace'::BlockInfoBuilder>> &)::$_0>(uint64_t *a1, mlir::Block *a2)
{
  unsigned int v3 = a1;
  uint64_t v4 = *a1;
  unsigned int v5 = *(_DWORD *)(*a1 + 16);
  if (!v5) {
    goto LABEL_91;
  }
  unsigned int v6 = (v5 - 1) & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = *(void *)v4 + 656 * v6;
  uint64_t v8 = *(void *)v7;
  if (*(mlir::Block **)v7 == a2) {
    goto LABEL_72;
  }
  uint64_t v9 = 0;
  int v10 = 1;
  while (v8 != -4096)
  {
    if (v9) {
      BOOL v11 = 0;
    }
    else {
      BOOL v11 = v8 == -8192;
    }
    if (v11) {
      uint64_t v9 = v7;
    }
    unsigned int v12 = v6 + v10++;
    unsigned int v6 = v12 & (v5 - 1);
    uint64_t v7 = *(void *)v4 + 656 * v6;
    uint64_t v8 = *(void *)v7;
    if (*(mlir::Block **)v7 == a2) {
      goto LABEL_72;
    }
  }
  if (v9) {
    uint64_t v7 = v9;
  }
  int v54 = *(_DWORD *)(v4 + 8);
  if (4 * v54 + 4 < 3 * v5)
  {
    if (v5 + ~v54 - *(_DWORD *)(v4 + 12) > v5 >> 3) {
      goto LABEL_14;
    }
  }
  else
  {
LABEL_91:
    v5 *= 2;
  }
  int v55 = *(_DWORD *)(v4 + 16) - 1;
  unsigned int v56 = v55 & ((a2 >> 4) ^ (a2 >> 9));
  uint64_t v7 = *(void *)v4 + 656 * v56;
  uint64_t v57 = *(void *)v7;
  if (*(mlir::Block **)v7 != a2)
  {
    uint64_t v58 = 0;
    int v59 = 1;
    while (v57 != -4096)
    {
      if (v58) {
        BOOL v60 = 0;
      }
      else {
        BOOL v60 = v57 == -8192;
      }
      if (v60) {
        uint64_t v58 = v7;
      }
      unsigned int v61 = v56 + v59++;
      unsigned int v56 = v61 & v55;
      uint64_t v7 = *(void *)v4 + 656 * v56;
      uint64_t v57 = *(void *)v7;
      if (*(mlir::Block **)v7 == a2) {
        goto LABEL_93;
      }
    }
    if (v58) {
      uint64_t v7 = v58;
    }
LABEL_14:
    uint64_t v13 = *(void *)v7;
    ++*(_DWORD *)(v4 + 8);
    if (v13 == -4096) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
LABEL_93:
  ++*(_DWORD *)(v4 + 8);
  if (a2 != (mlir::Block *)-4096) {
LABEL_15:
  }
    --*(_DWORD *)(v4 + 12);
LABEL_16:
  *(void *)(v7 + 8) = a2;
  *(void *)uint64_t v7 = a2;
  *(void *)(v7 + 16) = v7 + 48;
  *(void *)(v7 + 24) = v7 + 48;
  *(void *)(v7 + 32) = 16;
  *(_DWORD *)(v7 + 40) = 0;
  *(void *)(v7 + 176) = v7 + 208;
  *(void *)(v7 + 184) = v7 + 208;
  *(void *)(v7 + 192) = 16;
  *(_DWORD *)(v7 + 200) = 0;
  *(void *)(v7 + 336) = v7 + 368;
  *(void *)(v7 + 344) = v7 + 368;
  *(void *)(v7 + 352) = 16;
  *(_DWORD *)(v7 + 360) = 0;
  int v63 = (llvm::SmallPtrSetImplBase *)(v7 + 336);
  *(void *)(v7 + 496) = v7 + 528;
  *(void *)(v7 + 504) = v7 + 528;
  *(void *)(v7 + 512) = 16;
  *(_DWORD *)(v7 + 520) = 0;
  uint64_t v14 = (const void **)*((void *)a2 + 6);
  BOOL v15 = (const void **)*((void *)a2 + 7);
  if (v15 != v14)
  {
    while (1)
    {
      uint64_t v30 = *v14;
      uint64_t v31 = *(void *)(v7 + 344);
      if (v31 != *(void *)(v7 + 336)) {
        goto LABEL_44;
      }
      uint64_t v40 = *(unsigned int *)(v7 + 356);
      if (!v40) {
        break;
      }
      int64_t v41 = 0;
      uint64_t v42 = 8 * v40;
      unint64_t v43 = *(void **)(v7 + 344);
      while ((void *)*v43 != v30)
      {
        if (*v43 == -2) {
          int64_t v41 = v43;
        }
        ++v43;
        v42 -= 8;
        if (!v42)
        {
          if (!v41) {
            goto LABEL_65;
          }
          *int64_t v41 = v30;
          --*(_DWORD *)(v7 + 360);
          break;
        }
      }
LABEL_45:
      unsigned int v32 = v30;
      do
      {
        unsigned int v32 = (void *)*v32;
        if (!v32) {
          goto LABEL_42;
        }
        uint64_t v33 = *(mlir::Block **)(v32[2] + 16);
        Parent = (mlir::Region *)mlir::Block::getParent(a2);
      }
      while (mlir::Region::findAncestorBlockInRegion(Parent, v33) == a2);
      uint64_t v35 = *(void *)(v7 + 184);
      if (v35 != *(void *)(v7 + 176))
      {
LABEL_41:
        llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(v7 + 176), v30);
        goto LABEL_42;
      }
      uint64_t v36 = *(unsigned int *)(v7 + 196);
      if (v36)
      {
        uint64_t v37 = 0;
        uint64_t v38 = 8 * v36;
        int v39 = *(void **)(v7 + 184);
        while ((void *)*v39 != v30)
        {
          if (*v39 == -2) {
            uint64_t v37 = v39;
          }
          ++v39;
          v38 -= 8;
          if (!v38)
          {
            if (!v37) {
              goto LABEL_67;
            }
            void *v37 = v30;
            --*(_DWORD *)(v7 + 200);
            break;
          }
        }
      }
      else
      {
LABEL_67:
        if (v36 >= *(_DWORD *)(v7 + 192)) {
          goto LABEL_41;
        }
        *(_DWORD *)(v7 + 196) = v36 + 1;
        *(void *)(v35 + 8 * v36) = v30;
      }
LABEL_42:
      if (++v14 == v15) {
        goto LABEL_17;
      }
    }
LABEL_65:
    if (v40 < *(_DWORD *)(v7 + 352))
    {
      *(_DWORD *)(v7 + 356) = v40 + 1;
      *(void *)(v31 + 8 * v40) = v30;
      goto LABEL_45;
    }
LABEL_44:
    llvm::SmallPtrSetImplBase::insert_imp_big(v63, *v14);
    goto LABEL_45;
  }
LABEL_17:
  uint64_t v16 = (mlir::GenericProgramPoint *)*((void *)a2 + 5);
  if (v16 != (mlir::Block *)((char *)a2 + 32))
  {
    int v62 = v3;
    unsigned int v64 = (mlir::Block *)((char *)a2 + 32);
    do
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(v16);
      uint64_t v18 = *(unsigned int *)(v17 + 36);
      if (v18) {
        uint64_t v19 = v17 - 16;
      }
      else {
        uint64_t v19 = 0;
      }
      if (v18)
      {
        uint64_t v20 = 0;
        while (1)
        {
          uint64_t NextResultAtOffset = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(v19, v20);
          uint64_t v22 = NextResultAtOffset;
          do
          {
            uint64_t v22 = (void *)*v22;
            if (!v22) {
              goto LABEL_26;
            }
            unsigned int v23 = *(mlir::Block **)(v22[2] + 16);
            int v24 = (mlir::Region *)mlir::Block::getParent(a2);
          }
          while (mlir::Region::findAncestorBlockInRegion(v24, v23) == a2);
          uint64_t v25 = *(void *)(v7 + 184);
          if (v25 != *(void *)(v7 + 176)) {
            break;
          }
          uint64_t v26 = *(unsigned int *)(v7 + 196);
          if (v26)
          {
            BOOL v27 = 0;
            uint64_t v28 = 8 * v26;
            uint64_t v29 = *(void **)(v7 + 184);
            while ((void *)*v29 != NextResultAtOffset)
            {
              if (*v29 == -2) {
                BOOL v27 = v29;
              }
              ++v29;
              v28 -= 8;
              if (!v28)
              {
                if (!v27) {
                  goto LABEL_39;
                }
                *BOOL v27 = NextResultAtOffset;
                --*(_DWORD *)(v7 + 200);
                break;
              }
            }
          }
          else
          {
LABEL_39:
            if (v26 >= *(_DWORD *)(v7 + 192)) {
              break;
            }
            *(_DWORD *)(v7 + 196) = v26 + 1;
            *(void *)(v25 + 8 * v26) = NextResultAtOffset;
          }
LABEL_26:
          if (++v20 == v18) {
            goto LABEL_19;
          }
        }
        llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(v7 + 176), NextResultAtOffset);
        goto LABEL_26;
      }
LABEL_19:
      uint64_t v16 = (mlir::GenericProgramPoint *)*((void *)v16 + 1);
    }
    while (v16 != v64);
    uint64_t v44 = (mlir::GenericProgramPoint *)*((void *)a2 + 5);
    unsigned int v3 = v62;
    uint64_t v65 = (void *)(v7 + 8);
    if (v44 != v64)
    {
      do
      {
        uint64_t v45 = (mlir::GenericProgramPoint *)*((void *)v44 + 1);
        mlir::GenericProgramPoint::~GenericProgramPoint(v44);
        uint64_t v44 = v45;
      }
      while (v45 != v64);
    }
  }
  llvm::set_subtract<llvm::SmallPtrSet<mlir::Value,16u>,llvm::SmallPtrSet<mlir::Value,16u>>((const void **)(v7 + 496), v63);
LABEL_72:
  llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((llvm::SmallPtrSetImplBase *)&v65, &v70, (const llvm::SmallPtrSetImplBase *)(v7 + 496));
  llvm::set_union<llvm::SmallPtrSet<mlir::Value,16u>,llvm::SmallPtrSet<mlir::Value,16u>>((llvm::SmallPtrSetImplBase *)&v65, (void *)(v7 + 176));
  llvm::set_subtract<llvm::SmallPtrSet<mlir::Value,16u>,llvm::SmallPtrSet<mlir::Value,16u>>((const void **)&v65, (void *)(v7 + 336));
  int v47 = v68 - v69;
  int v48 = *(_DWORD *)(v7 + 36) - *(_DWORD *)(v7 + 40);
  if (&v65 != (void **)(v7 + 16) && v47 != v48) {
    llvm::SmallPtrSetImplBase::MoveFrom(v7 + 16, 16, (double *)&v65);
  }
  if (v66 != v65) {
    free(v66);
  }
  if (v47 != v48)
  {
    unint64_t v50 = *(void **)a2;
    if (v50)
    {
      int v51 = (int64x2_t *)v3[1];
      do
      {
        uint64_t v71 = mlir::PredecessorIterator::unwrap((uint64_t)v50);
        llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>,mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::try_emplace<llvm::detail::DenseSetEmpty&>(v51, &v71, (uint64_t)&v65);
        if (v67)
        {
          uint64_t v52 = v71;
          unint64_t v53 = v51[2].u32[0];
          if (v53 >= v51[2].u32[1])
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51[1].i64[1], &v51[2].u64[1], v53 + 1, 8);
            unint64_t v53 = v51[2].u32[0];
          }
          *(void *)(v51[1].i64[1] + 8 * v53) = v52;
          ++v51[2].i32[0];
        }
        unint64_t v50 = (void *)*v50;
      }
      while (v50);
    }
  }
}

void *llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,anonymous namespace'::BlockInfoBuilder,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,anonymous namespace'::BlockInfoBuilder>>,mlir::Block *,anonymous namespace'::BlockInfoBuilder,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,anonymous namespace'::BlockInfoBuilder>>::grow(uint64_t a1, int a2)
{
  unsigned int v3 = *(_DWORD *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(656 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    unsigned int v10 = *(_DWORD *)(a1 + 16);
    if (!v10) {
      goto LABEL_16;
    }
    unint64_t v11 = 656 * v10 - 656;
    if (v11 >= 0x290)
    {
      unint64_t v16 = v11 / 0x290 + 1;
      unsigned int v12 = &result[82 * (v16 & 0xFFFFFFFFFFFFFELL)];
      uint64_t v17 = v16 & 0xFFFFFFFFFFFFFELL;
      uint64_t v18 = result;
      do
      {
        *uint64_t v18 = -4096;
        v18[82] = -4096;
        v18 += 164;
        v17 -= 2;
      }
      while (v17);
      if (v16 == (v16 & 0xFFFFFFFFFFFFFELL))
      {
LABEL_16:
        if (v3)
        {
          uint64_t v20 = v4;
          do
          {
            uint64_t v21 = *(void *)v20;
            if ((*(void *)v20 | 0x1000) != 0xFFFFFFFFFFFFF000)
            {
              int v22 = *(_DWORD *)(a1 + 16);
              if (v22)
              {
                int v23 = v22 - 1;
                unsigned int v24 = v23 & ((v21 >> 4) ^ (v21 >> 9));
                uint64_t v25 = (void *)(*(void *)a1 + 656 * v24);
                uint64_t v26 = *v25;
                if (*v25 != v21)
                {
                  BOOL v27 = 0;
                  int v28 = 1;
                  while (v26 != -4096)
                  {
                    if (v27) {
                      BOOL v29 = 0;
                    }
                    else {
                      BOOL v29 = v26 == -8192;
                    }
                    if (v29) {
                      BOOL v27 = v25;
                    }
                    unsigned int v30 = v24 + v28++;
                    unsigned int v24 = v30 & v23;
                    uint64_t v25 = (void *)(*(void *)a1 + 656 * v24);
                    uint64_t v26 = *v25;
                    if (*v25 == v21) {
                      goto LABEL_32;
                    }
                  }
                  if (v27) {
                    uint64_t v25 = v27;
                  }
                }
              }
              else
              {
                uint64_t v25 = 0;
              }
LABEL_32:
              *uint64_t v25 = v21;
              v25[1] = *((void *)v20 + 1);
              llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v25 + 2), v25 + 6, 16, (uint64_t *)v20 + 2);
              llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v25 + 22), v25 + 26, 16, (uint64_t *)v20 + 22);
              llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v25 + 42), v25 + 46, 16, (uint64_t *)v20 + 42);
              llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v25 + 62), v25 + 66, 16, (uint64_t *)v20 + 62);
              ++*(_DWORD *)(a1 + 8);
              uint64_t v31 = (void *)*((void *)v20 + 63);
              if (v31 != *((void **)v20 + 62)) {
                free(v31);
              }
              unsigned int v32 = (void *)*((void *)v20 + 43);
              if (v32 != *((void **)v20 + 42)) {
                free(v32);
              }
              uint64_t v33 = (void *)*((void *)v20 + 23);
              if (v33 != *((void **)v20 + 22)) {
                free(v33);
              }
              unint64_t v34 = (void *)*((void *)v20 + 3);
              if (v34 != *((void **)v20 + 2)) {
                free(v34);
              }
            }
            uint64_t v20 = (llvm *)((char *)v20 + 656);
          }
          while (v20 != (llvm *)((char *)v4 + 656 * v3));
        }
        llvm::deallocate_buffer(v4, (void *)(656 * v3));
      }
    }
    else
    {
      unsigned int v12 = result;
    }
    uint64_t v19 = &result[82 * v10];
    do
    {
      void *v12 = -4096;
      v12 += 82;
    }
    while (v12 != v19);
    goto LABEL_16;
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    unint64_t v14 = 656 * v13 - 656;
    if (v14 < 0x290)
    {
      BOOL v15 = result;
LABEL_49:
      uint64_t v38 = &result[82 * v13];
      do
      {
        *BOOL v15 = -4096;
        v15 += 82;
      }
      while (v15 != v38);
      return result;
    }
    unint64_t v35 = v14 / 0x290 + 1;
    BOOL v15 = &result[82 * (v35 & 0xFFFFFFFFFFFFFELL)];
    uint64_t v36 = v35 & 0xFFFFFFFFFFFFFELL;
    uint64_t v37 = result;
    do
    {
      void *v37 = -4096;
      v37[82] = -4096;
      v37 += 164;
      v36 -= 2;
    }
    while (v36);
    if (v35 != (v35 & 0xFFFFFFFFFFFFFELL)) {
      goto LABEL_49;
    }
  }
  return result;
}

const void **llvm::set_subtract<llvm::SmallPtrSet<mlir::Value,16u>,llvm::SmallPtrSet<mlir::Value,16u>>(const void **this, void *a2)
{
  uint64_t v2 = (uint64_t)this;
  uint64_t v3 = a2[1];
  if (v3 == *a2) {
    uint64_t v4 = (unsigned int *)a2 + 5;
  }
  else {
    uint64_t v4 = (unsigned int *)(a2 + 2);
  }
  uint64_t v5 = *v4;
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    for (uint64_t i = (const void **)a2[1]; (unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL; ++i)
    {
      v6 -= 8;
      if (!v6) {
        return this;
      }
    }
  }
  else
  {
    uint64_t i = (const void **)a2[1];
  }
  unsigned int v8 = (const void **)(v3 + 8 * v5);
  while (i != v8)
  {
    uint64_t v9 = *i;
    uint64_t v10 = *(void *)(v2 + 8);
    if (v10 == *(void *)v2)
    {
      uint64_t v15 = *(unsigned int *)(v2 + 20);
      this = (const void **)(v10 + 8 * v15);
      if (v15)
      {
        uint64_t v16 = 0;
        while (*(const void **)(v10 + v16) != v9)
        {
          v16 += 8;
          if (8 * v15 == v16) {
            goto LABEL_31;
          }
        }
        this = (const void **)(v10 + v16);
      }
LABEL_31:
      if (this == (const void **)(*(void *)(v2 + 8) + 8 * v15)) {
        goto LABEL_21;
      }
LABEL_20:
      *this = (const void *)-2;
      ++*(_DWORD *)(v2 + 24);
      goto LABEL_21;
    }
    this = llvm::SmallPtrSetImplBase::FindBucketFor((llvm::SmallPtrSetImplBase *)v2, *i);
    uint64_t v11 = *(void *)v2;
    uint64_t v12 = *(void *)(v2 + 8);
    if (*this != v9)
    {
      unsigned int v13 = *(_DWORD *)(v2 + 16);
      if (v12 == v11) {
        unsigned int v13 = *(_DWORD *)(v2 + 20);
      }
      this = (const void **)(v12 + 8 * v13);
    }
    if (v12 == v11) {
      unsigned int v14 = *(_DWORD *)(v2 + 20);
    }
    else {
      unsigned int v14 = *(_DWORD *)(v2 + 16);
    }
    if (this != (const void **)(v12 + 8 * v14)) {
      goto LABEL_20;
    }
    do
    {
LABEL_21:
      if (++i == v8) {
        return this;
      }
    }
    while ((unint64_t)*i >= 0xFFFFFFFFFFFFFFFELL);
  }
  return this;
}

uint64_t *llvm::function_ref<void ()(mlir::Operation *)>::callback_fn<anonymous namespace'::BlockInfoBuilder::BlockInfoBuilder(mlir::Block *)::{lambda(mlir::Operation *)#1}>(uint64_t *result, uint64_t a2)
{
  uint64_t v3 = *result;
  uint64_t v4 = *(unsigned int *)(a2 + 36);
  if (v4) {
    uint64_t v5 = a2 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v4)
  {
    for (uint64_t i = 0; i != v4; ++i)
    {
      uint64_t result = (uint64_t *)mlir::detail::OpResultImpl::getNextResultAtOffset(v5, i);
      uint64_t v7 = *(void *)(v3 + 336);
      if (v7 != *(void *)(v3 + 328)) {
        goto LABEL_6;
      }
      uint64_t v8 = *(unsigned int *)(v3 + 348);
      if (v8)
      {
        uint64_t v9 = 0;
        uint64_t v10 = 8 * v8;
        uint64_t v11 = *(uint64_t ***)(v3 + 336);
        while (*v11 != result)
        {
          if (*v11 == (uint64_t *)-2) {
            uint64_t v9 = v11;
          }
          ++v11;
          v10 -= 8;
          if (!v10)
          {
            if (!v9) {
              goto LABEL_17;
            }
            *uint64_t v9 = result;
            --*(_DWORD *)(v3 + 352);
            goto LABEL_7;
          }
        }
        continue;
      }
LABEL_17:
      if (v8 < *(_DWORD *)(v3 + 344))
      {
        *(_DWORD *)(v3 + 348) = v8 + 1;
        *(void *)(v7 + 8 * v8) = result;
      }
      else
      {
LABEL_6:
        uint64_t result = (uint64_t *)llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(v3 + 328), result);
      }
LABEL_7:
      ;
    }
  }
  if ((*(unsigned char *)(a2 + 46) & 0x80) != 0)
  {
    uint64_t v12 = *(unsigned int *)(a2 + 68);
    if (v12)
    {
      uint64_t v13 = 0;
      uint64_t v14 = *(void *)(a2 + 72);
      do
      {
        uint64_t v15 = *(void *)(v3 + 496);
        uint64_t v16 = *(const void **)(v14 + 32 * v13 + 24);
        if (v15 != *(void *)(v3 + 488)) {
          goto LABEL_22;
        }
        uint64_t v17 = *(unsigned int *)(v3 + 508);
        if (v17)
        {
          uint64_t v18 = 0;
          uint64_t v19 = 8 * v17;
          uint64_t v20 = *(void **)(v3 + 496);
          while ((const void *)*v20 != v16)
          {
            if (*v20 == -2) {
              uint64_t v18 = v20;
            }
            ++v20;
            v19 -= 8;
            if (!v19)
            {
              if (!v18) {
                goto LABEL_33;
              }
              *uint64_t v18 = v16;
              --*(_DWORD *)(v3 + 512);
              goto LABEL_23;
            }
          }
          goto LABEL_23;
        }
LABEL_33:
        if (v17 < *(_DWORD *)(v3 + 504))
        {
          *(_DWORD *)(v3 + 508) = v17 + 1;
          *(void *)(v15 + 8 * v17) = v16;
        }
        else
        {
LABEL_22:
          uint64_t result = (uint64_t *)llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(v3 + 488), v16);
        }
LABEL_23:
        ++v13;
      }
      while (v13 != v12);
    }
  }
  return result;
}

uint64_t llvm::set_union<llvm::SmallPtrSet<mlir::Value,16u>,llvm::SmallPtrSet<mlir::Value,16u>>(llvm::SmallPtrSetImplBase *this, void *a2)
{
  uint64_t v3 = a2[1];
  if (v3 == *a2) {
    uint64_t v4 = (unsigned int *)a2 + 5;
  }
  else {
    uint64_t v4 = (unsigned int *)(a2 + 2);
  }
  uint64_t v5 = *v4;
  if (v5)
  {
    uint64_t v6 = 8 * v5;
    uint64_t v7 = (const void **)a2[1];
    while ((unint64_t)*v7 >= 0xFFFFFFFFFFFFFFFELL)
    {
      ++v7;
      v6 -= 8;
      if (!v6) {
        goto LABEL_32;
      }
    }
  }
  else
  {
    uint64_t v7 = (const void **)a2[1];
  }
  uint64_t v8 = (const void **)(v3 + 8 * v5);
  if (v7 != v8)
  {
    char v9 = 0;
    uint64_t v10 = *(void **)this;
    uint64_t v11 = (void *)*((void *)this + 1);
    while (1)
    {
      uint64_t v12 = *v7;
      if (v11 != v10) {
        goto LABEL_13;
      }
      uint64_t v15 = *((unsigned int *)this + 5);
      if (v15)
      {
        uint64_t v16 = 0;
        uint64_t v17 = 8 * v15;
        uint64_t v18 = v10;
        do
        {
          if ((const void *)*v18 == v12)
          {
            int v14 = 0;
            goto LABEL_14;
          }
          if (*v18 == -2) {
            uint64_t v16 = v18;
          }
          ++v18;
          v17 -= 8;
        }
        while (v17);
        if (!v16) {
          goto LABEL_29;
        }
        void *v16 = v12;
        --*((_DWORD *)this + 6);
        int v14 = 1;
        goto LABEL_14;
      }
LABEL_29:
      if (v15 < *((_DWORD *)this + 4))
      {
        *((_DWORD *)this + 5) = v15 + 1;
        v10[v15] = v12;
        int v14 = 1;
      }
      else
      {
LABEL_13:
        llvm::SmallPtrSetImplBase::insert_imp_big(this, v12);
        int v14 = v13;
      }
LABEL_14:
      v9 |= v14 != 0;
      if (++v7 != v8)
      {
        uint64_t v10 = *(void **)this;
        uint64_t v11 = (void *)*((void *)this + 1);
        while ((unint64_t)*v7 >= 0xFFFFFFFFFFFFFFFELL)
        {
          if (++v7 == v8) {
            return v9 & 1;
          }
        }
        if (v7 != v8) {
          continue;
        }
      }
      return v9 & 1;
    }
  }
LABEL_32:
  char v9 = 0;
  return v9 & 1;
}

int64x2_t *llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>,mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::try_emplace<llvm::detail::DenseSetEmpty&>@<X0>(int64x2_t *result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v4 = result;
  unsigned int v6 = result[1].u32[0];
  if (!v6) {
    goto LABEL_23;
  }
  uint64_t v7 = result->i64[0];
  unsigned int v8 = v6 - 1;
  unsigned int v9 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v6 - 1);
  uint64_t v10 = (uint64_t *)(result->i64[0] + 8 * v9);
  uint64_t v11 = *v10;
  if (*a2 == *v10)
  {
LABEL_3:
    char v12 = 0;
    goto LABEL_10;
  }
  int v14 = 0;
  int v15 = 1;
  while (v11 != -4096)
  {
    if (v14) {
      BOOL v16 = 0;
    }
    else {
      BOOL v16 = v11 == -8192;
    }
    if (v16) {
      int v14 = v10;
    }
    unsigned int v17 = v9 + v15++;
    unsigned int v9 = v17 & v8;
    uint64_t v10 = (uint64_t *)(v7 + 8 * (v17 & v8));
    uint64_t v11 = *v10;
    if (*a2 == *v10) {
      goto LABEL_3;
    }
  }
  if (v14) {
    uint64_t v10 = v14;
  }
  __int32 v18 = result->i32[2];
  if (4 * v18 + 4 < 3 * v6)
  {
    if (v6 + ~v18 - result->i32[3] > v6 >> 3) {
      goto LABEL_6;
    }
  }
  else
  {
LABEL_23:
    v6 *= 2;
  }
  uint64_t result = llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::grow((uint64_t)result, v6);
  unsigned int v6 = v4[1].u32[0];
  uint64_t v13 = *a2;
  unsigned int v19 = v6 - 1;
  unsigned int v20 = ((*a2 >> 4) ^ (*a2 >> 9)) & (v6 - 1);
  uint64_t v10 = (uint64_t *)(v4->i64[0] + 8 * v20);
  uint64_t v21 = *v10;
  if (*a2 == *v10) {
    goto LABEL_7;
  }
  int v22 = 0;
  int v23 = 1;
  while (v21 != -4096)
  {
    if (v22) {
      BOOL v24 = 0;
    }
    else {
      BOOL v24 = v21 == -8192;
    }
    if (v24) {
      int v22 = v10;
    }
    unsigned int v25 = v20 + v23++;
    unsigned int v20 = v25 & v19;
    uint64_t v10 = (uint64_t *)(v4->i64[0] + 8 * (v25 & v19));
    uint64_t v21 = *v10;
    if (v13 == *v10) {
      goto LABEL_7;
    }
  }
  if (v22) {
    uint64_t v10 = v22;
  }
LABEL_6:
  uint64_t v13 = *v10;
LABEL_7:
  ++v4->i32[2];
  if (v13 != -4096) {
    --v4->i32[3];
  }
  *uint64_t v10 = *a2;
  uint64_t v7 = v4->i64[0];
  char v12 = 1;
LABEL_10:
  *(void *)a3 = v10;
  *(void *)(a3 + 8) = v7 + 8 * v6;
  *(unsigned char *)(a3 + 16) = v12;
  return result;
}

int64x2_t *llvm::DenseMap<mlir::Block *,llvm::detail::DenseSetEmpty,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseSetPair<mlir::Block *>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  uint64_t v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = (int64x2_t *)llvm::allocate_buffer(8 * v8, (std::align_val_t)8uLL);
  uint64_t v10 = (char *)result;
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    uint64_t v11 = *(unsigned int *)(a1 + 16);
    if (v11)
    {
      unint64_t v12 = (v11 - 1) & 0x1FFFFFFFFFFFFFFFLL;
      if (v12 < 3) {
        goto LABEL_41;
      }
      unint64_t v13 = v12 + 1;
      uint64_t v10 = &result->i8[8 * (v13 & 0x3FFFFFFFFFFFFFFCLL)];
      int v14 = result + 1;
      int64x2_t v15 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
      uint64_t v16 = v13 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v14[-1] = v15;
        *int v14 = v15;
        v14 += 2;
        v16 -= 4;
      }
      while (v16);
      if (v13 != (v13 & 0x3FFFFFFFFFFFFFFCLL))
      {
LABEL_41:
        do
        {
          *(void *)uint64_t v10 = -4096;
          v10 += 8;
        }
        while (v10 != (char *)result + 8 * v11);
      }
    }
    if (v3)
    {
      int v17 = 0;
      int v18 = v11 - 1;
      unsigned int v19 = v4;
      do
      {
        uint64_t v28 = *(void *)v19;
        if ((*(void *)v19 | 0x1000) != 0xFFFFFFFFFFFFF000)
        {
          unsigned int v29 = ((v28 >> 4) ^ (v28 >> 9)) & v18;
          BOOL v27 = (void *)(*(void *)a1 + 8 * v29);
          uint64_t v30 = *v27;
          if (v28 != *v27)
          {
            uint64_t v31 = 0;
            int v32 = 1;
            while (v30 != -4096)
            {
              if (v31) {
                BOOL v33 = 0;
              }
              else {
                BOOL v33 = v30 == -8192;
              }
              if (v33) {
                uint64_t v31 = v27;
              }
              unsigned int v34 = v29 + v32++;
              unsigned int v29 = v34 & v18;
              BOOL v27 = (void *)(*(void *)a1 + 8 * (v34 & v18));
              uint64_t v30 = *v27;
              if (v28 == *v27) {
                goto LABEL_23;
              }
            }
            if (v31) {
              BOOL v27 = v31;
            }
          }
LABEL_23:
          *BOOL v27 = v28;
          *(_DWORD *)(a1 + 8) = ++v17;
        }
        unsigned int v19 = (llvm *)((char *)v19 + 8);
      }
      while (v19 != (llvm *)((char *)v4 + 8 * v3));
    }
    llvm::deallocate_buffer(v4, (void *)(8 * v3));
  }
  *(void *)(a1 + 8) = 0;
  uint64_t v20 = *(unsigned int *)(a1 + 16);
  if (v20)
  {
    unint64_t v21 = (v20 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v21 < 3) {
      goto LABEL_18;
    }
    unint64_t v22 = v21 + 1;
    uint64_t v10 = &result->i8[8 * (v22 & 0x3FFFFFFFFFFFFFFCLL)];
    int v23 = result + 1;
    int64x2_t v24 = vdupq_n_s64(0xFFFFFFFFFFFFF000);
    uint64_t v25 = v22 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      v23[-1] = v24;
      *int v23 = v24;
      v23 += 2;
      v25 -= 4;
    }
    while (v25);
    if (v22 != (v22 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_18:
      uint64_t v26 = &result->i8[8 * v20];
      do
      {
        *(void *)uint64_t v10 = -4096;
        v10 += 8;
      }
      while (v10 != v26);
    }
  }
  return result;
}

char *llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,mlir::LivenessBlockInfo,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,mlir::LivenessBlockInfo>>,mlir::Block *,mlir::LivenessBlockInfo,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,mlir::LivenessBlockInfo>>::InsertIntoBucket<mlir::Block * const&>(uint64_t a1, char *a2, uint64_t *a3)
{
  int v5 = *(_DWORD *)(a1 + 8);
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (4 * v5 + 4 >= 3 * v6)
  {
    int v9 = 2 * v6;
  }
  else
  {
    if (v6 + ~v5 - *(_DWORD *)(a1 + 12) > v6 >> 3)
    {
LABEL_3:
      uint64_t v7 = *(void *)a2;
      goto LABEL_4;
    }
    int v9 = *(_DWORD *)(a1 + 16);
  }
  uint64_t v10 = *(uint64_t **)a1;
  unint64_t v11 = (v9 - 1) | ((unint64_t)(v9 - 1) >> 1);
  unint64_t v12 = v11 | (v11 >> 2) | ((v11 | (v11 >> 2)) >> 4);
  int v13 = ((v12 | (v12 >> 8)) >> 16) | v12 | (v12 >> 8);
  if ((v13 + 1) > 0x40) {
    unsigned int v14 = v13 + 1;
  }
  else {
    unsigned int v14 = 64;
  }
  *(_DWORD *)(a1 + 16) = v14;
  buffer = llvm::allocate_buffer(336 * v14, (std::align_val_t)8uLL);
  *(void *)a1 = buffer;
  if (v10)
  {
    llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,mlir::LivenessBlockInfo,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,mlir::LivenessBlockInfo>>,mlir::Block *,mlir::LivenessBlockInfo,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,mlir::LivenessBlockInfo>>::moveFromOldBuckets(a1, v10, &v10[42 * v6]);
    llvm::deallocate_buffer((llvm *)v10, (void *)(336 * v6));
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v16 = *(_DWORD *)(a1 + 16);
  unint64_t v17 = 336 * v16 - 336;
  int v18 = buffer;
  if (v17 < 0x150) {
    goto LABEL_34;
  }
  unint64_t v19 = v17 / 0x150 + 1;
  int v18 = &buffer[42 * (v19 & 0x1FFFFFFFFFFFFFELL)];
  uint64_t v20 = v19 & 0x1FFFFFFFFFFFFFELL;
  unint64_t v21 = buffer;
  do
  {
    *unint64_t v21 = -4096;
    v21[42] = -4096;
    v21 += 84;
    v20 -= 2;
  }
  while (v20);
  if (v19 != (v19 & 0x1FFFFFFFFFFFFFELL))
  {
LABEL_34:
    do
    {
      *int v18 = -4096;
      v18 += 42;
    }
    while (v18 != &buffer[42 * v16]);
  }
  uint64_t v7 = *a3;
  unsigned int v22 = v16 - 1;
  unsigned int v23 = ((*a3 >> 4) ^ (*a3 >> 9)) & v22;
  a2 = (char *)&buffer[42 * v23];
  uint64_t v24 = *(void *)a2;
  if (*a3 != *(void *)a2)
  {
    uint64_t v25 = 0;
    int v26 = 1;
    while (v24 != -4096)
    {
      if (v25) {
        BOOL v27 = 0;
      }
      else {
        BOOL v27 = v24 == -8192;
      }
      if (v27) {
        uint64_t v25 = a2;
      }
      unsigned int v28 = v23 + v26++;
      unsigned int v23 = v28 & v22;
      a2 = (char *)&buffer[42 * v23];
      uint64_t v24 = *(void *)a2;
      if (v7 == *(void *)a2) {
        goto LABEL_4;
      }
    }
    if (v25) {
      a2 = v25;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v7 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *(void *)a2 = *a3;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 216) = 0u;
  *(_OWORD *)(a2 + 232) = 0u;
  *(_OWORD *)(a2 + 248) = 0u;
  *((void *)a2 + 41) = 0;
  *(_OWORD *)(a2 + 8) = 0u;
  *(_OWORD *)(a2 + 264) = 0u;
  *(_OWORD *)(a2 + 280) = 0u;
  *(_OWORD *)(a2 + 296) = 0u;
  *(_OWORD *)(a2 + 312) = 0u;
  *((void *)a2 + 2) = a2 + 48;
  *((void *)a2 + 3) = a2 + 48;
  *((_DWORD *)a2 + 8) = 16;
  *((_DWORD *)a2 + 10) = 0;
  *((void *)a2 + 22) = a2 + 208;
  *((void *)a2 + 23) = a2 + 208;
  *((_DWORD *)a2 + 48) = 16;
  *((_DWORD *)a2 + 50) = 0;
  return a2;
}

void llvm::DenseMapBase<llvm::DenseMap<mlir::Block *,mlir::LivenessBlockInfo,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,mlir::LivenessBlockInfo>>,mlir::Block *,mlir::LivenessBlockInfo,llvm::DenseMapInfo<mlir::Block *,void>,llvm::detail::DenseMapPair<mlir::Block *,mlir::LivenessBlockInfo>>::moveFromOldBuckets(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  uint64_t v4 = a2;
  *(void *)(a1 + 8) = 0;
  unsigned int v6 = *(_DWORD *)(a1 + 16);
  if (v6)
  {
    uint64_t v7 = *(void **)a1;
    unint64_t v8 = 336 * v6 - 336;
    if (v8 < 0x150)
    {
      int v9 = *(void **)a1;
LABEL_7:
      int v13 = &v7[42 * v6];
      do
      {
        *int v9 = -4096;
        v9 += 42;
      }
      while (v9 != v13);
      goto LABEL_9;
    }
    unint64_t v10 = v8 / 0x150 + 1;
    int v9 = &v7[42 * (v10 & 0x1FFFFFFFFFFFFFELL)];
    uint64_t v11 = v10 & 0x1FFFFFFFFFFFFFELL;
    unint64_t v12 = *(void **)a1;
    do
    {
      void *v12 = -4096;
      v12[42] = -4096;
      v12 += 84;
      v11 -= 2;
    }
    while (v11);
    if (v10 != (v10 & 0x1FFFFFFFFFFFFFELL)) {
      goto LABEL_7;
    }
  }
LABEL_9:
  if (a2 != a3)
  {
    do
    {
      uint64_t v14 = *v4;
      if ((*v4 | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        int v15 = *(_DWORD *)(a1 + 16);
        if (v15)
        {
          int v16 = v15 - 1;
          unsigned int v17 = v16 & ((v14 >> 4) ^ (v14 >> 9));
          int v18 = (void *)(*(void *)a1 + 336 * v17);
          uint64_t v19 = *v18;
          if (v14 != *v18)
          {
            uint64_t v20 = 0;
            int v21 = 1;
            while (v19 != -4096)
            {
              if (v20) {
                BOOL v22 = 0;
              }
              else {
                BOOL v22 = v19 == -8192;
              }
              if (v22) {
                uint64_t v20 = v18;
              }
              unsigned int v23 = v17 + v21++;
              unsigned int v17 = v23 & v16;
              int v18 = (void *)(*(void *)a1 + 336 * v17);
              uint64_t v19 = *v18;
              if (v14 == *v18) {
                goto LABEL_25;
              }
            }
            if (v20) {
              int v18 = v20;
            }
          }
        }
        else
        {
          int v18 = 0;
        }
LABEL_25:
        *int v18 = v14;
        v18[1] = v4[1];
        llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v18 + 2), v18 + 6, 16, v4 + 2);
        llvm::SmallPtrSetImplBase::SmallPtrSetImplBase((uint64_t)(v18 + 22), v18 + 26, 16, v4 + 22);
        ++*(_DWORD *)(a1 + 8);
        uint64_t v24 = (void *)v4[23];
        if (v24 != (void *)v4[22]) {
          free(v24);
        }
        uint64_t v25 = (void *)v4[3];
        if (v25 != (void *)v4[2]) {
          free(v25);
        }
      }
      v4 += 42;
    }
    while (v4 != a3);
  }
}

void *mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,mlir::Value>(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFF9 | 4;
  {
    uint64_t v31 = a1;
    a1 = v31;
    if (v23)
    {
      int v32 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>]";
      unint64_t v33 = 104;
      unint64_t v24 = llvm::StringRef::find((uint64_t *)&v32, "DesiredTypeName = ", 0x12uLL, 0);
      if (v33 >= v24) {
        unint64_t v25 = v24;
      }
      else {
        unint64_t v25 = v33;
      }
      int v26 = &v32[v25];
      unint64_t v27 = v33 - v25;
      if (v33 - v25 >= 0x12) {
        uint64_t v28 = 18;
      }
      else {
        uint64_t v28 = v33 - v25;
      }
      unint64_t v29 = v27 - v28;
      if (v29 >= v29 - 1) {
        uint64_t v30 = v29 - 1;
      }
      else {
        uint64_t v30 = v29;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v26[v28], v30);
      a1 = v31;
    }
  }
  int v32 = (const char *)v2;
  unint64_t v33 = mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,void>::resolveTypeID(void)::id;
  int v3 = *(_DWORD *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    unint64_t v5 = ((0x2500000000 * v2) | (mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,void>::resolveTypeID(void)::id >> 9))
       + ~((unint64_t)((mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,void>::resolveTypeID(void)::id >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = v3 - 1;
    unsigned int v9 = v8 & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    unint64_t v10 = (void *)(v4 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (v2 == *v10
      && mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,void>::resolveTypeID(void)::id == v12)
    {
      goto LABEL_25;
    }
    uint64_t v14 = 0;
    int v15 = 1;
    while (v11 != -4096 || v12 != -4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v12 == -8192;
      }
      if (v16 && v11 == -8192) {
        uint64_t v14 = v10;
      }
      unsigned int v18 = v9 + v15++;
      unsigned int v9 = v18 & v8;
      unint64_t v10 = (void *)(v4 + 24 * v9);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      if (v2 == *v10
        && mlir::detail::TypeIDResolver<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,void>::resolveTypeID(void)::id == v12)
      {
        goto LABEL_25;
      }
    }
    if (v14) {
      uint64_t v20 = v14;
    }
    else {
      uint64_t v20 = v10;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  unint64_t v10 = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>(a1 + 120, (uint64_t)&v32, (uint64_t *)&v32, v20);
  *unint64_t v10 = v32;
  v10[1] = v33;
  v10[2] = 0;
LABEL_25:
  uint64_t result = (void *)v10[2];
  if (!result)
  {
    uint64_t result = operator new(0xC0uLL);
    result[2] = 0;
    result[3] = 0;
    *((_DWORD *)result + 8) = 0;
    result[7] = result + 11;
    result[5] = result + 7;
    result[6] = 0;
    result[8] = result + 11;
    result[9] = 4;
    *((_DWORD *)result + 20) = 0;
    result[15] = result + 17;
    result[16] = 0x400000000;
    *uint64_t result = &unk_1EC9CDC80;
    result[1] = v2;
    *((unsigned char *)result + 168) = 0;
    *((unsigned char *)result + 176) = 0;
    result[23] = 0;
    uint64_t v22 = v10[2];
    v10[2] = result;
    if (v22)
    {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
      return (void *)v10[2];
    }
  }
  return result;
}

void mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>::~Lattice(mlir::AnalysisState *this)
{
  *(void *)this = &unk_1EC9CDBC0;
  unint64_t v2 = (char *)*((void *)this + 15);
  if (v2 != (char *)this + 136) {
    free(v2);
  }
  int v3 = (void *)*((void *)this + 8);
  if (v3 != *((void **)this + 7)) {
    free(v3);
  }

  mlir::AnalysisState::~AnalysisState(this);
}

{
  char *v2;
  void *v3;

  *(void *)this = &unk_1EC9CDBC0;
  unint64_t v2 = (char *)*((void *)this + 15);
  if (v2 != (char *)this + 136) {
    free(v2);
  }
  int v3 = (void *)*((void *)this + 8);
  if (v3 != *((void **)this + 7)) {
    free(v3);
  }
  mlir::AnalysisState::~AnalysisState(this);
}

void sub_18018AC18(void *__p)
{
  operator delete(__p);
}

void mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>::print(uint64_t a1, llvm::raw_ostream *this)
{
  if (*(unsigned char *)(a1 + 176))
  {
    if (*(void *)(a1 + 168))
    {
      uint64_t v7 = *(void *)(a1 + 168);
      mlir::Attribute::print((mlir::Attribute *)&v7, this, 0);
      return;
    }
    uint64_t v6 = *((void *)this + 4);
    if ((unint64_t)(*((void *)this + 3) - v6) <= 8)
    {
      int v3 = this;
      uint64_t v4 = "<UNKNOWN>";
      size_t v5 = 9;
LABEL_7:
      llvm::raw_ostream::write(v3, v4, v5);
      return;
    }
    *(unsigned char *)(v6 + 8) = 62;
    *(void *)uint64_t v6 = *(void *)"<UNKNOWN>";
    *((void *)this + 4) += 9;
  }
  else
  {
    unint64_t v2 = (void *)*((void *)this + 4);
    if (*((void *)this + 3) - (void)v2 <= 0xEuLL)
    {
      int v3 = this;
      uint64_t v4 = "<UNINITIALIZED>";
      size_t v5 = 15;
      goto LABEL_7;
    }
    qmemcpy(v2, "<UNINITIALIZED>", 15);
    *((void *)this + 4) += 15;
  }
}

uint64_t mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>::join(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 176))
  {
    if (*(unsigned char *)(a2 + 176))
    {
      uint64_t v2 = *(void *)(a1 + 168);
      if (v2 != *(void *)(a2 + 168) && v2 != 0)
      {
        uint64_t v4 = 0;
        uint64_t v5 = 0;
        char v6 = 1;
LABEL_10:
        *(void *)(a1 + 168) = v5;
        *(unsigned char *)(a1 + 176) = v6;
        *(_DWORD *)(a1 + 177) = *(_DWORD *)v8;
        *(_DWORD *)(a1 + 180) = *(_DWORD *)&v8[3];
        *(void *)(a1 + 184) = v4;
        return 1;
      }
    }
  }
  else
  {
    uint64_t v5 = *(void *)(a2 + 168);
    char v6 = *(unsigned char *)(a2 + 176);
    *(_DWORD *)int v8 = *(_DWORD *)(a2 + 177);
    *(_DWORD *)&uint64_t v8[3] = *(_DWORD *)(a2 + 180);
    if (v6)
    {
      uint64_t v4 = *(void *)(a2 + 184);
      goto LABEL_10;
    }
  }
  return 0;
}

uint64_t mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>::meet()
{
  return 0;
}

llvm::raw_ostream *mlir::dataflow::Executable::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  if (*((unsigned char *)this + 56)) {
    uint64_t v2 = "live";
  }
  else {
    uint64_t v2 = "dead";
  }
  int v3 = (_DWORD *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v3 <= 3uLL) {
    return llvm::raw_ostream::write(a2, v2, 4uLL);
  }
  _DWORD *v3 = *(_DWORD *)v2;
  *((void *)a2 + 4) += 4;
  return this;
}

void mlir::dataflow::Executable::onUpdate(mlir::dataflow::Executable *this, mlir::DataFlowSolver *a2)
{
  uint64_t v4 = *((unsigned int *)this + 12);
  if (v4)
  {
    uint64_t v5 = (long long *)*((void *)this + 5);
    uint64_t v6 = *((void *)a2 + 5);
    uint64_t v7 = 16 * v4;
    do
    {
      uint64_t v8 = *((void *)a2 + 2);
      uint64_t v9 = *((void *)a2 + 1);
      long long v10 = *v5;
      if (v8 == v9) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = 32 * (v8 - v9) - 1;
      }
      unint64_t v12 = *((void *)a2 + 4) + v6;
      if (v11 == v12)
      {
        long long v59 = *v5;
        std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::__add_back_capacity((uint64_t)a2);
        long long v10 = v59;
        uint64_t v9 = *((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 5) + *((void *)a2 + 4);
      }
      *(_OWORD *)(*(void *)(v9 + ((v12 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v12) = v10;
      uint64_t v6 = *((void *)a2 + 5) + 1;
      *((void *)a2 + 5) = v6;
      ++v5;
      v7 -= 16;
    }
    while (v7);
  }
  uint64_t v13 = *((void *)this + 1);
  unint64_t v14 = v13 & 0xFFFFFFFFFFFFFFF8;
  if ((v13 & 6) != 6 || v14 == 0)
  {
    if ((v13 & 6) == 0 && v14 != 0)
    {
      uint64_t v17 = *(void *)(v14 + 8);
      {
        BOOL v60 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::CFGEdge]";
        unint64_t v61 = 73;
        unint64_t v52 = llvm::StringRef::find((uint64_t *)&v60, "DesiredTypeName = ", 0x12uLL, 0);
        if (v61 >= v52) {
          unint64_t v53 = v52;
        }
        else {
          unint64_t v53 = v61;
        }
        int v54 = &v60[v53];
        unint64_t v55 = v61 - v53;
        if (v61 - v53 >= 0x12) {
          uint64_t v56 = 18;
        }
        else {
          uint64_t v56 = v61 - v53;
        }
        unint64_t v57 = v55 - v56;
        if (v57 >= v57 - 1) {
          uint64_t v58 = v57 - 1;
        }
        else {
          uint64_t v58 = v57;
        }
        mlir::detail::TypeIDResolver<mlir::dataflow::CFGEdge,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v54[v56], v58);
      }
      if (v17 == mlir::detail::TypeIDResolver<mlir::dataflow::CFGEdge,void>::resolveTypeID(void)::id)
      {
        uint64_t v18 = *((unsigned int *)this + 34);
        if (v18)
        {
          uint64_t v19 = (uint64_t *)*((void *)this + 16);
          uint64_t v20 = *((void *)a2 + 5);
          uint64_t v21 = 8 * v18;
          do
          {
            uint64_t v23 = *((void *)a2 + 2);
            uint64_t v24 = *((void *)a2 + 1);
            uint64_t v25 = *v19;
            uint64_t v26 = *(void *)(v14 + 24);
            if (v23 == v24) {
              uint64_t v27 = 0;
            }
            else {
              uint64_t v27 = 32 * (v23 - v24) - 1;
            }
            unint64_t v28 = v20 + *((void *)a2 + 4);
            if (v27 == v28)
            {
              std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::__add_back_capacity((uint64_t)a2);
              uint64_t v24 = *((void *)a2 + 1);
              unint64_t v28 = *((void *)a2 + 5) + *((void *)a2 + 4);
            }
            uint64_t v22 = (uint64_t *)(*(void *)(v24 + ((v28 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v28);
            *uint64_t v22 = v26 | 6;
            v22[1] = v25;
            uint64_t v20 = *((void *)a2 + 5) + 1;
            *((void *)a2 + 5) = v20;
            ++v19;
            v21 -= 8;
          }
          while (v21);
        }
      }
    }
  }
  else
  {
    uint64_t v29 = *((unsigned int *)this + 34);
    if (v29)
    {
      uint64_t v30 = (unint64_t *)*((void *)this + 16);
      uint64_t v31 = *((void *)a2 + 5);
      uint64_t v32 = 8 * v29;
      do
      {
        uint64_t v34 = *((void *)a2 + 2);
        uint64_t v35 = *((void *)a2 + 1);
        unint64_t v36 = *v30;
        if (v34 == v35) {
          uint64_t v37 = 0;
        }
        else {
          uint64_t v37 = 32 * (v34 - v35) - 1;
        }
        unint64_t v38 = v31 + *((void *)a2 + 4);
        if (v37 == v38)
        {
          std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::__add_back_capacity((uint64_t)a2);
          uint64_t v35 = *((void *)a2 + 1);
          unint64_t v38 = *((void *)a2 + 5) + *((void *)a2 + 4);
        }
        unint64_t v33 = (unint64_t *)(*(void *)(v35 + ((v38 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v38);
        unint64_t *v33 = v14 | 6;
        v33[1] = v36;
        uint64_t v31 = *((void *)a2 + 5) + 1;
        *((void *)a2 + 5) = v31;
        ++v30;
        v32 -= 8;
      }
      while (v32);
      uint64_t v39 = *((unsigned int *)this + 34);
      if (v39)
      {
        uint64_t v40 = (mlir::GenericProgramPoint *)(v14 + 32);
        if (*(void *)(v14 + 40) != v14 + 32)
        {
          int64_t v41 = (unint64_t *)*((void *)this + 16);
          uint64_t v42 = &v41[v39];
          do
          {
            unint64_t v43 = *(mlir::GenericProgramPoint **)(v14 + 40);
            if (v43 != v40)
            {
              unint64_t v44 = *v41;
              do
              {
                mlir::GenericProgramPoint::~GenericProgramPoint(v43);
                uint64_t v47 = v46;
                uint64_t v48 = *((void *)a2 + 2);
                uint64_t v49 = *((void *)a2 + 1);
                uint64_t v50 = 32 * (v48 - v49) - 1;
                if (v48 == v49) {
                  uint64_t v50 = 0;
                }
                unint64_t v51 = *((void *)a2 + 5) + *((void *)a2 + 4);
                if (v50 == v51)
                {
                  std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::__add_back_capacity((uint64_t)a2);
                  uint64_t v49 = *((void *)a2 + 1);
                  unint64_t v51 = *((void *)a2 + 5) + *((void *)a2 + 4);
                }
                uint64_t v45 = (unint64_t *)(*(void *)(v49 + ((v51 >> 5) & 0x7FFFFFFFFFFFFF8))
                                         + 16 * v51);
                *uint64_t v45 = v47 & 0xFFFFFFFFFFFFFFF9 | 2;
                v45[1] = v44;
                ++*((void *)a2 + 5);
                unint64_t v43 = (mlir::GenericProgramPoint *)*((void *)v43 + 1);
              }
              while (v43 != v40);
            }
            ++v41;
          }
          while (v41 != v42);
        }
      }
    }
  }
}

llvm::raw_ostream *mlir::dataflow::PredecessorState::print(llvm::raw_ostream *this, llvm::raw_ostream *a2)
{
  int v3 = this;
  if (!*((unsigned char *)this + 56))
  {
LABEL_4:
    uint64_t v5 = (void *)*((void *)a2 + 4);
    if (*((void *)a2 + 3) - (void)v5 <= 0xDuLL) {
      goto LABEL_5;
    }
    goto LABEL_8;
  }
  uint64_t v4 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v4) <= 5)
  {
    this = llvm::raw_ostream::write(a2, "(all) ", 6uLL);
    goto LABEL_4;
  }
  *(_WORD *)(v4 + 4) = 8233;
  *(_DWORD *)uint64_t v4 = 1819042088;
  *((void *)a2 + 4) += 6;
  uint64_t v5 = (void *)*((void *)a2 + 4);
  if (*((void *)a2 + 3) - (void)v5 <= 0xDuLL)
  {
LABEL_5:
    this = llvm::raw_ostream::write(a2, "predecessors:\n", 0xEuLL);
    uint64_t v6 = *((unsigned int *)v3 + 34);
    if (!v6) {
      return this;
    }
    goto LABEL_9;
  }
LABEL_8:
  qmemcpy(v5, "predecessors:\n", 14);
  *((void *)a2 + 4) += 14;
  uint64_t v6 = *((unsigned int *)v3 + 34);
  if (!v6) {
    return this;
  }
LABEL_9:
  uint64_t v7 = (mlir::Operation **)*((void *)v3 + 16);
  uint64_t v8 = 8 * v6;
  do
  {
    while (1)
    {
      uint64_t v9 = *v7;
      long long v10 = (_WORD *)*((void *)a2 + 4);
      if (*((void *)a2 + 3) - (void)v10 > 1uLL)
      {
        *long long v10 = 8224;
        *((void *)a2 + 4) += 2;
        uint64_t v11 = a2;
      }
      else
      {
        uint64_t v11 = llvm::raw_ostream::write(a2, "  ", 2uLL);
      }
      mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)v14);
      unint64_t v12 = (const mlir::OpPrintingFlags *)mlir::OpPrintingFlags::useLocalScope((uint64_t)v14);
      this = mlir::Operation::print(v9, v11, v12);
      uint64_t v13 = (unsigned char *)*((void *)v11 + 4);
      if (*((unsigned char **)v11 + 3) == v13) {
        break;
      }
      *uint64_t v13 = 10;
      ++*((void *)v11 + 4);
      ++v7;
      v8 -= 8;
      if (!v8) {
        return this;
      }
    }
    this = llvm::raw_ostream::write(v11, "\n", 1uLL);
    ++v7;
    v8 -= 8;
  }
  while (v8);
  return this;
}

BOOL llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u>,llvm::SmallPtrSet<mlir::Operation *,4u>,0u>::insert(llvm::SmallPtrSetImplBase *this, const void **a2)
{
  uint64_t v4 = *a2;
  uint64_t v5 = *((void *)this + 1);
  if (v5 != *(void *)this) {
    goto LABEL_2;
  }
  uint64_t v11 = *((unsigned int *)this + 5);
  if (v11)
  {
    unint64_t v12 = 0;
    uint64_t v13 = 8 * v11;
    unint64_t v14 = (void *)*((void *)this + 1);
    do
    {
      if ((const void *)*v14 == v4)
      {
        BOOL v7 = 0;
        goto LABEL_3;
      }
      if (*v14 == -2) {
        unint64_t v12 = v14;
      }
      ++v14;
      v13 -= 8;
    }
    while (v13);
    if (!v12) {
      goto LABEL_16;
    }
    void *v12 = v4;
    --*((_DWORD *)this + 6);
    BOOL v7 = 1;
  }
  else
  {
LABEL_16:
    if (v11 >= *((_DWORD *)this + 4))
    {
LABEL_2:
      llvm::SmallPtrSetImplBase::insert_imp_big(this, v4);
      BOOL v7 = v6 != 0;
      goto LABEL_3;
    }
    *((_DWORD *)this + 5) = v11 + 1;
    *(void *)(v5 + 8 * v11) = v4;
    BOOL v7 = 1;
  }
LABEL_3:
  if (v7)
  {
    uint64_t v8 = *a2;
    uint64_t v9 = *((unsigned int *)this + 18);
    if (v9 >= *((_DWORD *)this + 19))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)this + 64, (char *)this + 80, v9 + 1, 8);
      LODWORD(v9) = *((_DWORD *)this + 18);
    }
    *(void *)(*((void *)this + 8) + 8 * v9) = v8;
    ++*((_DWORD *)this + 18);
  }
  return v7;
}

uint64_t mlir::dataflow::PredecessorState::join(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v29 = a2;
  uint64_t v32 = a2;
  BOOL v8 = llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u>,llvm::SmallPtrSet<mlir::Operation *,4u>,0u>::insert((llvm::SmallPtrSetImplBase *)(a1 + 64), &v32);
  if (!a4) {
    return v8;
  }
  uint64_t v11 = *(void *)(a1 + 176);
  uint64_t v10 = a1 + 176;
  uint64_t v9 = v11;
  int v12 = *(_DWORD *)(v10 + 16);
  if (!v12)
  {
    uint64_t v21 = 0;
LABEL_14:
    int v15 = llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::ValueRange,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::ValueRange>>,mlir::Operation *,mlir::ValueRange,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::ValueRange>>::InsertIntoBucket<mlir::Operation * const&>(v10, v21, (uint64_t *)&v29);
    goto LABEL_15;
  }
  int v13 = v12 - 1;
  unsigned int v14 = ((a2 >> 4) ^ (a2 >> 9)) & v13;
  int v15 = (uint64_t *)(v9 + 24 * v14);
  uint64_t v16 = *v15;
  if ((const void *)*v15 != a2)
  {
    uint64_t v17 = 0;
    int v18 = 1;
    while (v16 != -4096)
    {
      if (v17) {
        BOOL v19 = 0;
      }
      else {
        BOOL v19 = v16 == -8192;
      }
      if (v19) {
        uint64_t v17 = v15;
      }
      unsigned int v20 = v14 + v18++;
      unsigned int v14 = v20 & v13;
      int v15 = (uint64_t *)(v9 + 24 * v14);
      uint64_t v16 = *v15;
      if ((const void *)*v15 == a2) {
        goto LABEL_15;
      }
    }
    if (v17) {
      uint64_t v21 = v17;
    }
    else {
      uint64_t v21 = v15;
    }
    goto LABEL_14;
  }
LABEL_15:
  if (v15[2] == a4)
  {
    uint64_t v22 = 0;
    uint64_t v23 = (const void *)v15[1];
    uint64_t v32 = v23;
    uint64_t v33 = 0;
    uint64_t v30 = a3;
    uint64_t v31 = 0;
    do
    {
      uint64_t v24 = mlir::ValueRange::dereference_iterator(&v32, v22);
      if (v24 != mlir::ValueRange::dereference_iterator(&v30, v31)) {
        break;
      }
      uint64_t v22 = ++v33;
      uint64_t v25 = ++v31;
      if (v32 == v23 && v22 == a4)
      {
        if (v30 == a3 && v25 == a4) {
          return v8;
        }
        break;
      }
    }
    while (v30 != a3 || v25 != a4);
  }
  v15[1] = a3;
  _OWORD v15[2] = a4;
  return 1;
}

void mlir::dataflow::CFGEdge::getLoc(mlir::Block **this)
{
  v6[2] = *(uint64_t **)MEMORY[0x1E4F143B8];
  Parent = (mlir::Region *)mlir::Block::getParent(this[2]);
  Context = (mlir::UnknownLoc *)mlir::Region::getContext(Parent);
  uint64_t v4 = (mlir::Region *)mlir::Block::getParent(this[2]);
  v6[0] = (uint64_t *)mlir::Region::getLoc(v4);
  uint64_t v5 = (mlir::Region *)mlir::Block::getParent(this[3]);
  v6[1] = (uint64_t *)mlir::Region::getLoc(v5);
  mlir::FusedLoc::get(v6, (mlir::MLIRContext *)2, 0, Context);
}

llvm::raw_ostream *mlir::dataflow::CFGEdge::print(mlir::Block **this, llvm::raw_ostream *a2)
{
  mlir::Block::print(this[2], a2);
  uint64_t v4 = *((void *)a2 + 4);
  if ((unint64_t)(*((void *)a2 + 3) - v4) > 5)
  {
    *(_WORD *)(v4 + 4) = 2592;
    *(_DWORD *)uint64_t v4 = 1043144714;
    *((void *)a2 + 4) += 6;
    uint64_t v5 = this[3];
    char v6 = a2;
  }
  else
  {
    llvm::raw_ostream::write(a2, "\n -> \n", 6uLL);
    uint64_t v5 = this[3];
    char v6 = a2;
  }
  return mlir::Block::print(v5, v6);
}

mlir::dataflow::DeadCodeAnalysis *mlir::dataflow::DeadCodeAnalysis::DeadCodeAnalysis(mlir::dataflow::DeadCodeAnalysis *this, mlir::DataFlowSolver *a2)
{
  int v3 = mlir::DataFlowAnalysis::DataFlowAnalysis(this, a2);
  void *v3 = &unk_1EC9CDAF8;
  v3[3] = 0;
  v3[4] = 0;
  *((_DWORD *)v3 + 10) = 0;
  mlir::StorageUniquer::registerParametricStorageType<mlir::dataflow::CFGEdge>((uint64_t *)(v3[1] + 112));
  return this;
}

uint64_t mlir::dataflow::DeadCodeAnalysis::initialize(mlir::dataflow::DeadCodeAnalysis *this, mlir::Operation *a2)
{
  unint64_t v4 = *((unsigned int *)a2 + 11);
  if ((v4 & 0x7FFFFF) != 0)
  {
    uint64_t v5 = (void *)((((unint64_t)a2 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)a2 + 10));
    uint64_t v6 = 24 * (v4 & 0x7FFFFF);
    do
    {
      if (v5 != (void *)*v5)
      {
        uint64_t v8 = v5[1];
        if (v8) {
          uint64_t v9 = v8 - 8;
        }
        else {
          uint64_t v9 = 0;
        }
        uint64_t v10 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(*((void *)this + 1), v9);
        if (*((unsigned char *)v10 + 56))
        {
          int v7 = 0;
        }
        else
        {
          int v7 = 1;
          *((unsigned char *)v10 + 56) = 1;
        }
        mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)this, (uint64_t)v10, v7);
      }
      v5 += 3;
      v6 -= 24;
    }
    while (v6);
  }
  *((void *)this + 2) = a2;
  v12[0] = this;
  v12[1] = &v13;
  int v13 = a2;
  mlir::SymbolTable::walkSymbolTables((uint64_t)a2, *((void *)a2 + 2) == 0, (uint64_t (*)(uint64_t, uint64_t, BOOL))llvm::function_ref<void ()(mlir::Operation *,BOOL)>::callback_fn<mlir::dataflow::DeadCodeAnalysis::initializeSymbolCallables(mlir::Operation *)::$_0>, (uint64_t)v12);
  return mlir::dataflow::DeadCodeAnalysis::initializeRecursively(this, (unint64_t)a2);
}

uint64_t mlir::dataflow::DeadCodeAnalysis::initializeRecursively(mlir::dataflow::DeadCodeAnalysis *this, unint64_t a2)
{
  if ((*(_DWORD *)(a2 + 44) & 0x7FFFFF) != 0 || *(_DWORD *)(a2 + 40)) {
    goto LABEL_3;
  }
  ParentOp = *(mlir::Block **)(a2 + 16);
  if (ParentOp) {
    ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
  }
  *(void *)&long long v21 = ParentOp;
  if (_ZN4llvm3isaIN4mlir23RegionBranchOpInterfaceENS1_19CallableOpInterfaceEJEPNS1_9OperationEEEbRKT2_((uint64_t *)&v21))
  {
    mlir::Block::getTerminator(*(mlir::GenericProgramPoint ***)(a2 + 16));
    if (v14 == (mlir::Operation *)a2) {
      goto LABEL_3;
    }
  }
  uint64_t v15 = *(void *)(a2 + 48);
  uint64_t v16 = *(void **)(v15 + 16);
  BOOL v17 = v16 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v16 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v18 = 0;
  }
  else {
    uint64_t v18 = *(void *)(a2 + 48);
  }
  if (v17)
  {
    *(void *)&long long v21 = *(void *)(v15 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v21);
    if (!Values || !mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(Values, v15)) {
      goto LABEL_6;
    }
LABEL_3:
    uint64_t v4 = *(void *)(a2 + 16);
    if (v4)
    {
      uint64_t v5 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(*((void *)this + 1), v4);
      *(void *)&long long v21 = this;
      llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u>,llvm::SmallPtrSet<mlir::Operation *,4u>,0u>::insert((llvm::SmallPtrSetImplBase *)(v5 + 8), (const void **)&v21);
    }
    if (!(*(unsigned __int8 (**)(mlir::dataflow::DeadCodeAnalysis *, unint64_t))(*(void *)this
                                                                                                  + 24))(this, a2 & 0xFFFFFFFFFFFFFFF9 | 2))return 0;
    goto LABEL_6;
  }
  unint64_t v19 = v18 | v15 & 0xFFFFFFFFFFFFFF00;
  if (mlir::detail::InterfaceMap::lookup<mlir::CallOpInterface>(v19 + 32)
    || mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(*(void *)(v19 + 24), *(void *)(a2 + 48)))
  {
    goto LABEL_3;
  }
LABEL_6:
  unint64_t v6 = *(unsigned int *)(a2 + 44);
  if ((v6 & 0x7FFFFF) == 0) {
    return 1;
  }
  int v7 = (mlir::Region *)(((a2 + 16 * ((v6 >> 23) & 1) + ((v6 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                      + 32 * *(unsigned int *)(a2 + 40));
  uint64_t v8 = (mlir::Region *)((char *)v7 + 24 * (v6 & 0x7FFFFF));
  while (1)
  {
    mlir::Region::OpIterator::OpIterator(&v25, v7, 0);
    mlir::Region::OpIterator::OpIterator(&v23, v7, 1);
    uint64_t v9 = v26;
    uint64_t v22 = v26;
    long long v21 = v25;
    uint64_t v10 = v24;
    if (v26 != v24) {
      break;
    }
LABEL_11:
    int v7 = (mlir::Region *)((char *)v7 + 24);
    if (v7 == v8) {
      return 1;
    }
  }
  while (1)
  {
    mlir::GenericProgramPoint::~GenericProgramPoint(v9);
    if (!mlir::dataflow::DeadCodeAnalysis::initializeRecursively(this, v11)) {
      return 0;
    }
    mlir::Region::OpIterator::operator++((uint64_t *)&v25);
    uint64_t v9 = v26;
    if (v26 == v10) {
      goto LABEL_11;
    }
  }
}

uint64_t mlir::dataflow::DeadCodeAnalysis::markEdgeLive(mlir::dataflow::DeadCodeAnalysis *this, mlir::Block *a2, mlir::Block *a3)
{
  uint64_t v9 = a3;
  uint64_t v10 = a2;
  uint64_t v4 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(*((void *)this + 1), (uint64_t)a3);
  if (*((unsigned char *)v4 + 56))
  {
    int v5 = 0;
  }
  else
  {
    int v5 = 1;
    *((unsigned char *)v4 + 56) = 1;
  }
  mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)this, (uint64_t)v4, v5);
  uint64_t v6 = mlir::StorageUniquer::get<mlir::dataflow::CFGEdge,mlir::Block *&,mlir::Block *&>((unsigned __int8 **)(*((void *)this + 1) + 112), 0, 0, &v10, &v9);
  int v7 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::dataflow::CFGEdge *>(*((void *)this + 1), v6);
  if (*((unsigned char *)v7 + 56)) {
    return mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)this, (uint64_t)v7, 0);
  }
  *((unsigned char *)v7 + 56) = 1;
  return mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)this, (uint64_t)v7, 1);
}

uint64_t mlir::dataflow::DeadCodeAnalysis::markEntryBlocksLive(uint64_t this, mlir::Operation *a2)
{
  unint64_t v2 = *((unsigned int *)a2 + 11);
  if ((v2 & 0x7FFFFF) != 0)
  {
    uint64_t v3 = this;
    uint64_t v4 = (void *)((((unint64_t)a2 + 16 * ((v2 >> 23) & 1) + ((v2 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)a2 + 10));
    uint64_t v5 = 24 * (v2 & 0x7FFFFF);
    do
    {
      if (v4 != (void *)*v4)
      {
        uint64_t v7 = v4[1];
        if (v7) {
          uint64_t v8 = v7 - 8;
        }
        else {
          uint64_t v8 = 0;
        }
        uint64_t v9 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(*(void *)(v3 + 8), v8);
        if (*((unsigned char *)v9 + 56))
        {
          int v6 = 0;
        }
        else
        {
          int v6 = 1;
          *((unsigned char *)v9 + 56) = 1;
        }
        this = mlir::DataFlowAnalysis::propagateIfChanged(v3, (uint64_t)v9, v6);
      }
      v4 += 3;
      v5 -= 24;
    }
    while (v5);
  }
  return this;
}

uint64_t mlir::dataflow::DeadCodeAnalysis::visit(uint64_t *a1, uint64_t a2)
{
  v52[1] = *MEMORY[0x1E4F143B8];
  v52[0] = a2;
  if ((a2 & 6) == 6) {
    return 1;
  }
  if ((a2 & 6) == 2 && (unint64_t v4 = a2 & 0xFFFFFFFFFFFFFFF8, (a2 & 0xFFFFFFFFFFFFFFF8) != 0))
  {
    if (!*((unsigned char *)mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(a1[1], *(void *)(v4 + 16))+ 56))return 1; {
    uint64_t v6 = llvm::DefaultDoCastIfPossible<mlir::CallOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallOpInterface,mlir::Operation *,void>>::doCastIfPossible(v4);
    }
    if (v6) {
      mlir::dataflow::DeadCodeAnalysis::visitCallOperation((uint64_t)a1, v6, v7);
    }
    if ((*(_DWORD *)(v4 + 44) & 0x7FFFFF) != 0)
    {
      uint64_t v8 = (void *)llvm::DefaultDoCastIfPossible<mlir::RegionBranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::RegionBranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(v4);
      if (v8)
      {
        mlir::dataflow::DeadCodeAnalysis::visitRegionBranchOperation(a1, v8, v9);
      }
      else
      {
        uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::CallableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallableOpInterface,mlir::Operation *,void>>::doCastIfPossible(v4);
        if (v19)
        {
          unsigned int v20 = (mlir::Operation *)v19;
          long long v21 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(a1[1], v19);
          mlir::DataFlowAnalysis::addDependency((uint64_t)a1, (uint64_t)v21, v4 | 2);
          if (!*((unsigned char *)v21 + 56) || *((_DWORD *)v21 + 34)) {
            mlir::dataflow::DeadCodeAnalysis::markEntryBlocksLive((uint64_t)a1, v20);
          }
        }
        else
        {
          unint64_t v22 = *(unsigned int *)(v4 + 44);
          if ((v22 & 0x7FFFFF) != 0)
          {
            uint64_t v23 = (void *)(((v4 + 16 * ((v22 >> 23) & 1) + ((v22 >> 21) & 0x7F8) + 64) & 0xFFFFFFFFFFFFFFF8)
                           + 32 * *(unsigned int *)(v4 + 40));
            uint64_t v24 = 24 * (v22 & 0x7FFFFF);
            do
            {
              if (v23 != (void *)*v23)
              {
                uint64_t v26 = v23[1];
                if (v26) {
                  uint64_t v27 = v26 - 8;
                }
                else {
                  uint64_t v27 = 0;
                }
                unint64_t v28 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(a1[1], v27);
                if (*((unsigned char *)v28 + 56))
                {
                  int v25 = 0;
                }
                else
                {
                  int v25 = 1;
                  *((unsigned char *)v28 + 56) = 1;
                }
                mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)a1, (uint64_t)v28, v25);
              }
              v23 += 3;
              v24 -= 24;
            }
            while (v24);
          }
        }
      }
    }
    if (!*(_DWORD *)(v4 + 40))
    {
      ParentOp = *(mlir::Block **)(v4 + 16);
      if (ParentOp) {
        ParentOp = (mlir::Block *)mlir::Block::getParentOp(ParentOp);
      }
      unint64_t v43 = ParentOp;
      if (_ZN4llvm3isaIN4mlir23RegionBranchOpInterfaceENS1_19CallableOpInterfaceEJEPNS1_9OperationEEEbRKT2_((uint64_t *)&v43))
      {
        mlir::Block::getTerminator(*(mlir::GenericProgramPoint ***)(v4 + 16));
        if (v30 == v4)
        {
          uint64_t v31 = *(mlir::Block **)(v4 + 16);
          if (v31) {
            uint64_t v31 = (mlir::Block *)mlir::Block::getParentOp(v31);
          }
          uint64_t v32 = llvm::DefaultDoCastIfPossible<mlir::RegionBranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::RegionBranchOpInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v31);
          if (v32)
          {
            mlir::dataflow::DeadCodeAnalysis::visitRegionTerminator(a1, (mlir::Operation *)v4, v32, v33);
          }
          else
          {
            uint64_t v34 = *(mlir::Block **)(v4 + 16);
            if (v34) {
              uint64_t v34 = (mlir::Block *)mlir::Block::getParentOp(v34);
            }
            uint64_t v35 = llvm::DefaultDoCastIfPossible<mlir::CallableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallableOpInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v34);
            if (v35) {
              mlir::dataflow::DeadCodeAnalysis::visitCallableTerminator((uint64_t)a1, v4, v35);
            }
          }
        }
      }
    }
    if (!*(_DWORD *)(v4 + 40)) {
      return 1;
    }
    unint64_t v36 = (Operation *)llvm::DefaultDoCastIfPossible<mlir::BranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::BranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(v4);
    if (v36)
    {
      mlir::dataflow::DeadCodeAnalysis::visitBranchOperation((mlir::dataflow::DeadCodeAnalysis *)a1, v36, v37);
      return 1;
    }
    mlir::SuccessorRange::SuccessorRange((unint64_t *)&v43, (Operation *)v4);
    uint64_t v38 = v44;
    if (!v44) {
      return 1;
    }
    uint64_t v39 = (mlir::Block **)((char *)v43 + 24);
    uint64_t v2 = 1;
    do
    {
      uint64_t v40 = *v39;
      v39 += 4;
      mlir::dataflow::DeadCodeAnalysis::markEdgeLive((mlir::dataflow::DeadCodeAnalysis *)a1, *(mlir::Block **)(v4 + 16), v40);
      --v38;
    }
    while (v38);
  }
  else
  {
    uint64_t Loc = mlir::ProgramPoint::getLoc((mlir::ProgramPoint *)v52);
    int64_t v41 = "unknown program point kind";
    __int16 v42 = 259;
    mlir::emitError(Loc, (uint64_t)&v41, (uint64_t)&v43);
    uint64_t v2 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v43);
    if (v43) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v43);
    }
    if (v51)
    {
      uint64_t v11 = (void **)__p;
      if (__p)
      {
        int v12 = v50;
        int v13 = __p;
        if (v50 != __p)
        {
          do
            int v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
          while (v12 != v11);
          int v13 = __p;
        }
        uint64_t v50 = v11;
        operator delete(v13);
      }
      unsigned int v14 = v47;
      if (v47)
      {
        uint64_t v15 = v48;
        uint64_t v16 = v47;
        if (v48 != v47)
        {
          do
          {
            uint64_t v18 = (void *)*--v15;
            BOOL v17 = v18;
            *uint64_t v15 = 0;
            if (v18) {
              operator delete[](v17);
            }
          }
          while (v15 != v14);
          uint64_t v16 = v47;
        }
        uint64_t v48 = v14;
        operator delete(v16);
      }
      if (v45 != &v46) {
        free(v45);
      }
    }
  }
  return v2;
}

uint64_t mlir::dataflow::DeadCodeAnalysis::visitCallOperation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v14[0] = a2;
  v14[1] = a3;
  unint64_t v4 = (mlir::SymbolOpInterface *)mlir::CallOpInterface::resolveCallable((uint64_t)v14, a1 + 24);
  if (v4
    && (uint64_t v6 = v4, mlir::SymbolOpInterface::classof(v4, v5))
    && ((uint64_t v7 = *(mlir::Operation **)(a1 + 16), v7 == v6) || mlir::Operation::isProperAncestor(v7, v6))
    && ((v15[0] = (const void *)llvm::DefaultDoCastIfPossible<mlir::CallableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallableOpInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)v6),
         v15[1] = v8,
         !v15[0])
     || mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)v15)))
  {
    uint64_t v9 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*(void *)(a1 + 8), (uint64_t)v6);
    v15[0] = (const void *)v14[0];
    BOOL v10 = llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u>,llvm::SmallPtrSet<mlir::Operation *,4u>,0u>::insert((llvm::SmallPtrSetImplBase *)(v9 + 8), v15);
    return mlir::DataFlowAnalysis::propagateIfChanged(a1, (uint64_t)v9, v10);
  }
  else
  {
    int v12 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*(void *)(a1 + 8), v14[0]);
    int v13 = *((unsigned __int8 *)v12 + 56);
    *((unsigned char *)v12 + 56) = 0;
    return mlir::DataFlowAnalysis::propagateIfChanged(a1, (uint64_t)v12, v13);
  }
}

void mlir::dataflow::DeadCodeAnalysis::visitRegionBranchOperation(uint64_t *a1, void *a2, const void *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  v13[0] = a2;
  v13[1] = a3;
  mlir::dataflow::DeadCodeAnalysis::getOperandValues((mlir::dataflow::DeadCodeAnalysis *)a1, (mlir::Operation *)a2, (uint64_t)&v17);
  if (!v20) {
    return;
  }
  unsigned int v14 = v16;
  uint64_t v15 = 0x200000000;
  mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v13, (uint64_t)v17, v18, (uint64_t)&v14);
  unint64_t v4 = (uint64_t *)v14;
  if (!v15) {
    goto LABEL_15;
  }
  uint64_t v5 = (uint64_t *)((char *)v14 + 24 * v15);
  do
  {
    if (*v4)
    {
      uint64_t v9 = *(void *)(*v4 + 8);
      if (v9) {
        uint64_t v10 = v9 - 8;
      }
      else {
        uint64_t v10 = 0;
      }
      uint64_t v11 = (const char *)(v10 | 6);
      int v12 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::ProgramPoint>(a1[1], (const char *)(v10 | 6));
      if (!v12[56])
      {
LABEL_4:
        int v6 = 1;
        v12[56] = 1;
        goto LABEL_5;
      }
    }
    else
    {
      uint64_t v11 = (const char *)((unint64_t)v13[0] & 0xFFFFFFFFFFFFFFF9 | 2);
      int v12 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::ProgramPoint>(a1[1], v11);
      if (!v12[56]) {
        goto LABEL_4;
      }
    }
    int v6 = 0;
LABEL_5:
    mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)a1, (uint64_t)v12, v6);
    uint64_t v7 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::ProgramPoint>(a1[1], v11);
    int v8 = mlir::dataflow::PredecessorState::join((uint64_t)v7, v13[0], v4[1], v4[2]);
    mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)a1, (uint64_t)v7, v8);
    v4 += 3;
  }
  while (v4 != v5);
  unint64_t v4 = (uint64_t *)v14;
LABEL_15:
  if (v4 != (uint64_t *)v16) {
    free(v4);
  }
  if (v20)
  {
    if (v17 != &v19) {
      free(v17);
    }
  }
}

void mlir::dataflow::DeadCodeAnalysis::visitRegionTerminator(uint64_t *a1, mlir::Operation *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  v23[0] = a3;
  v23[1] = a4;
  mlir::dataflow::DeadCodeAnalysis::getOperandValues((mlir::dataflow::DeadCodeAnalysis *)a1, a2, (uint64_t)&v27);
  if (!v30) {
    return;
  }
  uint64_t v24 = v26;
  uint64_t v25 = 0x200000000;
  v22[0] = llvm::DefaultDoCastIfPossible<mlir::RegionBranchTerminatorOpInterface,mlir::Operation *,llvm::CastInfo<mlir::RegionBranchTerminatorOpInterface,mlir::Operation *,void>>::doCastIfPossible((uint64_t)a2);
  v22[1] = v6;
  if (!v22[0])
  {
    uint64_t v9 = (mlir::Block *)*((void *)a2 + 2);
    if (v9) {
      unint64_t Parent = mlir::Block::getParent(v9);
    }
    else {
      unint64_t Parent = 0;
    }
    mlir::BranchOpInterface::getSuccessorForOperands(v23, Parent, (uint64_t)&v24);
    uint64_t v7 = (uint64_t *)v24;
    unsigned int v8 = v25;
    if (!v25) {
      goto LABEL_24;
    }
LABEL_9:
    uint64_t v11 = &v7[3 * v8];
    do
    {
      uint64_t v15 = *v7;
      if (*v7)
      {
        uint64_t v16 = *(void *)(v15 + 8);
        if (v16) {
          uint64_t v17 = v16 - 8;
        }
        else {
          uint64_t v17 = 0;
        }
        unsigned int v18 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(a1[1], v17);
        if (*((unsigned char *)v18 + 56))
        {
          int v19 = 0;
        }
        else
        {
          int v19 = 1;
          *((unsigned char *)v18 + 56) = 1;
        }
        mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)a1, (uint64_t)v18, v19);
        uint64_t v20 = *(void *)(v15 + 8);
        if (v20) {
          uint64_t v21 = v20 - 8;
        }
        else {
          uint64_t v21 = 0;
        }
        int v12 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Block *>(a1[1], v21);
      }
      else
      {
        int v12 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(a1[1], v23[0]);
      }
      uint64_t v13 = (uint64_t)v12;
      int v14 = mlir::dataflow::PredecessorState::join((uint64_t)v12, a2, v7[1], v7[2]);
      mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)a1, v13, v14);
      v7 += 3;
    }
    while (v7 != v11);
    uint64_t v7 = (uint64_t *)v24;
    goto LABEL_24;
  }
  mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v22, (uint64_t)v27, v28, (uint64_t)&v24);
  uint64_t v7 = (uint64_t *)v24;
  unsigned int v8 = v25;
  if (v25) {
    goto LABEL_9;
  }
LABEL_24:
  if (v7 != (uint64_t *)v26) {
    free(v7);
  }
  if (v30)
  {
    if (v27 != &v29) {
      free(v27);
    }
  }
}

uint64_t mlir::dataflow::DeadCodeAnalysis::visitCallableTerminator(uint64_t a1, unint64_t a2, uint64_t a3)
{
  unint64_t v5 = a2 & 0xFFFFFFFFFFFFFFF9 | 2;
  uint64_t v6 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*(void *)(a1 + 8), a3);
  mlir::DataFlowAnalysis::addDependency(a1, (uint64_t)v6, v5);
  uint64_t result = mlir::OperationName::hasTrait<mlir::OpTrait::ReturnLike>((void *)(a2 + 48));
  uint64_t v8 = *((unsigned int *)v6 + 34);
  if (v8)
  {
    uint64_t v9 = (uint64_t *)v6[16];
    if (result)
    {
      uint64_t v10 = 8 * v8;
      do
      {
        uint64_t v11 = *v9++;
        int v12 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*(void *)(a1 + 8), v11);
        unint64_t v18 = a2;
        BOOL v13 = llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u>,llvm::SmallPtrSet<mlir::Operation *,4u>,0u>::insert((llvm::SmallPtrSetImplBase *)(v12 + 8), (const void **)&v18);
        uint64_t result = mlir::DataFlowAnalysis::propagateIfChanged(a1, (uint64_t)v12, v13);
        v10 -= 8;
      }
      while (v10);
    }
    else
    {
      uint64_t v14 = 8 * v8;
      do
      {
        uint64_t v15 = *v9++;
        uint64_t v16 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*(void *)(a1 + 8), v15);
        int v17 = *((unsigned __int8 *)v16 + 56);
        *((unsigned char *)v16 + 56) = 0;
        uint64_t result = mlir::DataFlowAnalysis::propagateIfChanged(a1, (uint64_t)v16, v17);
        v14 -= 8;
      }
      while (v14);
    }
  }
  return result;
}

void mlir::dataflow::DeadCodeAnalysis::visitBranchOperation(mlir::dataflow::DeadCodeAnalysis *a1, Operation *a2, Operation *a3)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  v8[0] = a2;
  v8[1] = a3;
  mlir::dataflow::DeadCodeAnalysis::getOperandValues(a1, a2, (uint64_t)&v11);
  if (v14)
  {
    SuccessorForOperands = (mlir::Block *)mlir::BranchOpInterface::getSuccessorForOperands(v8, (uint64_t)v11, v12);
    if (SuccessorForOperands)
    {
      mlir::dataflow::DeadCodeAnalysis::markEdgeLive(a1, *((mlir::Block **)v8[0] + 2), SuccessorForOperands);
    }
    else
    {
      mlir::SuccessorRange::SuccessorRange(&v9, v8[0]);
      uint64_t v5 = v10;
      if (v10)
      {
        uint64_t v6 = (mlir::Block **)(v9 + 24);
        do
        {
          uint64_t v7 = *v6;
          v6 += 4;
          mlir::dataflow::DeadCodeAnalysis::markEdgeLive(a1, *((mlir::Block **)v8[0] + 2), v7);
          --v5;
        }
        while (v5);
      }
    }
    if (v14)
    {
      if (v11 != &v13) {
        free(v11);
      }
    }
  }
}

void mlir::dataflow::DeadCodeAnalysis::getOperandValues(mlir::dataflow::DeadCodeAnalysis *this@<X0>, mlir::Operation *a2@<X1>, uint64_t a3@<X8>)
{
  v22[6] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = v22;
  uint64_t v21 = 0x600000000;
  if ((*((unsigned char *)a2 + 46) & 0x80) == 0) {
    goto LABEL_12;
  }
  unint64_t v6 = *((unsigned int *)a2 + 17);
  if (v6 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v6, 8);
    if ((*((unsigned char *)a2 + 46) & 0x80) == 0) {
      goto LABEL_12;
    }
    LODWORD(v6) = *((_DWORD *)a2 + 17);
  }
  if (v6)
  {
    uint64_t v7 = v6;
    uint64_t v8 = (uint64_t *)(*((void *)a2 + 9) + 24);
    while (1)
    {
      unint64_t v9 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Lattice<mlir::dataflow::ConstantValue>,mlir::Value>(*((void *)this + 1), *v8);
      int v19 = this;
      llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u>,llvm::SmallPtrSet<mlir::Operation *,4u>,0u>::insert((llvm::SmallPtrSetImplBase *)(v9 + 7), &v19);
      if (!*((unsigned char *)v9 + 176)) {
        break;
      }
      uint64_t v10 = v9[21];
      uint64_t v11 = v21;
      if (v21 >= (unint64_t)HIDWORD(v21))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v20, v22, v21 + 1, 8);
        uint64_t v11 = v21;
      }
      *((void *)v20 + v11) = v10;
      unsigned int v12 = v21 + 1;
      LODWORD(v21) = v21 + 1;
      v8 += 4;
      if (!--v7) {
        goto LABEL_13;
      }
    }
    char v14 = 0;
    *(unsigned char *)a3 = 0;
    goto LABEL_18;
  }
LABEL_12:
  unsigned int v12 = v21;
LABEL_13:
  uint64_t v13 = (void *)(a3 + 16);
  *(void *)a3 = a3 + 16;
  *(void *)(a3 + 8) = 0x600000000;
  char v14 = 1;
  if (!v12 || &v20 == (void **)a3)
  {
LABEL_18:
    *(unsigned char *)(a3 + 64) = v14;
    uint64_t v16 = v20;
    if (v20 == v22) {
      return;
    }
    goto LABEL_19;
  }
  if (v20 != v22)
  {
    *(void *)a3 = v20;
    int v15 = HIDWORD(v21);
    *(_DWORD *)(a3 + 8) = v12;
    *(_DWORD *)(a3 + 12) = v15;
    uint64_t v20 = v22;
    HIDWORD(v21) = 0;
    goto LABEL_27;
  }
  if (v12 < 7)
  {
    unint64_t v18 = v22;
    unsigned int v17 = v12;
    goto LABEL_25;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod(a3, (void *)(a3 + 16), v12, 8);
  unsigned int v17 = v21;
  if (v21)
  {
    unint64_t v18 = v20;
    uint64_t v13 = *(void **)a3;
LABEL_25:
    memcpy(v13, v18, 8 * v17);
  }
  *(_DWORD *)(a3 + 8) = v12;
LABEL_27:
  LODWORD(v21) = 0;
  *(unsigned char *)(a3 + 64) = 1;
  uint64_t v16 = v20;
  if (v20 == v22) {
    return;
  }
LABEL_19:
  free(v16);
}

void mlir::dataflow::Executable::~Executable(mlir::dataflow::Executable *this)
{
  *(void *)this = &unk_1EC9CDAC8;
  uint64_t v2 = (char *)*((void *)this + 16);
  if (v2 != (char *)this + 144) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 9);
  if (v3 != *((void **)this + 8)) {
    free(v3);
  }

  mlir::AnalysisState::~AnalysisState(this);
}

{
  char *v2;
  void *v3;

  *(void *)this = &unk_1EC9CDAC8;
  uint64_t v2 = (char *)*((void *)this + 16);
  if (v2 != (char *)this + 144) {
    free(v2);
  }
  uint64_t v3 = (void *)*((void *)this + 9);
  if (v3 != *((void **)this + 8)) {
    free(v3);
  }
  mlir::AnalysisState::~AnalysisState(this);
}

void sub_18018C940(void *__p)
{
  operator delete(__p);
}

void mlir::dataflow::PredecessorState::~PredecessorState(llvm **this)
{
  *this = (llvm *)&unk_1EC9CDB28;
  llvm::deallocate_buffer(this[22], (void *)(24 * *((unsigned int *)this + 48)));
}

{
  *this = (llvm *)&unk_1EC9CDB28;
  llvm::deallocate_buffer(this[22], (void *)(24 * *((unsigned int *)this + 48)));
}

void sub_18018C9A4(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v13 = (void *)*((void *)v12 + 16);
  if (v13 != (void *)((char *)v12 + 144)) {
    free(v13);
  }
  char v14 = (void *)*((void *)v12 + 9);
  if (v14 != *((void **)v12 + 8)) {
    free(v14);
  }
  mlir::AnalysisState::~AnalysisState(v12);
}

void sub_18018CA30()
{
  uint64_t v1 = (void *)*((void *)v0 + 16);
  if (v1 != (void *)((char *)v0 + 144)) {
    free(v1);
  }
  uint64_t v2 = (void *)*((void *)v0 + 9);
  if (v2 != *((void **)v0 + 8)) {
    free(v2);
  }
  mlir::AnalysisState::~AnalysisState(v0);
}

void sub_18018CA5C(void *__p)
{
  operator delete(__p);
}

void mlir::dataflow::CFGEdge::~CFGEdge(mlir::dataflow::CFGEdge *this)
{
  mlir::GenericProgramPoint::~GenericProgramPoint(this);

  operator delete(v1);
}

void mlir::dataflow::DeadCodeAnalysis::~DeadCodeAnalysis(mlir::dataflow::DeadCodeAnalysis *this)
{
  *(void *)this = &unk_1EC9CDAF8;
  uint64_t v2 = *((unsigned int *)this + 10);
  uint64_t v3 = (llvm *)*((void *)this + 3);
  if (v2)
  {
    unint64_t v4 = (uint64_t *)((char *)v3 + 8);
    uint64_t v5 = 16 * v2;
    do
    {
      if ((*(v4 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = *v4;
        uint64_t *v4 = 0;
        if (v6) {
          llvm::deallocate_buffer(*(llvm **)(v6 + 8), (void *)(16 * *(unsigned int *)(v6 + 24)));
        }
      }
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
    uint64_t v3 = (llvm *)*((void *)this + 3);
    uint64_t v7 = (void *)(16 * *((unsigned int *)this + 10));
  }
  else
  {
    uint64_t v7 = 0;
  }
  llvm::deallocate_buffer(v3, v7);
}

{
  uint64_t v2;
  llvm *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;

  *(void *)this = &unk_1EC9CDAF8;
  uint64_t v2 = *((unsigned int *)this + 10);
  uint64_t v3 = (llvm *)*((void *)this + 3);
  if (v2)
  {
    unint64_t v4 = (uint64_t *)((char *)v3 + 8);
    uint64_t v5 = 16 * v2;
    do
    {
      if ((*(v4 - 1) | 0x1000) != 0xFFFFFFFFFFFFF000)
      {
        uint64_t v6 = *v4;
        uint64_t *v4 = 0;
        if (v6) {
          llvm::deallocate_buffer(*(llvm **)(v6 + 8), (void *)(16 * *(unsigned int *)(v6 + 24)));
        }
      }
      v4 += 2;
      v5 -= 16;
    }
    while (v5);
    uint64_t v3 = (llvm *)*((void *)this + 3);
    uint64_t v7 = (void *)(16 * *((unsigned int *)this + 10));
  }
  else
  {
    uint64_t v7 = 0;
  }
  llvm::deallocate_buffer(v3, v7);
}

void sub_18018CB54(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  mlir::GenericProgramPoint::~GenericProgramPoint(v14);
}

void sub_18018CC28(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  mlir::GenericProgramPoint::~GenericProgramPoint(v14);
  operator delete(v15);
}

BOOL _ZN4llvm3isaIN4mlir23RegionBranchOpInterfaceENS1_19CallableOpInterfaceEJEPNS1_9OperationEEEbRKT2_(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = *(void *)(*a1 + 48);
  unint64_t v4 = *(void **)(v3 + 16);
  BOOL v5 = v4 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *(void *)(*a1 + 48);
  }
  if (v5)
  {
    uint64_t v18 = *(void *)(v3 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v18);
    if (!Values || !mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>(Values, v3)) {
      goto LABEL_11;
    }
    return 1;
  }
  unint64_t v7 = v6 | v3 & 0xFFFFFFFFFFFFFF00;
  if (mlir::detail::InterfaceMap::lookup<mlir::RegionBranchOpInterface>(v7 + 32)) {
    return 1;
  }
  if (mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>(*(void *)(v7 + 24), *(void *)(v2 + 48)))
  {
    return 1;
  }
LABEL_11:
  uint64_t v10 = *a1;
  uint64_t v11 = *(void *)(*a1 + 48);
  unsigned int v12 = *(void **)(v11 + 16);
  BOOL v13 = v12 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v12 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v14 = 0;
  }
  else {
    uint64_t v14 = v11;
  }
  if (v13)
  {
    uint64_t v18 = *(void *)(v11 + 8);
    uint64_t v16 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v18);
    if (v16)
    {
      uint64_t v17 = v11;
      goto LABEL_19;
    }
  }
  else
  {
    unint64_t v15 = v14 | v11 & 0xFFFFFFFFFFFFFF00;
    uint64_t v16 = mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(v15 + 32);
    if (!v16)
    {
      uint64_t v16 = *(void *)(v15 + 24);
      uint64_t v17 = *(void *)(v10 + 48);
LABEL_19:
      uint64_t v16 = mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(v16, v17);
    }
  }
  return v16 != 0;
}

uint64_t mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v15 = a1;
    unint64_t v3 = 0x1E8EB8000;
    int v6 = v5;
    uint64_t v2 = a2;
    a1 = v15;
    if (v6)
    {
      uint64_t v16 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      unint64_t v17 = 79;
      unint64_t v7 = llvm::StringRef::find((uint64_t *)&v16, "DesiredTypeName = ", 0x12uLL, 0);
      if (v17 >= v7) {
        unint64_t v8 = v7;
      }
      else {
        unint64_t v8 = v17;
      }
      unint64_t v9 = &v16[v8];
      unint64_t v10 = v17 - v8;
      if (v17 - v8 >= 0x12) {
        uint64_t v11 = 18;
      }
      else {
        uint64_t v11 = v17 - v8;
      }
      unint64_t v12 = v10 - v11;
      if (v12 >= v12 - 1) {
        uint64_t v13 = v12 - 1;
      }
      else {
        uint64_t v13 = v12;
      }
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = a2;
      a1 = v15;
    }
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, *(void *)(v3 + 3920), v2);
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::RegionBranchOpInterface>(uint64_t a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    uint64_t v20 = a1;
    unint64_t v1 = 0x1E8EB8000;
    int v12 = v11;
    a1 = v20;
    if (v12)
    {
      uint64_t v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchOpInterface]";
      unint64_t v22 = 79;
      unint64_t v13 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
      if (v22 >= v13) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = v22;
      }
      uint64_t v15 = &v21[v14];
      unint64_t v16 = v22 - v14;
      if (v22 - v14 >= 0x12) {
        uint64_t v17 = 18;
      }
      else {
        uint64_t v17 = v22 - v14;
      }
      unint64_t v18 = v16 - v17;
      if (v18 >= v18 - 1) {
        uint64_t v19 = v18 - 1;
      }
      else {
        uint64_t v19 = v18;
      }
      mlir::detail::TypeIDResolver<mlir::RegionBranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v15[v17], v19);
      unint64_t v1 = 0x1E8EB8000;
      a1 = v20;
    }
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *(void *)(v1 + 3920);
  unint64_t v4 = *(void **)a1;
  uint64_t v5 = *(void *)a1 + 16 * v2;
  do
  {
    unint64_t v6 = v2 >> 1;
    unint64_t v7 = &v4[2 * (v2 >> 1)];
    unint64_t v9 = *v7;
    unint64_t v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3) {
      unint64_t v4 = v8;
    }
    else {
      unint64_t v2 = v6;
    }
  }
  while (v2);
  if (v4 != (void *)v5 && *v4 == v3) {
    return v4[1];
  }
  else {
    return 0;
  }
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::RegionBranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::RegionBranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void **)(v2 + 16);
  BOOL v4 = v3 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 48);
  }
  if (v4)
  {
    uint64_t v16 = *(void *)(v2 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!Values || !mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>(Values, v2)) {
      return 0;
    }
  }
  else
  {
    unint64_t v6 = v5 | v2 & 0xFFFFFFFFFFFFFF00;
    if (!mlir::detail::InterfaceMap::lookup<mlir::RegionBranchOpInterface>(v6 + 32)
      && !mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>(*(void *)(v6 + 24), *(void *)(v1 + 48)))
    {
      return 0;
    }
  }
  uint64_t v8 = *(void *)(v1 + 48);
  unint64_t v9 = *(void **)(v8 + 16);
  BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *(void *)(v1 + 48);
  }
  if (v10)
  {
    uint64_t v16 = *(void *)(v8 + 8);
    uint64_t v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!v14) {
      return v1;
    }
    uint64_t v15 = v8;
  }
  else
  {
    unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
    if (mlir::detail::InterfaceMap::lookup<mlir::RegionBranchOpInterface>(v12 + 32)) {
      return v1;
    }
    uint64_t v14 = *(void *)(v12 + 24);
    uint64_t v15 = *(void *)(v1 + 48);
  }
  mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchOpInterface>(v14, v15);
  return v1;
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::BranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::BranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void **)(v2 + 16);
  BOOL v4 = v3 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 48);
  }
  if (v4)
  {
    uint64_t v16 = *(void *)(v2 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!Values || !mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(Values, v2)) {
      return 0;
    }
  }
  else
  {
    unint64_t v6 = v5 | v2 & 0xFFFFFFFFFFFFFF00;
    if (!mlir::detail::InterfaceMap::lookup<mlir::BranchOpInterface>(v6 + 32)
      && !mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(*(void *)(v6 + 24), *(void *)(v1 + 48)))
    {
      return 0;
    }
  }
  uint64_t v8 = *(void *)(v1 + 48);
  unint64_t v9 = *(void **)(v8 + 16);
  BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *(void *)(v1 + 48);
  }
  if (v10)
  {
    uint64_t v16 = *(void *)(v8 + 8);
    uint64_t v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!v14) {
      return v1;
    }
    uint64_t v15 = v8;
  }
  else
  {
    unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
    if (mlir::detail::InterfaceMap::lookup<mlir::BranchOpInterface>(v12 + 32)) {
      return v1;
    }
    uint64_t v14 = *(void *)(v12 + 24);
    uint64_t v15 = *(void *)(v1 + 48);
  }
  mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(v14, v15);
  return v1;
}

uint64_t mlir::Dialect::getRegisteredInterfaceForOp<mlir::BranchOpInterface>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v15 = a1;
    unint64_t v3 = 0x1E8EB8000;
    int v6 = v5;
    uint64_t v2 = a2;
    a1 = v15;
    if (v6)
    {
      uint64_t v16 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
      unint64_t v17 = 73;
      unint64_t v7 = llvm::StringRef::find((uint64_t *)&v16, "DesiredTypeName = ", 0x12uLL, 0);
      if (v17 >= v7) {
        unint64_t v8 = v7;
      }
      else {
        unint64_t v8 = v17;
      }
      unint64_t v9 = &v16[v8];
      unint64_t v10 = v17 - v8;
      if (v17 - v8 >= 0x12) {
        uint64_t v11 = 18;
      }
      else {
        uint64_t v11 = v17 - v8;
      }
      unint64_t v12 = v10 - v11;
      if (v12 >= v12 - 1) {
        uint64_t v13 = v12 - 1;
      }
      else {
        uint64_t v13 = v12;
      }
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = a2;
      a1 = v15;
    }
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, *(void *)(v3 + 3768), v2);
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::BranchOpInterface>(uint64_t a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    uint64_t v20 = a1;
    unint64_t v1 = 0x1E8EB8000;
    int v12 = v11;
    a1 = v20;
    if (v12)
    {
      uint64_t v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BranchOpInterface]";
      unint64_t v22 = 73;
      unint64_t v13 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
      if (v22 >= v13) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = v22;
      }
      uint64_t v15 = &v21[v14];
      unint64_t v16 = v22 - v14;
      if (v22 - v14 >= 0x12) {
        uint64_t v17 = 18;
      }
      else {
        uint64_t v17 = v22 - v14;
      }
      unint64_t v18 = v16 - v17;
      if (v18 >= v18 - 1) {
        uint64_t v19 = v18 - 1;
      }
      else {
        uint64_t v19 = v18;
      }
      mlir::detail::TypeIDResolver<mlir::BranchOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v15[v17], v19);
      unint64_t v1 = 0x1E8EB8000;
      a1 = v20;
    }
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *(void *)(v1 + 3768);
  BOOL v4 = *(void **)a1;
  uint64_t v5 = *(void *)a1 + 16 * v2;
  do
  {
    unint64_t v6 = v2 >> 1;
    unint64_t v7 = &v4[2 * (v2 >> 1)];
    unint64_t v9 = *v7;
    unint64_t v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3) {
      BOOL v4 = v8;
    }
    else {
      unint64_t v2 = v6;
    }
  }
  while (v2);
  if (v4 != (void *)v5 && *v4 == v3) {
    return v4[1];
  }
  else {
    return 0;
  }
}

uint64_t llvm::DefaultDoCastIfPossible<mlir::RegionBranchTerminatorOpInterface,mlir::Operation *,llvm::CastInfo<mlir::RegionBranchTerminatorOpInterface,mlir::Operation *,void>>::doCastIfPossible(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = *(void *)(a1 + 48);
  unint64_t v3 = *(void **)(v2 + 16);
  BOOL v4 = v3 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 48);
  }
  if (v4)
  {
    uint64_t v16 = *(void *)(v2 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!Values || !mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchTerminatorOpInterface>(Values, v2)) {
      return 0;
    }
  }
  else
  {
    unint64_t v6 = v5 | v2 & 0xFFFFFFFFFFFFFF00;
    if (!mlir::detail::InterfaceMap::lookup<mlir::RegionBranchTerminatorOpInterface>(v6 + 32)
      && !mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchTerminatorOpInterface>(*(void *)(v6 + 24), *(void *)(v1 + 48)))
    {
      return 0;
    }
  }
  uint64_t v8 = *(void *)(v1 + 48);
  unint64_t v9 = *(void **)(v8 + 16);
  BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *(void *)(v1 + 48);
  }
  if (v10)
  {
    uint64_t v16 = *(void *)(v8 + 8);
    uint64_t v14 = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v16);
    if (!v14) {
      return v1;
    }
    uint64_t v15 = v8;
  }
  else
  {
    unint64_t v12 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
    if (mlir::detail::InterfaceMap::lookup<mlir::RegionBranchTerminatorOpInterface>(v12 + 32)) {
      return v1;
    }
    uint64_t v14 = *(void *)(v12 + 24);
    uint64_t v15 = *(void *)(v1 + 48);
  }
  mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchTerminatorOpInterface>(v14, v15);
  return v1;
}

uint64_t mlir::Dialect::getRegisteredInterfaceForOp<mlir::RegionBranchTerminatorOpInterface>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v15 = a1;
    unint64_t v3 = 0x1E8EB8000;
    int v6 = v5;
    uint64_t v2 = a2;
    a1 = v15;
    if (v6)
    {
      uint64_t v16 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
      unint64_t v17 = 89;
      unint64_t v7 = llvm::StringRef::find((uint64_t *)&v16, "DesiredTypeName = ", 0x12uLL, 0);
      if (v17 >= v7) {
        unint64_t v8 = v7;
      }
      else {
        unint64_t v8 = v17;
      }
      unint64_t v9 = &v16[v8];
      unint64_t v10 = v17 - v8;
      if (v17 - v8 >= 0x12) {
        uint64_t v11 = 18;
      }
      else {
        uint64_t v11 = v17 - v8;
      }
      unint64_t v12 = v10 - v11;
      if (v12 >= v12 - 1) {
        uint64_t v13 = v12 - 1;
      }
      else {
        uint64_t v13 = v12;
      }
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = a2;
      a1 = v15;
    }
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, *(void *)(v3 + 4016), v2);
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::RegionBranchTerminatorOpInterface>(uint64_t a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    uint64_t v20 = a1;
    unint64_t v1 = 0x1E8EB8000;
    int v12 = v11;
    a1 = v20;
    if (v12)
    {
      uint64_t v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::RegionBranchTerminatorOpInterface]";
      unint64_t v22 = 89;
      unint64_t v13 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
      if (v22 >= v13) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = v22;
      }
      uint64_t v15 = &v21[v14];
      unint64_t v16 = v22 - v14;
      if (v22 - v14 >= 0x12) {
        uint64_t v17 = 18;
      }
      else {
        uint64_t v17 = v22 - v14;
      }
      unint64_t v18 = v16 - v17;
      if (v18 >= v18 - 1) {
        uint64_t v19 = v18 - 1;
      }
      else {
        uint64_t v19 = v18;
      }
      mlir::detail::TypeIDResolver<mlir::RegionBranchTerminatorOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v15[v17], v19);
      unint64_t v1 = 0x1E8EB8000;
      a1 = v20;
    }
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *(void *)(v1 + 4016);
  BOOL v4 = *(void **)a1;
  uint64_t v5 = *(void *)a1 + 16 * v2;
  do
  {
    unint64_t v6 = v2 >> 1;
    unint64_t v7 = &v4[2 * (v2 >> 1)];
    unint64_t v9 = *v7;
    unint64_t v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3) {
      BOOL v4 = v8;
    }
    else {
      unint64_t v2 = v6;
    }
  }
  while (v2);
  if (v4 != (void *)v5 && *v4 == v3) {
    return v4[1];
  }
  else {
    return 0;
  }
}

uint64_t *llvm::DenseMapBase<llvm::DenseMap<mlir::Operation *,mlir::ValueRange,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::ValueRange>>,mlir::Operation *,mlir::ValueRange,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::ValueRange>>::InsertIntoBucket<mlir::Operation * const&>(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v6 = *(_DWORD *)(a1 + 8);
  unsigned int v7 = *(_DWORD *)(a1 + 16);
  if (4 * v6 + 4 >= 3 * v7)
  {
    v7 *= 2;
  }
  else if (v7 + ~v6 - *(_DWORD *)(a1 + 12) > v7 >> 3)
  {
LABEL_3:
    uint64_t v8 = *a2;
    goto LABEL_4;
  }
  llvm::DenseMap<mlir::Operation *,mlir::ValueRange,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::ValueRange>>::grow(a1, v7);
  uint64_t v8 = *a3;
  int v10 = *(_DWORD *)(a1 + 16) - 1;
  unsigned int v11 = ((*a3 >> 4) ^ (*a3 >> 9)) & v10;
  a2 = (uint64_t *)(*(void *)a1 + 24 * v11);
  uint64_t v12 = *a2;
  if (*a3 != *a2)
  {
    unint64_t v13 = 0;
    int v14 = 1;
    while (v12 != -4096)
    {
      if (v13) {
        BOOL v15 = 0;
      }
      else {
        BOOL v15 = v12 == -8192;
      }
      if (v15) {
        unint64_t v13 = a2;
      }
      unsigned int v16 = v11 + v14++;
      unsigned int v11 = v16 & v10;
      a2 = (uint64_t *)(*(void *)a1 + 24 * v11);
      uint64_t v12 = *a2;
      if (v8 == *a2) {
        goto LABEL_4;
      }
    }
    if (v13) {
      a2 = v13;
    }
    goto LABEL_3;
  }
LABEL_4:
  ++*(_DWORD *)(a1 + 8);
  if (v8 != -4096) {
    --*(_DWORD *)(a1 + 12);
  }
  *a2 = *a3;
  mlir::ValueRange::ValueRange((unint64_t *)a2 + 1, 0, 0);
  return a2;
}

void *llvm::DenseMap<mlir::Operation *,mlir::ValueRange,llvm::DenseMapInfo<mlir::Operation *,void>,llvm::detail::DenseMapPair<mlir::Operation *,mlir::ValueRange>>::grow(uint64_t a1, int a2)
{
  uint64_t v3 = *(unsigned int *)(a1 + 16);
  BOOL v4 = *(llvm **)a1;
  unint64_t v5 = (a2 - 1) | ((unint64_t)(a2 - 1) >> 1);
  unint64_t v6 = v5 | (v5 >> 2) | ((v5 | (v5 >> 2)) >> 4);
  int v7 = ((v6 | (v6 >> 8)) >> 16) | v6 | (v6 >> 8);
  if ((v7 + 1) > 0x40) {
    unsigned int v8 = v7 + 1;
  }
  else {
    unsigned int v8 = 64;
  }
  *(_DWORD *)(a1 + 16) = v8;
  uint64_t result = llvm::allocate_buffer(24 * v8, (std::align_val_t)8uLL);
  *(void *)a1 = result;
  if (v4)
  {
    *(void *)(a1 + 8) = 0;
    unsigned int v10 = *(_DWORD *)(a1 + 16);
    if (!v10) {
      goto LABEL_16;
    }
    unint64_t v11 = 24 * v10 - 24;
    if (v11 >= 0x18)
    {
      unint64_t v16 = v11 / 0x18 + 1;
      uint64_t v12 = &result[3 * (v16 & 0x1FFFFFFFFFFFFFFELL)];
      uint64_t v17 = v16 & 0x1FFFFFFFFFFFFFFELL;
      unint64_t v18 = result;
      do
      {
        *unint64_t v18 = -4096;
        v18[3] = -4096;
        v18 += 6;
        v17 -= 2;
      }
      while (v17);
      if (v16 == (v16 & 0x1FFFFFFFFFFFFFFELL))
      {
LABEL_16:
        if (v3)
        {
          uint64_t v20 = v4;
          do
          {
            uint64_t v22 = *(void *)v20;
            if ((*(void *)v20 | 0x1000) != 0xFFFFFFFFFFFFF000)
            {
              int v23 = *(_DWORD *)(a1 + 16);
              if (v23)
              {
                int v24 = v23 - 1;
                unsigned int v25 = (v23 - 1) & ((v22 >> 4) ^ (v22 >> 9));
                uint64_t v21 = *(void *)a1 + 24 * v25;
                uint64_t v26 = *(void *)v21;
                if (v22 != *(void *)v21)
                {
                  uint64_t v27 = 0;
                  int v28 = 1;
                  while (v26 != -4096)
                  {
                    if (v27) {
                      BOOL v29 = 0;
                    }
                    else {
                      BOOL v29 = v26 == -8192;
                    }
                    if (v29) {
                      uint64_t v27 = v21;
                    }
                    unsigned int v30 = v25 + v28++;
                    unsigned int v25 = v30 & v24;
                    uint64_t v21 = *(void *)a1 + 24 * (v30 & v24);
                    uint64_t v26 = *(void *)v21;
                    if (v22 == *(void *)v21) {
                      goto LABEL_19;
                    }
                  }
                  if (v27) {
                    uint64_t v21 = v27;
                  }
                }
              }
              else
              {
                uint64_t v21 = 0;
              }
LABEL_19:
              *(void *)uint64_t v21 = v22;
              *(_OWORD *)(v21 + 8) = *(_OWORD *)((char *)v20 + 8);
              ++*(_DWORD *)(a1 + 8);
            }
            uint64_t v20 = (llvm *)((char *)v20 + 24);
          }
          while (v20 != (llvm *)((char *)v4 + 24 * v3));
        }
        llvm::deallocate_buffer(v4, (void *)(24 * v3));
      }
    }
    else
    {
      uint64_t v12 = result;
    }
    uint64_t v19 = &result[3 * v10];
    do
    {
      void *v12 = -4096;
      v12 += 3;
    }
    while (v12 != v19);
    goto LABEL_16;
  }
  *(void *)(a1 + 8) = 0;
  unsigned int v13 = *(_DWORD *)(a1 + 16);
  if (v13)
  {
    unint64_t v14 = 24 * v13 - 24;
    if (v14 < 0x18)
    {
      BOOL v15 = result;
LABEL_42:
      uint64_t v34 = &result[3 * v13];
      do
      {
        *BOOL v15 = -4096;
        v15 += 3;
      }
      while (v15 != v34);
      return result;
    }
    unint64_t v31 = v14 / 0x18 + 1;
    BOOL v15 = &result[3 * (v31 & 0x1FFFFFFFFFFFFFFELL)];
    uint64_t v32 = v31 & 0x1FFFFFFFFFFFFFFELL;
    uint64_t v33 = result;
    do
    {
      void *v33 = -4096;
      v33[3] = -4096;
      v33 += 6;
      v32 -= 2;
    }
    while (v32);
    if (v31 != (v31 & 0x1FFFFFFFFFFFFFFELL)) {
      goto LABEL_42;
    }
  }
  return result;
}

uint64_t *mlir::StorageUniquer::registerParametricStorageType<mlir::dataflow::CFGEdge>(uint64_t *a1)
{
  unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v12 = a1;
    unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    int v4 = v3;
    a1 = v12;
    if (v4)
    {
      unsigned int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::CFGEdge]";
      unint64_t v14 = 73;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      int v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::CFGEdge,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v1 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a1 = v12;
    }
  }
  return mlir::StorageUniquer::registerParametricStorageTypeImpl(a1, v1[33], (uint64_t)llvm::function_ref<void ()(mlir::StorageUniquer::BaseStorage *)>::callback_fn<void mlir::StorageUniquer::registerParametricStorageType<mlir::dataflow::CFGEdge>(mlir::TypeID)::{lambda(mlir::StorageUniquer::BaseStorage *)#1}>, (uint64_t)&v13);
}

uint64_t llvm::function_ref<void ()(mlir::StorageUniquer::BaseStorage *)>::callback_fn<void mlir::StorageUniquer::registerParametricStorageType<mlir::dataflow::CFGEdge>(mlir::TypeID)::{lambda(mlir::StorageUniquer::BaseStorage *)#1}>(uint64_t a1, uint64_t (***a2)(void))
{
  return (**a2)(a2);
}

void *mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2 | 6;
  {
    uint64_t v31 = a1;
    a1 = v31;
    if (v23)
    {
      uint64_t v32 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::Executable]";
      unint64_t v33 = 76;
      unint64_t v24 = llvm::StringRef::find((uint64_t *)&v32, "DesiredTypeName = ", 0x12uLL, 0);
      if (v33 >= v24) {
        unint64_t v25 = v24;
      }
      else {
        unint64_t v25 = v33;
      }
      uint64_t v26 = &v32[v25];
      unint64_t v27 = v33 - v25;
      if (v33 - v25 >= 0x12) {
        uint64_t v28 = 18;
      }
      else {
        uint64_t v28 = v33 - v25;
      }
      unint64_t v29 = v27 - v28;
      if (v29 >= v29 - 1) {
        uint64_t v30 = v29 - 1;
      }
      else {
        uint64_t v30 = v29;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v26[v28], v30);
      a1 = v31;
    }
  }
  uint64_t v32 = (const char *)v2;
  unint64_t v33 = mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id;
  int v3 = *(_DWORD *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    unint64_t v5 = ((0x2500000000 * v2) | (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 9))
       + ~((unint64_t)((mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = v3 - 1;
    unsigned int v9 = v8 & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    unint64_t v10 = (void *)(v4 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (v2 == *v10 && mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id == v12) {
      goto LABEL_25;
    }
    unint64_t v14 = 0;
    int v15 = 1;
    while (v11 != -4096 || v12 != -4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v12 == -8192;
      }
      if (v16 && v11 == -8192) {
        unint64_t v14 = v10;
      }
      unsigned int v18 = v9 + v15++;
      unsigned int v9 = v18 & v8;
      unint64_t v10 = (void *)(v4 + 24 * v9);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      if (v2 == *v10 && mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id == v12) {
        goto LABEL_25;
      }
    }
    if (v14) {
      uint64_t v20 = v14;
    }
    else {
      uint64_t v20 = v10;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  unint64_t v10 = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>(a1 + 120, (uint64_t)&v32, (uint64_t *)&v32, v20);
  *unint64_t v10 = v32;
  v10[1] = v33;
  v10[2] = 0;
LABEL_25:
  uint64_t result = (void *)v10[2];
  if (!result)
  {
    uint64_t result = operator new(0xB0uLL);
    result[2] = 0;
    result[3] = 0;
    *((_DWORD *)result + 8) = 0;
    *((unsigned char *)result + 56) = 0;
    result[5] = result + 7;
    result[6] = 0;
    *uint64_t result = &unk_1EC9CDAC8;
    result[1] = v2;
    result[8] = result + 12;
    result[9] = result + 12;
    result[10] = 4;
    *((_DWORD *)result + 22) = 0;
    result[16] = result + 18;
    result[17] = 0x400000000;
    uint64_t v22 = v10[2];
    v10[2] = result;
    if (v22)
    {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
      return (void *)v10[2];
    }
  }
  return result;
}

void *mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFF9 | 2;
  {
    uint64_t v31 = a1;
    a1 = v31;
    if (v23)
    {
      uint64_t v32 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::PredecessorState]";
      unint64_t v33 = 82;
      unint64_t v24 = llvm::StringRef::find((uint64_t *)&v32, "DesiredTypeName = ", 0x12uLL, 0);
      if (v33 >= v24) {
        unint64_t v25 = v24;
      }
      else {
        unint64_t v25 = v33;
      }
      uint64_t v26 = &v32[v25];
      unint64_t v27 = v33 - v25;
      if (v33 - v25 >= 0x12) {
        uint64_t v28 = 18;
      }
      else {
        uint64_t v28 = v33 - v25;
      }
      unint64_t v29 = v27 - v28;
      if (v29 >= v29 - 1) {
        uint64_t v30 = v29 - 1;
      }
      else {
        uint64_t v30 = v29;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v26[v28], v30);
      a1 = v31;
    }
  }
  uint64_t v32 = (const char *)v2;
  unint64_t v33 = mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id;
  int v3 = *(_DWORD *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    unint64_t v5 = ((0x2500000000 * v2) | (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 9))
       + ~((unint64_t)((mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = v3 - 1;
    unsigned int v9 = v8 & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    unint64_t v10 = (void *)(v4 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (v2 == *v10
      && mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id == v12)
    {
      goto LABEL_25;
    }
    unint64_t v14 = 0;
    int v15 = 1;
    while (v11 != -4096 || v12 != -4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v12 == -8192;
      }
      if (v16 && v11 == -8192) {
        unint64_t v14 = v10;
      }
      unsigned int v18 = v9 + v15++;
      unsigned int v9 = v18 & v8;
      unint64_t v10 = (void *)(v4 + 24 * v9);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      if (v2 == *v10
        && mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id == v12)
      {
        goto LABEL_25;
      }
    }
    if (v14) {
      uint64_t v20 = v14;
    }
    else {
      uint64_t v20 = v10;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  unint64_t v10 = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>(a1 + 120, (uint64_t)&v32, (uint64_t *)&v32, v20);
  *unint64_t v10 = v32;
  v10[1] = v33;
  v10[2] = 0;
LABEL_25:
  uint64_t result = (void *)v10[2];
  if (!result)
  {
    uint64_t result = operator new(0xC8uLL);
    result[2] = 0;
    result[3] = 0;
    *((unsigned char *)result + 56) = 1;
    *((_DWORD *)result + 8) = 0;
    result[5] = result + 7;
    result[6] = 0;
    *uint64_t result = &unk_1EC9CDB28;
    result[1] = v2;
    result[8] = result + 12;
    result[9] = result + 12;
    result[10] = 4;
    *((_DWORD *)result + 22) = 0;
    result[16] = result + 18;
    result[17] = 0x400000000;
    result[22] = 0;
    result[23] = 0;
    *((_DWORD *)result + 48) = 0;
    uint64_t v22 = v10[2];
    v10[2] = result;
    if (v22)
    {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
      return (void *)v10[2];
    }
  }
  return result;
}

void llvm::function_ref<void ()(mlir::Operation *,BOOL)>::callback_fn<mlir::dataflow::DeadCodeAnalysis::initializeSymbolCallables(mlir::Operation *)::$_0>(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v5 = *(void *)a1;
  unint64_t v6 = (mlir::SymbolTable *)(((a2
                             + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1)
                             + (((unint64_t)*(unsigned int *)(a2 + 44) >> 21) & 0x7F8)
                             + 71) & 0xFFFFFFFFFFFFFFF8)
                           + 32 * *(unsigned int *)(a2 + 40));
  uint64_t v7 = *((void *)v6 + 1);
  if (v7) {
    uint64_t v8 = v7 - 8;
  }
  else {
    uint64_t v8 = 0;
  }
  mlir::Block::getOps<mlir::CallableOpInterface>(v8, (mlir::GenericProgramPoint **)&__p);
  unsigned int v9 = (mlir::GenericProgramPoint *)__p;
  unint64_t v10 = v44;
  if (__p != v44)
  {
    char v11 = 0;
    uint64_t v12 = v41;
    unsigned int v13 = v42;
    unint64_t v14 = v43;
    do
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(v9);
      v39[0] = (mlir::SymbolOpInterface *)v14(v15, v16);
      v39[1] = v17;
      if (mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)v39))
      {
        v38[0] = llvm::DefaultDoCastIfPossible<mlir::SymbolOpInterface,mlir::Operation *,llvm::CastInfo<mlir::SymbolOpInterface,mlir::Operation *,void>>::doCastIfPossible(v39[0], v18);
        v38[1] = v19;
        if (v38[0])
        {
          if ((mlir::SymbolOpInterface::isPublic((mlir::SymbolOpInterface *)v38) & 1) != 0
            || (a3 & 1) == 0
            && mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38))
          {
            uint64_t v20 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*(void *)(v5 + 8), (uint64_t)v39[0]);
            int v21 = *((unsigned __int8 *)v20 + 56);
            *((unsigned char *)v20 + 56) = 0;
            mlir::DataFlowAnalysis::propagateIfChanged(v5, (uint64_t)v20, v21);
          }
          char v11 = 1;
        }
      }
      uint64_t v22 = (mlir::GenericProgramPoint *)*((void *)v9 + 1);
      unsigned int v9 = v12;
      if (v22 != v12)
      {
        unsigned int v9 = v22;
        while (1)
        {
          mlir::GenericProgramPoint::~GenericProgramPoint(v9);
          if (v13(v23, v24)) {
            break;
          }
          unsigned int v9 = (mlir::GenericProgramPoint *)*((void *)v9 + 1);
          if (v9 == v12)
          {
            unsigned int v9 = v12;
            break;
          }
        }
      }
    }
    while (v9 != v10);
    if (v11)
    {
      mlir::SymbolTable::getSymbolUses(v6, (uint64_t)&__p);
      if ((_BYTE)v43)
      {
        unint64_t v25 = (uint64_t *)__p;
        uint64_t v26 = (uint64_t *)v41;
        if (__p != v41)
        {
          do
          {
            uint64_t v30 = *v25;
            uint64_t v31 = *(void *)(*v25 + 48);
            uint64_t v32 = *(void **)(v31 + 16);
            BOOL v33 = v32 == &mlir::detail::TypeIDResolver<void,void>::id;
            if (v32 == &mlir::detail::TypeIDResolver<void,void>::id) {
              uint64_t v34 = 0;
            }
            else {
              uint64_t v34 = *(void *)(*v25 + 48);
            }
            if (v33)
            {
              v39[0] = *(mlir::SymbolOpInterface **)(v31 + 8);
              uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)v39);
              if (Values && mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(Values, v31)) {
                goto LABEL_24;
              }
            }
            else
            {
              unint64_t v35 = v34 | v31 & 0xFFFFFFFFFFFFFF00;
              if (mlir::detail::InterfaceMap::lookup<mlir::CallOpInterface>(v35 + 32)
                || mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(*(void *)(v35 + 24), *(void *)(v30 + 48)))
              {
                goto LABEL_24;
              }
            }
            uint64_t v27 = mlir::SymbolTableCollection::lookupSymbolIn(v5 + 24, **(void **)(a1 + 8), v25[1]);
            uint64_t v28 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*(void *)(v5 + 8), v27);
            int v29 = *((unsigned __int8 *)v28 + 56);
            *((unsigned char *)v28 + 56) = 0;
            mlir::DataFlowAnalysis::propagateIfChanged(v5, (uint64_t)v28, v29);
LABEL_24:
            v25 += 2;
          }
          while (v25 != v26);
        }
      }
      else
      {
        uint64_t v37 = **(mlir::ForwardIterator ***)(a1 + 8);
        v38[0] = v5;
        v39[0] = (mlir::SymbolOpInterface *)v38;
        mlir::detail::walk<mlir::ForwardIterator>(v37, (mlir::Operation *)_ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_8dataflow16DeadCodeAnalysis25initializeSymbolCallablesES3_ENK3__0clES3_bEUlNS1_19CallableOpInterfaceEE_SE_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESN_E4typeES3_OT1_EUlS3_E_EEvlS3_, (uint64_t)v39, 1);
      }
      if ((_BYTE)v43)
      {
        if (__p)
        {
          int64_t v41 = (mlir::GenericProgramPoint *)__p;
          operator delete(__p);
        }
      }
    }
  }
}

uint64_t mlir::Block::getOps<mlir::CallableOpInterface>@<X0>(uint64_t result@<X0>, mlir::GenericProgramPoint **a2@<X8>)
{
  int v3 = (mlir::GenericProgramPoint *)(result + 32);
  uint64_t v4 = (mlir::GenericProgramPoint *)(result + 32);
  if (*(void *)(result + 40) != result + 32)
  {
    uint64_t v4 = *(mlir::GenericProgramPoint **)(result + 40);
    do
    {
      mlir::GenericProgramPoint::~GenericProgramPoint(v4);
      uint64_t v8 = *(void *)(v7 + 48);
      unsigned int v9 = *(void **)(v8 + 16);
      BOOL v10 = v9 == &mlir::detail::TypeIDResolver<void,void>::id;
      if (v9 == &mlir::detail::TypeIDResolver<void,void>::id) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = *(void *)(v7 + 48);
      }
      if (v10)
      {
        uint64_t v12 = *(void *)(v8 + 8);
        uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v12);
        if (result)
        {
          uint64_t result = mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(result, v8);
          if (result) {
            goto LABEL_15;
          }
        }
      }
      else
      {
        uint64_t v5 = v7;
        unint64_t v6 = v11 | v8 & 0xFFFFFFFFFFFFFF00;
        uint64_t result = mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(v6 + 32);
        if (result) {
          goto LABEL_15;
        }
        uint64_t result = mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(*(void *)(v6 + 24), *(void *)(v5 + 48));
        if (result) {
          goto LABEL_15;
        }
      }
      uint64_t v4 = (mlir::GenericProgramPoint *)*((void *)v4 + 1);
    }
    while (v4 != v3);
    uint64_t v4 = v3;
  }
LABEL_15:
  *a2 = v4;
  a2[1] = v3;
  a2[2] = (mlir::GenericProgramPoint *)mlir::detail::op_filter_iterator<mlir::CallableOpInterface,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::filter;
  a2[3] = (mlir::GenericProgramPoint *)mlir::detail::op_iterator<mlir::CallableOpInterface,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::unwrap;
  a2[4] = v3;
  a2[5] = v3;
  a2[6] = (mlir::GenericProgramPoint *)mlir::detail::op_filter_iterator<mlir::CallableOpInterface,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::filter;
  a2[7] = (mlir::GenericProgramPoint *)mlir::detail::op_iterator<mlir::CallableOpInterface,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::unwrap;
  return result;
}

BOOL mlir::detail::op_filter_iterator<mlir::CallableOpInterface,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::filter(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 48);
  unint64_t v2 = *(void **)(v1 + 16);
  BOOL v3 = v2 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v2 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = *(void *)(a1 + 48);
  }
  if (v3)
  {
    uint64_t v10 = *(void *)(v1 + 8);
    uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v10);
    if (!Values) {
      return Values != 0;
    }
    uint64_t v9 = v1;
  }
  else
  {
    unint64_t v6 = v4 | v1 & 0xFFFFFFFFFFFFFF00;
    uint64_t Values = mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(v6 + 32);
    if (Values) {
      return Values != 0;
    }
    uint64_t Values = *(void *)(v6 + 24);
    uint64_t v9 = *(void *)(a1 + 48);
  }
  return mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(Values, v9) != 0;
}

uint64_t mlir::detail::op_iterator<mlir::CallableOpInterface,llvm::ilist_iterator<llvm::ilist_detail::node_options<mlir::Operation,false,false,void,false>,false,false>>::unwrap(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  BOOL v3 = *(void **)(v2 + 16);
  BOOL v4 = v3 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v3 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = *(void *)(a1 + 48);
  }
  if (!v4)
  {
    unint64_t v6 = v5 | v2 & 0xFFFFFFFFFFFFFF00;
    if (mlir::detail::InterfaceMap::lookup<mlir::CallableOpInterface>(v6 + 32)) {
      return a1;
    }
    uint64_t Values = *(void *)(v6 + 24);
    uint64_t v9 = *(void *)(a1 + 48);
    goto LABEL_10;
  }
  uint64_t v10 = *(void *)(v2 + 8);
  uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v10);
  if (Values)
  {
    uint64_t v9 = v2;
LABEL_10:
    mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallableOpInterface>(Values, v9);
    return a1;
  }
  return a1;
}

mlir::SymbolOpInterface *llvm::DefaultDoCastIfPossible<mlir::SymbolOpInterface,mlir::Operation *,llvm::CastInfo<mlir::SymbolOpInterface,mlir::Operation *,void>>::doCastIfPossible(mlir::SymbolOpInterface *a1, mlir::Operation *a2)
{
  uint64_t v2 = a1;
  if (!mlir::SymbolOpInterface::classof(a1, a2)) {
    return 0;
  }
  if (!v2) {
    return v2;
  }
  uint64_t v3 = *((void *)v2 + 6);
  BOOL v4 = *(void **)(v3 + 16);
  BOOL v5 = v4 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *((void *)v2 + 6);
  }
  if (!v5)
  {
    unint64_t v7 = v6 | v3 & 0xFFFFFFFFFFFFFF00;
    if (mlir::detail::InterfaceMap::lookup<mlir::SymbolOpInterface>(v7 + 32)) {
      return v2;
    }
    uint64_t Values = *(void *)(v7 + 24);
    uint64_t v10 = *((void *)v2 + 6);
    goto LABEL_14;
  }
  uint64_t v11 = *(void *)(v3 + 8);
  uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v11);
  if (!Values) {
    return v2;
  }
  uint64_t v10 = v3;
LABEL_14:
  mlir::Dialect::getRegisteredInterfaceForOp<mlir::SymbolOpInterface>(Values, v10);
  return v2;
}

uint64_t mlir::SymbolOpInterface::classof(mlir::SymbolOpInterface *this, mlir::Operation *a2)
{
  uint64_t v3 = *((void *)this + 6);
  BOOL v4 = *(void **)(v3 + 16);
  BOOL v5 = v4 == &mlir::detail::TypeIDResolver<void,void>::id;
  if (v4 == &mlir::detail::TypeIDResolver<void,void>::id) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = *((void *)this + 6);
  }
  if (v5)
  {
    uint64_t v11 = *(void *)(v3 + 8);
    uint64_t result = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v11);
    if (!result) {
      return result;
    }
    uint64_t result = mlir::Dialect::getRegisteredInterfaceForOp<mlir::SymbolOpInterface>(result, v3);
    if (!result) {
      return result;
    }
  }
  else
  {
    unint64_t v7 = v6 | v3 & 0xFFFFFFFFFFFFFF00;
    if (!mlir::detail::InterfaceMap::lookup<mlir::SymbolOpInterface>(v7 + 32))
    {
      uint64_t result = mlir::Dialect::getRegisteredInterfaceForOp<mlir::SymbolOpInterface>(*(void *)(v7 + 24), *((void *)this + 6));
      if (!result) {
        return result;
      }
    }
  }
  if (*((unsigned char *)this + 47)
    && (uint64_t InherentAttr = mlir::Operation::getInherentAttr((uint64_t)this, (uint64_t)"sym_name", 8), v10))
  {
    return InherentAttr != 0;
  }
  else
  {
    return mlir::DictionaryAttr::contains((uint64_t)this + 56, "sym_name", 8uLL);
  }
}

uint64_t mlir::Dialect::getRegisteredInterfaceForOp<mlir::SymbolOpInterface>(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a2;
  unint64_t v3 = 0x1E8EB8000uLL;
  {
    uint64_t v15 = a1;
    unint64_t v3 = 0x1E8EB8000;
    int v6 = v5;
    uint64_t v2 = a2;
    a1 = v15;
    if (v6)
    {
      uint64_t v16 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolOpInterface]";
      unint64_t v17 = 73;
      unint64_t v7 = llvm::StringRef::find((uint64_t *)&v16, "DesiredTypeName = ", 0x12uLL, 0);
      if (v17 >= v7) {
        unint64_t v8 = v7;
      }
      else {
        unint64_t v8 = v17;
      }
      uint64_t v9 = &v16[v8];
      unint64_t v10 = v17 - v8;
      if (v17 - v8 >= 0x12) {
        uint64_t v11 = 18;
      }
      else {
        uint64_t v11 = v17 - v8;
      }
      unint64_t v12 = v10 - v11;
      if (v12 >= v12 - 1) {
        uint64_t v13 = v12 - 1;
      }
      else {
        uint64_t v13 = v12;
      }
      mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
      unint64_t v3 = 0x1E8EB8000;
      uint64_t v2 = a2;
      a1 = v15;
    }
  }
  return (*(uint64_t (**)(uint64_t, void, uint64_t))(*(void *)a1 + 104))(a1, *(void *)(v3 + 3784), v2);
}

uint64_t mlir::detail::InterfaceMap::lookup<mlir::SymbolOpInterface>(uint64_t a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    uint64_t v20 = a1;
    unint64_t v1 = 0x1E8EB8000;
    int v12 = v11;
    a1 = v20;
    if (v12)
    {
      int v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SymbolOpInterface]";
      unint64_t v22 = 73;
      unint64_t v13 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
      if (v22 >= v13) {
        unint64_t v14 = v13;
      }
      else {
        unint64_t v14 = v22;
      }
      uint64_t v15 = &v21[v14];
      unint64_t v16 = v22 - v14;
      if (v22 - v14 >= 0x12) {
        uint64_t v17 = 18;
      }
      else {
        uint64_t v17 = v22 - v14;
      }
      unint64_t v18 = v16 - v17;
      if (v18 >= v18 - 1) {
        uint64_t v19 = v18 - 1;
      }
      else {
        uint64_t v19 = v18;
      }
      mlir::detail::TypeIDResolver<mlir::SymbolOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v15[v17], v19);
      unint64_t v1 = 0x1E8EB8000;
      a1 = v20;
    }
  }
  unint64_t v2 = *(unsigned int *)(a1 + 8);
  if (!v2) {
    return 0;
  }
  unint64_t v3 = *(void *)(v1 + 3784);
  BOOL v4 = *(void **)a1;
  uint64_t v5 = *(void *)a1 + 16 * v2;
  do
  {
    unint64_t v6 = v2 >> 1;
    unint64_t v7 = &v4[2 * (v2 >> 1)];
    unint64_t v9 = *v7;
    unint64_t v8 = v7 + 2;
    v2 += ~(v2 >> 1);
    if (v9 < v3) {
      BOOL v4 = v8;
    }
    else {
      unint64_t v2 = v6;
    }
  }
  while (v2);
  if (v4 != (void *)v5 && *v4 == v3) {
    return v4[1];
  }
  else {
    return 0;
  }
}

uint64_t _ZN4llvm12function_refIFvPN4mlir9OperationEEE11callback_fnIZNS1_6detail4walkILNS1_9WalkOrderE1ENS1_15ForwardIteratorEZZNS1_8dataflow16DeadCodeAnalysis25initializeSymbolCallablesES3_ENK3__0clES3_bEUlNS1_19CallableOpInterfaceEE_SE_vEENSt3__19enable_ifIXaantsr4llvm9is_one_ofIT2_S3_PNS1_6RegionEPNS1_5BlockEEE5valuesr3std7is_sameIT3_vEE5valueESN_E4typeES3_OT1_EUlS3_E_EEvlS3_(uint64_t **a1, uint64_t a2)
{
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::CallableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallableOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
  if (result)
  {
    uint64_t v4 = **a1;
    uint64_t v5 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*(void *)(v4 + 8), result);
    int v6 = *((unsigned __int8 *)v5 + 56);
    *((unsigned char *)v5 + 56) = 0;
    return mlir::DataFlowAnalysis::propagateIfChanged(v4, (uint64_t)v5, v6);
  }
  return result;
}

uint64_t mlir::StorageUniquer::get<mlir::dataflow::CFGEdge,mlir::Block *&,mlir::Block *&>(unsigned __int8 **a1, const char *a2, unint64_t a3, void *a4, void *a5)
{
  uint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
  {
    uint64_t v24 = a5;
    unint64_t v25 = a1;
    unint64_t v22 = a3;
    uint64_t v23 = a4;
    int v21 = a2;
    uint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
    a2 = v21;
    a3 = v22;
    a4 = v23;
    a5 = v24;
    int v13 = v12;
    a1 = v25;
    if (v13)
    {
      int v29 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::CFGEdge]";
      unint64_t v30 = 73;
      unint64_t v14 = llvm::StringRef::find((uint64_t *)&v29, "DesiredTypeName = ", 0x12uLL, 0);
      if (v30 >= v14) {
        unint64_t v15 = v14;
      }
      else {
        unint64_t v15 = v30;
      }
      unint64_t v16 = &v29[v15];
      unint64_t v17 = v30 - v15;
      if (v30 - v15 >= 0x12) {
        uint64_t v18 = 18;
      }
      else {
        uint64_t v18 = v30 - v15;
      }
      unint64_t v19 = v17 - v18;
      if (v19 >= v19 - 1) {
        uint64_t v20 = v19 - 1;
      }
      else {
        uint64_t v20 = v19;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::CFGEdge,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      uint64_t v5 = &mlir::detail::TypeIDResolver<mlir::OpTrait::AffineScope<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AffineScope>(void)::Empty>,void>::resolveTypeID(void)::id;
      a2 = v21;
      a3 = v22;
      a4 = v23;
      a5 = v24;
      a1 = v25;
    }
  }
  uint64_t v6 = v5[33];
  int v29 = a2;
  unint64_t v30 = a3;
  uint64_t v7 = *a5;
  v28[0] = *a4;
  v28[1] = v7;
  unint64_t v8 = ((v7 >> 4) ^ (v7 >> 9) | ((unint64_t)((LODWORD(v28[0]) >> 4) ^ (LODWORD(v28[0]) >> 9)) << 32))
     + ~((unint64_t)((v7 >> 4) ^ (v7 >> 9)) << 32);
  unint64_t v9 = (v8 ^ (v8 >> 22)) + ~((v8 ^ (v8 >> 22)) << 13);
  unint64_t v10 = (9 * (v9 ^ (v9 >> 8))) ^ ((9 * (v9 ^ (v9 >> 8))) >> 15);
  v26[0] = v28;
  v26[1] = &v29;
  uint64_t v27 = v28;
  return mlir::StorageUniquer::getParametricStorageTypeImpl(a1, v6, ((v10 + ~(v10 << 27)) >> 31) ^ (v10 + ~(v10 << 27)), (uint64_t (*)(uint64_t))llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::dataflow::CFGEdge * mlir::StorageUniquer::get<mlir::dataflow::CFGEdge,mlir::Block *&,mlir::Block *&>(llvm::function_ref<void ()(mlir::dataflow::CFGEdge *)>,mlir::TypeID,mlir::Block *&,mlir::Block *&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>, (uint64_t)&v27, llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::dataflow::CFGEdge * mlir::StorageUniquer::get<mlir::dataflow::CFGEdge,mlir::Block *&,mlir::Block *&>(llvm::function_ref<void ()(mlir::dataflow::CFGEdge *)>,mlir::TypeID,mlir::Block *&,mlir::Block *&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>, (uint64_t)v26);
}

BOOL llvm::function_ref<BOOL ()(mlir::StorageUniquer::BaseStorage const*)>::callback_fn<mlir::dataflow::CFGEdge * mlir::StorageUniquer::get<mlir::dataflow::CFGEdge,mlir::Block *&,mlir::Block *&>(llvm::function_ref<void ()(mlir::dataflow::CFGEdge *)>,mlir::TypeID,mlir::Block *&,mlir::Block *&)::{lambda(mlir::StorageUniquer::BaseStorage const*)#1}>(uint64_t a1, uint64_t a2)
{
  return *(void *)(a2 + 16) == **(void **)a1 && *(void *)(a2 + 24) == *(void *)(*(void *)a1 + 8);
}

uint64_t llvm::function_ref<mlir::StorageUniquer::BaseStorage * ()(mlir::StorageUniquer::StorageAllocator &)>::callback_fn<mlir::dataflow::CFGEdge * mlir::StorageUniquer::get<mlir::dataflow::CFGEdge,mlir::Block *&,mlir::Block *&>(llvm::function_ref<void ()(mlir::dataflow::CFGEdge *)>,mlir::TypeID,mlir::Block *&,mlir::Block *&)::{lambda(mlir::StorageUniquer::StorageAllocator &)#1}>(uint64_t a1, uint64_t a2)
{
  __n128 v4 = mlir::GenericProgramPointBase<mlir::dataflow::CFGEdge,std::pair<mlir::Block *,mlir::Block *>>::construct<std::pair<mlir::Block *,mlir::Block *>>(a2, (__n128 *)*(void *)a1);
  uint64_t v5 = v3;
  uint64_t v6 = *(void *)(a1 + 8);
  if (*(void *)v6) {
    (*(void (**)(void, uint64_t, __n128))v6)(*(void *)(v6 + 8), v3, v4);
  }
  return v5;
}

__n128 mlir::GenericProgramPointBase<mlir::dataflow::CFGEdge,std::pair<mlir::Block *,mlir::Block *>>::construct<std::pair<mlir::Block *,mlir::Block *>>(uint64_t a1, __n128 *a2)
{
  *(void *)(a1 + 80) += 32;
  if (*(void *)a1) {
    BOOL v4 = ((*(void *)a1 + 7) & 0xFFFFFFFFFFFFFFF8) - *(void *)a1 + 32 > *(void *)(a1 + 8) - *(void *)a1;
  }
  else {
    BOOL v4 = 1;
  }
  if (v4)
  {
    unsigned int v5 = *(_DWORD *)(a1 + 24) >> 7;
    if (v5 >= 0x1E) {
      LOBYTE(v5) = 30;
    }
    uint64_t v6 = 4096 << v5;
    buffer = (char *)llvm::allocate_buffer(4096 << v5, (std::align_val_t)8uLL);
    uint64_t v8 = *(unsigned int *)(a1 + 24);
    if (v8 >= *(_DWORD *)(a1 + 28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1 + 16, (void *)(a1 + 32), v8 + 1, 8);
      LODWORD(v8) = *(_DWORD *)(a1 + 24);
    }
    *(void *)(*(void *)(a1 + 16) + 8 * v8) = buffer;
    ++*(_DWORD *)(a1 + 24);
    *(void *)(a1 + 8) = &buffer[v6];
    unint64_t v9 = (unint64_t)(buffer + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  else
  {
    unint64_t v9 = (*(void *)a1 + 7) & 0xFFFFFFFFFFFFFFF8;
  }
  *(void *)a1 = v9 + 32;
  {
    unint64_t v12 = v9;
    unint64_t v9 = v12;
    if (v13)
    {
      int v21 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::CFGEdge]";
      unint64_t v22 = 73;
      unint64_t v14 = llvm::StringRef::find((uint64_t *)&v21, "DesiredTypeName = ", 0x12uLL, 0);
      if (v22 >= v14) {
        unint64_t v15 = v14;
      }
      else {
        unint64_t v15 = v22;
      }
      unint64_t v16 = &v21[v15];
      unint64_t v17 = v22 - v15;
      if (v22 - v15 >= 0x12) {
        uint64_t v18 = 18;
      }
      else {
        uint64_t v18 = v22 - v15;
      }
      unint64_t v19 = v17 - v18;
      if (v19 >= v19 - 1) {
        uint64_t v20 = v19 - 1;
      }
      else {
        uint64_t v20 = v19;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::CFGEdge,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v16[v18], v20);
      unint64_t v9 = v12;
    }
  }
  uint64_t v10 = mlir::detail::TypeIDResolver<mlir::dataflow::CFGEdge,void>::resolveTypeID(void)::id;
  *(void *)unint64_t v9 = &unk_1EC9AAE78;
  *(void *)(v9 + 8) = v10;
  __n128 result = *a2;
  *(__n128 *)(v9 + 16) = *a2;
  *(void *)unint64_t v9 = &unk_1EC9CDC50;
  return result;
}

void *mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::dataflow::CFGEdge *>(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v2 = a2 & 0xFFFFFFFFFFFFFFF9;
  {
    uint64_t v31 = a1;
    a1 = v31;
    if (v23)
    {
      uint64_t v32 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::Executable]";
      unint64_t v33 = 76;
      unint64_t v24 = llvm::StringRef::find((uint64_t *)&v32, "DesiredTypeName = ", 0x12uLL, 0);
      if (v33 >= v24) {
        unint64_t v25 = v24;
      }
      else {
        unint64_t v25 = v33;
      }
      uint64_t v26 = &v32[v25];
      unint64_t v27 = v33 - v25;
      if (v33 - v25 >= 0x12) {
        uint64_t v28 = 18;
      }
      else {
        uint64_t v28 = v33 - v25;
      }
      unint64_t v29 = v27 - v28;
      if (v29 >= v29 - 1) {
        uint64_t v30 = v29 - 1;
      }
      else {
        uint64_t v30 = v29;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v26[v28], v30);
      a1 = v31;
    }
  }
  uint64_t v32 = (const char *)v2;
  unint64_t v33 = mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id;
  int v3 = *(_DWORD *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    unint64_t v5 = ((0x2500000000 * v2) | (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 9))
       + ~((unint64_t)((mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = v3 - 1;
    unsigned int v9 = v8 & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (void *)(v4 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (v2 == *v10 && mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id == v12) {
      goto LABEL_25;
    }
    unint64_t v14 = 0;
    int v15 = 1;
    while (v11 != -4096 || v12 != -4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v12 == -8192;
      }
      if (v16 && v11 == -8192) {
        unint64_t v14 = v10;
      }
      unsigned int v18 = v9 + v15++;
      unsigned int v9 = v18 & v8;
      uint64_t v10 = (void *)(v4 + 24 * v9);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      if (v2 == *v10 && mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id == v12) {
        goto LABEL_25;
      }
    }
    if (v14) {
      uint64_t v20 = v14;
    }
    else {
      uint64_t v20 = v10;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v10 = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>(a1 + 120, (uint64_t)&v32, (uint64_t *)&v32, v20);
  *uint64_t v10 = v32;
  v10[1] = v33;
  v10[2] = 0;
LABEL_25:
  __n128 result = (void *)v10[2];
  if (!result)
  {
    __n128 result = operator new(0xB0uLL);
    result[2] = 0;
    result[3] = 0;
    *((_DWORD *)result + 8) = 0;
    *((unsigned char *)result + 56) = 0;
    result[5] = result + 7;
    result[6] = 0;
    *__n128 result = &unk_1EC9CDAC8;
    result[1] = v2;
    result[8] = result + 12;
    result[9] = result + 12;
    result[10] = 4;
    *((_DWORD *)result + 22) = 0;
    result[16] = result + 18;
    result[17] = 0x400000000;
    uint64_t v22 = v10[2];
    v10[2] = result;
    if (v22)
    {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
      return (void *)v10[2];
    }
  }
  return result;
}

char *mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::ProgramPoint>(uint64_t a1, const char *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  {
    uint64_t v31 = a1;
    a1 = v31;
    if (v23)
    {
      uint64_t v32 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::Executable]";
      unint64_t v33 = 76;
      unint64_t v24 = llvm::StringRef::find((uint64_t *)&v32, "DesiredTypeName = ", 0x12uLL, 0);
      if (v33 >= v24) {
        unint64_t v25 = v24;
      }
      else {
        unint64_t v25 = v33;
      }
      uint64_t v26 = &v32[v25];
      unint64_t v27 = v33 - v25;
      if (v33 - v25 >= 0x12) {
        uint64_t v28 = 18;
      }
      else {
        uint64_t v28 = v33 - v25;
      }
      unint64_t v29 = v27 - v28;
      if (v29 >= v29 - 1) {
        uint64_t v30 = v29 - 1;
      }
      else {
        uint64_t v30 = v29;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v26[v28], v30);
      a1 = v31;
    }
  }
  uint64_t v32 = a2;
  unint64_t v33 = mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id;
  int v3 = *(_DWORD *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    unint64_t v5 = ((0x2500000000 * (void)a2) | (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 9))
       + ~((unint64_t)((mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = v3 - 1;
    unsigned int v9 = v8 & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (const char **)(v4 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (a2 == *v10
      && mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id == (void)v12)
    {
      goto LABEL_25;
    }
    unint64_t v14 = 0;
    int v15 = 1;
    while (v11 != (const char *)-4096 || v12 != (const char *)-4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v12 == (const char *)-8192;
      }
      if (v16 && v11 == (const char *)-8192) {
        unint64_t v14 = v10;
      }
      unsigned int v18 = v9 + v15++;
      unsigned int v9 = v18 & v8;
      uint64_t v10 = (const char **)(v4 + 24 * v9);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      if (a2 == *v10
        && mlir::detail::TypeIDResolver<mlir::dataflow::Executable,void>::resolveTypeID(void)::id == (void)v12)
      {
        goto LABEL_25;
      }
    }
    if (v14) {
      uint64_t v20 = v14;
    }
    else {
      uint64_t v20 = v10;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v10 = (const char **)llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>(a1 + 120, (uint64_t)&v32, (uint64_t *)&v32, v20);
  *uint64_t v10 = v32;
  v10[1] = (const char *)v33;
  v10[2] = 0;
LABEL_25:
  __n128 result = (char *)v10[2];
  if (!result)
  {
    __n128 result = (char *)operator new(0xB0uLL);
    *((void *)result + 2) = 0;
    *((void *)result + 3) = 0;
    *((_DWORD *)result + 8) = 0;
    result[56] = 0;
    *((void *)result + 5) = result + 56;
    *((void *)result + 6) = 0;
    *(void *)__n128 result = &unk_1EC9CDAC8;
    *((void *)result + 1) = a2;
    *((void *)result + 8) = result + 96;
    *((void *)result + 9) = result + 96;
    *((void *)result + 10) = 4;
    *((_DWORD *)result + 22) = 0;
    *((void *)result + 16) = result + 144;
    *((void *)result + 17) = 0x400000000;
    uint64_t v22 = v10[2];
    v10[2] = result;
    if (v22)
    {
      (*(void (**)(const char *))(*(void *)v22 + 8))(v22);
      return (char *)v10[2];
    }
  }
  return result;
}

char *mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::ProgramPoint>(uint64_t a1, const char *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  {
    uint64_t v31 = a1;
    a1 = v31;
    if (v23)
    {
      uint64_t v32 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::PredecessorState]";
      unint64_t v33 = 82;
      unint64_t v24 = llvm::StringRef::find((uint64_t *)&v32, "DesiredTypeName = ", 0x12uLL, 0);
      if (v33 >= v24) {
        unint64_t v25 = v24;
      }
      else {
        unint64_t v25 = v33;
      }
      uint64_t v26 = &v32[v25];
      unint64_t v27 = v33 - v25;
      if (v33 - v25 >= 0x12) {
        uint64_t v28 = 18;
      }
      else {
        uint64_t v28 = v33 - v25;
      }
      unint64_t v29 = v27 - v28;
      if (v29 >= v29 - 1) {
        uint64_t v30 = v29 - 1;
      }
      else {
        uint64_t v30 = v29;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v26[v28], v30);
      a1 = v31;
    }
  }
  uint64_t v32 = a2;
  unint64_t v33 = mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id;
  int v3 = *(_DWORD *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    unint64_t v5 = ((0x2500000000 * (void)a2) | (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 9))
       + ~((unint64_t)((mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = v3 - 1;
    unsigned int v9 = v8 & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (const char **)(v4 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (a2 == *v10
      && mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id == (void)v12)
    {
      goto LABEL_25;
    }
    unint64_t v14 = 0;
    int v15 = 1;
    while (v11 != (const char *)-4096 || v12 != (const char *)-4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v12 == (const char *)-8192;
      }
      if (v16 && v11 == (const char *)-8192) {
        unint64_t v14 = v10;
      }
      unsigned int v18 = v9 + v15++;
      unsigned int v9 = v18 & v8;
      uint64_t v10 = (const char **)(v4 + 24 * v9);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      if (a2 == *v10
        && mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id == (void)v12)
      {
        goto LABEL_25;
      }
    }
    if (v14) {
      uint64_t v20 = v14;
    }
    else {
      uint64_t v20 = v10;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v10 = (const char **)llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>(a1 + 120, (uint64_t)&v32, (uint64_t *)&v32, v20);
  *uint64_t v10 = v32;
  v10[1] = (const char *)v33;
  v10[2] = 0;
LABEL_25:
  __n128 result = (char *)v10[2];
  if (!result)
  {
    __n128 result = (char *)operator new(0xC8uLL);
    *((void *)result + 2) = 0;
    *((void *)result + 3) = 0;
    result[56] = 1;
    *((_DWORD *)result + 8) = 0;
    *((void *)result + 5) = result + 56;
    *((void *)result + 6) = 0;
    *(void *)__n128 result = &unk_1EC9CDB28;
    *((void *)result + 1) = a2;
    *((void *)result + 8) = result + 96;
    *((void *)result + 9) = result + 96;
    *((void *)result + 10) = 4;
    *((_DWORD *)result + 22) = 0;
    *((void *)result + 16) = result + 144;
    *((void *)result + 17) = 0x400000000;
    *((void *)result + 22) = 0;
    *((void *)result + 23) = 0;
    *((_DWORD *)result + 48) = 0;
    uint64_t v22 = v10[2];
    v10[2] = result;
    if (v22)
    {
      (*(void (**)(const char *))(*(void *)v22 + 8))(v22);
      return (char *)v10[2];
    }
  }
  return result;
}

void *mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Block *>(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a2 | 6;
  {
    uint64_t v31 = a1;
    a1 = v31;
    if (v23)
    {
      uint64_t v32 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::dataflow::PredecessorState]";
      unint64_t v33 = 82;
      unint64_t v24 = llvm::StringRef::find((uint64_t *)&v32, "DesiredTypeName = ", 0x12uLL, 0);
      if (v33 >= v24) {
        unint64_t v25 = v24;
      }
      else {
        unint64_t v25 = v33;
      }
      uint64_t v26 = &v32[v25];
      unint64_t v27 = v33 - v25;
      if (v33 - v25 >= 0x12) {
        uint64_t v28 = 18;
      }
      else {
        uint64_t v28 = v33 - v25;
      }
      unint64_t v29 = v27 - v28;
      if (v29 >= v29 - 1) {
        uint64_t v30 = v29 - 1;
      }
      else {
        uint64_t v30 = v29;
      }
      mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v26[v28], v30);
      a1 = v31;
    }
  }
  uint64_t v32 = (const char *)v2;
  unint64_t v33 = mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id;
  int v3 = *(_DWORD *)(a1 + 136);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 120);
    unint64_t v5 = ((0x2500000000 * v2) | (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 9))
       + ~((unint64_t)((mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 4) ^ (mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id >> 9)) << 32);
    unint64_t v6 = (v5 ^ (v5 >> 22)) + ~((v5 ^ (v5 >> 22)) << 13);
    unint64_t v7 = (9 * (v6 ^ (v6 >> 8))) ^ ((9 * (v6 ^ (v6 >> 8))) >> 15);
    int v8 = v3 - 1;
    unsigned int v9 = v8 & (((v7 + ~(v7 << 27)) >> 31) ^ (v7 + ~(v7 << 27)));
    uint64_t v10 = (void *)(v4 + 24 * v9);
    uint64_t v11 = *v10;
    uint64_t v12 = v10[1];
    if (v2 == *v10
      && mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id == v12)
    {
      goto LABEL_25;
    }
    unint64_t v14 = 0;
    int v15 = 1;
    while (v11 != -4096 || v12 != -4096)
    {
      if (v14) {
        BOOL v16 = 0;
      }
      else {
        BOOL v16 = v12 == -8192;
      }
      if (v16 && v11 == -8192) {
        unint64_t v14 = v10;
      }
      unsigned int v18 = v9 + v15++;
      unsigned int v9 = v18 & v8;
      uint64_t v10 = (void *)(v4 + 24 * v9);
      uint64_t v11 = *v10;
      uint64_t v12 = v10[1];
      if (v2 == *v10
        && mlir::detail::TypeIDResolver<mlir::dataflow::PredecessorState,void>::resolveTypeID(void)::id == v12)
      {
        goto LABEL_25;
      }
    }
    if (v14) {
      uint64_t v20 = v14;
    }
    else {
      uint64_t v20 = v10;
    }
  }
  else
  {
    uint64_t v20 = 0;
  }
  uint64_t v10 = llvm::DenseMapBase<llvm::DenseMap<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>,std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>,llvm::DenseMapInfo<std::pair<mlir::ProgramPoint,mlir::TypeID>,void>,llvm::detail::DenseMapPair<std::pair<mlir::ProgramPoint,mlir::TypeID>,std::unique_ptr<mlir::AnalysisState>>>::InsertIntoBucketImpl<std::pair<mlir::ProgramPoint,mlir::TypeID>>(a1 + 120, (uint64_t)&v32, (uint64_t *)&v32, v20);
  *uint64_t v10 = v32;
  v10[1] = v33;
  v10[2] = 0;
LABEL_25:
  __n128 result = (void *)v10[2];
  if (!result)
  {
    __n128 result = operator new(0xC8uLL);
    result[2] = 0;
    result[3] = 0;
    *((unsigned char *)result + 56) = 1;
    *((_DWORD *)result + 8) = 0;
    result[5] = result + 7;
    result[6] = 0;
    *__n128 result = &unk_1EC9CDB28;
    result[1] = v2;
    result[8] = result + 12;
    result[9] = result + 12;
    result[10] = 4;
    *((_DWORD *)result + 22) = 0;
    result[16] = result + 18;
    result[17] = 0x400000000;
    result[22] = 0;
    result[23] = 0;
    *((_DWORD *)result + 48) = 0;
    uint64_t v22 = v10[2];
    v10[2] = result;
    if (v22)
    {
      (*(void (**)(uint64_t))(*(void *)v22 + 8))(v22);
      return (void *)v10[2];
    }
  }
  return result;
}

uint64_t mlir::OperationName::hasTrait<mlir::OpTrait::ReturnLike>(void *a1)
{
  unint64_t v1 = 0x1E8EB8000uLL;
  {
    uint64_t v12 = a1;
    unint64_t v1 = 0x1E8EB8000;
    int v4 = v3;
    a1 = v12;
    if (v4)
    {
      int v13 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ReturnLike<Empty>]";
      unint64_t v14 = 82;
      unint64_t v5 = llvm::StringRef::find((uint64_t *)&v13, "DesiredTypeName = ", 0x12uLL, 0);
      if (v14 >= v5) {
        unint64_t v6 = v5;
      }
      else {
        unint64_t v6 = v14;
      }
      unint64_t v7 = &v13[v6];
      unint64_t v8 = v14 - v6;
      if (v14 - v6 >= 0x12) {
        uint64_t v9 = 18;
      }
      else {
        uint64_t v9 = v14 - v6;
      }
      unint64_t v10 = v8 - v9;
      if (v10 >= v10 - 1) {
        uint64_t v11 = v10 - 1;
      }
      else {
        uint64_t v11 = v10;
      }
      mlir::detail::TypeIDResolver<mlir::OpTrait::ReturnLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ReturnLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v7[v9], v11);
      unint64_t v1 = 0x1E8EB8000;
      a1 = v12;
    }
  }
  return (*(uint64_t (**)(void, void))(*(void *)*a1 + 32))(*a1, *(void *)(v1 + 4088));
}

void mlir::dataflow::AbstractSparseLattice::onUpdate(mlir::dataflow::AbstractSparseLattice *this, mlir::DataFlowSolver *a2)
{
  uint64_t v4 = *((unsigned int *)this + 12);
  if (v4)
  {
    unint64_t v5 = (long long *)*((void *)this + 5);
    uint64_t v6 = *((void *)a2 + 5);
    uint64_t v7 = 16 * v4;
    do
    {
      uint64_t v8 = *((void *)a2 + 2);
      uint64_t v9 = *((void *)a2 + 1);
      long long v10 = *v5;
      if (v8 == v9) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = 32 * (v8 - v9) - 1;
      }
      unint64_t v12 = *((void *)a2 + 4) + v6;
      if (v11 == v12)
      {
        long long v25 = *v5;
        std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::__add_back_capacity((uint64_t)a2);
        long long v10 = v25;
        uint64_t v9 = *((void *)a2 + 1);
        unint64_t v12 = *((void *)a2 + 5) + *((void *)a2 + 4);
      }
      *(_OWORD *)(*(void *)(v9 + ((v12 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v12) = v10;
      uint64_t v6 = *((void *)a2 + 5) + 1;
      *((void *)a2 + 5) = v6;
      ++v5;
      v7 -= 16;
    }
    while (v7);
  }
  for (uint64_t i = *(void **)(*((void *)this + 1) & 0xFFFFFFFFFFFFFFF8); i; uint64_t i = (void *)*i)
  {
    uint64_t v14 = *((unsigned int *)this + 32);
    if (v14)
    {
      int v15 = (unint64_t *)*((void *)this + 15);
      unint64_t v16 = i[2] & 0xFFFFFFFFFFFFFFF9 | 2;
      uint64_t v17 = *((void *)a2 + 5);
      uint64_t v18 = 8 * v14;
      do
      {
        uint64_t v20 = *((void *)a2 + 2);
        uint64_t v21 = *((void *)a2 + 1);
        unint64_t v22 = *v15;
        if (v20 == v21) {
          uint64_t v23 = 0;
        }
        else {
          uint64_t v23 = 32 * (v20 - v21) - 1;
        }
        unint64_t v24 = v17 + *((void *)a2 + 4);
        if (v23 == v24)
        {
          std::deque<std::pair<mlir::ProgramPoint,mlir::DataFlowAnalysis *>>::__add_back_capacity((uint64_t)a2);
          uint64_t v21 = *((void *)a2 + 1);
          unint64_t v24 = *((void *)a2 + 5) + *((void *)a2 + 4);
        }
        unint64_t v19 = (unint64_t *)(*(void *)(v21 + ((v24 >> 5) & 0x7FFFFFFFFFFFFF8)) + 16 * v24);
        *unint64_t v19 = v16;
        v19[1] = v22;
        uint64_t v17 = *((void *)a2 + 5) + 1;
        *((void *)a2 + 5) = v17;
        ++v15;
        v18 -= 8;
      }
      while (v18);
    }
  }
}

mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::AbstractSparseForwardDataFlowAnalysis(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *this, mlir::DataFlowSolver *a2)
{
  int v3 = mlir::DataFlowAnalysis::DataFlowAnalysis(this, a2);
  void *v3 = &unk_1EC9CDC00;
  mlir::StorageUniquer::registerParametricStorageType<mlir::dataflow::CFGEdge>((uint64_t *)(v3[1] + 112));
  return this;
}

uint64_t mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::initialize(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *this, mlir::Operation *a2)
{
  unint64_t v4 = *((unsigned int *)a2 + 11);
  if ((v4 & 0x7FFFFF) != 0)
  {
    unint64_t v5 = (void *)((((unint64_t)a2 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
                  + 32 * *((unsigned int *)a2 + 10));
    uint64_t v6 = &v5[3 * (v4 & 0x7FFFFF)];
    do
    {
      if ((void *)*v5 != v5)
      {
        uint64_t v7 = v5[1];
        uint64_t v8 = v7 ? v7 - 8 : 0;
        uint64_t v9 = *(uint64_t **)(v8 + 48);
        uint64_t v10 = *(void *)(v8 + 56) - (void)v9;
        if (v10)
        {
          uint64_t v11 = 8 * (v10 >> 3);
          do
          {
            uint64_t v12 = *v9++;
            uint64_t v13 = (*(uint64_t (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t))(*(void *)this + 48))(this, v12);
            (*(void (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t))(*(void *)this + 56))(this, v13);
            v11 -= 8;
          }
          while (v11);
        }
      }
      v5 += 3;
    }
    while (v5 != v6);
  }

  return mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::initializeRecursively(this, a2);
}

uint64_t mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::initializeRecursively(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *this, mlir::Operation *a2)
{
  mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitOperation(this, (uint64_t)a2);
  unint64_t v4 = *((unsigned int *)a2 + 11);
  if ((v4 & 0x7FFFFF) != 0)
  {
    unint64_t v5 = (((unint64_t)a2 + 16 * ((v4 >> 23) & 1) + ((v4 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)a2 + 10);
    unint64_t v6 = v5 + 24 * (v4 & 0x7FFFFF);
LABEL_3:
    for (uint64_t i = *(void *)(v5 + 8); ; uint64_t i = *(void *)(i + 8))
    {
      if (i == v5)
      {
        v5 += 24;
        if (v5 != v6) {
          goto LABEL_3;
        }
        return 1;
      }
      if (i) {
        uint64_t v8 = i - 8;
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t v9 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(*((void *)this + 1), v8);
      uint64_t v10 = v9[9];
      if (v10 != v9[8]) {
        goto LABEL_10;
      }
      uint64_t v16 = *((unsigned int *)v9 + 21);
      if (!v16) {
        break;
      }
      uint64_t v17 = 0;
      uint64_t v18 = 8 * v16;
      unint64_t v19 = (void *)v9[9];
      while ((mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *)*v19 != this)
      {
        if (*v19 == -2) {
          uint64_t v17 = v19;
        }
        ++v19;
        v18 -= 8;
        if (!v18)
        {
          if (!v17) {
            goto LABEL_26;
          }
          *uint64_t v17 = this;
          --*((_DWORD *)v9 + 22);
          goto LABEL_11;
        }
      }
LABEL_14:
      mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitBlock(this, v8);
      uint64_t v13 = (mlir::GenericProgramPoint *)(v8 + 32);
      for (uint64_t j = *(mlir::GenericProgramPoint **)(v8 + 40); j != v13; uint64_t j = (mlir::GenericProgramPoint *)*((void *)j + 1))
      {
        mlir::GenericProgramPoint::~GenericProgramPoint(j);
        if (!mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::initializeRecursively(this, v15)) {
          return 0;
        }
      }
    }
LABEL_26:
    if (v16 >= *((_DWORD *)v9 + 20))
    {
LABEL_10:
      llvm::SmallPtrSetImplBase::insert_imp_big((llvm::SmallPtrSetImplBase *)(v9 + 8), this);
      if (!v11) {
        goto LABEL_14;
      }
    }
    else
    {
      *((_DWORD *)v9 + 21) = v16 + 1;
      *(void *)(v10 + 8 * v16) = this;
    }
LABEL_11:
    unint64_t v12 = *((unsigned int *)v9 + 34);
    if (v12 >= *((unsigned int *)v9 + 35))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v9 + 16), v9 + 18, v12 + 1, 8);
      unint64_t v12 = *((unsigned int *)v9 + 34);
    }
    *(void *)(v9[16] + 8 * v12) = this;
    ++*((_DWORD *)v9 + 34);
    goto LABEL_14;
  }
  return 1;
}

void mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitOperation(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *this, uint64_t a2)
{
  v48[6] = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 36)
    && *((unsigned char *)mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(*((void *)this + 1), *(void *)(a2 + 16))+ 56))
  {
    uint64_t v46 = v48;
    uint64_t v47 = 0x600000000;
    unint64_t v4 = *(unsigned int *)(a2 + 36);
    if (v4 >= 7)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v48, v4, 8);
      LODWORD(v4) = *(_DWORD *)(a2 + 36);
    }
    if (v4) {
      unint64_t v5 = (char *)(a2 - 16);
    }
    else {
      unint64_t v5 = 0;
    }
    if (v4)
    {
      uint64_t v6 = 0;
      uint64_t v7 = v4;
      do
      {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v5, v6);
        uint64_t v9 = (*(uint64_t (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t))(*(void *)this + 48))(this, NextResultAtOffset);
        uint64_t v10 = v47;
        if (v47 >= (unint64_t)HIDWORD(v47))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v48, v47 + 1, 8);
          uint64_t v10 = v47;
        }
        *((void *)v46 + v10) = v9;
        LODWORD(v47) = v47 + 1;
        ++v6;
      }
      while (v7 != v6);
    }
    uint64_t v11 = llvm::DefaultDoCastIfPossible<mlir::RegionBranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::RegionBranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
    if (v11)
    {
      mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitRegionSuccessors((uint64_t *)this, v11 & 0xFFFFFFFFFFFFFFF9 | 2, v11, v12, 0, (uint64_t *)v46, v47);
    }
    else
    {
      uint64_t v13 = llvm::DefaultDoCastIfPossible<mlir::CallOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallOpInterface,mlir::Operation *,void>>::doCastIfPossible(a2);
      if (v13)
      {
        unint64_t v14 = a2 & 0xFFFFFFFFFFFFFFF9 | 2;
        int v15 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*((void *)this + 1), v13);
        mlir::DataFlowAnalysis::addDependency((uint64_t)this, (uint64_t)v15, v14);
        if (*((unsigned char *)v15 + 56))
        {
          uint64_t v16 = *((unsigned int *)v15 + 34);
          if (v16)
          {
            uint64_t v17 = (uint64_t *)v15[16];
            uint64_t v18 = &v17[v16];
            do
            {
              uint64_t v19 = *v17;
              if ((*(unsigned char *)(*v17 + 46) & 0x80) != 0)
              {
                uint64_t v20 = *(unsigned int *)(v19 + 68);
                if (v20 && v47 != 0)
                {
                  unint64_t v22 = (uint64_t *)v46;
                  uint64_t v23 = 8 * v47 - 8;
                  unint64_t v24 = (uint64_t *)(*(void *)(v19 + 72) + 24);
                  uint64_t v25 = v20 - 1;
                  do
                  {
                    uint64_t v27 = *v24;
                    v24 += 4;
                    uint64_t v26 = v27;
                    uint64_t v28 = *v22++;
                    uint64_t v29 = (*(uint64_t (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t))(*(void *)this + 48))(this, v26);
                    mlir::DataFlowAnalysis::addDependency((uint64_t)this, v29, v14);
                    int v30 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v28 + 32))(v28, v29);
                    mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)this, v28, v30);
                    if (v25-- == 0) {
                      break;
                    }
                    uint64_t v32 = v23;
                    v23 -= 8;
                  }
                  while (v32);
                }
              }
              ++v17;
            }
            while (v17 != v18);
          }
        }
        else if (v47)
        {
          uint64_t v39 = (uint64_t *)v46;
          uint64_t v40 = 8 * v47;
          do
          {
            uint64_t v41 = *v39++;
            (*(void (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t))(*(void *)this + 56))(this, v41);
            v40 -= 8;
          }
          while (v40);
        }
      }
      else
      {
        unint64_t v43 = v45;
        uint64_t v44 = 0x600000000;
        if ((*(unsigned char *)(a2 + 46) & 0x80) != 0
          && ((unint64_t v33 = *(unsigned int *)(a2 + 68), v33 < 7)
           || (llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v33, 8),
               (*(unsigned char *)(a2 + 46) & 0x80) != 0))
          && (uint64_t v34 = *(unsigned int *)(a2 + 68), v34))
        {
          unint64_t v35 = (void *)(*(void *)(a2 + 72) + 24);
          do
          {
            uint64_t v36 = (*(uint64_t (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, void))(*(void *)this + 48))(this, *v35);
            __int16 v42 = this;
            llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u>,llvm::SmallPtrSet<mlir::Operation *,4u>,0u>::insert((llvm::SmallPtrSetImplBase *)(v36 + 56), &v42);
            uint64_t v37 = v44;
            if (v44 >= (unint64_t)HIDWORD(v44))
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 8);
              uint64_t v37 = v44;
            }
            *((void *)v43 + v37) = v36;
            unsigned int v38 = v44 + 1;
            LODWORD(v44) = v44 + 1;
            v35 += 4;
            --v34;
          }
          while (v34);
        }
        else
        {
          unsigned int v38 = v44;
        }
        (*(void (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t, void *, void, void *, void))(*(void *)this + 32))(this, a2, v43, v38, v46, v47);
        if (v43 != v45) {
          free(v43);
        }
      }
    }
    if (v46 != v48) {
      free(v46);
    }
  }
}

void mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitBlock(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *this, uint64_t a2)
{
  v76[6] = *MEMORY[0x1E4F143B8];
  uint64_t v69 = a2;
  if (((*(void *)(a2 + 56) - *(void *)(a2 + 48)) & 0x7FFFFFFF8) == 0
    || !*((unsigned char *)mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::Block *>(*((void *)this + 1), a2)+ 56))
  {
    return;
  }
  int32x2_t v74 = v76;
  uint64_t v75 = 0x600000000;
  unint64_t v5 = *(char **)(a2 + 48);
  unint64_t v4 = *(char **)(a2 + 56);
  uint64_t v6 = v4 - v5;
  unint64_t v7 = ((unint64_t)(v4 - v5) >> 3);
  if (v7 >= 7)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v76, v7, 8);
    unint64_t v5 = *(char **)(a2 + 48);
    unint64_t v4 = *(char **)(a2 + 56);
    uint64_t v6 = v4 - v5;
  }
  if (v4 != v5)
  {
    uint64_t v8 = 8 * (v6 >> 3);
    do
    {
      uint64_t v9 = (*(uint64_t (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, void))(*(void *)this + 48))(this, *(void *)v5);
      uint64_t v10 = v75;
      if (v75 >= (unint64_t)HIDWORD(v75))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v76, v75 + 1, 8);
        uint64_t v10 = v75;
      }
      *((void *)v74 + v10) = v9;
      LODWORD(v75) = v75 + 1;
      v5 += 8;
      v8 -= 8;
    }
    while (v8);
  }
  if (mlir::Block::isEntryBlock((mlir::Block *)a2))
  {
    uint64_t ParentOp = mlir::Block::getParentOp((mlir::Block *)a2);
    char v67 = (mlir::BlockOperand **)llvm::DefaultDoCastIfPossible<mlir::CallableOpInterface,mlir::Operation *,llvm::CastInfo<mlir::CallableOpInterface,mlir::Operation *,void>>::doCastIfPossible(ParentOp);
    int v68 = v12;
    if (!v67
      || (uint64_t canMapOperands = mlir::MemoryMapperInterface::canMapOperands((mlir::MemoryMapperInterface *)&v67),
          canMapOperands != mlir::Block::getParent((mlir::Block *)a2)))
    {
      uint64_t v14 = mlir::Block::getParentOp((mlir::Block *)a2);
      uint64_t v15 = llvm::DefaultDoCastIfPossible<mlir::RegionBranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::RegionBranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(v14);
      if (v15)
      {
        uint64_t v17 = v15;
        uint64_t v18 = v16;
        unint64_t Parent = mlir::Block::getParent((mlir::Block *)a2);
        mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitRegionSuccessors((uint64_t *)this, a2 | 6, v17, v18, Parent, (uint64_t *)v74, v75);
      }
      else
      {
        uint64_t v32 = mlir::Block::getParentOp((mlir::Block *)a2);
        unint64_t v70 = mlir::Block::getParent((mlir::Block *)a2);
        mlir::ValueRange::ValueRange(v71, 0, 0);
        (*(void (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t, unint64_t *, void *, void, void))(*(void *)this + 40))(this, v32, &v70, v74, v75, 0);
      }
      goto LABEL_58;
    }
    unint64_t v36 = a2 | 6;
    uint64_t v37 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::Operation *>(*((void *)this + 1), (uint64_t)v67);
    mlir::DataFlowAnalysis::addDependency((uint64_t)this, (uint64_t)v37, v36);
    if (!*((unsigned char *)v37 + 56))
    {
      if (v75)
      {
        int v62 = (uint64_t *)v74;
        uint64_t v63 = 8 * v75;
        do
        {
          uint64_t v64 = *v62++;
          (*(void (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t))(*(void *)this + 56))(this, v64);
          v63 -= 8;
        }
        while (v63);
      }
      goto LABEL_58;
    }
    uint64_t v38 = *((unsigned int *)v37 + 34);
    if (!v38) {
      goto LABEL_58;
    }
    uint64_t v39 = (void **)v37[16];
    uint64_t v40 = &v39[v38];
    while (1)
    {
      uint64_t v41 = *v39;
      if (!*v39)
      {
        uint64_t Values = 0;
        goto LABEL_48;
      }
      uint64_t v42 = v41[6];
      unint64_t v43 = *(void **)(v42 + 16);
      BOOL v44 = v43 == &mlir::detail::TypeIDResolver<void,void>::id;
      if (v43 == &mlir::detail::TypeIDResolver<void,void>::id) {
        uint64_t v45 = 0;
      }
      else {
        uint64_t v45 = v41[6];
      }
      if (v44)
      {
        unint64_t v70 = *(void *)(v42 + 8);
        uint64_t Values = mlir::SparseElementsAttr::getValues((mlir::SparseElementsAttr *)&v70);
        if (!Values) {
          goto LABEL_48;
        }
        uint64_t v48 = v42;
      }
      else
      {
        unint64_t v46 = v45 | v42 & 0xFFFFFFFFFFFFFF00;
        uint64_t Values = mlir::detail::InterfaceMap::lookup<mlir::CallOpInterface>(v46 + 32);
        if (Values) {
          goto LABEL_48;
        }
        uint64_t Values = *(void *)(v46 + 24);
        uint64_t v48 = v41[6];
      }
      uint64_t Values = mlir::Dialect::getRegisteredInterfaceForOp<mlir::CallOpInterface>(Values, v48);
LABEL_48:
      unint64_t v70 = (unint64_t)v41;
      v71[0] = Values;
      uint64_t ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v70);
      if (v50 && v75)
      {
        char v51 = (uint64_t *)v74;
        uint64_t v52 = 8 * v75 - 8;
        unint64_t v53 = (uint64_t *)(ArgOperands + 24);
        uint64_t v54 = v50 - 1;
        do
        {
          uint64_t v56 = *v53;
          v53 += 4;
          uint64_t v55 = v56;
          uint64_t v57 = *v51++;
          uint64_t v58 = (*(uint64_t (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t))(*(void *)this + 48))(this, v55);
          mlir::DataFlowAnalysis::addDependency((uint64_t)this, v58, v36);
          int v59 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v57 + 32))(v57, v58);
          mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)this, v57, v59);
          if (v54-- == 0) {
            break;
          }
          uint64_t v61 = v52;
          v52 -= 8;
        }
        while (v61);
      }
      if (++v39 == v40) {
        goto LABEL_58;
      }
    }
  }
  char v67 = *(mlir::BlockOperand ***)a2;
  int v68 = (uint64_t (*)(void))mlir::PredecessorIterator::unwrap;
  if (!v67) {
    goto LABEL_58;
  }
  while (1)
  {
    unint64_t v66 = 0;
    unint64_t v66 = (mlir::Block *)v68();
    uint64_t v20 = mlir::StorageUniquer::get<mlir::dataflow::CFGEdge,mlir::Block *&,mlir::Block *&>((unsigned __int8 **)(*((void *)this + 1) + 112), 0, 0, &v66, &v69);
    uint64_t v21 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::Executable,mlir::dataflow::CFGEdge *>(*((void *)this + 1), v20);
    unint64_t v70 = (unint64_t)this;
    llvm::SetVector<mlir::Operation *,llvm::SmallVector<mlir::Operation *,4u>,llvm::SmallPtrSet<mlir::Operation *,4u>,0u>::insert((llvm::SmallPtrSetImplBase *)(v21 + 8), (const void **)&v70);
    if (*((unsigned char *)v21 + 56)) {
      break;
    }
LABEL_17:
    char v67 = (mlir::BlockOperand **)*v67;
    if (!v67) {
      goto LABEL_58;
    }
  }
  mlir::Block::getTerminator((mlir::GenericProgramPoint **)v66);
  v65[0] = llvm::DefaultDoCastIfPossible<mlir::BranchOpInterface,mlir::Operation *,llvm::CastInfo<mlir::BranchOpInterface,mlir::Operation *,void>>::doCastIfPossible(v22);
  v65[1] = v23;
  if (v65[0])
  {
    unint64_t SuccessorIndex = mlir::PredecessorIterator::getSuccessorIndex((mlir::BlockOperand **)&v67);
    mlir::BranchOpInterface::getSuccessorOperands((mlir::BranchOpInterface *)v65, SuccessorIndex);
    if (v75)
    {
      uint64_t v25 = 0;
      uint64_t v26 = v74;
      uint64_t v27 = 8 * v75;
      do
      {
        while (v70 > v25
             || !*(void *)(mlir::MutableOperandRange::operator[](v71, (int)v25 - (int)v70) + 24))
        {
          (*(void (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, void))(*(void *)this
                                                                                                  + 56))(this, v26[v25++]);
          v27 -= 8;
          if (!v27) {
            goto LABEL_26;
          }
        }
        uint64_t v28 = v26[v25];
        uint64_t v29 = v69 | 6;
        uint64_t v30 = (*(uint64_t (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *))(*(void *)this + 48))(this);
        mlir::DataFlowAnalysis::addDependency((uint64_t)this, v30, v29);
        int v31 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v28 + 32))(v28, v30);
        mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)this, v28, v31);
        ++v25;
        v27 -= 8;
      }
      while (v27);
    }
LABEL_26:
    if (v72 != &v73) {
      free(v72);
    }
    goto LABEL_17;
  }
  if (v75)
  {
    unint64_t v33 = (uint64_t *)v74;
    uint64_t v34 = 8 * v75;
    do
    {
      uint64_t v35 = *v33++;
      (*(void (**)(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *, uint64_t))(*(void *)this + 56))(this, v35);
      v34 -= 8;
    }
    while (v34);
  }
LABEL_58:
  if (v74 != v76) {
    free(v74);
  }
}

uint64_t mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visit(mlir::dataflow::AbstractSparseForwardDataFlowAnalysis *a1, uint64_t a2)
{
  uint64_t v2 = a2 & 6;
  unint64_t v3 = a2 & 0xFFFFFFFFFFFFFFF8;
  if (v2 == 2 && v3 != 0)
  {
    mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitOperation(a1, v3);
    return 1;
  }
  uint64_t v5 = 0;
  if (v2 == 6 && v3)
  {
    mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitBlock(a1, v3);
    return 1;
  }
  return v5;
}

void mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::visitRegionSuccessors(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  v63[4] = *MEMORY[0x1E4F143B8];
  v59[0] = a3;
  v59[1] = a4;
  uint64_t v10 = mlir::DataFlowSolver::getOrCreateState<mlir::dataflow::PredecessorState,mlir::ProgramPoint>(a1[1], (const char *)a2);
  mlir::DataFlowAnalysis::addDependency((uint64_t)a1, (uint64_t)v10, a2);
  uint64_t v11 = *((unsigned int *)v10 + 34);
  if (!v11) {
    return;
  }
  uint64_t v12 = (uint64_t *)*((void *)v10 + 16);
  BOOL v13 = (a2 & 6) != 2;
  if ((a2 & 0xFFFFFFFFFFFFFFF8) == 0) {
    BOOL v13 = 1;
  }
  BOOL v53 = v13;
  uint64_t v54 = 8 * a7;
  uint64_t v55 = &v12[v11];
  uint64_t v52 = (mlir::Block *)(a2 & 0xFFFFFFFFFFFFFFF8);
  uint64_t v56 = v10;
  while (1)
  {
    uint64_t v14 = *v12;
    if (*v12 != v59[0]) {
      break;
    }
    uint64_t v16 = mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)v59, a5);
    uint64_t v18 = v20;
    int v19 = *((_DWORD *)v10 + 48);
    if (!v19) {
      goto LABEL_21;
    }
LABEL_13:
    uint64_t v21 = *((void *)v10 + 22);
    int v22 = v19 - 1;
    unsigned int v23 = (v19 - 1) & ((v14 >> 4) ^ (v14 >> 9));
    uint64_t v24 = *(void *)(v21 + 24 * v23);
    if (v24 == v14)
    {
LABEL_14:
      long long v61 = *(_OWORD *)(v21 + 24 * v23 + 8);
      uint64_t v25 = *((void *)&v61 + 1);
      long long v60 = v61;
      if (*((void *)&v61 + 1) == a7) {
        goto LABEL_15;
      }
      goto LABEL_22;
    }
    int v27 = 1;
    while (v24 != -4096)
    {
      unsigned int v28 = v23 + v27++;
      unsigned int v23 = v28 & v22;
      uint64_t v24 = *(void *)(v21 + 24 * v23);
      if (v24 == v14) {
        goto LABEL_14;
      }
    }
LABEL_21:
    mlir::ValueRange::ValueRange((unint64_t *)&v61, 0, 0);
    uint64_t v25 = *((void *)&v61 + 1);
    long long v60 = v61;
    if (*((void *)&v61 + 1) == a7)
    {
LABEL_15:
      LODWORD(v26) = 0;
      if (v18) {
        goto LABEL_48;
      }
      goto LABEL_5;
    }
LABEL_22:
    if (v53)
    {
      uint64_t v29 = v16;
      if (v25)
      {
        uint64_t v26 = *(unsigned int *)(mlir::ValueRange::dereference_iterator(&v60, 0) + 24);
        unint64_t Parent = (void *)mlir::Block::getParent(v52);
        uint64_t v31 = v59[0];
        if ((void *)*Parent != Parent) {
          goto LABEL_25;
        }
LABEL_34:
        uint64_t v34 = 0;
      }
      else
      {
        uint64_t v26 = 0;
        unint64_t Parent = (void *)mlir::Block::getParent(v52);
        uint64_t v31 = v59[0];
        if ((void *)*Parent == Parent) {
          goto LABEL_34;
        }
LABEL_25:
        uint64_t v32 = Parent[1];
        if (v32) {
          uint64_t v33 = v32 - 8;
        }
        else {
          uint64_t v33 = 0;
        }
        uint64_t v34 = *(void *)(v33 + 48);
      }
      *(void *)&long long v61 = Parent;
      mlir::ValueRange::ValueRange((unint64_t *)&v61 + 1, v34 + 8 * v26, *((unint64_t *)&v60 + 1));
      (*(void (**)(uint64_t *, uint64_t, long long *, uint64_t *, uint64_t, uint64_t))(*a1 + 40))(a1, v31, &v61, a6, a7, v26);
      goto LABEL_47;
    }
    if (v25)
    {
      uint64_t v35 = mlir::ValueRange::dereference_iterator(&v60, 0);
      if (v35 && (*(void *)(v35 + 8) & 7) == 6)
      {
        uint64_t v29 = v16;
        uint64_t v26 = (*(_DWORD *)(v35 + 16) + 6);
      }
      else
      {
        uint64_t v29 = v16;
        uint64_t v26 = *(void *)(v35 + 8) & 7;
      }
      uint64_t v36 = v59[0];
      if (*(_DWORD *)(v59[0] + 36)) {
        uint64_t NextResultAtOffset = v59[0] - 16;
      }
      else {
        uint64_t NextResultAtOffset = 0;
      }
      unint64_t v38 = *((void *)&v60 + 1);
      if (v26) {
        uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, v26);
      }
    }
    else
    {
      uint64_t v29 = v16;
      uint64_t v26 = 0;
      uint64_t v36 = v59[0];
      if (*(_DWORD *)(v59[0] + 36)) {
        uint64_t NextResultAtOffset = v59[0] - 16;
      }
      else {
        uint64_t NextResultAtOffset = 0;
      }
      unint64_t v38 = *((void *)&v60 + 1);
    }
    *(void *)&long long v61 = 0;
    mlir::ValueRange::ValueRange((unint64_t *)&v61 + 1, NextResultAtOffset, v38);
    (*(void (**)(uint64_t *, uint64_t, long long *, uint64_t *, uint64_t, uint64_t))(*a1 + 40))(a1, v36, &v61, a6, a7, v26);
LABEL_47:
    uint64_t v16 = v29;
    if (v18)
    {
LABEL_48:
      if (a7 != v26)
      {
        uint64_t v39 = v26;
        uint64_t v40 = &a6[v39];
        uint64_t v41 = 8 * a7 - 8 - v39 * 8;
        uint64_t v42 = (uint64_t *)(v16 + 24);
        uint64_t v43 = v18 - 1;
        do
        {
          uint64_t v45 = *v42;
          v42 += 4;
          uint64_t v44 = v45;
          uint64_t v46 = *v40++;
          uint64_t v47 = (*(uint64_t (**)(uint64_t *, uint64_t))(*a1 + 48))(a1, v44);
          mlir::DataFlowAnalysis::addDependency((uint64_t)a1, v47, a2);
          int v48 = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v46 + 32))(v46, v47);
          mlir::DataFlowAnalysis::propagateIfChanged((uint64_t)a1, v46, v48);
          if (v43-- == 0) {
            break;
          }
          uint64_t v50 = v41;
          v41 -= 8;
        }
        while (v50);
      }
    }
LABEL_5:
    ++v12;
    uint64_t v10 = v56;
    if (v12 == v55) {
      return;
    }
  }
  *(void *)&long long v60 = llvm::DefaultDoCastIfPossible<mlir::RegionBranchTerminatorOpInterface,mlir::Operation *,llvm::CastInfo<mlir::RegionBranchTerminatorOpInterface,mlir::Operation *,void>>::doCastIfPossible(*v12);
  *((void *)&v60 + 1) = v15;
  if ((void)v60)
  {
    mlir::BranchOpInterface::getSuccessorOperands((mlir::BranchOpInterface *)&v60, a5);
    uint64_t v16 = mlir::MutableOperandRange::operator mlir::OperandRange((unsigned int *)&v61);
    uint64_t v18 = v17;
    if (v62 != v63) {
      free(v62);
    }
    int v19 = *((_DWORD *)v10 + 48);
    if (!v19) {
      goto LABEL_21;
    }
    goto LABEL_13;
  }
  if (a7)
  {
    do
    {
      uint64_t v51 = *a6++;
      (*(void (**)(uint64_t *, uint64_t))(*a1 + 56))(a1, v51);
      v54 -= 8;
    }
    while (v54);
  }
}

uint64_t mlir::dataflow::AbstractSparseForwardDataFlowAnalysis::setAllToEntryStates(uint64_t result, uint64_t *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = result;
    uint64_t v5 = 8 * a3;
    do
    {
      uint64_t v6 = *a2++;
      __n128 result = (*(uint64_t (**)(uint64_t, uint64_t))(*(void *)v4 + 56))(v4, v6);
      v5 -= 8;
    }
    while (v5);
  }
  return result;
}

uint64_t mlir::dataflow::AbstractSparseLattice::join()
{
  return 0;
}

uint64_t mlir::dataflow::AbstractSparseLattice::meet()
{
  return 0;
}

mlir::anec::ANECDialect *mlir::anec::ANECDialect::ANECDialect(mlir::anec::ANECDialect *this, mlir::MLIRContext *a2)
{
  unint64_t v3 = (void *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"anec", 4, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::anec::ANECDialect,void>::id);
  void *v3 = &unk_1EC9CB338;
  mlir::Dialect::addOperations<mlir::anec::A11Legacy,mlir::anec::A12,mlir::anec::A13,mlir::anec::A14,mlir::anec::A15,mlir::anec::A16,mlir::anec::A17,mlir::anec::ArgMinMax,mlir::anec::AveragePool,mlir::anec::BatchToSpace,mlir::anec::Broadcast,mlir::anec::Cast,mlir::anec::Ceil,mlir::anec::ChannelToSpace,mlir::anec::ClampedRelu,mlir::anec::Concat,mlir::anec::Convolution,mlir::anec::Cos,mlir::anec::CropResize,mlir::anec::DeQuant,mlir::anec::Deconvolution,mlir::anec::Degamma,mlir::anec::Dirac,mlir::anec::ElementwiseAbs,mlir::anec::ElementwiseAdd,mlir::anec::ElementwiseDiv,mlir::anec::ElementwiseEqual,mlir::anec::ElementwiseEqualZero,mlir::anec::ElementwiseGreaterThan,mlir::anec::ElementwiseGreaterThanEqual,mlir::anec::ElementwiseGreaterThanEqualZero,mlir::anec::ElementwiseGreaterThanZero,mlir::anec::ElementwiseLessThan,mlir::anec::ElementwiseLessThanEqual,mlir::anec::ElementwiseLessThanEqualZero,mlir::anec::ElementwiseLessThanZero,mlir::anec::ElementwiseMax,mlir::anec::ElementwiseMin,mlir::anec::ElementwiseMult,mlir::anec::ElementwiseNotEqual,mlir::anec::ElementwiseNotEqualZero,mlir::anec::ElementwisePower,mlir::anec::ElementwiseSquare,mlir::anec::ElementwiseSub,mlir::anec::Elu,mlir::anec::Erf,mlir::anec::Exp2,mlir::anec::Flatten,mlir::anec::Floor,mlir::anec::GOC,mlir::anec::GatherND,mlir::anec::Gelu,mlir::anec::GlobalArgMinMax,mlir::anec::HighPrecisionSigmoid,mlir::anec::InputView,mlir::anec::InstanceNorm,mlir::anec::Invert,mlir::anec::L2NormPool,mlir::anec::LeakyRelu,mlir::anec::Linear,mlir::anec::Log2,mlir::anec::MatMul,mlir::anec::MaxPool,mlir::anec::NRelu,mlir::anec::Padding,mlir::anec::PixelShuffle,mlir::anec::PixelUnshuffle,mlir::anec::Quant,mlir::anec::ReduceAvg,mlir::anec::ReduceMax,mlir::anec::ReduceMin,mlir::anec::ReduceSum,mlir::anec::RegionReturn,mlir::anec::Relu,mlir::anec::Reshape,mlir::anec::Resize,mlir::anec::RoundNearest,mlir::anec::Rsqrt,mlir::anec::Sigmoid,mlir::anec::Sign,mlir::anec::Sin,mlir::anec::Softmax,mlir::anec::SpaceToBatch,mlir::anec::SpaceToChannel,mlir::anec::Sqr,mlir::anec::Sqrt,mlir::anec::Swish,mlir::anec::T0,mlir::anec::Tanh,mlir::anec::Tile,mlir::anec::Transpose,mlir::anec::Trunc,mlir::anec::Unflatten,mlir::anec::UnrealizedConversionCast>((uint64_t)v3);
  return this;
}

void mlir::anec::ANECDialect::~ANECDialect(llvm **this)
{
}

void sub_1801910B0(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::anec::BoxCoordinateModeAttr::classof(uint64_t a1)
{
  if (*(_UNKNOWN **)(*(void *)a1 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
    return 0;
  }
  uint64_t v19 = a1;
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v19);
  uint64_t result = mlir::Type::isSignlessInteger((mlir::Type *)&Value, 64);
  if (result)
  {
    uint64_t v18 = a1;
    if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v18))
    {
      uint64_t v17 = a1;
      uint64_t result = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v17);
      if (result == 1) {
        return result;
      }
      uint64_t v16 = a1;
      if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v16) != 2)
      {
        uint64_t v15 = a1;
        if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v15) != 3)
        {
          uint64_t v14 = a1;
          if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v14) != 4)
          {
            uint64_t v13 = a1;
            if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v13) != 5)
            {
              uint64_t v12 = a1;
              if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v12) != 6)
              {
                uint64_t v11 = a1;
                if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v11) != 7)
                {
                  uint64_t v10 = a1;
                  if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v10) != 8)
                  {
                    uint64_t v9 = a1;
                    if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v9) != 9)
                    {
                      uint64_t v8 = a1;
                      if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v8) != 10)
                      {
                        uint64_t v7 = a1;
                        if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v7) != 11)
                        {
                          uint64_t v6 = a1;
                          if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v6) != 12)
                          {
                            uint64_t v5 = a1;
                            if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v5) != 13)
                            {
                              uint64_t v4 = a1;
                              if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v4) != 14)
                              {
                                uint64_t v3 = a1;
                                return mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v3) == 15;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return 1;
  }
  return result;
}

uint64_t mlir::anec::BoxCoordinateModeAttr::get(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = mlir::IntegerType::get(a1, 0x40u, 0);

  return mlir::IntegerAttr::get(v3, a2);
}

uint64_t mlir::anec::PaddingModeAttr::classof(uint64_t a1)
{
  if (*(_UNKNOWN **)(*(void *)a1 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
    return 0;
  }
  uint64_t v12 = a1;
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v12);
  uint64_t result = mlir::Type::isSignlessInteger((mlir::Type *)&Value, 64);
  if (result)
  {
    uint64_t v11 = a1;
    if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v11))
    {
      uint64_t v10 = a1;
      uint64_t result = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v10);
      if (result == 1) {
        return result;
      }
      uint64_t v9 = a1;
      if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v9) != 2)
      {
        uint64_t v8 = a1;
        if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v8) != 3)
        {
          uint64_t v7 = a1;
          if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v7) != 4)
          {
            uint64_t v6 = a1;
            if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v6) != 5)
            {
              uint64_t v5 = a1;
              if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v5) != 6)
              {
                uint64_t v4 = a1;
                if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v4) != 7)
                {
                  uint64_t v3 = a1;
                  return mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v3) == 8;
                }
              }
            }
          }
        }
      }
    }
    return 1;
  }
  return result;
}

uint64_t mlir::anec::getFamily(uint64_t a1, uint64_t a2)
{
  if (a2 != 3) {
    return 6;
  }
  if (*(_WORD *)a1 == 12609 && *(unsigned char *)(a1 + 2) == 50) {
    return 0;
  }
  if (*(_WORD *)a1 == 12609 && *(unsigned char *)(a1 + 2) == 51) {
    return 1;
  }
  if (*(_WORD *)a1 == 12609 && *(unsigned char *)(a1 + 2) == 52) {
    return 2;
  }
  if (*(_WORD *)a1 == 12609 && *(unsigned char *)(a1 + 2) == 53) {
    return 3;
  }
  if (*(_WORD *)a1 == 12609 && *(unsigned char *)(a1 + 2) == 54) {
    return 4;
  }
  if (*(_WORD *)a1 != 12609 || *(unsigned char *)(a1 + 2) != 55) {
    return 6;
  }
  return 5;
}

uint64_t mlir::anec::getFamilyString@<X0>(uint64_t result@<X0>, char *a2@<X8>)
{
  switch((int)result)
  {
    case 1:
      a2[23] = 3;
      *(_WORD *)a2 = 12609;
      char v2 = 51;
      goto LABEL_8;
    case 2:
      a2[23] = 3;
      *(_WORD *)a2 = 12609;
      char v2 = 52;
      goto LABEL_8;
    case 3:
      a2[23] = 3;
      *(_WORD *)a2 = 12609;
      char v2 = 53;
      goto LABEL_8;
    case 4:
      a2[23] = 3;
      *(_WORD *)a2 = 12609;
      char v2 = 54;
      goto LABEL_8;
    case 5:
      a2[23] = 3;
      *(_WORD *)a2 = 12609;
      char v2 = 55;
      goto LABEL_8;
    case 6:
      a2[23] = 9;
      strcpy(a2, "A11Legacy");
      return result;
    default:
      a2[23] = 3;
      *(_WORD *)a2 = 12609;
      char v2 = 50;
LABEL_8:
      a2[2] = v2;
      a2[3] = 0;
      return result;
  }
}

uint64_t mlir::Dialect::addOperations<mlir::anec::A11Legacy,mlir::anec::A12,mlir::anec::A13,mlir::anec::A14,mlir::anec::A15,mlir::anec::A16,mlir::anec::A17,mlir::anec::ArgMinMax,mlir::anec::AveragePool,mlir::anec::BatchToSpace,mlir::anec::Broadcast,mlir::anec::Cast,mlir::anec::Ceil,mlir::anec::ChannelToSpace,mlir::anec::ClampedRelu,mlir::anec::Concat,mlir::anec::Convolution,mlir::anec::Cos,mlir::anec::CropResize,mlir::anec::DeQuant,mlir::anec::Deconvolution,mlir::anec::Degamma,mlir::anec::Dirac,mlir::anec::ElementwiseAbs,mlir::anec::ElementwiseAdd,mlir::anec::ElementwiseDiv,mlir::anec::ElementwiseEqual,mlir::anec::ElementwiseEqualZero,mlir::anec::ElementwiseGreaterThan,mlir::anec::ElementwiseGreaterThanEqual,mlir::anec::ElementwiseGreaterThanEqualZero,mlir::anec::ElementwiseGreaterThanZero,mlir::anec::ElementwiseLessThan,mlir::anec::ElementwiseLessThanEqual,mlir::anec::ElementwiseLessThanEqualZero,mlir::anec::ElementwiseLessThanZero,mlir::anec::ElementwiseMax,mlir::anec::ElementwiseMin,mlir::anec::ElementwiseMult,mlir::anec::ElementwiseNotEqual,mlir::anec::ElementwiseNotEqualZero,mlir::anec::ElementwisePower,mlir::anec::ElementwiseSquare,mlir::anec::ElementwiseSub,mlir::anec::Elu,mlir::anec::Erf,mlir::anec::Exp2,mlir::anec::Flatten,mlir::anec::Floor,mlir::anec::GOC,mlir::anec::GatherND,mlir::anec::Gelu,mlir::anec::GlobalArgMinMax,mlir::anec::HighPrecisionSigmoid,mlir::anec::InputView,mlir::anec::InstanceNorm,mlir::anec::Invert,mlir::anec::L2NormPool,mlir::anec::LeakyRelu,mlir::anec::Linear,mlir::anec::Log2,mlir::anec::MatMul,mlir::anec::MaxPool,mlir::anec::NRelu,mlir::anec::Padding,mlir::anec::PixelShuffle,mlir::anec::PixelUnshuffle,mlir::anec::Quant,mlir::anec::ReduceAvg,mlir::anec::ReduceMax,mlir::anec::ReduceMin,mlir::anec::ReduceSum,mlir::anec::RegionReturn,mlir::anec::Relu,mlir::anec::Reshape,mlir::anec::Resize,mlir::anec::RoundNearest,mlir::anec::Rsqrt,mlir::anec::Sigmoid,mlir::anec::Sign,mlir::anec::Sin,mlir::anec::Softmax,mlir::anec::SpaceToBatch,mlir::anec::SpaceToChannel,mlir::anec::Sqr,mlir::anec::Sqrt,mlir::anec::Swish,mlir::anec::T0,mlir::anec::Tanh,mlir::anec::Tile,mlir::anec::Transpose,mlir::anec::Trunc,mlir::anec::Unflatten,mlir::anec::UnrealizedConversionCast>(uint64_t a1)
{
  mlir::RegisteredOperationName::insert<mlir::anec::A11Legacy>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::A12>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::A13>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::A14>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::A15>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::A16>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::A17>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ArgMinMax>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::AveragePool>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::BatchToSpace>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Broadcast>(a1);
  char v2 = operator new(0x70uLL);
  uint64_t v8 = mlir::RegisteredOperationName::Model<mlir::anec::Cast>::Model(v2, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  uint64_t v3 = (uint64_t)v8;
  uint64_t v8 = 0;
  if (v3) {
    (*(void (**)(uint64_t))(*(void *)v3 + 8))(v3);
  }
  mlir::RegisteredOperationName::insert<mlir::anec::Ceil>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ChannelToSpace>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ClampedRelu>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Concat>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Convolution>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Cos>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::CropResize>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::DeQuant>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Deconvolution>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Degamma>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Dirac>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseAbs>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseAdd>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseDiv>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseEqual>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseEqualZero>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseGreaterThan>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseGreaterThanEqual>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseGreaterThanEqualZero>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseGreaterThanZero>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseLessThan>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseLessThanEqual>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseLessThanEqualZero>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseLessThanZero>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseMax>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseMin>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseMult>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseNotEqual>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseNotEqualZero>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwisePower>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseSquare>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ElementwiseSub>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Elu>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Erf>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Exp2>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Flatten>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Floor>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::GOC>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::GatherND>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Gelu>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::GlobalArgMinMax>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::HighPrecisionSigmoid>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::InputView>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::InstanceNorm>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Invert>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::L2NormPool>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::LeakyRelu>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Linear>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Log2>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::MatMul>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::MaxPool>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::NRelu>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Padding>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::PixelShuffle>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::PixelUnshuffle>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Quant>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ReduceAvg>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ReduceMax>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ReduceMin>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::ReduceSum>(a1);
  uint64_t v4 = operator new(0x70uLL);
  uint64_t v8 = mlir::RegisteredOperationName::Model<mlir::anec::RegionReturn>::Model(v4, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  uint64_t v5 = (uint64_t)v8;
  uint64_t v8 = 0;
  if (v5) {
    (*(void (**)(uint64_t))(*(void *)v5 + 8))(v5);
  }
  mlir::RegisteredOperationName::insert<mlir::anec::Relu>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Reshape>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Resize>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::RoundNearest>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Rsqrt>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Sigmoid>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Sign>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Sin>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Softmax>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::SpaceToBatch>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::SpaceToChannel>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Sqr>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Sqrt>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Swish>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::T0>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Tanh>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Tile>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Transpose>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Trunc>(a1);
  mlir::RegisteredOperationName::insert<mlir::anec::Unflatten>(a1);
  uint64_t v6 = operator new(0x70uLL);
  uint64_t v8 = mlir::RegisteredOperationName::Model<mlir::anec::UnrealizedConversionCast>::Model(v6, a1);
  mlir::RegisteredOperationName::insert((uint64_t *)&v8, 0, 0);
  uint64_t result = (uint64_t)v8;
  uint64_t v8 = 0;
  if (result) {
    return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
  }
  return result;
}

uint64_t *mlir::anec::ANECDialect::materializeConstant(uint64_t a1, mlir::OpBuilder *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10 = a4;
  uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible(a3);
  v9[0] = result;
  v9[1] = v8;
  if (result) {
    return (uint64_t *)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(a2, a5, &v10, v9);
  }
  return result;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, void **a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"mps.constant";
    v17[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::mps::ConstantOp::build((uint64_t)a1, (uint64_t)v19, *a3, *a4);
  uint64_t v11 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

void mlir::anec::getANECInputName(uint64_t a1@<X0>, std::string *a2@<X8>)
{
  uint64_t v4 = *(unsigned int *)(a1 + 24);
  v2[0] = "__arg";
  v2[2] = &v4;
  __int16 v3 = 3331;
  llvm::Twine::str((llvm::Twine *)v2, a2);
}

void mlir::anec::getANECInputName(mlir::anec *this@<X0>, std::string *a2@<X8>)
{
  uint64_t v4 = this;
  v2[0] = "__arg";
  v2[2] = &v4;
  __int16 v3 = 3331;
  llvm::Twine::str((llvm::Twine *)v2, a2);
}

uint64_t *llvm::operator+@<X0>(uint64_t *result@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  int v3 = *((unsigned __int8 *)result + 32);
  if (*((unsigned char *)result + 32) && (int v4 = *((unsigned __int8 *)a2 + 32), *((unsigned char *)a2 + 32)))
  {
    if (v3 == 1)
    {
      long long v5 = *((_OWORD *)a2 + 1);
      *(_OWORD *)a3 = *(_OWORD *)a2;
      *(_OWORD *)(a3 + 16) = v5;
      *(void *)(a3 + 32) = a2[4];
    }
    else if (v4 == 1)
    {
      long long v6 = *((_OWORD *)result + 1);
      *(_OWORD *)a3 = *(_OWORD *)result;
      *(_OWORD *)(a3 + 16) = v6;
      *(void *)(a3 + 32) = result[4];
    }
    else
    {
      uint64_t v7 = (uint64_t *)*result;
      uint64_t v8 = result[1];
      if (*((unsigned char *)result + 33) != 1)
      {
        LOBYTE(v3) = 2;
        uint64_t v7 = result;
      }
      uint64_t v9 = a2[1];
      if (*((unsigned char *)a2 + 33) == 1)
      {
        char v10 = (uint64_t *)*a2;
      }
      else
      {
        LOBYTE(v4) = 2;
        char v10 = a2;
      }
      *(void *)a3 = v7;
      *(void *)(a3 + 8) = v8;
      *(void *)(a3 + 16) = v10;
      *(void *)(a3 + 24) = v9;
      *(unsigned char *)(a3 + 32) = v3;
      *(unsigned char *)(a3 + 33) = v4;
    }
  }
  else
  {
    *(_WORD *)(a3 + 32) = 256;
  }
  return result;
}

void mlir::anec::getANECOutputName(mlir::anec *this@<X0>, std::string *a2@<X8>)
{
  int v4 = this;
  v2[0] = "__out:";
  v2[2] = &v4;
  __int16 v3 = 3331;
  llvm::Twine::str((llvm::Twine *)v2, a2);
}

uint64_t mlir::anec::getOpMinimumFamilyImpl<(mlir::anec::Family)0>(uint64_t a1)
{
  v7[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v2)) {
    return 0x100000000;
  }
  __int16 v5 = 259;
  mlir::Operation::emitOpError((uint64_t *)a1, &v4, (uint64_t)&v6);
  mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v6);
  if (v6) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v6);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v7);
  return 0;
}

void mlir::InFlightDiagnostic::~InFlightDiagnostic(mlir::InFlightDiagnostic *this)
{
  if (*(void *)this) {
    mlir::InFlightDiagnostic::report(this);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)this + 8);
}

uint64_t mlir::anec::getOpMinimumFamilyImpl<(mlir::anec::Family)6>(uint64_t a1)
{
  uint64_t v2 = 0x100000004;
  uint64_t v3 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)6>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)6>::Impl>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v3)) {
    return 0x100000006;
  }
  uint64_t v4 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v4)) {
    return 0x100000005;
  }
  uint64_t v5 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(a1 + 48) + 32))(*(void *)(a1 + 48), v5)) {
    return v2;
  }

  return mlir::anec::getOpMinimumFamilyImpl<(mlir::anec::Family)3>(a1);
}

BOOL mlir::anec::isCompatibleWithFamily(uint64_t a1, int a2)
{
  uint64_t v3 = mlir::anec::getOpMinimumFamilyImpl<(mlir::anec::Family)6>(a1);
  return (v3 & 0xFF00000000) == 0 || (int)v3 <= a2;
}

void mlir::anec::anonymous namespace'::getZinIrEWUnitInfo(mlir::anec::_anonymous_namespace_ *this@<X0>, void *a2@<X8>)
{
  uint64_t v5 = (char *)operator new(0x58uLL);
  *((void *)v5 + 2) = 0;
  *((void *)v5 + 3) = 0;
  *((_DWORD *)v5 + 8) = 0;
  *(_OWORD *)(v5 + 40) = 0u;
  *(_OWORD *)(v5 + 56) = 0u;
  *((void *)v5 + 9) = -1;
  *(void *)uint64_t v5 = &unk_1EC995660;
  *((void *)v5 + 1) = 0;
  *((_DWORD *)v5 + 20) = 0;
  uint64_t v6 = *(void **)(*((void *)this + 6) + 16);
  if (this && v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAbs,void>::id)
  {
    int v7 = 9;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqualZero,void>::id)
  {
    int v7 = 10;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqualZero,void>::id)
  {
    int v7 = 14;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanZero,void>::id)
  {
    int v7 = 15;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqualZero,void>::id)
  {
    int v7 = 13;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanZero,void>::id)
  {
    int v7 = 12;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqualZero,void>::id)
  {
    int v7 = 11;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSquare,void>::id)
  {
    int v7 = 3;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
  {
    int v7 = 1;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
  {
    int v7 = 2;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMin,void>::id)
  {
    int v7 = 8;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMax,void>::id)
  {
    int v7 = 7;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSub,void>::id)
  {
    int v7 = 4;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseDiv,void>::id)
  {
    int v7 = 6;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwisePower,void>::id)
  {
    int v7 = 5;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseEqual,void>::id)
  {
    int v7 = 16;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseNotEqual,void>::id)
  {
    int v7 = 17;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThan,void>::id)
  {
    int v7 = 18;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseLessThanEqual,void>::id)
  {
    int v7 = 19;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThanEqual,void>::id)
  {
    int v7 = 20;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseGreaterThan,void>::id)
  {
    int v7 = 21;
  }
  else
  {
    int v7 = 0;
  }
  *((_DWORD *)v5 + 20) = v7;
  *a2 = v5;
}

uint64_t mlir::anec::Broadcast::getResult(mlir::anec::Broadcast *this)
{
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v1 = *(void *)this - 16;
  }
  else {
    uint64_t v1 = 0;
  }
  return mlir::detail::OpResultImpl::getNextResultAtOffset(v1, 0);
}

uint64_t mlir::anec::verifyANECBroadcastOp(mlir::anec *this, mlir::Operation *a2)
{
  v45[23] = *MEMORY[0x1E4F143B8];
    return 0;
  uint64_t v3 = (uint64_t *)(*(void *)(*(void *)(*((void *)this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_11;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_11;
  }
  int v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    char v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      int v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_11:
  }
    uint64_t v13 = 0;
  v43[0] = v3;
  v43[1] = v13;
  uint64_t v14 = (uint64_t *)(*((void *)this - 1) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_21;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_21;
  }
  __int16 v18 = *(void **)(v15 + 8);
  uint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    int v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      __int16 v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_21:
  }
    uint64_t v24 = 0;
  v42[0] = v14;
  v42[1] = v24;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
  if (!v26) {
    return 1;
  }
  uint64_t v27 = ArgAttrsAttr;
  unsigned int v28 = 0;
  uint64_t v29 = 8 * v26;
  while (1)
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
    uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v28, v30);
    if ((DimFromIndex & 0xFF00000000) == 0) {
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    int v32 = DimFromIndex;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43);
    unsigned int IndexFromDim = mlir::anec::getIndexFromDim(v32, v33);
    if (v35)
    {
      unsigned int v36 = IndexFromDim;
      uint64_t v37 = *(void *)(v27 + 8 * (void)v28);
      if (v37 != *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43)
                            + 8 * IndexFromDim)
        && *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43) + 8 * v36) != 1)
      {
        break;
      }
    }
    unsigned int v28 = (mlir::anec *)((char *)v28 + 1);
    v29 -= 8;
    if (!v29) {
      return 1;
    }
  }
  uint64_t v40 = (const void **)"failed: input cannot be broadcasted to the target shape";
  __int16 v41 = 259;
  mlir::Operation::emitOpError((uint64_t *)this, &v40, (uint64_t)&v44);
  uint64_t v38 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v45);
  return v38;
}

uint64_t mlir::anec::anonymous namespace'::defaultVerifyANECOp(mlir::anec::_anonymous_namespace_ *this, mlir::Operation *a2)
{
  v57[23] = *MEMORY[0x1E4F143B8];
  if ((*((unsigned char *)this + 46) & 0x80) != 0)
  {
    uint64_t v3 = *((unsigned int *)this + 17);
    if (v3)
    {
      uint64_t v4 = *((void *)this + 9) + 24;
      while (1)
      {
        uint64_t v52 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(*(void *)v4 + 8) & 0xFFFFFFFFFFFFFFF8));
        uint64_t v53 = v5;
        if (!v52) {
          break;
        }
        v50[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v52);
        if (!mlir::Type::isF16((mlir::Type *)v50)
          && !mlir::Type::isF32((mlir::Type *)v50)
          && !mlir::Type::isInteger((mlir::Type *)v50, 8))
        {
          goto LABEL_65;
        }
        v4 += 32;
        if (!--v3) {
          goto LABEL_10;
        }
      }
      v50[0] = (const void **)"Expecting input tensor to be ShapedType";
      __int16 v51 = 259;
      __int16 v41 = (const void ***)&v56;
      mlir::Operation::emitOpError((uint64_t *)this, v50, (uint64_t)&v56);
      if (!v56) {
        goto LABEL_64;
      }
      uint64_t v42 = (mlir::InFlightDiagnostic *)&v56;
      goto LABEL_63;
    }
  }
LABEL_10:
  uint64_t v6 = *((unsigned int *)this + 9);
  if (v6) {
    int v7 = (char *)this - 16;
  }
  else {
    int v7 = 0;
  }
  if (!v6)
  {
LABEL_21:
    if ((*((unsigned char *)this + 46) & 0x80) != 0)
    {
      uint64_t v11 = *((unsigned int *)this + 17);
      if (v11)
      {
        uint64_t v12 = 0;
        uint64_t v13 = *((void *)this + 9);
        do
        {
          uint64_t v14 = (uint64_t *)(*(void *)(*(void *)(v13 + 32 * v12 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
          if (!v14) {
            goto LABEL_33;
          }
          uint64_t v15 = *v14;
          unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
          unint64_t v17 = *(unsigned int *)(v15 + 16);
          if (!v17) {
            goto LABEL_33;
          }
          __int16 v18 = *(void **)(v15 + 8);
          uint64_t v19 = &v18[2 * v17];
          do
          {
            unint64_t v20 = v17 >> 1;
            uint64_t v21 = &v18[2 * (v17 >> 1)];
            unint64_t v23 = *v21;
            int v22 = v21 + 2;
            v17 += ~(v17 >> 1);
            if (v23 < v16) {
              __int16 v18 = v22;
            }
            else {
              unint64_t v17 = v20;
            }
          }
          while (v17);
          if (v18 != v19 && *v18 == v16) {
            uint64_t v24 = v18[1];
          }
          else {
LABEL_33:
          }
            uint64_t v24 = 0;
            return 0;
        }
        while (++v12 != v11);
      }
    }
    uint64_t v25 = mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::SupportConstantOperands>(void)::Empty>>();
    if (((*(uint64_t (**)(void, uint64_t))(**((void **)this + 6) + 32))(*((void *)this + 6), v25) & 1) == 0)
    {
      uint64_t v26 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if (((*(uint64_t (**)(void, uint64_t))(**((void **)this + 6) + 32))(*((void *)this + 6), v26) & 1) == 0)
      {
        if ((*((unsigned char *)this + 46) & 0x80) == 0) {
          return 0;
        }
        uint64_t v44 = *((unsigned int *)this + 17);
        if (!v44) {
          return 0;
        }
        for (uint64_t i = (uint64_t *)(*((void *)this + 9) + 24); ; i += 4)
        {
          uint64_t v56 = *i;
          uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v56);
          if (!DefiningOp) {
            break;
          }
          uint64_t v47 = DefiningOp;
          uint64_t v48 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
          if (((*(uint64_t (**)(void, uint64_t))(**(void **)(v47 + 48) + 32))(*(void *)(v47 + 48), v48) & 1) == 0)break; {
          uint64_t v43 = 0;
          }
          if (!--v44) {
            return v43;
          }
        }
      }
    }
    uint64_t v27 = *((unsigned int *)this + 9);
    if (v27) {
      unsigned int v28 = (char *)this - 16;
    }
    else {
      unsigned int v28 = 0;
    }
    if (!v27) {
      return 1;
    }
    uint64_t v29 = 0;
    while (1)
    {
      unint64_t v30 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v28, v29) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v30) {
        goto LABEL_54;
      }
      uint64_t v31 = *v30;
      unint64_t v32 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v33 = *(unsigned int *)(v31 + 16);
      if (!v33) {
        goto LABEL_54;
      }
      uint64_t v34 = *(void **)(v31 + 8);
      char v35 = &v34[2 * v33];
      do
      {
        unint64_t v36 = v33 >> 1;
        uint64_t v37 = &v34[2 * (v33 >> 1)];
        unint64_t v39 = *v37;
        uint64_t v38 = v37 + 2;
        v33 += ~(v33 >> 1);
        if (v39 < v32) {
          uint64_t v34 = v38;
        }
        else {
          unint64_t v33 = v36;
        }
      }
      while (v33);
      if (v34 != v35 && *v34 == v32) {
        uint64_t v40 = v34[1];
      }
      else {
LABEL_54:
      }
        uint64_t v40 = 0;
        return 0;
      if (++v29 == v27) {
        return 1;
      }
    }
  }
  uint64_t v8 = 0;
  while (1)
  {
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset((uint64_t)v7, v8);
    uint64_t v52 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v53 = v10;
    if (!v52) {
      break;
    }
    v50[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v52);
    if (!mlir::Type::isF16((mlir::Type *)v50)
      && !mlir::Type::isF32((mlir::Type *)v50)
      && !mlir::Type::isInteger((mlir::Type *)v50, 8))
    {
      goto LABEL_65;
    }
    if (v6 == ++v8) {
      goto LABEL_21;
    }
  }
  v50[0] = (const void **)"Expecting output tensor to be ShapedType";
  __int16 v51 = 259;
  __int16 v41 = v54;
  mlir::Operation::emitOpError((uint64_t *)this, v50, (uint64_t)v54);
  if (v54[0])
  {
    uint64_t v42 = (mlir::InFlightDiagnostic *)v54;
LABEL_63:
    mlir::InFlightDiagnostic::report(v42);
  }
LABEL_64:
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)(v41 + 1));
LABEL_65:
  __int16 v55 = 257;
  mlir::Operation::emitOpError((uint64_t *)this, v54, (uint64_t)&v56);
  if (v56) {
    mlir::Diagnostic::operator<<((uint64_t)v57, "does not have ANE-compatible types");
  }
  uint64_t v43 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v56);
  if (v56) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v56);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v57);
  return v43;
}

uint64_t *mlir::Type::cast<mlir::ShapedType>(uint64_t **a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v2 = *v1;
    unint64_t v3 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v4 = *(unsigned int *)(v2 + 16);
    if (v4)
    {
      uint64_t v5 = *(void **)(v2 + 8);
      do
      {
        unint64_t v6 = v4 >> 1;
        int v7 = &v5[2 * (v4 >> 1)];
        unint64_t v9 = *v7;
        uint64_t v8 = v7 + 2;
        v4 += ~(v4 >> 1);
        if (v9 < v3) {
          uint64_t v5 = v8;
        }
        else {
          unint64_t v4 = v6;
        }
      }
      while (v4);
    }
  }
  return v1;
}

void mlir::anec::Broadcast::getZinIrUnitInfo(mlir::anec::Broadcast *this@<X0>, void *a2@<X8>)
{
  unint64_t v4 = (char *)operator new(0x78uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)unint64_t v4 = &unk_1EC995C50;
  *((void *)v4 + 1) = 0;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_DWORD *)v4 + 28) = 1065353216;
  uint64_t v5 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v52[0] = v5;
  v52[1] = v15;
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v16 = *(void *)this - 16;
  }
  else {
    uint64_t v16 = 0;
  }
  unint64_t v17 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v49 = a2;
  if (!v17) {
    goto LABEL_23;
  }
  uint64_t v18 = *v17;
  unint64_t v19 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v20 = *(unsigned int *)(v18 + 16);
  if (!v20) {
    goto LABEL_23;
  }
  uint64_t v21 = *(void **)(v18 + 8);
  int v22 = &v21[2 * v20];
  do
  {
    unint64_t v23 = v20 >> 1;
    uint64_t v24 = &v21[2 * (v20 >> 1)];
    unint64_t v26 = *v24;
    uint64_t v25 = v24 + 2;
    v20 += ~(v20 >> 1);
    if (v26 < v19) {
      uint64_t v21 = v25;
    }
    else {
      unint64_t v20 = v23;
    }
  }
  while (v20);
  if (v21 != v22 && *v21 == v19) {
    uint64_t v27 = v21[1];
  }
  else {
LABEL_23:
  }
    uint64_t v27 = 0;
  v51[0] = v17;
  v51[1] = v27;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
  if (v29)
  {
    uint64_t v30 = ArgAttrsAttr;
    uint64_t v31 = 0;
    uint64_t v32 = 8 * v29;
    while (1)
    {
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
      uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v31, v37);
      if ((DimFromIndex & 0xFF00000000) == 0) {
        break;
      }
      int v39 = DimFromIndex;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v52);
      unsigned int IndexFromDim = mlir::anec::getIndexFromDim(v39, v40);
      if (!v42
        || (uint64_t v43 = *(void *)(v30 + 8 * (void)v31),
            v43 != *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v52)
                             + 8 * IndexFromDim)))
      {
        uint64_t v33 = *(void *)(v30 + 8 * (void)v31);
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v51);
        uint64_t v35 = mlir::anec::getDimFromIndex(v31, v34);
        if ((v35 & 0xFF00000000) != 0) {
          int v36 = dword_1810FE490[(int)v35];
        }
        else {
          int v36 = 5;
        }
        int v50 = v36;
        uint64_t v53 = &v50;
        std::__hash_table<std::__hash_value_type<ZinIrDimension,unsigned long>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,unsigned long>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,unsigned long>>>::__emplace_unique_key_args<ZinIrDimension,std::piecewise_construct_t const&,std::tuple<ZinIrDimension&&>,std::tuple<>>((uint64_t)(v4 + 80), &v50, (uint64_t)&std::piecewise_construct, &v53)[3] = v33;
      }
      uint64_t v31 = (mlir::anec *)((char *)v31 + 1);
      v32 -= 8;
      if (!v32) {
        goto LABEL_35;
      }
    }
    uint64_t v44 = std::__throw_bad_optional_access[abi:nn180100]();
  }
  else
  {
LABEL_35:
    void *v49 = v4;
  }
}

void mlir::anec::anonymous namespace'::fillZinIrCommonInfo(uint64_t a1, uint64_t a2, int a3, unint64_t a4, char a5)
{
  mlir::anec::computeOpKeyString((mlir::anec *)a1, &__str);
  std::string::operator=((std::string *)(a2 + 8), &__str);
  int v72 = a3;
  *(_DWORD *)(a2 + 32) = a3;
  uint64_t v10 = (const char *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void *)v10;
  unint64_t v12 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v13 = *(unsigned int *)(v11 + 16);
  if (!v13) {
    goto LABEL_10;
  }
  unint64_t v14 = *(void **)(v11 + 8);
  uint64_t v15 = &v14[2 * v13];
  do
  {
    unint64_t v16 = v13 >> 1;
    unint64_t v17 = &v14[2 * (v13 >> 1)];
    unint64_t v19 = *v17;
    uint64_t v18 = v17 + 2;
    v13 += ~(v13 >> 1);
    if (v19 < v12) {
      unint64_t v14 = v18;
    }
    else {
      unint64_t v13 = v16;
    }
  }
  while (v13);
  if (v14 != v15 && *v14 == v12) {
    uint64_t v20 = v14[1];
  }
  else {
LABEL_10:
  }
    uint64_t v20 = 0;
  int v76 = v10;
  uint64_t v77 = v20;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v76);
  uint64_t v71 = a1;
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0)
  {
    uint64_t v22 = *(unsigned int *)(a1 + 68);
    if (v22)
    {
      unint64_t v23 = 0;
      uint64_t v24 = *(void *)(a1 + 72);
      do
      {
        uint64_t v25 = v24 + 32 * v23;
        uint64_t v26 = *(void *)(v25 + 24);
        if (a5 && v23 >= a4) {
          break;
        }
        uint64_t v75 = *(void *)(v25 + 24);
        if (mlir::Value::getDefiningOp((mlir::Value *)&v75))
        {
          uint64_t DefiningOp = (mlir::anec *)mlir::Value::getDefiningOp((mlir::Value *)&v75);
          mlir::anec::computeOpKeyString(DefiningOp, &__p);
        }
        else
        {
          uint64_t v28 = v75;
          if ((~*(_DWORD *)(v75 + 8) & 7) != 0) {
            uint64_t v28 = 0;
          }
          uint64_t v80 = *(unsigned int *)(v28 + 24);
          int v76 = "__arg";
          uint64_t v78 = &v80;
          __int16 v79 = 3331;
          llvm::Twine::str((llvm::Twine *)&v76, &__p);
        }
        uint64_t v29 = (const char *)(*(void *)(v26 + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v29) {
          goto LABEL_31;
        }
        uint64_t v30 = *(void *)v29;
        unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v32 = *(unsigned int *)(v30 + 16);
        if (!v32) {
          goto LABEL_31;
        }
        uint64_t v33 = *(void **)(v30 + 8);
        unint64_t v34 = &v33[2 * v32];
        do
        {
          unint64_t v35 = v32 >> 1;
          int v36 = &v33[2 * (v32 >> 1)];
          unint64_t v38 = *v36;
          unint64_t v37 = v36 + 2;
          v32 += ~(v32 >> 1);
          if (v38 < v31) {
            uint64_t v33 = v37;
          }
          else {
            unint64_t v32 = v35;
          }
        }
        while (v32);
        if (v33 != v34 && *v33 == v31) {
          uint64_t v39 = v33[1];
        }
        else {
LABEL_31:
        }
          uint64_t v39 = 0;
        int v76 = v29;
        uint64_t v77 = v39;
        if (OperandRange != mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v76)) {
          uint64_t OperandRange = 0;
        }
        unint64_t v40 = *(void *)(a2 + 48);
        if (v40 >= *(void *)(a2 + 56))
        {
          char v42 = std::vector<std::string>::__push_back_slow_path<std::string const&>(a2 + 40, (uint64_t)&__p);
        }
        else
        {
          if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          {
            std::string::__init_copy_ctor_external(*(std::string **)(a2 + 48), __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
          }
          else
          {
            long long v41 = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
            *(void *)(v40 + 16) = *((void *)&__p.__r_.__value_.__l + 2);
            *(_OWORD *)unint64_t v40 = v41;
          }
          char v42 = (std::string *)(v40 + 24);
        }
        *(void *)(a2 + 48) = v42;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
          operator delete(__p.__r_.__value_.__l.__data_);
        }
        ++v23;
      }
      while (v23 != v22);
    }
  }
  if (OperandRange)
  {
    uint64_t v43 = *(void **)(*(void *)OperandRange + 136);
    uint64_t v44 = v71;
    if (v43 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      int v76 = (const char *)OperandRange;
      int Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&v76);
      if (Width == 16)
      {
        if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v76) == 2) {
          int v46 = 10;
        }
        else {
          int v46 = 9;
        }
      }
      else if (Width == 8)
      {
        if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v76) == 2) {
          int v46 = 2;
        }
        else {
          int v46 = 1;
        }
      }
      else
      {
        int v46 = 0;
      }
    }
    else
    {
      if (v43 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id) {
        int v45 = 11;
      }
      else {
        int v45 = 0;
      }
      if (v43 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id) {
        int v46 = 3;
      }
      else {
        int v46 = v45;
      }
    }
  }
  else
  {
    int v46 = 0;
    uint64_t v44 = v71;
  }
  *(_DWORD *)(a2 + 64) = v46;
  unint64_t v47 = (const char *)(*(void *)(v44 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v47) {
    goto LABEL_61;
  }
  uint64_t v48 = *(void *)v47;
  unint64_t v49 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v50 = *(unsigned int *)(v48 + 16);
  if (!v50) {
    goto LABEL_61;
  }
  __int16 v51 = *(void **)(v48 + 8);
  uint64_t v52 = &v51[2 * v50];
  do
  {
    unint64_t v53 = v50 >> 1;
    uint64_t v54 = &v51[2 * (v50 >> 1)];
    unint64_t v56 = *v54;
    __int16 v55 = v54 + 2;
    v50 += ~(v50 >> 1);
    if (v56 < v49) {
      __int16 v51 = v55;
    }
    else {
      unint64_t v50 = v53;
    }
  }
  while (v50);
  if (v51 != v52 && *v51 == v49) {
    uint64_t v57 = v51[1];
  }
  else {
LABEL_61:
  }
    uint64_t v57 = 0;
  int v76 = v47;
  uint64_t v77 = v57;
  uint64_t v58 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v76);
  int v59 = *(void **)(*(void *)v58 + 136);
  if (v59 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    if (v59 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id)
    {
      int v60 = 3;
    }
    else if (v59 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id)
    {
      int v60 = 11;
    }
    else
    {
      int v60 = 0;
    }
LABEL_81:
    int v62 = v72;
    goto LABEL_82;
  }
  __p.__r_.__value_.__r.__words[0] = v58;
  int v61 = mlir::IntegerType::getWidth((mlir::IntegerType *)&__p);
  if (v61 == 16)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&__p) == 2) {
      int v60 = 10;
    }
    else {
      int v60 = 9;
    }
    goto LABEL_81;
  }
  int v62 = v72;
  if (v61 == 8)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&__p) == 2) {
      int v60 = 2;
    }
    else {
      int v60 = 1;
    }
  }
  else
  {
    int v60 = 0;
  }
LABEL_82:
  *(_DWORD *)(a2 + 68) = v60;
  if ((v62 - 23) > 0xFFFFFFFD)
  {
    uint64_t v67 = 0;
  }
  else
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v76);
    unsigned int IndexFromDim = mlir::anec::getIndexFromDim(1, v64);
    if (!v66)
    {
      int v68 = (mlir::anec::Broadcast *)std::__throw_bad_optional_access[abi:nn180100]();
      mlir::anec::Broadcast::addOpToNetwork(v68, v69, v70);
      return;
    }
    uint64_t v67 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v76) + 8 * IndexFromDim);
  }
  *(void *)(a2 + 72) = v67;
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__str.__r_.__value_.__l.__data_);
  }
}

uint64_t mlir::anec::Broadcast::addOpToNetwork(mlir::anec::Broadcast *a1, uint64_t a2)
{
  mlir::anec::Broadcast::getZinIrUnitInfo(a1, &v11);
  unint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  unint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    unint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    unint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *unint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::Convolution::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v128[22] = *MEMORY[0x1E4F143B8];
  uint64_t v119 = a6;
  LOBYTE(v120) = 0;
  char v121 = 0;
  uint64_t v122 = a7;
  uint64_t v123 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v119);
    if (v121) {
      char v121 = 0;
    }
    mlir::OperationName::OperationName(&v120, "anec.convolution", 16, Context);
    char v121 = 1;
  }
  uint64_t v124 = a4;
  uint64_t v125 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::ConvolutionAdaptor::verify(&v119, v18)) {
    return 0;
  }
  unint64_t v19 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v20 = v19;
  if (!v19)
  {
    long long v102 = 0;
    uint64_t v103 = 0;
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v126);
      if (v126)
      {
        unint64_t v32 = "input must be a ShapedType";
        goto LABEL_26;
      }
LABEL_27:
      uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v126);
      if (v126) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v126);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v127);
      return v33;
    }
    return 0;
  }
  uint64_t v21 = *v19;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_18;
  }
  uint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      uint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_18:
  }
    uint64_t v30 = 0;
  long long v102 = v20;
  uint64_t v103 = v30;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
  if (v31 >= 6)
  {
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v126);
      if (v126)
      {
        unint64_t v32 = "input must be a tensor of rank 4 or 5";
LABEL_26:
        mlir::Diagnostic::operator<<((uint64_t)&v127, v32);
        goto LABEL_27;
      }
      goto LABEL_27;
    }
    return 0;
  }
  uint64_t ArgAttrsAttr = (const char **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
  v117[0] = v118;
  v117[1] = (void *)0x300000000;
  int v36 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v119) + 32);
  unint64_t v37 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v119);
  unint64_t v38 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v36, v37, *(void *)(*(void *)(v120 + 96) + 56));
  if (v39) {
    uint64_t v40 = *((void *)v38 + 1);
  }
  else {
    uint64_t v40 = 0;
  }
  mlir::getValues<unsigned long long>(v40, (uint64_t)v117);
  v115[0] = v116;
  v115[1] = (void *)0x300000000;
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v119);
  uint64_t v42 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v119);
  uint64_t v43 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v42 - 32), *(void *)(*(void *)(v120 + 96) + 8));
  if (v44) {
    uint64_t v45 = *((void *)v43 + 1);
  }
  else {
    uint64_t v45 = 0;
  }
  mlir::getValues<unsigned long long>(v45, (uint64_t)v115);
  v113[0] = v114;
  v113[1] = (void *)0x600000000;
  int v46 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v119) + 16);
  uint64_t v47 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v119);
  uint64_t v48 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v46, (mlir::CallGraphNode *)(v47 - 16), *(void *)(*(void *)(v120 + 96) + 40));
  if (v49) {
    uint64_t v50 = *((void *)v48 + 1);
  }
  else {
    uint64_t v50 = 0;
  }
  mlir::getValues<unsigned long long>(v50, (uint64_t)v113);
  __int16 v51 = (void *)mlir::TypeRange::dereference_iterator(a9, 1);
  uint64_t v52 = v51;
  if (!v51) {
    goto LABEL_50;
  }
  uint64_t v53 = *v51;
  unint64_t v54 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_50;
  }
  unint64_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    int v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    int v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      unint64_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_50:
  }
    uint64_t v62 = 0;
  v101[0] = v52;
  v101[1] = v62;
  uint64_t v63 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v101);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v101);
  if (v64 >= 6)
  {
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v126);
      if (v126) {
        mlir::Diagnostic::operator<<((uint64_t)&v127, "filter must be a tensor of rank 4 or 5");
      }
LABEL_63:
      uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v126);
      if (v126) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v126);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v127);
      goto LABEL_90;
    }
LABEL_66:
    uint64_t v33 = 0;
LABEL_90:
    if (v113[0] != v114) {
      free(v113[0]);
    }
    if (v115[0] != v116) {
      free(v115[0]);
    }
    if (v117[0] != v118) {
      free(v117[0]);
    }
    return v33;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v101);
  if (v65 == 4) {
    uint64_t v66 = -1;
  }
  else {
    uint64_t v66 = 4;
  }
  uint64_t Groups = (uint64_t)mlir::anec::detail::ConvolutionGenericAdaptorBase::getGroups((mlir::anec::detail::ConvolutionGenericAdaptorBase *)&v119);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v67);
  if (v69)
  {
    uint64_t v99 = 0;
    uint64_t v99 = (uint64_t)ArgAttrsAttr[IndexFromDim];
    if (v99 % Groups)
    {
      long long v106 = "input channels {0} should be divisible by groups {1}";
      uint64_t v107 = 52;
      long long v108 = v112;
      uint64_t v109 = 2;
      v110[0] = &unk_1EC9A4648;
      v110[1] = &v99;
      v111[0] = &unk_1EC9A4648;
      v111[1] = &Groups;
      v112[0] = v110;
      v112[1] = v111;
      if (a3)
      {
        mlir::emitError((uint64_t)a2, (uint64_t)&v126);
        if (v126)
        {
          __int16 v105 = 263;
          v104[0] = (const void **)&v106;
          mlir::Diagnostic::operator<<((uint64_t)&v127, v104);
        }
        goto LABEL_63;
      }
      goto LABEL_66;
    }
    unint64_t v70 = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v119);
    uint64_t v71 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v119);
    int v72 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v70, (mlir::CallGraphNode *)(v71 - 48), **(void **)(v120 + 96));
    if ((v73 & 1) != 0
      && (uint64_t v74 = *((void *)v72 + 1)) != 0
      && *(_UNKNOWN **)(*(void *)v74 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      uint64_t v75 = *(void *)(v63 + 8) * *(void *)v63;
    }
    else
    {
      uint64_t v75 = *(void *)v63;
    }
    uint64_t v98 = v75;
    if (v75 % Groups)
    {
      llvm::formatv<long long &,long long &>("output channels {0} should be divisible by groups {1}", (const char *)&v98, (const char *)&Groups, (const char **)&v126);
      uint64_t v33 = mlir::emitOptionalError<llvm::formatv_object<std::tuple<llvm::detail::provider_format_adapter<long long &>,llvm::detail::provider_format_adapter<long long &>>>>((uint64_t)a2, a3, (const void **)&v126);
      goto LABEL_90;
    }
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
    mlir::anec::getIndexFromDim(1, v76);
    if (v77)
    {
      if (*(void *)(v63 + 8) * Groups == v99)
      {
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
        unint64_t v79 = mlir::anec::getIndexFromDim(3, v78);
        if (v80)
        {
          unint64_t v81 = v79;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
          unint64_t v83 = mlir::anec::getIndexFromDim(4, v82);
          if (v84)
          {
            unint64_t v85 = (unint64_t)&ArgAttrsAttr[v81][*((void *)v113[0] + 2)
                                                     + *((void *)v113[0] + 3)
                                                     - *(void *)(v63 + 16)
                                                     + *((void *)v115[0] + 1)
                                                     - 1
                                                     - (*((void *)v115[0] + 1) - 1) * *(void *)(v63 + 16)]
                / *((void *)v117[0] + 1)
                + 1;
            unint64_t v86 = (unint64_t)&ArgAttrsAttr[v83][*((void *)v113[0] + 4)
                                                     + *((void *)v113[0] + 5)
                                                     - *(void *)(v63 + 24)
                                                     + *((void *)v115[0] + 2)
                                                     - 1
                                                     - (*((void *)v115[0] + 2) - 1) * *(void *)(v63 + 24)]
                / *((void *)v117[0] + 2)
                + 1;
            unint64_t v87 = *ArgAttrsAttr;
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v102);
            unint64_t v89 = mlir::anec::getIndexFromDim(2, v88);
            if (v90) {
              uint64_t v91 = (const char *)((unint64_t)&ArgAttrsAttr[v89][*(void *)v113[0]
            }
                                                                      + *((void *)v113[0] + 1)
                                                                      - *(void *)(v63 + 8 * v66)
                                                                      + *(void *)v115[0]
                                                                      - 1
                                                                      - (*(void *)v115[0] - 1)
                                                                      * *(void *)(v63 + 8 * v66)]
                                 / *(void *)v117[0]
                                 + 1);
            else {
              uint64_t v91 = 0;
            }
            long long v106 = v87;
            uint64_t v107 = v75;
            long long v108 = (void *)v85;
            uint64_t v109 = v86;
            llvm::SmallVector<long long,6u>::SmallVector(&v126, &v106, 4);
            if (v91)
            {
              long long v106 = v91;
              llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v126, (uint64_t)v126 + 8, (uint64_t *)&v106);
            }
            uint64_t v92 = v126;
            uint64_t v93 = (mlir::AffineMap *)v127;
            uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v102);
            uint64_t v95 = mlir::MemRefType::get(v92, v93, OperandRange, 0, 0, 0);
            llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(a11, v95);
            if (v126 != v128) {
              free(v126);
            }
            uint64_t v33 = 1;
            goto LABEL_90;
          }
        }
      }
      else if (a3)
      {
        llvm::formatv<long long const&,long long &,long long &>("Filter shape Cin {0} * groups {1} must match input Cin {2}", (const char *)(v63 + 8), (const char *)&Groups, (const char *)&v99, &v106);
        __int16 v105 = 263;
        v104[0] = (const void **)&v106;
        mlir::emitError((uint64_t)a2, (uint64_t)v104, (uint64_t)&v126);
        uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v126);
        mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v126);
        goto LABEL_90;
      }
    }
  }
  uint64_t v96 = (uint64_t *)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::anec::ConvolutionAdaptor::verify(v96, v97);
}

uint64_t mlir::anec::ConvolutionAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v89[23] = *MEMORY[0x1E4F143B8];
  uint64_t v83 = *a1;
  uint64_t Value = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v83);
  unint64_t v82 = 0;
  if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83))
  {
LABEL_7:
    long long v6 = "'anec.convolution' op requires attribute 'dilation'";
LABEL_70:
    unint64_t v79 = (uint64_t *)v6;
    __int16 v81 = 259;
    mlir::emitError(a2, (uint64_t)&v79, (uint64_t)&v88);
    uint64_t v48 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v88);
    if (v88) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v88);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v89);
    return v48;
  }
  uint64_t v5 = 0;
  while (*(void *)(*(void *)(a1[1] + 96) + 8) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      uint64_t v5 = Value[1];
    }
    Value += 2;
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83)) {
      goto LABEL_7;
    }
  }
  unint64_t v82 = (uint64_t *)Value[1];
  char v77 = 0;
  unint64_t v78 = 0;
  unint64_t v76 = 0;
  if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83))
  {
LABEL_18:
    long long v6 = "'anec.convolution' op requires attribute 'padding'";
    goto LABEL_70;
  }
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  uint64_t v9 = 0;
  while (*(void *)(*(void *)(a1[1] + 96) + 40) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      uint64_t v9 = (uint64_t *)Value[1];
    }
    else if (*(void *)(*(void *)(a1[1] + 96) + 24) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      unint64_t v8 = (uint64_t *)Value[1];
      char v77 = v8;
    }
    else if (*(void *)(*(void *)(a1[1] + 96) + 32) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      unint64_t v7 = (uint64_t *)Value[1];
      unint64_t v76 = v7;
    }
    Value += 2;
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83)) {
      goto LABEL_18;
    }
  }
  unint64_t v78 = (uint64_t *)Value[1];
  if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83))
  {
LABEL_25:
    long long v6 = "'anec.convolution' op requires attribute 'stride'";
    goto LABEL_70;
  }
  uint64_t v10 = 0;
  while (*(void *)(*(void *)(a1[1] + 96) + 56) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (*(void *)(*(void *)(a1[1] + 96) + 48) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      uint64_t v10 = Value[1];
    }
    Value += 2;
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83)) {
      goto LABEL_25;
    }
  }
  uint64_t v11 = (uint64_t *)Value[1];
  if (v11)
  {
    if (!mlir::DenseIntElementsAttr::classof(Value[1])) {
      goto LABEL_68;
    }
    uint64_t v12 = *v11;
    unint64_t v13 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v14 = *(unsigned int *)(v12 + 16);
    if (!v14) {
      goto LABEL_36;
    }
    uint64_t v15 = *(void **)(v12 + 8);
    unint64_t v16 = &v15[2 * v14];
    do
    {
      unint64_t v17 = v14 >> 1;
      uint64_t v18 = &v15[2 * (v14 >> 1)];
      unint64_t v20 = *v18;
      unint64_t v19 = v18 + 2;
      v14 += ~(v14 >> 1);
      if (v20 < v13) {
        uint64_t v15 = v19;
      }
      else {
        unint64_t v14 = v17;
      }
    }
    while (v14);
    if (v15 != v16 && *v15 == v13) {
      uint64_t v21 = v15[1];
    }
    else {
LABEL_36:
    }
      uint64_t v21 = 0;
    unint64_t v79 = v11;
    uint64_t v80 = v21;
    Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
    unint64_t v23 = Type;
    if (!Type) {
      goto LABEL_46;
    }
    uint64_t v24 = *Type;
    unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v26 = *(unsigned int *)(v24 + 16);
    if (!v26) {
      goto LABEL_46;
    }
    uint64_t v27 = *(void **)(v24 + 8);
    uint64_t v28 = &v27[2 * v26];
    do
    {
      unint64_t v29 = v26 >> 1;
      uint64_t v30 = &v27[2 * (v26 >> 1)];
      unint64_t v32 = *v30;
      uint64_t v31 = v30 + 2;
      v26 += ~(v26 >> 1);
      if (v32 < v25) {
        uint64_t v27 = v31;
      }
      else {
        unint64_t v26 = v29;
      }
    }
    while (v26);
    if (v27 != v28 && *v27 == v25) {
      uint64_t v33 = v27[1];
    }
    else {
LABEL_46:
    }
      uint64_t v33 = 0;
    unint64_t v88 = v23;
    v89[0] = v33;
    uint64_t ArgAttrsAttr = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
    uint64_t v86 = 3;
    if (v35 != 1
      || *ArgAttrsAttr != (uint64_t *)v86
      || (uint64_t v67 = (uint64_t)v11,
          uint64_t v74 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v67),
          uint64_t v75 = v36,
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v74),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
LABEL_68:
      long long v6 = "'anec.convolution' op attribute 'stride' failed to satisfy constraint: ui64 elements attribute of shape {3}";
      goto LABEL_70;
    }
  }
  if (v82)
  {
    if (!mlir::DenseIntElementsAttr::classof((uint64_t)v82)) {
      goto LABEL_69;
    }
    unint64_t v79 = mlir::Attribute::cast<mlir::ElementsAttr>(&v82);
    uint64_t v80 = v37;
    uint64_t v86 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
    unint64_t v88 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v86);
    v89[0] = v38;
    char v39 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
    uint64_t OperandRange = 3;
    if (v40 != 1
      || *v39 != OperandRange
      || (char v73 = v82,
          uint64_t v74 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v73),
          uint64_t v75 = v41,
          uint64_t v67 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v74),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&v67, 64)))
    {
LABEL_69:
      long long v6 = "'anec.convolution' op attribute 'dilation' failed to satisfy constraint: ui64 elements attribute of shape {3}";
      goto LABEL_70;
    }
  }
  if (!v78) {
    goto LABEL_61;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v78)) {
    goto LABEL_74;
  }
  unint64_t v79 = mlir::Attribute::cast<mlir::ElementsAttr>(&v78);
  uint64_t v80 = v42;
  uint64_t v86 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
  unint64_t v88 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v86);
  v89[0] = v43;
  char v44 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
  uint64_t OperandRange = 6;
  if (v45 != 1) {
    goto LABEL_74;
  }
  if (*v44 == OperandRange
    && (char v73 = v78,
        uint64_t v74 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v73),
        uint64_t v75 = v46,
        uint64_t v67 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v74),
        mlir::Type::isUnsignedInteger((mlir::Type *)&v67, 64)))
  {
LABEL_61:
    if (v10 && (mlir::anec::PaddingModeAttr::classof(v10) & 1) == 0)
    {
      uint64_t v47 = "'anec.convolution' op attribute 'padding_mode' failed to satisfy constraint: valid PaddingMode";
    }
    else if (!v9 {
           || *(_UNKNOWN **)(*v9 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    }
           && (unint64_t v79 = v9,
               unint64_t v88 = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v79),
               mlir::Type::isUnsignedInteger((mlir::Type *)&v88, 64)))
    {
      if (!v5 || *(_UNKNOWN **)(*(void *)v5 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        if (!v8) {
          goto LABEL_97;
        }
        if (!mlir::DenseFPElementsAttr::classof((uint64_t)v8)) {
          goto LABEL_93;
        }
        unint64_t v79 = mlir::Attribute::cast<mlir::ElementsAttr>(&v77);
        uint64_t v80 = v50;
        char v73 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
        unint64_t v88 = mlir::Type::cast<mlir::ShapedType>(&v73);
        v89[0] = v51;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
        if (v52)
        {
          uint64_t v86 = (uint64_t)mlir::Attribute::cast<mlir::ElementsAttr>(&v77);
          uint64_t v87 = v53;
          int v72 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v86);
          uint64_t v74 = mlir::Type::cast<mlir::ShapedType>(&v72);
          uint64_t v75 = v54;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v74);
          if (v55 != 1) {
            goto LABEL_93;
          }
        }
        unint64_t v70 = v77;
        uint64_t OperandRange = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
        uint64_t v85 = v56;
        uint64_t v71 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange);
        if (mlir::Type::isF16((mlir::Type *)&v71)
          || (uint64_t v66 = v77,
              uint64_t v67 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v66),
              uint64_t v68 = v57,
              uint64_t v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v67),
              mlir::Type::isF32((mlir::Type *)&v69)))
        {
LABEL_97:
          if (!v7) {
            return 1;
          }
          if (mlir::DenseIntElementsAttr::classof((uint64_t)v7))
          {
            unint64_t v79 = mlir::Attribute::cast<mlir::ElementsAttr>(&v76);
            uint64_t v80 = v58;
            char v73 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
            unint64_t v88 = mlir::Type::cast<mlir::ShapedType>(&v73);
            v89[0] = v59;
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
            if (!v60
              || (uint64_t v86 = (uint64_t)mlir::Attribute::cast<mlir::ElementsAttr>(&v76),
                  uint64_t v87 = v61,
                  int v72 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v86),
                  uint64_t v74 = mlir::Type::cast<mlir::ShapedType>(&v72),
                  uint64_t v75 = v62,
                  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v74),
                  v63 == 1))
            {
              unint64_t v70 = v76;
              uint64_t OperandRange = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
              uint64_t v85 = v64;
              uint64_t v71 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange);
              if (mlir::Type::isSignedInteger((mlir::Type *)&v71, 8)) {
                return 1;
              }
              uint64_t v66 = v76;
              uint64_t v67 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v66);
              uint64_t v68 = v65;
              uint64_t v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v67);
              if (mlir::Type::isUnsignedInteger((mlir::Type *)&v69, 8)) {
                return 1;
              }
            }
          }
          uint64_t v47 = "'anec.convolution' op attribute 'kernel_zero_point' failed to satisfy constraint: si8 or ui8 elements at"
                "tribute of rank 0/1";
        }
        else
        {
LABEL_93:
          uint64_t v47 = "'anec.convolution' op attribute 'kernel_scale' failed to satisfy constraint: f16 or f32 elements attribute of rank 0/1";
        }
      }
      else
      {
        uint64_t v47 = "'anec.convolution' op attribute 'channel_wise' failed to satisfy constraint: unit attribute";
      }
    }
    else
    {
      uint64_t v47 = "'anec.convolution' op attribute 'groups' failed to satisfy constraint: 64-bit unsigned integer attribute";
    }
  }
  else
  {
LABEL_74:
    uint64_t v47 = "'anec.convolution' op attribute 'padding' failed to satisfy constraint: ui64 elements attribute of shape {6}";
  }
  unint64_t v79 = (uint64_t *)v47;
  __int16 v81 = 259;
  mlir::emitError(a2, (uint64_t)&v79, (uint64_t)&v88);
  uint64_t v48 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v88);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v88);
  return v48;
}

void mlir::getValues<unsigned long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v15, a1, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v18);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v12, a1, NumElements);
  while (1)
  {
    BOOL v5 = v15 == v12 && v16 == v13;
    if (v5 && v17 == v14) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v15, (llvm::APInt *)&__p);
    unsigned int v6 = v11;
    p_p = (uint64_t *)__p;
    if (v11 < 0x41) {
      p_p = (uint64_t *)&__p;
    }
    uint64_t v8 = *p_p;
    uint64_t v9 = *(unsigned int *)(a2 + 8);
    if (v9 >= *(_DWORD *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v9 + 1, 8);
      *(void *)(*(void *)a2 + 8 * *(unsigned int *)(a2 + 8)) = v8;
      LODWORD(v9) = *(_DWORD *)(a2 + 8);
      unsigned int v6 = v11;
    }
    else
    {
      *(void *)(*(void *)a2 + 8 * v9) = v8;
    }
    *(_DWORD *)(a2 + 8) = v9 + 1;
    if (v6 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v17;
  }
}

void *mlir::anec::detail::ConvolutionGenericAdaptorBase::getGroups(mlir::anec::detail::ConvolutionGenericAdaptorBase *this)
{
  uint64_t v2 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue(this) + 16);
  uint64_t v3 = mlir::DictionaryAttr::end(this);
  uint64_t v4 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v2, (mlir::CallGraphNode *)(v3 - 32), *(void *)(*(void *)(*((void *)this + 1) + 96) + 16));
  if (v5)
  {
    uint64_t v6 = *((void *)v4 + 1);
    if (v6 && *(_UNKNOWN **)(*(void *)v6 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
      uint64_t v6 = 0;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  mlir::IntegerAttr::getValue(&v11, (llvm::APInt *)&__p);
  if (v10 <= 0x40) {
    return __p;
  }
  uint64_t v7 = *(void *)__p;
  operator delete[](__p);
  return (void *)v7;
}

uint64_t mlir::emitOptionalError<llvm::formatv_object<std::tuple<llvm::detail::provider_format_adapter<long long &>,llvm::detail::provider_format_adapter<long long &>>>>(uint64_t a1, char a2, const void **a3)
{
  v9[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 0;
  }
  mlir::emitError(a1, (uint64_t)&v8);
  if (v8)
  {
    __int16 v7 = 263;
    uint64_t v6 = a3;
    mlir::Diagnostic::operator<<((uint64_t)v9, &v6);
  }
  uint64_t v4 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v8);
  if (v8) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v8);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v9);
  return v4;
}

const char *llvm::formatv<long long &,long long &>@<X0>(const char *__s@<X0>, const char *a2@<X1>, const char *a3@<X2>, const char **a4@<X8>)
{
  uint64_t v6 = __s;
  if (__s) {
    __s = (const char *)strlen(__s);
  }
  *a4 = v6;
  a4[1] = __s;
  a4[8] = (const char *)(a4 + 4);
  a4[2] = (const char *)(a4 + 8);
  a4[3] = (const char *)2;
  a4[4] = (const char *)&unk_1EC9A4648;
  a4[5] = a2;
  a4[6] = (const char *)&unk_1EC9A4648;
  a4[7] = a3;
  a4[9] = (const char *)(a4 + 6);
  return __s;
}

const char *llvm::formatv<long long const&,long long &,long long &>@<X0>(const char *__s@<X0>, const char *a2@<X1>, const char *a3@<X2>, const char *a4@<X3>, const char **a5@<X8>)
{
  uint64_t v8 = __s;
  if (__s) {
    __s = (const char *)strlen(__s);
  }
  *a5 = v8;
  a5[1] = __s;
  a5[10] = (const char *)(a5 + 4);
  a5[2] = (const char *)(a5 + 10);
  a5[3] = (const char *)3;
  a5[4] = (const char *)&unk_1EC9A45B8;
  a5[5] = a2;
  a5[6] = (const char *)&unk_1EC9A4648;
  a5[7] = a3;
  a5[8] = (const char *)&unk_1EC9A4648;
  a5[9] = a4;
  a5[11] = (const char *)(a5 + 6);
  a5[12] = (const char *)(a5 + 8);
  return __s;
}

void *llvm::SmallVector<long long,6u>::SmallVector(void *a1, const void *a2, uint64_t a3)
{
  *a1 = a1 + 2;
  a1[1] = 0x600000000;
  size_t v6 = 8 * a3;
  if ((unint64_t)(8 * a3) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)a1, a1 + 2, (8 * a3) >> 3, 8);
    unsigned int v7 = *((_DWORD *)a1 + 2);
    if (!a3) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  unsigned int v7 = 0;
  if (a3)
  {
LABEL_5:
    memcpy((void *)(*a1 + 8 * v7), a2, v6);
    unsigned int v7 = *((_DWORD *)a1 + 2);
  }
LABEL_6:
  *((_DWORD *)a1 + 2) = v7 + (v6 >> 3);
  return a1;
}

void llvm::SmallVectorTemplateBase<mlir::Type,true>::push_back(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 8);
  if (v4 >= *(_DWORD *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v4 + 1, 8);
    LODWORD(v4) = *(_DWORD *)(a1 + 8);
  }
  *(void *)(*(void *)a1 + 8 * v4) = a2;
  ++*(_DWORD *)(a1 + 8);
}

BOOL mlir::anec::anonymous namespace'::defaultMixedDataTypesIsCompatibleReturnType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL result = 1;
  if (a2 && a4)
  {
    uint64_t v9 = 0;
    while (1)
    {
      unsigned int v10 = (void *)mlir::TypeRange::dereference_iterator(a1, v9);
      uint64_t v11 = (uint64_t *)mlir::TypeRange::dereference_iterator(a3, v9);
      if (!v10) {
        goto LABEL_13;
      }
      uint64_t v12 = *v10;
      unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v14 = *(unsigned int *)(v12 + 16);
      if (!v14) {
        goto LABEL_13;
      }
      uint64_t v15 = *(void **)(v12 + 8);
      char v16 = &v15[2 * v14];
      do
      {
        unint64_t v17 = v14 >> 1;
        uint64_t v18 = &v15[2 * (v14 >> 1)];
        unint64_t v20 = *v18;
        unint64_t v19 = v18 + 2;
        v14 += ~(v14 >> 1);
        if (v20 < v13) {
          uint64_t v15 = v19;
        }
        else {
          unint64_t v14 = v17;
        }
      }
      while (v14);
      if (v15 != v16 && *v15 == v13)
      {
        uint64_t v31 = v15[1];
        char v39 = v10;
        uint64_t v40 = v31;
        if (!v11) {
          goto LABEL_24;
        }
      }
      else
      {
LABEL_13:
        char v39 = v10;
        uint64_t v40 = 0;
        if (!v11) {
          goto LABEL_24;
        }
      }
      uint64_t v21 = *v11;
      unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v23 = *(unsigned int *)(v21 + 16);
      if (!v23) {
        goto LABEL_24;
      }
      uint64_t v24 = *(void **)(v21 + 8);
      unint64_t v25 = &v24[2 * v23];
      do
      {
        unint64_t v26 = v23 >> 1;
        uint64_t v27 = &v24[2 * (v23 >> 1)];
        unint64_t v29 = *v27;
        uint64_t v28 = v27 + 2;
        v23 += ~(v23 >> 1);
        if (v29 < v22) {
          uint64_t v24 = v28;
        }
        else {
          unint64_t v23 = v26;
        }
      }
      while (v23);
      if (v24 == v25 || *v24 != v22)
      {
LABEL_24:
        uint64_t v30 = 0;
        goto LABEL_25;
      }
      uint64_t v30 = v24[1];
LABEL_25:
      v38[0] = v11;
      v38[1] = v30;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v39)) {
        return 0;
      }
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v38)) {
        return 0;
      }
      uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v39);
      uint64_t v34 = v33;
      uint64_t v35 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v38);
      if (v34 != v36) {
        return 0;
      }
      int v37 = memcmp(ArgAttrsAttr, v35, 8 * v34);
      BOOL result = v37 == 0;
      if (!v37 && ++v9 != a2 && v9 != a4) {
        continue;
      }
      return result;
    }
  }
  return result;
}

uint64_t mlir::anec::anonymous namespace'::doAttributesVerificationWithANEC(uint64_t a1, uint64_t a2)
{
  v28[6] = *MEMORY[0x1E4F143B8];
  unint64_t v26 = v28;
  uint64_t v27 = 0x300000000;
  if ((*(unsigned char *)(a1 + 46) & 0x80) != 0)
  {
    uint64_t v4 = *(unsigned int *)(a1 + 68);
    if (v4)
    {
      uint64_t v5 = 0;
      uint64_t v6 = *(void *)(a1 + 72);
      do
      {
        unsigned int v7 = (uint64_t *)(*(void *)(*(void *)(v6 + 32 * v5 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v7) {
          goto LABEL_13;
        }
        uint64_t v8 = *v7;
        unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v10 = *(unsigned int *)(v8 + 16);
        if (!v10) {
          goto LABEL_13;
        }
        uint64_t v11 = *(void **)(v8 + 8);
        uint64_t v12 = &v11[2 * v10];
        do
        {
          unint64_t v13 = v10 >> 1;
          unint64_t v14 = &v11[2 * (v10 >> 1)];
          unint64_t v16 = *v14;
          uint64_t v15 = v14 + 2;
          v10 += ~(v10 >> 1);
          if (v16 < v9) {
            uint64_t v11 = v15;
          }
          else {
            unint64_t v10 = v13;
          }
        }
        while (v10);
        if (v11 != v12 && *v11 == v9) {
          uint64_t v17 = v11[1];
        }
        else {
LABEL_13:
        }
          uint64_t v17 = 0;
        uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v7, v17);
        uint64_t v20 = v19;
        uint64_t v21 = v27;
        if (v27 >= (unint64_t)HIDWORD(v27))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v28, v27 + 1, 16);
          uint64_t v21 = v27;
        }
        unint64_t v22 = (uint64_t *)((char *)v26 + 16 * v21);
        *unint64_t v22 = RankPromotionTypeForANE;
        v22[1] = v20;
        LODWORD(v27) = v27 + 1;
        ++v5;
      }
      while (v5 != v4);
    }
  }
  uint64_t InterfaceFor = (uint64_t (**)(void, uint64_t, void *, void, uint64_t))mlir::OpInterface<mlir::anec::ANECompilerVerifierInterface,mlir::anec::detail::ANECompilerVerifierInterfaceInterfaceTraits>::getInterfaceFor(a1);
  uint64_t v24 = (*InterfaceFor)(InterfaceFor, a1, v26, v27, a2);
  if (v26 != v28) {
    free(v26);
  }
  return v24;
}

uint64_t mlir::anec::anonymous namespace'::doCustomVerificationWithANEC(mlir::anec::_anonymous_namespace_ *this, mlir::Operation *a2)
{
  v29[6] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = v29;
  uint64_t v28 = 0x300000000;
  if ((*((unsigned char *)this + 46) & 0x80) == 0) {
    goto LABEL_20;
  }
  uint64_t v3 = *((unsigned int *)this + 17);
  if (!v3) {
    goto LABEL_20;
  }
  uint64_t v4 = 0;
  uint64_t v5 = *((void *)this + 9);
  do
  {
    uint64_t v6 = (uint64_t *)(*(void *)(*(void *)(v5 + 32 * v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v6) {
      goto LABEL_13;
    }
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_13;
    }
    unint64_t v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      unint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      unint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        unint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      unint64_t v16 = (uint64_t *)v10[1];
    }
    else {
LABEL_13:
    }
      unint64_t v16 = 0;
    uint64_t v17 = v28;
    if (v28 >= (unint64_t)HIDWORD(v28))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v27, v29, v28 + 1, 16);
      uint64_t v17 = v28;
    }
    uint64_t v18 = (uint64_t **)((char *)v27 + 16 * v17);
    *uint64_t v18 = v6;
    v18[1] = v16;
    unsigned int v19 = v28 + 1;
    LODWORD(v28) = v28 + 1;
    ++v4;
  }
  while (v4 != v3);
  if (!this)
  {
    uint64_t InterfaceFor = 0;
  }
  else
  {
LABEL_20:
    uint64_t InterfaceFor = (uint64_t (**)(void, mlir::anec::_anonymous_namespace_ *, void *, uint64_t, uint64_t))mlir::OpInterface<mlir::anec::ANECompilerVerifierInterface,mlir::anec::detail::ANECompilerVerifierInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
    unsigned int v19 = v28;
  }
  uint64_t v21 = v27;
  uint64_t v22 = v19;
  unint64_t v23 = *(void **)(*(void *)(mlir::Block::getParentOp(*((mlir::Block **)this + 2)) + 48) + 16);
  if (v23 == &mlir::detail::TypeIDResolver<mlir::anec::A12,void>::id)
  {
    uint64_t v24 = 0;
  }
  else if (v23 == &mlir::detail::TypeIDResolver<mlir::anec::A13,void>::id)
  {
    uint64_t v24 = 1;
  }
  else if (v23 == &mlir::detail::TypeIDResolver<mlir::anec::A14,void>::id)
  {
    uint64_t v24 = 2;
  }
  else if (v23 == &mlir::detail::TypeIDResolver<mlir::anec::A15,void>::id)
  {
    uint64_t v24 = 3;
  }
  else if (v23 == &mlir::detail::TypeIDResolver<mlir::anec::A16,void>::id)
  {
    uint64_t v24 = 4;
  }
  else if (v23 == &mlir::detail::TypeIDResolver<mlir::anec::A17,void>::id)
  {
    uint64_t v24 = 5;
  }
  else
  {
    uint64_t v24 = 6;
  }
  uint64_t v25 = (*InterfaceFor)(InterfaceFor, this, v21, v22, v24);
  if (v27 != v29) {
    free(v27);
  }
  return v25;
}

uint64_t mlir::anec::Convolution::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  uint64_t v131 = *MEMORY[0x1E4F143B8];
  ANECConvLayerDescInitialize();
  uint64_t v6 = *(uint64_t **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  unint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    unint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      unint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v119[0] = v6;
  v119[1] = v16;
  uint64_t v17 = (uint64_t *)*((void *)a2 + 2);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *v17;
  unint64_t v19 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v20 = *(unsigned int *)(v18 + 16);
  if (!v20) {
    goto LABEL_20;
  }
  uint64_t v21 = *(void **)(v18 + 8);
  uint64_t v22 = &v21[2 * v20];
  do
  {
    unint64_t v23 = v20 >> 1;
    uint64_t v24 = &v21[2 * (v20 >> 1)];
    unint64_t v26 = *v24;
    uint64_t v25 = v24 + 2;
    v20 += ~(v20 >> 1);
    if (v26 < v19) {
      uint64_t v21 = v25;
    }
    else {
      unint64_t v20 = v23;
    }
  }
  while (v20);
  if (v21 != v22 && *v21 == v19) {
    uint64_t v27 = v21[1];
  }
  else {
LABEL_20:
  }
    uint64_t v27 = 0;
  v118[0] = v17;
  v118[1] = v27;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v119);
  uint64_t v29 = v28;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v119);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v30);
  if (v32)
  {
    unint64_t v33 = IndexFromDim;
    uint64_t v123 = v125;
    uint64_t v124 = 0x300000000;
    uint64_t v120 = v122;
    uint64_t v121 = 0x300000000;
    uint64_t v126 = v128;
    uint64_t v127 = 0x600000000;
    uint64_t StrideAttr = mlir::anec::Convolution::getStrideAttr(a1);
    mlir::getValues<int>(StrideAttr, (uint64_t)&v123);
    uint64_t KsizeAttr = mlir::anec::AveragePool::getKsizeAttr(a1);
    mlir::getValues<int>(KsizeAttr, (uint64_t)&v120);
    uint64_t PaddingAttr = mlir::anec::Convolution::getPaddingAttr(a1);
    mlir::getValues<int>(PaddingAttr, (uint64_t)&v126);
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v119);
    uint64_t v38 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v118);
    char v39 = (void **)v38;
    if (v121)
    {
      uint64_t v40 = 4 * v121 - 4;
      uint64_t v41 = (int *)v120;
      do
      {
        int v42 = *v41++;
        BOOL v43 = v42 != 1;
        BOOL v44 = v42 != 1 || v40 == 0;
        v40 -= 4;
      }
      while (!v44);
    }
    else
    {
      BOOL v43 = 0;
    }
    uint64_t v46 = *(void **)(ArgAttrsAttr + 8 * v33);
    if (v29 == 5)
    {
      if (v124 <= 2)
      {
        uint64_t v47 = "failed: found 2 strides, but the convolution op is 3d";
LABEL_64:
        v116[0] = (const void **)v47;
        __int16 v117 = 259;
        mlir::OpState::emitOpError((uint64_t **)a1, v116, (uint64_t)&__p);
        char v45 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&__p);
        if (__p) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__p);
        }
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v130);
LABEL_103:
        if (v126 != v128) {
          free(v126);
        }
        if (v120 != v122) {
          free(v120);
        }
        if (v123 != v125) {
          free(v123);
        }
        goto LABEL_109;
      }
      if (v121 <= 2)
      {
        uint64_t v47 = "failed: found 2 dilations, but the convolution op is 3d";
        goto LABEL_64;
      }
      if (v127 <= 5)
      {
        uint64_t v47 = "failed: found 4 paddings, but the convolution op is 3d";
        goto LABEL_64;
      }
      unint64_t v98 = a3;
      uint64_t v48 = (uint64_t *)(v38 + 32);
      char v49 = (uint64_t *)(v38 + 24);
      uint64_t v50 = *(void *)(v38 + 16);
    }
    else
    {
      unint64_t v98 = a3;
      uint64_t v48 = (uint64_t *)(v38 + 24);
      char v49 = (uint64_t *)(v38 + 16);
      uint64_t v50 = 1;
    }
    uint64_t v51 = *v48;
    uint64_t v52 = *v49;
    int v53 = *((_DWORD *)v123 + 2);
    int32x2_t v54 = *(int32x2_t *)v123;
    uint64_t v55 = *((int *)v120 + 1);
    uint64_t v96 = *((int *)v120 + 2);
    uint64_t v97 = v50;
    uint64_t v56 = *(int *)v120;
    uint64_t v94 = *((void *)v126 + 2);
    int8x16_t v95 = *(int8x16_t *)v126;
    uint64_t IncPadAttr = mlir::anec::AveragePool::getIncPadAttr(a1);
    if (!IncPadAttr || !v43)
    {
      if (IncPadAttr) {
        BOOL v59 = 0;
      }
      else {
        BOOL v59 = v43;
      }
      if (v59)
      {
        uint64_t v58 = @"DilatedConv";
      }
      else
      {
        if (IncPadAttr) {
          int v60 = v43;
        }
        else {
          int v60 = 1;
        }
        if (v60) {
          uint64_t v58 = @"Conv";
        }
        else {
          uint64_t v58 = @"ChannelWiseConv";
        }
      }
    }
    else
    {
      uint64_t v58 = @"ChannelWiseDilatedConv";
    }
    v99[0] = v58;
    v99[1] = @"Dense";
    std::string __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v118);
    if (mlir::Type::isF16((mlir::Type *)&__p))
    {
      uint64_t v61 = @"Float16";
    }
    else if (mlir::Type::isF32((mlir::Type *)&__p))
    {
      uint64_t v61 = @"Float32";
    }
    else if (mlir::Type::isUnsignedInteger((mlir::Type *)&__p, 8))
    {
      uint64_t v61 = @"UInt8";
    }
    else
    {
      mlir::Type::isInteger((mlir::Type *)&__p, 8);
      uint64_t v61 = @"Int8";
    }
    v99[2] = v61;
    std::string __p = (void *)mlir::anec::Convolution::getPaddingModeAttr(a1);
    v99[3] = *(&off_1E4FBF0D0 + mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&__p));
    uint64_t v62 = mlir::anec::AveragePool::getIncPadAttr(a1);
    uint64_t v63 = v46;
    if (!v62) {
      uint64_t v63 = *v39;
    }
    v99[4] = v63;
    if (!mlir::anec::AveragePool::getIncPadAttr(a1))
    {
      v116[0] = (const void **)mlir::anec::Convolution::getGroupsAttr(a1);
      mlir::IntegerAttr::getValue(v116, (llvm::APInt *)&__p);
      if (v130[0] > 0x40u)
      {
        uint64_t v46 = *(void **)__p;
        operator delete[](__p);
      }
      else
      {
        uint64_t v46 = __p;
      }
    }
    v99[5] = v46;
    char v100 = 0;
    uint64_t v101 = v51;
    uint64_t v102 = v52;
    uint64_t v103 = v97;
    int v104 = v53;
    *(int32x2_t *)&long long v64 = vrev64_s32(v54);
    *((void *)&v64 + 1) = v94;
    long long v105 = v64;
    int8x16_t v106 = vextq_s8(v95, v95, 8uLL);
    char v107 = 0;
    uint64_t v108 = v96;
    uint64_t v109 = v55;
    uint64_t v110 = v56;
    a3 = v98;
    if (mlir::anec::Convolution::getKernelScaleAttr(a1))
    {
      KernelScaleAttr = (uint64_t *)mlir::anec::Convolution::getKernelScaleAttr(a1);
      uint64_t v66 = (uint64_t)KernelScaleAttr;
      if (!KernelScaleAttr) {
        goto LABEL_84;
      }
      uint64_t v67 = *KernelScaleAttr;
      unint64_t v68 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v69 = *(unsigned int *)(v67 + 16);
      if (!v69) {
        goto LABEL_84;
      }
      unint64_t v70 = *(void **)(v67 + 8);
      uint64_t v71 = &v70[2 * v69];
      do
      {
        unint64_t v72 = v69 >> 1;
        char v73 = &v70[2 * (v69 >> 1)];
        unint64_t v75 = *v73;
        uint64_t v74 = v73 + 2;
        v69 += ~(v69 >> 1);
        if (v75 < v68) {
          unint64_t v70 = v74;
        }
        else {
          unint64_t v69 = v72;
        }
      }
      while (v69);
      if (v70 != v71 && *v70 == v68) {
        uint64_t v76 = v70[1];
      }
      else {
LABEL_84:
      }
        uint64_t v76 = 0;
      uint64_t SplatFloat = mlir::getSplatFloatValue<float>(v66, v76);
      if ((SplatFloat & 0xFF00000000) != 0)
      {
        int v112 = SplatFloat;
      }
      else
      {
        char v111 = 1;
        unint64_t v78 = (void *)mlir::anec::Convolution::getKernelScaleAttr(a1);
        uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v78);
      }
    }
    if (mlir::anec::Convolution::getKernelZeroPointAttr(a1))
    {
      KernelZeroPointAttr = (uint64_t *)mlir::anec::Convolution::getKernelZeroPointAttr(a1);
      uint64_t v81 = (uint64_t)KernelZeroPointAttr;
      if (!KernelZeroPointAttr) {
        goto LABEL_98;
      }
      uint64_t v82 = *KernelZeroPointAttr;
      unint64_t v83 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v84 = *(unsigned int *)(v82 + 16);
      if (!v84) {
        goto LABEL_98;
      }
      uint64_t v85 = *(void **)(v82 + 8);
      uint64_t v86 = &v85[2 * v84];
      do
      {
        unint64_t v87 = v84 >> 1;
        unint64_t v88 = &v85[2 * (v84 >> 1)];
        unint64_t v90 = *v88;
        unint64_t v89 = v88 + 2;
        v84 += ~(v84 >> 1);
        if (v90 < v83) {
          uint64_t v85 = v89;
        }
        else {
          unint64_t v84 = v87;
        }
      }
      while (v84);
      if (v85 != v86 && *v85 == v83) {
        uint64_t v91 = v85[1];
      }
      else {
LABEL_98:
      }
        uint64_t v91 = 0;
      uint64_t SplatInt = mlir::getSplatIntValue<int>(v81, v91);
      if ((SplatInt & 0xFF00000000) != 0)
      {
        int v115 = SplatInt;
        char v45 = 1;
      }
      else
      {
        char v45 = 1;
        char v114 = 1;
      }
    }
    else
    {
      char v45 = 1;
    }
    goto LABEL_103;
  }
  uint64_t v126 = "Failed to get channel index for Conv";
  v128[8] = 259;
  mlir::OpState::emitOpError((uint64_t **)a1, (const void ***)&v126, (uint64_t)&__p);
  char v45 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&__p);
  if (__p) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__p);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v130);
LABEL_109:
  if (v45) {
    return mlir::anec::verifyConvolutionWithANEC((uint64_t)v99, (uint64_t)*a1, a2, a3);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::verifyConvolutionWithANEC(uint64_t a1, uint64_t a2, mlir::MemoryMapperInterface *a3, unint64_t a4)
{
  v32[63] = *MEMORY[0x1E4F143B8];
  v29[0] = v30;
  v29[1] = (void *)0x100000000;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v5 = 1;
  *(void *)buffer = 1;
  v21[0] = 0;
  ANECUnitValidatorCreate();
  if (ANECValidateConvLayer())
  {
    uint64_t v16 = (uint64_t *)a2;
    unint64_t v15 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v6 = MEMORY[0x1E4FBA488] + 104;
    v28[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v7 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v22 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v8 = MEMORY[0x1E4FBA408];
    unint64_t v9 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v21[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v21 + (unint64_t)*(v21[0] - 3)) = v9;
    v21[1] = 0;
    unint64_t v10 = (std::ios_base *)((char *)v21 + (unint64_t)*(v21[0] - 3));
    std::ios_base::init(v10, &v23);
    v10[1].__vftable = 0;
    v10[1].__fmtflags_ = -1;
    uint64_t v11 = *(void *)(v8 + 40);
    uint64_t v22 = *(void *)(v8 + 32);
    *(uint64_t *)((char *)&v22 + *(void *)(v22 - 24)) = v11;
    v21[0] = *(const void ***)(v8 + 8);
    *(const void ***)((char *)v21 + (unint64_t)*(v21[0] - 3)) = *(const void ***)(v8 + 48);
    v28[0] = v6;
    v21[0] = v15;
    uint64_t v22 = v7;
    std::streambuf::basic_streambuf();
    uint64_t v12 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v23 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v26 = 0u;
    int v27 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v21[0] = *(const void ***)v8;
    uint64_t v13 = *(void *)(v8 + 72);
    *(const void ***)((char *)v21 + (unint64_t)*(v21[0] - 3)) = *(const void ***)(v8 + 64);
    uint64_t v22 = v13;
    uint64_t v23 = v12;
    if (SBYTE7(v26) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v28);
    __int16 v24 = 260;
    v21[0] = (const void **)&v17;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v32);
    if (v18 < 0) {
      operator delete(v17);
    }
  }
  ANECUnitValidatorDelete();
  if (v29[0] != v30) {
    free(v29[0]);
  }
  return v5;
}

uint64_t mlir::anec::Convolution::addOpToNetwork(mlir::Operation **a1, uint64_t a2, mlir::anec::ANECIRWeights *a3)
{
  v154[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *a1;
  uint64_t v5 = *((void *)*a1 + 9);
  uint64_t v6 = *(void *)(v5 + 24);
  long long v140 = *(void **)(v5 + 56);
  uint64_t v141 = v4;
  if (*((_DWORD *)v4 + 9)) {
    uint64_t v7 = (uint64_t)v4 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  v143[0] = (void *)mlir::anec::Convolution::getGroupsAttr(&v141);
  mlir::IntegerAttr::getValue(v143, (llvm::APInt *)&__p);
  if (v148 > 0x40)
  {
    int v133 = *(void **)__p;
    operator delete[](__p);
  }
  else
  {
    int v133 = __p;
  }
  uint64_t IncPadAttr = mlir::anec::AveragePool::getIncPadAttr(&v141);
  v153[0] = v154;
  v153[1] = (void *)0x200000000;
  uint64_t StrideAttr = mlir::anec::Convolution::getStrideAttr(&v141);
  mlir::getValues<unsigned long long>(StrideAttr, (uint64_t)v153);
  uint64_t v150 = (int32x4_t *)v152;
  uint64_t v151 = 0x200000000;
  uint64_t KsizeAttr = mlir::anec::AveragePool::getKsizeAttr(&v141);
  mlir::getValues<unsigned long long>(KsizeAttr, (uint64_t)&v150);
  long long __p = v149;
  uint64_t v148 = 0x400000000;
  uint64_t PaddingAttr = mlir::anec::Convolution::getPaddingAttr(&v141);
  mlir::getValues<unsigned long long>(PaddingAttr, (uint64_t)&__p);
  uint64_t v13 = (uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_16;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_16;
  }
  uint64_t v17 = *(void **)(v14 + 8);
  char v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    uint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    uint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      uint64_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_16:
  }
    uint64_t v23 = 0;
  v139[0] = v13;
  v139[1] = v23;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v139);
  __int16 v24 = (uint64_t *)(*(void *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24) {
    goto LABEL_26;
  }
  uint64_t v25 = *v24;
  unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v27 = *(unsigned int *)(v25 + 16);
  if (!v27) {
    goto LABEL_26;
  }
  uint64_t v28 = *(void **)(v25 + 8);
  uint64_t v29 = &v28[2 * v27];
  do
  {
    unint64_t v30 = v27 >> 1;
    uint64_t v31 = &v28[2 * (v27 >> 1)];
    unint64_t v33 = *v31;
    char v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26) {
      uint64_t v28 = v32;
    }
    else {
      unint64_t v27 = v30;
    }
  }
  while (v27);
  if (v28 != v29 && *v28 == v26) {
    uint64_t v34 = v28[1];
  }
  else {
LABEL_26:
  }
    uint64_t v34 = 0;
  v138[0] = v24;
  v138[1] = v34;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v138);
  uint64_t v35 = (uint64_t *)(v140[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v35) {
    goto LABEL_36;
  }
  uint64_t v36 = *v35;
  unint64_t v37 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v38 = *(unsigned int *)(v36 + 16);
  if (!v38) {
    goto LABEL_36;
  }
  char v39 = *(void **)(v36 + 8);
  uint64_t v40 = &v39[2 * v38];
  do
  {
    unint64_t v41 = v38 >> 1;
    int v42 = &v39[2 * (v38 >> 1)];
    unint64_t v44 = *v42;
    BOOL v43 = v42 + 2;
    v38 += ~(v38 >> 1);
    if (v44 < v37) {
      char v39 = v43;
    }
    else {
      unint64_t v38 = v41;
    }
  }
  while (v38);
  if (v39 != v40 && *v39 == v37) {
    uint64_t v45 = v39[1];
  }
  else {
LABEL_36:
  }
    uint64_t v45 = 0;
  *(void *)&long long v137 = v35;
  *((void *)&v137 + 1) = v45;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v137);
  uint64_t v48 = v47;
  v136[0] = 0;
  v136[1] = 0;
  uint64_t v142 = (uint64_t **)v136;
  v143[0] = v140;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v143);
  if (DefiningOp) {
    mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v142, DefiningOp);
  }
  uint64_t v50 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v140);
  uint64_t v51 = (uint64_t *)a3;
  uint64_t v52 = mlir::anec::ANECIRWeights::lookupConstant(a3, v50);
  int v53 = (char *)operator new(0x150uLL);
  *(_OWORD *)int v53 = 0u;
  *((_OWORD *)v53 + 1) = 0u;
  *((_OWORD *)v53 + 2) = 0u;
  *((_OWORD *)v53 + 3) = 0u;
  *((_OWORD *)v53 + 4) = 0u;
  *((_OWORD *)v53 + 5) = 0u;
  *((_OWORD *)v53 + 6) = 0u;
  *((_OWORD *)v53 + 7) = 0u;
  *((_OWORD *)v53 + 8) = 0u;
  *((_OWORD *)v53 + 9) = 0u;
  *((_OWORD *)v53 + 10) = 0u;
  *((_OWORD *)v53 + 11) = 0u;
  *((_OWORD *)v53 + 12) = 0u;
  *((_OWORD *)v53 + 13) = 0u;
  *((_OWORD *)v53 + 14) = 0u;
  *((_OWORD *)v53 + 15) = 0u;
  *((_OWORD *)v53 + 16) = 0u;
  *((_OWORD *)v53 + 17) = 0u;
  *((_OWORD *)v53 + 18) = 0u;
  *((_OWORD *)v53 + 19) = 0u;
  *((_OWORD *)v53 + 20) = 0u;
  *((void *)v53 + 9) = -1;
  *((_DWORD *)v53 + 22) = -1;
  *((void *)v53 + 12) = -1;
  *((_DWORD *)v53 + 26) = -1;
  *((void *)v53 + 14) = -1;
  *(_OWORD *)(v53 + 120) = 0u;
  *(_OWORD *)(v53 + 136) = 0u;
  *(_OWORD *)(v53 + 152) = 0u;
  *((void *)v53 + 21) = 0;
  *((_DWORD *)v53 + 44) = 1;
  *((_DWORD *)v53 + 48) = -1;
  *((void *)v53 + 25) = -1;
  *((_DWORD *)v53 + 52) = -1;
  *((void *)v53 + 27) = -1;
  *((void *)v53 + 28) = 0x3F80000000000006;
  *(void *)int v53 = &unk_1EC9958C8;
  int64x2_t v54 = vdupq_n_s64(1uLL);
  *(int64x2_t *)(v53 + 248) = v54;
  *(void *)&long long v55 = 0x100000001;
  *((void *)&v55 + 1) = 0x100000001;
  *(int64x2_t *)(v53 + 264) = v54;
  *(_OWORD *)(v53 + 280) = v55;
  *((void *)v53 + 37) = 0x100000001;
  *((void *)v53 + 38) = 0;
  *((void *)v53 + 39) = 0;
  *((void *)v53 + 40) = 0;
  *((_DWORD *)v53 + 82) = 1;
  v143[0] = v4;
  v143[1] = v145;
  uint64_t v144 = 0x200000000;
  uint64_t v56 = v151;
  if (!v151)
  {
    BOOL v146 = IncPadAttr != 0;
    BOOL v59 = v145;
LABEL_49:
    if (IncPadAttr) {
      int v61 = 2;
    }
    else {
      int v61 = 1;
    }
    if (v59 != v145) {
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  if (v151 < 3)
  {
    uint64_t v57 = v151;
    uint64_t v58 = v145;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v143[1], v145, v151, 8);
    uint64_t v57 = v151;
    if (!v151) {
      goto LABEL_46;
    }
    uint64_t v58 = v143[1];
  }
  memcpy(v58, v150, 8 * v57);
LABEL_46:
  uint64_t v60 = 0;
  LODWORD(v144) = v56;
  BOOL v59 = v143[1];
  BOOL v146 = IncPadAttr != 0;
  while (*(void *)((char *)v143[1] + v60) == 1)
  {
    v60 += 8;
    if (8 * v56 == v60) {
      goto LABEL_49;
    }
  }
  if (IncPadAttr)
  {
    int v61 = 6;
    if (v143[1] == v145) {
      goto LABEL_54;
    }
LABEL_53:
    free(v59);
    goto LABEL_54;
  }
  int v61 = 5;
  if (v143[1] != v145) {
    goto LABEL_53;
  }
LABEL_54:
  *((_DWORD *)v53 + 60) = v61;
  v53[244] = 0;
  *((_DWORD *)v53 + 20) = 1;
  *(_OWORD *)uint64_t v143 = v137;
  uint64_t OperandRange = (uint64_t **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v143);
  uint64_t v63 = (void *)(*OperandRange)[17];
  if (v63 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    if (v63 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id)
    {
      int v64 = 4;
    }
    else if (v63 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id)
    {
      int v64 = 6;
    }
    else
    {
      int v64 = 0;
    }
    goto LABEL_71;
  }
  uint64_t v142 = OperandRange;
  int Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&v142);
  if (Width == 16)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v142) == 1)
    {
      int v64 = 3;
      goto LABEL_71;
    }
  }
  else if (Width == 8)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v142) == 2) {
      int v64 = 2;
    }
    else {
      int v64 = 1;
    }
    goto LABEL_71;
  }
  int v64 = 0;
LABEL_71:
  *((void *)v53 + 31) = v133;
  *((_DWORD *)v53 + 21) = v64;
  *((_DWORD *)v53 + 22) = 0;
  *((void *)v53 + 12) = v52;
  *((int8x16_t *)v53 + 16) = vextq_s8(*(int8x16_t *)(ArgAttrsAttr + 8 * v48 - 16), *(int8x16_t *)(ArgAttrsAttr + 8 * v48 - 16), 8uLL);
  if (v48 == 5) {
    uint64_t v66 = *(void *)(ArgAttrsAttr + 16);
  }
  else {
    uint64_t v66 = 1;
  }
  *((void *)v53 + 34) = v66;
  uint64_t v67 = v150;
  *((_DWORD *)v53 + 70) = v150[1].i64[0];
  int32x4_t v68 = *v67;
  unint64_t v69 = v153[0];
  *(int32x4_t *)(v53 + 284) = vrev64q_s32(vuzp1q_s32(v68, *(int32x4_t *)((char *)v153[0] + 8)));
  *((_DWORD *)v53 + 75) = *v69;
  unint64_t v70 = (int64x2_t *)__p;
  *((int32x4_t *)v53 + 19) = vuzp1q_s32(*((int32x4_t *)__p + 2), *((int32x4_t *)__p + 1));
  *((int32x2_t *)v53 + 40) = vmovn_s64(*v70);
  v143[0] = (void *)mlir::anec::Convolution::getPaddingModeAttr(&v141);
  *((_DWORD *)v53 + 82) = dword_1810FE3D0[mlir::IntegerAttr::getInt((mlir::IntegerAttr *)v143)];
  v53[180] = 0;
  if (mlir::anec::Convolution::getKernelScaleAttr(&v141))
  {
    KernelScaleAttr = (uint64_t *)mlir::anec::Convolution::getKernelScaleAttr(&v141);
    uint64_t v72 = (uint64_t)KernelScaleAttr;
    if (!KernelScaleAttr) {
      goto LABEL_84;
    }
    uint64_t v73 = *KernelScaleAttr;
    unint64_t v74 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v75 = *(unsigned int *)(v73 + 16);
    if (!v75) {
      goto LABEL_84;
    }
    uint64_t v76 = *(void **)(v73 + 8);
    char v77 = &v76[2 * v75];
    do
    {
      unint64_t v78 = v75 >> 1;
      unint64_t v79 = &v76[2 * (v75 >> 1)];
      unint64_t v81 = *v79;
      uint64_t v80 = v79 + 2;
      v75 += ~(v75 >> 1);
      if (v81 < v74) {
        uint64_t v76 = v80;
      }
      else {
        unint64_t v75 = v78;
      }
    }
    while (v75);
    if (v76 != v77 && *v76 == v74) {
      uint64_t v82 = v76[1];
    }
    else {
LABEL_84:
    }
      uint64_t v82 = 0;
    uint64_t SplatFloat = mlir::getSplatFloatValue<float>(v72, v82);
    if ((SplatFloat & 0xFF00000000) != 0)
    {
      *((_DWORD *)v53 + 57) = SplatFloat;
      goto LABEL_118;
    }
    unint64_t v84 = (uint64_t *)mlir::anec::Convolution::getKernelScaleAttr(&v141);
    uint64_t v85 = (uint64_t)v84;
    if (!v84) {
      goto LABEL_96;
    }
    uint64_t v86 = *v84;
    unint64_t v87 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v88 = *(unsigned int *)(v86 + 16);
    if (!v88) {
      goto LABEL_96;
    }
    unint64_t v89 = *(void **)(v86 + 8);
    unint64_t v90 = &v89[2 * v88];
    do
    {
      unint64_t v91 = v88 >> 1;
      uint64_t v92 = &v89[2 * (v88 >> 1)];
      unint64_t v94 = *v92;
      uint64_t v93 = v92 + 2;
      v88 += ~(v88 >> 1);
      if (v94 < v87) {
        unint64_t v89 = v93;
      }
      else {
        unint64_t v88 = v91;
      }
    }
    while (v88);
    if (v89 != v90 && *v89 == v87) {
      uint64_t v95 = v89[1];
    }
    else {
LABEL_96:
    }
      uint64_t v95 = 0;
    uint64_t v96 = mlir::anec::ANECIRWeights::addConstant(v51, v85, v95);
    uint64_t v135 = mlir::anec::Convolution::getKernelScaleAttr(&v141);
    v143[0] = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v135);
    v143[1] = v97;
    unint64_t v98 = (uint64_t **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v143);
    uint64_t v99 = (void *)(*v98)[17];
    if (v99 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      if (v99 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id)
      {
        int v100 = 4;
      }
      else if (v99 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id)
      {
        int v100 = 6;
      }
      else
      {
        int v100 = 0;
      }
      goto LABEL_117;
    }
    uint64_t v142 = v98;
    int v101 = mlir::IntegerType::getWidth((mlir::IntegerType *)&v142);
    if (v101 == 16)
    {
      if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v142) == 1)
      {
        int v100 = 3;
LABEL_117:
        *((_DWORD *)v53 + 56) = v100;
        v53[184] = 1;
        *((_DWORD *)v53 + 48) = 0;
        *((void *)v53 + 25) = v96;
        goto LABEL_118;
      }
    }
    else if (v101 == 8)
    {
      if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v142) == 2) {
        int v100 = 2;
      }
      else {
        int v100 = 1;
      }
      goto LABEL_117;
    }
    int v100 = 0;
    goto LABEL_117;
  }
LABEL_118:
  if (mlir::anec::Convolution::getKernelZeroPointAttr(&v141))
  {
    KernelZeroPointAttr = (uint64_t *)mlir::anec::Convolution::getKernelZeroPointAttr(&v141);
    uint64_t v103 = (uint64_t)KernelZeroPointAttr;
    if (!KernelZeroPointAttr) {
      goto LABEL_128;
    }
    uint64_t v104 = *KernelZeroPointAttr;
    unint64_t v105 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v106 = *(unsigned int *)(v104 + 16);
    if (!v106) {
      goto LABEL_128;
    }
    char v107 = *(void **)(v104 + 8);
    uint64_t v108 = &v107[2 * v106];
    do
    {
      unint64_t v109 = v106 >> 1;
      uint64_t v110 = &v107[2 * (v106 >> 1)];
      unint64_t v112 = *v110;
      char v111 = v110 + 2;
      v106 += ~(v106 >> 1);
      if (v112 < v105) {
        char v107 = v111;
      }
      else {
        unint64_t v106 = v109;
      }
    }
    while (v106);
    if (v107 != v108 && *v107 == v105) {
      uint64_t v113 = v107[1];
    }
    else {
LABEL_128:
    }
      uint64_t v113 = 0;
    uint64_t SplatInt = mlir::getSplatIntValue<int>(v103, v113);
    if ((SplatInt & 0xFF00000000) != 0)
    {
      *((_DWORD *)v53 + 58) = SplatInt;
    }
    else
    {
      int v115 = (uint64_t *)mlir::anec::Convolution::getKernelZeroPointAttr(&v141);
      uint64_t v116 = (uint64_t)v115;
      if (!v115) {
        goto LABEL_140;
      }
      uint64_t v117 = *v115;
      unint64_t v118 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v119 = *(unsigned int *)(v117 + 16);
      if (!v119) {
        goto LABEL_140;
      }
      uint64_t v120 = *(void **)(v117 + 8);
      uint64_t v121 = &v120[2 * v119];
      do
      {
        unint64_t v122 = v119 >> 1;
        uint64_t v123 = &v120[2 * (v119 >> 1)];
        unint64_t v125 = *v123;
        uint64_t v124 = v123 + 2;
        v119 += ~(v119 >> 1);
        if (v125 < v118) {
          uint64_t v120 = v124;
        }
        else {
          unint64_t v119 = v122;
        }
      }
      while (v119);
      if (v120 != v121 && *v120 == v118) {
        uint64_t v126 = v120[1];
      }
      else {
LABEL_140:
      }
        uint64_t v126 = 0;
      uint64_t v127 = mlir::anec::ANECIRWeights::addConstant(v51, v116, v126);
      v53[185] = 1;
      *((_DWORD *)v53 + 52) = 0;
      *((void *)v53 + 27) = v127;
    }
  }
  uint64_t v128 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v128->__shared_owners_ = 0;
  v128->__shared_weak_owners_ = 0;
  v128->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  v128[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v128[1].__shared_owners_;
  if (v53[31] < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *((const std::string::value_type **)v53 + 1), *((void *)v53 + 2));
  }
  else
  {
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = *(_OWORD *)(v53 + 8);
    v128[2].__vftable = (std::__shared_weak_count_vtbl *)*((void *)v53 + 3);
  }
  LODWORD(v128[2].__shared_owners_) = 17;
  v128[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v128[2].__shared_weak_owners_ = (uint64_t)v53;
  LOBYTE(v128[3].__vftable) = 0;
  v128[3].__shared_owners_ = 0;
  v128[3].__shared_weak_owners_ = (uint64_t)&v128[4].__shared_owners_;
  v128[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v128[5].__shared_weak_owners_ = (uint64_t)&v128[6].__shared_owners_;
  v128[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  v143[0] = &v128[1];
  v143[1] = v128;
  uint64_t v130 = *(void **)(a2 + 232);
  if ((unint64_t)v130 >= *(void *)(a2 + 240))
  {
    uint64_t v131 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, (long long *)v143);
    uint64_t v128 = (std::__shared_weak_count *)v143[1];
    *(void *)(a2 + 232) = v131;
    if (!v128) {
      goto LABEL_150;
    }
  }
  else
  {
    *uint64_t v130 = v128 + 1;
    v130[1] = v128;
    atomic_fetch_add_explicit(&v128->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v130 + 2;
  }
  if (!atomic_fetch_add(&v128->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v128->__on_zero_shared)(v128);
    std::__shared_weak_count::__release_weak(v128);
  }
LABEL_150:
  if (__p != v149) {
    free(__p);
  }
  if (v150 != (int32x4_t *)v152) {
    free(v150);
  }
  if (v153[0] != v154) {
    free(v153[0]);
  }
  return 1;
}

uint64_t mlir::anec::findDilatedConvTiles(uint64_t this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t *a8, uint64_t *a9, uint64_t *a10, uint64_t *a11, uint64_t *a12)
{
  uint64_t v12 = 1;
  uint64_t v13 = a3;
  if ((a3 & 1) == 0)
  {
    do
    {
      if (v13 >= 0) {
        uint64_t v14 = v13;
      }
      else {
        uint64_t v14 = v13 + 1;
      }
      uint64_t v13 = v14 >> 1;
      ++v12;
    }
    while (((v14 >> 1) & 1) == 0);
  }
  if (0xAAAAAAAAAAAAAAABLL * v13 + 0x2AAAAAAAAAAAAAAALL <= 0x5555555555555554)
  {
    uint64_t v15 = 1;
    do
    {
      v13 /= 3;
      ++v15;
    }
    while ((unint64_t)(0x2AAAAAAAAAAAAAAALL - 0x5555555555555555 * v13) < 0x5555555555555555);
  }
  else
  {
    uint64_t v15 = 1;
  }
  uint64_t v16 = 1;
  uint64_t v17 = a4;
  if ((a4 & 1) == 0)
  {
    do
    {
      if (v17 >= 0) {
        uint64_t v18 = v17;
      }
      else {
        uint64_t v18 = v17 + 1;
      }
      uint64_t v17 = v18 >> 1;
      ++v16;
    }
    while (((v18 >> 1) & 1) == 0);
  }
  if (0xAAAAAAAAAAAAAAABLL * v17 + 0x2AAAAAAAAAAAAAAALL <= 0x5555555555555554)
  {
    uint64_t v19 = 1;
    do
    {
      v17 /= 3;
      ++v19;
    }
    while ((unint64_t)(0x2AAAAAAAAAAAAAAALL - 0x5555555555555555 * v17) < 0x5555555555555555);
  }
  else
  {
    uint64_t v19 = 1;
  }
  uint64_t v20 = 0;
  uint64_t v21 = a5 - 1;
  uint64_t v22 = a6 - 1;
  uint64_t v23 = this - 1;
  uint64_t v24 = a2 - 1;
  uint64_t v25 = -1;
  do
  {
    unint64_t v26 = (uint64_t *)((char *)&unk_1810FE360 + 16 * v20);
    uint64_t v27 = *v26;
    uint64_t v28 = v26[1];
    uint64_t v29 = 1;
    uint64_t v30 = 1;
    do
    {
      if (v15)
      {
        uint64_t v31 = 0;
        uint64_t v32 = -1;
        uint64_t v33 = 1;
        uint64_t v34 = v29;
        do
        {
          uint64_t v35 = v12;
          for (uint64_t i = v33; v35; --v35)
          {
            if (i > v29 && (v32 == -1 || ((v23 + i) / i + v28 - 1) / v28 * v28 * i - this <= v32))
            {
              uint64_t v32 = ((v23 + i) / i + v28 - 1) / v28 * v28 * i - this;
              uint64_t v34 = i;
            }
            i *= 2;
          }
          ++v31;
          v33 *= 3;
        }
        while (v31 != v15);
      }
      else
      {
        uint64_t v34 = v29;
      }
      uint64_t v37 = a7 + a7 * a3 / v34 * v21;
      uint64_t v38 = v37 + v37 * a4 / v30 * v22;
      if (v38 >= 0) {
        uint64_t v39 = v37 + v37 * a4 / v30 * v22;
      }
      else {
        uint64_t v39 = v38 + 1;
      }
      uint64_t v40 = v39 >> 1;
      if (v34 * v30 > 8) {
        uint64_t v38 = v40;
      }
      if (v38 <= 0x10000)
      {
        uint64_t v44 = v30;
        goto LABEL_56;
      }
      uint64_t v41 = 0;
      uint64_t v42 = -1;
      uint64_t v43 = 1;
      uint64_t v44 = v30;
      do
      {
        uint64_t v45 = v16;
        uint64_t v46 = v43;
        do
        {
          if (v46 > v30 && (v42 == -1 || ((v24 + v46) / v46 + v27 - 1) / v27 * v27 * v46 - a2 <= v42))
          {
            uint64_t v42 = ((v24 + v46) / v46 + v27 - 1) / v27 * v27 * v46 - a2;
            uint64_t v44 = v46;
          }
          v46 *= 2;
          --v45;
        }
        while (v45);
        ++v41;
        v43 *= 3;
      }
      while (v41 != v19);
      uint64_t v47 = v37 + v37 * a4 / v44 * v22;
      if (v47 >= 0) {
        uint64_t v48 = v37 + v37 * a4 / v44 * v22;
      }
      else {
        uint64_t v48 = v47 + 1;
      }
      uint64_t v49 = v48 >> 1;
      if (v44 * v34 > 8) {
        uint64_t v47 = v49;
      }
      if (v42 == -1) {
        break;
      }
      uint64_t v29 = v34;
      uint64_t v30 = v44;
    }
    while (v47 > 0x10000);
    if (v47 > 0x10000) {
      goto LABEL_21;
    }
LABEL_56:
    if (v25 == -1
      || v34 * v27 * v44 * ((v27 + (v24 + v44) / v44 - 1) / v27) * ((v23 + v34) / v34 + v28 - 1) / v28 * v28 - a2 * this < v25)
    {
      *a8 = v28;
      *a9 = v27;
      *a10 = v34;
      uint64_t v25 = v34 * v27 * v44 * ((v27 + (v24 + v44) / v44 - 1) / v27) * ((v23 + v34) / v34 + v28 - 1) / v28 * v28
          - a2 * this;
      *a11 = v44;
    }
LABEL_21:
    ++v20;
  }
  while (v20 != 4);
  return this;
}

float mlir::anec::Convolution::getExecutionCost(mlir::anec::AveragePool *a1, uint64_t a2)
{
  v190[6] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v3) {
    goto LABEL_10;
  }
  uint64_t v4 = *v3;
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *(unsigned int *)(v4 + 16);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void **)(v4 + 8);
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    unint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  v184[0] = v3;
  v184[1] = v13;
  uint64_t v14 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)a1 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_20;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  uint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    uint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_20:
  }
    uint64_t v24 = 0;
  v183[0] = v14;
  v183[1] = v24;
  if (*(_DWORD *)(*(void *)a1 + 36)) {
    uint64_t v25 = *(void *)a1 - 16;
  }
  else {
    uint64_t v25 = 0;
  }
  unint64_t v26 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v25, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  unint64_t v170 = a1;
  if (!v26) {
    goto LABEL_33;
  }
  uint64_t v27 = *v26;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *(unsigned int *)(v27 + 16);
  if (!v29) {
    goto LABEL_33;
  }
  uint64_t v30 = *(void **)(v27 + 8);
  uint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    uint64_t v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      uint64_t v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_33:
  }
    uint64_t v36 = 0;
  v182[0] = v26;
  v182[1] = v36;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184);
  uint64_t v38 = (int64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v183);
  uint64_t v40 = v39;
  uint64_t v41 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v182);
  int64_t v42 = *v38;
  uint64_t v176 = v38[v40 - 2];
  uint64_t v172 = v38[v40 - 1];
  uint64_t OperandRange = (int *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v183);
  IntOrFloatBitint Width = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v44);
  if (!v46) {
    goto LABEL_136;
  }
  unint64_t v47 = IndexFromDim;
  int64_t v167 = v42;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184);
  unint64_t v49 = mlir::anec::getIndexFromDim(1, v48);
  if (!v50
    || (unint64_t v51 = v49,
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184),
        unint64_t v53 = mlir::anec::getIndexFromDim(3, v52),
        !v54)
    || (unint64_t v55 = v53,
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184),
        unint64_t v57 = mlir::anec::getIndexFromDim(4, v56),
        !v58))
  {
LABEL_136:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v164 = *(uint64_t **)(ArgAttrsAttr + 8 * v47);
  unint64_t v59 = *(void *)(ArgAttrsAttr + 8 * v51);
  uint64_t v174 = *(void *)(v41 + 8 * v57);
  uint64_t v175 = *(void *)(v41 + 8 * v55);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184);
  unint64_t v61 = mlir::anec::getIndexFromDim(2, v60);
  if (v62)
  {
    uint64_t v168 = *(void *)(v41 + 8 * v61);
    int v63 = v38[v40 - 1];
    uint64_t v176 = v38[v40 - 3];
    uint64_t v64 = v38[v40 - 2];
    uint64_t v65 = (mlir::Operation **)v170;
  }
  else
  {
    uint64_t v168 = 1;
    int v63 = 1;
    uint64_t v65 = (mlir::Operation **)v170;
    uint64_t v64 = v172;
  }
  uint64_t v66 = IntOrFloatBitWidth >> 3;
  uint64_t OperandRange = (int *)v190;
  uint64_t v189 = 0xC00000000;
  uint64_t KsizeAttr = mlir::anec::AveragePool::getKsizeAttr(v65);
  mlir::getValues<int>(KsizeAttr, (uint64_t)&OperandRange);
  if (v189)
  {
    int v68 = *OperandRange;
    if (v189 == 1)
    {
      int v69 = 1;
      int v70 = 1;
    }
    else
    {
      int v69 = OperandRange[1];
      if (v189 < 3) {
        int v70 = 1;
      }
      else {
        int v70 = OperandRange[2];
      }
    }
  }
  else
  {
    int v69 = 1;
    int v68 = 1;
    int v70 = 1;
  }
  uint64_t v71 = v70;
  int v72 = v68 * (v63 - 1) + 1;
  uint64_t GroupsAttr = mlir::anec::Convolution::getGroupsAttr(v65);
  mlir::IntegerAttr::getValue(&GroupsAttr, (llvm::APInt *)&__p);
  int v166 = v63;
  if (v186 > 0x40)
  {
    unint64_t v73 = *(void *)__p;
    operator delete[](__p);
  }
  else
  {
    unint64_t v73 = (unint64_t)__p;
  }
  uint64_t v74 = v64 - 1;
  uint64_t v75 = v176 - 1;
  uint64_t v76 = v69;
  uint64_t v77 = v72;
  if (v175 <= 0) {
    uint64_t v78 = -(-v175 & 7);
  }
  else {
    uint64_t v78 = v175 & 7;
  }
  BOOL v79 = v78 == 0;
  uint64_t v80 = v175 - v78 + 8;
  BOOL v82 = v168 < 9 && v175 < 9;
  if (v82 && v174 < 9 || v79) {
    uint64_t v83 = v175;
  }
  else {
    uint64_t v83 = v80;
  }
  if (v69 > 5 || (int)v71 > 5)
  {
    int v169 = v77;
    int v171 = v66;
    uint64_t GroupsAttr = 8;
    uint64_t v181 = 16;
    uint64_t v179 = 1;
    uint64_t v180 = 1;
    uint64_t v173 = v64;
    mlir::anec::findDilatedConvTiles(v174, v175, v71, v69, v64, v176, v59, &GroupsAttr, &v181, &v180, &v179, v164);
    uint64_t v86 = v179;
    uint64_t v87 = v180;
    uint64_t v88 = (v174 + v180 - 1) / v180;
    uint64_t v89 = (v175 + v179 - 1) / v179;
    uint64_t v90 = (int)(v71 / v180) * v74 + 1;
    uint64_t v91 = (int)(v76 / v179) * (v176 - 1) + 1;
    unint64_t v92 = v59 / v73;
    if (v180 != 1 || (float v93 = 0.0, v179 != 1))
    {
      uint64_t v94 = (v175 + v179 - 1) / v179;
      if (v180 == 1)
      {
        uint64_t v100 = 0;
      }
      else
      {
        uint64_t v95 = v179;
        long long __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v184);
        unsigned int v96 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p);
        uint64_t v97 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184);
        uint64_t NumElements = mlir::ShapedType::getNumElements(v97, v98);
        uint64_t v86 = v95;
        uint64_t v100 = NumElements * ((v96 >> 2) & 0x3FFFFFFE);
      }
      uint64_t v129 = v86;
      if (v86 != 1)
      {
        long long __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v184);
        unsigned int v130 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p);
        uint64_t v131 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184);
        v100 += mlir::ShapedType::getNumElements(v131, v132) * ((v130 >> 2) & 0x3FFFFFFE);
      }
      long long __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v182);
      unsigned int v133 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p);
      unsigned int v134 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v182);
      unint64_t v136 = v100 + mlir::ShapedType::getNumElements(v134, v135) * ((v133 >> 2) & 0x3FFFFFFE);
      float v137 = (float)v136;
      uint64_t v138 = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v184);
      if (v136 <= 0x200000) {
        float v137 = 0.0;
      }
      long long __p = v138;
      float v139 = *(float *)(a2 + 40) * 1.0e12;
      BOOL isF16 = mlir::Type::isF16((mlir::Type *)&__p);
      float v141 = v139 + v139;
      if (isF16) {
        float v141 = v139;
      }
      float v142 = (float)(0.0 / v141) / 0.65;
      if (v142 < (float)(v137 / (float)(*(float *)(a2 + 44) * 1000000000.0))) {
        float v142 = v137 / (float)(*(float *)(a2 + 44) * 1000000000.0);
      }
      float v93 = v142 + 0.0;
      uint64_t v86 = v129;
      uint64_t v89 = v94;
    }
    uint64_t v143 = 0x10000 / (uint64_t)(v169 * (uint64_t)v171 * v90 * v92 * v91);
    if ((unint64_t)v143 <= 1) {
      uint64_t v143 = 1;
    }
    if (v143 >= 8) {
      uint64_t v143 = 8;
    }
    uint64_t v144 = 16 * v143;
    uint64_t v145 = v167 / (16 * v143);
    uint64_t v146 = v87 * (void)v165 * v86 * ((v88 + GroupsAttr - 1) / GroupsAttr) * ((v89 + v181 - 1) / v181);
    uint64_t v147 = v176 * v173 * v166 * v92;
    uint64_t v148 = (v147 * 16 * v143 * v146 * v145) << 9;
    uint64_t v149 = (v146 * v145) << 8;
    if (v167 != v145 * v144)
    {
      int64_t v150 = v167 - v144 * v145;
      uint64_t v151 = v150 + 15;
      unint64_t v152 = v150 + 30;
      if (v151 >= 0) {
        unint64_t v152 = v151;
      }
      v148 += 32 * v147 * (v152 >> 4) * (v146 << 8);
      v149 += v146 << 8;
    }
    float v153 = (float)(uint64_t)(v149 * v92);
    long long __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v182);
    uint64_t v154 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p) >> 3;
    uint64_t v155 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v182);
    float v157 = v153 + (float)(mlir::ShapedType::getNumElements(v155, v156) * v154);
    unint64_t v158 = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v184);
    if (v157 <= 2097200.0) {
      float v157 = 0.0;
    }
    long long __p = v158;
    float v159 = *(float *)(a2 + 40) * 1.0e12;
    BOOL v160 = mlir::Type::isF16((mlir::Type *)&__p);
    float v161 = v159 + v159;
    if (v160) {
      float v161 = v159;
    }
    float v162 = (float)((float)v148 / v161) / 0.65;
    if (v162 < (float)(v157 / (float)(*(float *)(a2 + 44) * 1000000000.0))) {
      float v162 = v157 / (float)(*(float *)(a2 + 44) * 1000000000.0);
    }
    float v105 = v93 + v162;
  }
  else
  {
    uint64_t v84 = v75 * v69 + 1;
    if (v71 == 1)
    {
      uint64_t v85 = v74 * v71 + 1;
    }
    else
    {
      v59 *= v71;
      v73 *= v71;
      uint64_t v85 = v64;
    }
    if ((uint64_t)(v176 * v64 * v66 * v166 * (v59 / v73)) <= 0x8000)
    {
      BOOL v109 = v84 == v176 && v85 == v64;
      float v101 = 0.0;
      if (!v109 && (uint64_t)(v84 * v77 * v85 * (v59 / v73) * v66) > 0x8000)
      {
        uint64_t v177 = v64 * v77;
        do
        {
          if (v101 == 0.0)
          {
            uint64_t v113 = v75;
            long long __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v184);
            uint64_t v114 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p) >> 3;
            int v115 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v184);
            uint64_t v117 = mlir::ShapedType::getNumElements(v115, v116) * v114;
            long long __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v182);
            uint64_t v118 = v66;
            uint64_t v119 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p) >> 3;
            uint64_t v120 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v182);
            unint64_t v122 = 2 * (v117 + mlir::ShapedType::getNumElements(v120, v121) * v119);
            float v123 = (float)v122;
            uint64_t v124 = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v184);
            if (v122 <= 0x200000) {
              float v123 = 0.0;
            }
            long long __p = v124;
            float v125 = *(float *)(a2 + 40) * 1.0e12;
            BOOL v126 = mlir::Type::isF16((mlir::Type *)&__p);
            uint64_t v75 = v113;
            float v127 = v125 + v125;
            if (v126) {
              float v127 = v125;
            }
            float v128 = (float)(0.0 / v127) / 0.65;
            uint64_t v66 = v118;
            if (v128 >= (float)(v123 / (float)(*(float *)(a2 + 44) * 1000000000.0))) {
              float v101 = v128;
            }
            else {
              float v101 = v123 / (float)(*(float *)(a2 + 44) * 1000000000.0);
            }
          }
          if (v69)
          {
            if (v69 != 3 * (v69 / 3)) {
              break;
            }
            uint64_t v111 = 2;
            uint64_t v112 = 3;
            v69 /= 3;
            v59 *= 3;
            v73 *= 3;
          }
          else
          {
            if (v69 >= 0) {
              int v110 = v69;
            }
            else {
              int v110 = v69 + 1;
            }
            int v69 = v110 >> 1;
            v59 *= 2;
            v73 *= 2;
            uint64_t v111 = 1;
            uint64_t v112 = 2;
          }
          uint64_t v83 = (v83 + v111) / v112;
        }
        while ((uint64_t)((v177 * (v59 / v73) + v177 * (v59 / v73) * v75 * v69) * v66) > 0x8000);
      }
    }
    else
    {
      float v101 = 0.0;
    }
    uint64_t v102 = *(void *)v170;
    uint64_t v103 = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v184);
    float v105 = v101 + v104;
    long long __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v184);
    unsigned int v106 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&__p);
    if ((uint64_t)v59 >= v167
      && (uint64_t)v59 >= 64
      && ((v174 * v175 * v168 * (v106 >> 3)) & 0x7FFFF) == 0)
    {
      float v105 = v105 + v105;
    }
  }
  if (OperandRange != (int *)v190) {
    free(OperandRange);
  }
  return v105;
}

uint64_t mlir::anec::Convolution::getFilter(mlir::anec::Convolution *this)
{
  return *(void *)(*(void *)(*(void *)this + 72) + 56);
}

void mlir::getValues<int>(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v13, a1, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v16);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, a1, NumElements);
  while (1)
  {
    BOOL v5 = v13 == v10 && v14 == v11;
    if (v5 && v15 == v12) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v13, (llvm::APInt *)&__p);
    if (v9 > 0x40) {
      uint64_t v6 = *(void *)__p;
    }
    else {
      uint64_t v6 = (uint64_t)((void)__p << -(uint64_t)v9) >> -(uint64_t)v9;
    }
    uint64_t v7 = *(unsigned int *)(a2 + 8);
    if (v7 >= *(_DWORD *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v7 + 1, 4);
      uint64_t v7 = *(unsigned int *)(a2 + 8);
    }
    *(_DWORD *)(*(void *)a2 + 4 * v7) = v6;
    ++*(_DWORD *)(a2 + 8);
    if (v9 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v15;
  }
}

void *mlir::anec::Convolution::getGroups(mlir::Operation **this)
{
  uint64_t GroupsAttr = mlir::anec::Convolution::getGroupsAttr(this);
  mlir::IntegerAttr::getValue(&GroupsAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return __p;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return (void *)v1;
}

BOOL mlir::anec::anonymous namespace'::executionCost(uint64_t a1, uint64_t a2, void *a3)
{
  float v5 = 0.0;
  if ((*(unsigned char *)(a2 + 46) & 0x80) != 0)
  {
    uint64_t v6 = *(unsigned int *)(a2 + 68);
    if (v6)
    {
      uint64_t v7 = 0;
      uint64_t v8 = *(void *)(a2 + 72);
      do
      {
        uint64_t v13 = (void *)(*(void *)(*(void *)(v8 + 32 * v7 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
        if (!v13) {
          goto LABEL_4;
        }
        uint64_t v14 = *v13;
        unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v16 = *(unsigned int *)(v14 + 16);
        if (!v16) {
          goto LABEL_4;
        }
        unint64_t v17 = *(void **)(v14 + 8);
        uint64_t v18 = &v17[2 * v16];
        do
        {
          unint64_t v19 = v16 >> 1;
          unint64_t v20 = &v17[2 * (v16 >> 1)];
          unint64_t v22 = *v20;
          uint64_t v21 = v20 + 2;
          v16 += ~(v16 >> 1);
          if (v22 < v15) {
            unint64_t v17 = v21;
          }
          else {
            unint64_t v16 = v19;
          }
        }
        while (v16);
        if (v17 != v18 && *v17 == v15) {
          uint64_t v9 = v17[1];
        }
        else {
LABEL_4:
        }
          uint64_t v9 = 0;
        uint64_t v41 = v13;
        uint64_t v42 = v9;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v41);
        uint64_t v10 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange) >> 3;
        uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
        float v5 = v5 + (float)(mlir::ShapedType::getNumElements(ArgAttrsAttr, v12) * v10);
        ++v7;
      }
      while (v7 != v6);
    }
  }
  uint64_t v23 = *(unsigned int *)(a2 + 36);
  if (v23) {
    uint64_t v24 = a2 - 16;
  }
  else {
    uint64_t v24 = 0;
  }
  if (v23)
  {
    for (uint64_t i = 0; i != v23; ++i)
    {
      unint64_t v26 = (void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v24, i) + 8) & 0xFFFFFFFFFFFFFFF8);
      if (!v26) {
        goto LABEL_30;
      }
      uint64_t v27 = *v26;
      unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v29 = *(unsigned int *)(v27 + 16);
      if (!v29) {
        goto LABEL_30;
      }
      uint64_t v30 = *(void **)(v27 + 8);
      uint64_t v31 = &v30[2 * v29];
      do
      {
        unint64_t v32 = v29 >> 1;
        uint64_t v33 = &v30[2 * (v29 >> 1)];
        unint64_t v35 = *v33;
        uint64_t v34 = v33 + 2;
        v29 += ~(v29 >> 1);
        if (v35 < v28) {
          uint64_t v30 = v34;
        }
        else {
          unint64_t v29 = v32;
        }
      }
      while (v29);
      if (v30 != v31 && *v30 == v28) {
        uint64_t v36 = v30[1];
      }
      else {
LABEL_30:
      }
        uint64_t v36 = 0;
      uint64_t v41 = v26;
      uint64_t v42 = v36;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v41);
      uint64_t v37 = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange) >> 3;
      uint64_t v38 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
      float v5 = v5 + (float)(mlir::ShapedType::getNumElements(v38, v39) * v37);
    }
  }
  uint64_t v41 = a3;
  return mlir::Type::isF16((mlir::Type *)&v41);
}

uint64_t mlir::anec::Linear::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  uint64_t v65 = a6;
  v66[0] = 0;
  char v67 = 0;
  uint64_t v68 = a7;
  uint64_t v69 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v65);
    if (v67) {
      char v67 = 0;
    }
    mlir::OperationName::OperationName(v66, "anec.linear", 11, Context);
    char v67 = 1;
  }
  uint64_t v70 = a4;
  uint64_t v71 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::LinearAdaptor::verify(&v65, v18)) {
    return 0;
  }
  unint64_t v19 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  unint64_t v20 = v19;
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v21 = *v19;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_18;
  }
  uint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    unint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      uint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_18:
  }
    uint64_t v30 = 0;
  v61[0] = v20;
  v61[1] = v30;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61);
  uint64_t v33 = v32;
  uint64_t v34 = (void *)mlir::TypeRange::dereference_iterator(a9, 1);
  unint64_t v35 = v34;
  if (!v34) {
    goto LABEL_28;
  }
  uint64_t v36 = *v34;
  unint64_t v37 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v38 = *(unsigned int *)(v36 + 16);
  if (!v38) {
    goto LABEL_28;
  }
  uint64_t v39 = *(void **)(v36 + 8);
  uint64_t v40 = &v39[2 * v38];
  do
  {
    unint64_t v41 = v38 >> 1;
    uint64_t v42 = &v39[2 * (v38 >> 1)];
    unint64_t v44 = *v42;
    uint64_t v43 = v42 + 2;
    v38 += ~(v38 >> 1);
    if (v44 < v37) {
      uint64_t v39 = v43;
    }
    else {
      unint64_t v38 = v41;
    }
  }
  while (v38);
  if (v39 != v40 && *v39 == v37) {
    uint64_t v45 = v39[1];
  }
  else {
LABEL_28:
  }
    uint64_t v45 = 0;
  v60[0] = v35;
  v60[1] = v45;
  uint64_t v46 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v60) + 8);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v47);
  if (!v49)
  {
    char v58 = (uint64_t *)std::__throw_bad_optional_access[abi:nn180100]();
    return mlir::anec::LinearAdaptor::verify(v58, v59);
  }
  unint64_t v50 = IndexFromDim;
  char v62 = v64;
  uint64_t v63 = 0x600000000;
  if ((unint64_t)(8 * v33) >= 0x31)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v64, (8 * v33) >> 3, 8);
    int v51 = v63;
    unint64_t v52 = v62;
    if (!v33) {
      goto LABEL_36;
    }
    goto LABEL_35;
  }
  int v51 = 0;
  unint64_t v52 = v64;
  if (v33)
  {
LABEL_35:
    memcpy(&v52[8 * v51], ArgAttrsAttr, 8 * v33);
    int v51 = v63;
    unint64_t v52 = v62;
  }
LABEL_36:
  char v54 = (mlir::AffineMap *)(v51 + v33);
  LODWORD(v63) = v51 + v33;
  *(void *)&v52[8 * v50] = v46;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
  uint64_t v56 = mlir::MemRefType::get(v52, v54, OperandRange, 0, 0, 0);
  uint64_t v57 = *(unsigned int *)(a11 + 8);
  if (v57 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v57 + 1, 8);
    LODWORD(v57) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v57) = v56;
  ++*(_DWORD *)(a11 + 8);
  if (v62 != v64) {
    free(v62);
  }
  return 1;
}

uint64_t mlir::anec::LinearAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v123[23] = *MEMORY[0x1E4F143B8];
  uint64_t v121 = *a1;
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v121);
  if (Value == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v121))
  {
    uint64_t v6 = 0;
  }
  else
  {
    float v5 = 0;
    uint64_t v6 = 0;
    do
    {
      if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(Value))
      {
        float v5 = (const char *)*((void *)Value + 1);
      }
      else if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(Value))
      {
        uint64_t v6 = (const char *)*((void *)Value + 1);
      }
      uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    }
    while (Value != (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v121));
    if (v5)
    {
      if (!mlir::DenseFPElementsAttr::classof((uint64_t)v5)) {
        goto LABEL_52;
      }
      uint64_t v7 = *(void *)v5;
      unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v9 = *(unsigned int *)(v7 + 16);
      if (!v9) {
        goto LABEL_18;
      }
      uint64_t v10 = *(void **)(v7 + 8);
      char v11 = &v10[2 * v9];
      do
      {
        unint64_t v12 = v9 >> 1;
        uint64_t v13 = &v10[2 * (v9 >> 1)];
        unint64_t v15 = *v13;
        uint64_t v14 = v13 + 2;
        v9 += ~(v9 >> 1);
        if (v15 < v8) {
          uint64_t v10 = v14;
        }
        else {
          unint64_t v9 = v12;
        }
      }
      while (v9);
      if (v10 != v11 && *v10 == v8) {
        uint64_t v16 = v10[1];
      }
      else {
LABEL_18:
      }
        uint64_t v16 = 0;
      unsigned int v106 = v5;
      uint64_t v107 = v16;
      Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v106);
      uint64_t v18 = Type;
      if (!Type) {
        goto LABEL_28;
      }
      uint64_t v19 = *Type;
      unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v21 = *(unsigned int *)(v19 + 16);
      if (!v21) {
        goto LABEL_28;
      }
      unint64_t v22 = *(void **)(v19 + 8);
      unint64_t v23 = &v22[2 * v21];
      do
      {
        unint64_t v24 = v21 >> 1;
        uint64_t v25 = &v22[2 * (v21 >> 1)];
        unint64_t v27 = *v25;
        unint64_t v26 = v25 + 2;
        v21 += ~(v21 >> 1);
        if (v27 < v20) {
          unint64_t v22 = v26;
        }
        else {
          unint64_t v21 = v24;
        }
      }
      while (v21);
      if (v22 != v23 && *v22 == v20) {
        uint64_t v28 = v22[1];
      }
      else {
LABEL_28:
      }
        uint64_t v28 = 0;
      unint64_t v122 = v18;
      v123[0] = v28;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v122);
      if (v29)
      {
        uint64_t v30 = *(void *)v5;
        unint64_t v31 = mlir::TypeID::get<mlir::ElementsAttr>();
        unint64_t v32 = *(unsigned int *)(v30 + 16);
        if (!v32) {
          goto LABEL_38;
        }
        uint64_t v33 = *(void **)(v30 + 8);
        uint64_t v34 = &v33[2 * v32];
        do
        {
          unint64_t v35 = v32 >> 1;
          uint64_t v36 = &v33[2 * (v32 >> 1)];
          unint64_t v38 = *v36;
          unint64_t v37 = v36 + 2;
          v32 += ~(v32 >> 1);
          if (v38 < v31) {
            uint64_t v33 = v37;
          }
          else {
            unint64_t v32 = v35;
          }
        }
        while (v32);
        if (v33 != v34 && *v33 == v31) {
          uint64_t v39 = v33[1];
        }
        else {
LABEL_38:
        }
          uint64_t v39 = 0;
        uint64_t v117 = v5;
        uint64_t v118 = v39;
        uint64_t v40 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v117);
        unint64_t v41 = v40;
        if (!v40) {
          goto LABEL_48;
        }
        uint64_t v42 = *v40;
        unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v44 = *(unsigned int *)(v42 + 16);
        if (!v44) {
          goto LABEL_48;
        }
        uint64_t v45 = *(void **)(v42 + 8);
        uint64_t v46 = &v45[2 * v44];
        do
        {
          unint64_t v47 = v44 >> 1;
          unint64_t v48 = &v45[2 * (v44 >> 1)];
          unint64_t v50 = *v48;
          char v49 = v48 + 2;
          v44 += ~(v44 >> 1);
          if (v50 < v43) {
            uint64_t v45 = v49;
          }
          else {
            unint64_t v44 = v47;
          }
        }
        while (v44);
        if (v45 != v46 && *v45 == v43) {
          uint64_t v51 = v45[1];
        }
        else {
LABEL_48:
        }
          uint64_t v51 = 0;
        uint64_t v119 = v41;
        uint64_t v120 = v51;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v119);
        if (v52 != 1) {
          goto LABEL_52;
        }
      }
      uint64_t v113 = v5;
      uint64_t v114 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v113);
      uint64_t v115 = v53;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v114);
      if (!mlir::Type::isF16((mlir::Type *)&OperandRange))
      {
        BOOL v109 = v5;
        uint64_t v110 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v109);
        uint64_t v111 = v54;
        uint64_t v112 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v110);
        if (!mlir::Type::isF32((mlir::Type *)&v112))
        {
LABEL_52:
          unint64_t v55 = "'anec.linear' op attribute 'kernel_scale' failed to satisfy constraint: f16 or f32 elements attribute of rank 0/1";
          goto LABEL_100;
        }
      }
    }
  }
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof((uint64_t)v6))
  {
    uint64_t v56 = *(void *)v6;
    unint64_t v57 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v58 = *(unsigned int *)(v56 + 16);
    if (!v58) {
      goto LABEL_64;
    }
    uint64_t v59 = *(void **)(v56 + 8);
    unint64_t v60 = &v59[2 * v58];
    do
    {
      unint64_t v61 = v58 >> 1;
      char v62 = &v59[2 * (v58 >> 1)];
      unint64_t v64 = *v62;
      uint64_t v63 = v62 + 2;
      v58 += ~(v58 >> 1);
      if (v64 < v57) {
        uint64_t v59 = v63;
      }
      else {
        unint64_t v58 = v61;
      }
    }
    while (v58);
    if (v59 != v60 && *v59 == v57) {
      uint64_t v65 = v59[1];
    }
    else {
LABEL_64:
    }
      uint64_t v65 = 0;
    unsigned int v106 = v6;
    uint64_t v107 = v65;
    uint64_t v66 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v106);
    char v67 = v66;
    if (!v66) {
      goto LABEL_74;
    }
    uint64_t v68 = *v66;
    unint64_t v69 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v70 = *(unsigned int *)(v68 + 16);
    if (!v70) {
      goto LABEL_74;
    }
    uint64_t v71 = *(void **)(v68 + 8);
    uint64_t v72 = &v71[2 * v70];
    do
    {
      unint64_t v73 = v70 >> 1;
      uint64_t v74 = &v71[2 * (v70 >> 1)];
      unint64_t v76 = *v74;
      uint64_t v75 = v74 + 2;
      v70 += ~(v70 >> 1);
      if (v76 < v69) {
        uint64_t v71 = v75;
      }
      else {
        unint64_t v70 = v73;
      }
    }
    while (v70);
    if (v71 != v72 && *v71 == v69) {
      uint64_t v77 = v71[1];
    }
    else {
LABEL_74:
    }
      uint64_t v77 = 0;
    unint64_t v122 = v67;
    v123[0] = v77;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v122);
    if (!v78) {
      goto LABEL_96;
    }
    uint64_t v79 = *(void *)v6;
    unint64_t v80 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v81 = *(unsigned int *)(v79 + 16);
    if (!v81) {
      goto LABEL_84;
    }
    BOOL v82 = *(void **)(v79 + 8);
    uint64_t v83 = &v82[2 * v81];
    do
    {
      unint64_t v84 = v81 >> 1;
      uint64_t v85 = &v82[2 * (v81 >> 1)];
      unint64_t v87 = *v85;
      uint64_t v86 = v85 + 2;
      v81 += ~(v81 >> 1);
      if (v87 < v80) {
        BOOL v82 = v86;
      }
      else {
        unint64_t v81 = v84;
      }
    }
    while (v81);
    if (v82 != v83 && *v82 == v80) {
      uint64_t v88 = v82[1];
    }
    else {
LABEL_84:
    }
      uint64_t v88 = 0;
    uint64_t v117 = v6;
    uint64_t v118 = v88;
    uint64_t v89 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v117);
    uint64_t v90 = v89;
    if (!v89) {
      goto LABEL_94;
    }
    uint64_t v91 = *v89;
    unint64_t v92 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v93 = *(unsigned int *)(v91 + 16);
    if (!v93) {
      goto LABEL_94;
    }
    uint64_t v94 = *(void **)(v91 + 8);
    uint64_t v95 = &v94[2 * v93];
    do
    {
      unint64_t v96 = v93 >> 1;
      uint64_t v97 = &v94[2 * (v93 >> 1)];
      unint64_t v99 = *v97;
      uint64_t v98 = v97 + 2;
      v93 += ~(v93 >> 1);
      if (v99 < v92) {
        uint64_t v94 = v98;
      }
      else {
        unint64_t v93 = v96;
      }
    }
    while (v93);
    if (v94 != v95 && *v94 == v92) {
      uint64_t v100 = v94[1];
    }
    else {
LABEL_94:
    }
      uint64_t v100 = 0;
    uint64_t v119 = v90;
    uint64_t v120 = v100;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v119);
    if (v101 == 1)
    {
LABEL_96:
      uint64_t v113 = v6;
      uint64_t v114 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v113);
      uint64_t v115 = v102;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v114);
      if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)) {
        return 1;
      }
      BOOL v109 = v6;
      uint64_t v110 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v109);
      uint64_t v111 = v103;
      uint64_t v112 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v110);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&v112, 8)) {
        return 1;
      }
    }
  }
  unint64_t v55 = "'anec.linear' op attribute 'kernel_zero_point' failed to satisfy constraint: si8 or ui8 elements attribute of rank 0/1";
LABEL_100:
  unsigned int v106 = v55;
  __int16 v108 = 259;
  mlir::emitError(a2, (uint64_t)&v106, (uint64_t)&v122);
  uint64_t v104 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v122);
  if (v122) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v122);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v123);
  return v104;
}

uint64_t mlir::anec::Linear::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v97[63] = *MEMORY[0x1E4F143B8];
  ANECLinearLayerDescInitialize();
  uint64_t v6 = *(uint64_t **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  char v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    uint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  *(void *)buffer = v6;
  v97[0] = v16;
  uint64_t v17 = (const void **)*((void *)a2 + 2);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *v17;
  unint64_t v19 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v20 = *((unsigned int *)v18 + 4);
  if (!v20) {
    goto LABEL_20;
  }
  unint64_t v21 = (void *)v18[1];
  unint64_t v22 = &v21[2 * v20];
  do
  {
    unint64_t v23 = v20 >> 1;
    unint64_t v24 = &v21[2 * (v20 >> 1)];
    unint64_t v26 = *v24;
    uint64_t v25 = v24 + 2;
    v20 += ~(v20 >> 1);
    if (v26 < v19) {
      unint64_t v21 = v25;
    }
    else {
      unint64_t v20 = v23;
    }
  }
  while (v20);
  if (v21 != v22 && *v21 == v19) {
    uint64_t v27 = v21[1];
  }
  else {
LABEL_20:
  }
    uint64_t v27 = 0;
  uint64_t v85 = (void **)v17;
  uint64_t v86 = v27;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)buffer);
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v85);
  uint64_t v74 = @"Dense";
  v94[0] = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v85);
  if (mlir::Type::isF16((mlir::Type *)v94))
  {
    uint64_t v29 = @"Float16";
  }
  else if (mlir::Type::isF32((mlir::Type *)v94))
  {
    uint64_t v29 = @"Float32";
  }
  else if (mlir::Type::isUnsignedInteger((mlir::Type *)v94, 8))
  {
    uint64_t v29 = @"UInt8";
  }
  else
  {
    mlir::Type::isInteger((mlir::Type *)v94, 8);
    uint64_t v29 = @"Int8";
  }
  uint64_t v75 = v29;
  uint64_t v76 = *(void *)(ArgAttrsAttr + 8);
  uint64_t v77 = @"Batch";
  char v78 = 0;
  int v84 = 1;
  if (mlir::anec::Linear::getKernelScaleAttr(a1))
  {
    KernelScaleAttr = (uint64_t *)mlir::anec::Linear::getKernelScaleAttr(a1);
    uint64_t v31 = (uint64_t)KernelScaleAttr;
    if (!KernelScaleAttr) {
      goto LABEL_38;
    }
    uint64_t v32 = *KernelScaleAttr;
    unint64_t v33 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v34 = *(unsigned int *)(v32 + 16);
    if (!v34) {
      goto LABEL_38;
    }
    unint64_t v35 = *(void **)(v32 + 8);
    uint64_t v36 = &v35[2 * v34];
    do
    {
      unint64_t v37 = v34 >> 1;
      unint64_t v38 = &v35[2 * (v34 >> 1)];
      unint64_t v40 = *v38;
      uint64_t v39 = v38 + 2;
      v34 += ~(v34 >> 1);
      if (v40 < v33) {
        unint64_t v35 = v39;
      }
      else {
        unint64_t v34 = v37;
      }
    }
    while (v34);
    if (v35 != v36 && *v35 == v33) {
      uint64_t v41 = v35[1];
    }
    else {
LABEL_38:
    }
      uint64_t v41 = 0;
    uint64_t SplatFloat = mlir::getSplatFloatValue<float>(v31, v41);
    if ((SplatFloat & 0xFF00000000) != 0)
    {
      int v80 = SplatFloat;
    }
    else
    {
      char v79 = 1;
      unint64_t v43 = (void *)mlir::anec::Linear::getKernelScaleAttr(a1);
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v43);
    }
  }
  if (mlir::anec::Linear::getKernelZeroPointAttr(a1))
  {
    KernelZeroPointAttr = (uint64_t *)mlir::anec::Linear::getKernelZeroPointAttr(a1);
    uint64_t v46 = (uint64_t)KernelZeroPointAttr;
    if (!KernelZeroPointAttr) {
      goto LABEL_52;
    }
    uint64_t v47 = *KernelZeroPointAttr;
    unint64_t v48 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v49 = *(unsigned int *)(v47 + 16);
    if (!v49) {
      goto LABEL_52;
    }
    unint64_t v50 = *(void **)(v47 + 8);
    uint64_t v51 = &v50[2 * v49];
    do
    {
      unint64_t v52 = v49 >> 1;
      uint64_t v53 = &v50[2 * (v49 >> 1)];
      unint64_t v55 = *v53;
      uint64_t v54 = v53 + 2;
      v49 += ~(v49 >> 1);
      if (v55 < v48) {
        unint64_t v50 = v54;
      }
      else {
        unint64_t v49 = v52;
      }
    }
    while (v49);
    if (v50 != v51 && *v50 == v48) {
      uint64_t v56 = v50[1];
    }
    else {
LABEL_52:
    }
      uint64_t v56 = 0;
    uint64_t SplatInt = mlir::getSplatIntValue<int>(v46, v56);
    if ((SplatInt & 0xFF00000000) != 0) {
      int v83 = SplatInt;
    }
    else {
      char v82 = 1;
    }
  }
  v94[0] = v95;
  v94[1] = (void *)0x100000000;
  uint64_t v72 = 0;
  uint64_t v73 = 0;
  uint64_t v58 = 1;
  *(void *)buffer = 1;
  uint64_t v85 = 0;
  ANECUnitValidatorCreate();
  if (ANECValidateLinearLayer())
  {
    uint64_t v68 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    unint64_t v69 = *a1;
    uint64_t v59 = MEMORY[0x1E4FBA488] + 104;
    v93[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v60 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v87 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v61 = MEMORY[0x1E4FBA408];
    char v62 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    uint64_t v85 = *(void ***)(MEMORY[0x1E4FBA408] + 16);
    *(void ***)((char *)&v85 + (void)*(v85 - 3)) = (void **)v62;
    uint64_t v86 = 0;
    uint64_t v63 = (std::ios_base *)((char *)&v85 + (void)*(v85 - 3));
    std::ios_base::init(v63, &v88);
    v63[1].__vftable = 0;
    v63[1].__fmtflags_ = -1;
    uint64_t v64 = *(void *)(v61 + 40);
    uint64_t v87 = *(void *)(v61 + 32);
    *(uint64_t *)((char *)&v87 + *(void *)(v87 - 24)) = v64;
    uint64_t v85 = *(void ***)(v61 + 8);
    *(void ***)((char *)&v85 + (void)*(v85 - 3)) = *(void ***)(v61 + 48);
    v93[0] = v59;
    uint64_t v85 = (void **)v68;
    uint64_t v87 = v60;
    std::streambuf::basic_streambuf();
    uint64_t v65 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v88 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v91 = 0u;
    int v92 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v87, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    uint64_t v85 = *(void ***)v61;
    uint64_t v66 = *(void *)(v61 + 72);
    *(void ***)((char *)&v85 + (void)*(v85 - 3)) = *(void ***)(v61 + 64);
    uint64_t v87 = v66;
    uint64_t v88 = v65;
    if (SBYTE7(v91) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v93);
    __int16 v89 = 260;
    uint64_t v85 = &v70;
    uint64_t v58 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v97);
    if (v71 < 0) {
      operator delete(v70);
    }
  }
  ANECUnitValidatorDelete();
  if (v94[0] != v95) {
    free(v94[0]);
  }
  return v58;
}

void mlir::anec::anonymous namespace'::getANECTensorDescs(mlir::MemoryMapperInterface *a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  *(_DWORD *)(a4 + 8) = 0;
  if (a2 > *(unsigned int *)(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), a2, 64);
LABEL_4:
    unint64_t v52 = (void *)(a4 + 16);
    uint64_t v8 = 16 * a2;
    for (uint64_t i = 24; ; i += 32)
    {
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange(a1);
      char v11 = *(void **)(*(void *)OperandRange + 136);
      if (v11 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        uint64_t v53 = OperandRange;
        uint64_t v47 = @"Int8";
        if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v53) != 1)
        {
          if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v53)) {
            uint64_t v47 = @"UInt8";
          }
          else {
            uint64_t v47 = @"Int8";
          }
        }
      }
      else
      {
        BOOL v12 = v11 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
           || v11 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id;
        BOOL v13 = v12 || v11 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id;
        BOOL v14 = v13 || v11 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id;
        BOOL v15 = v14 || v11 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id;
        BOOL v16 = v15 || v11 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id;
        BOOL v17 = v16 || v11 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id;
        BOOL v18 = v17 || v11 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id;
        BOOL v19 = v18 || v11 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id;
        BOOL v20 = v19 || v11 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id;
        BOOL v21 = v20 || v11 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id;
        if (v21 || v11 == &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id)
        {
          uint64_t v53 = OperandRange;
          uint64_t v47 = mlir::Type::isF16((mlir::Type *)&v53) ? @"Float16" : @"Float32";
        }
        else
        {
          uint64_t v47 = @"Float32";
        }
      }
      mlir::CallableOpInterface::getArgAttrsAttr(a1);
      uint64_t v24 = *(void *)(*(void *)(a3 + 72) + i);
      uint64_t v53 = (uint64_t)v47;
      if (v23 < 1) {
        break;
      }
      unint64_t v25 = v23;
      unsigned int IndexFromDim = mlir::anec::getIndexFromDim(0, v23);
      if (!v27
        || (v54.i64[0] = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr(a1) + 8 * IndexFromDim),
            unsigned int v28 = mlir::anec::getIndexFromDim(1, v25),
            !v29)
        || (v54.i64[1] = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr(a1) + 8 * v28),
            unsigned int v30 = mlir::anec::getIndexFromDim(3, v25),
            !v31)
        || (v55.i64[0] = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr(a1) + 8 * v30),
            unsigned int v32 = mlir::anec::getIndexFromDim(4, v25),
            !v33))
      {
LABEL_69:
        uint64_t v51 = std::__throw_bad_optional_access[abi:nn180100]();
        return;
      }
      v55.i64[1] = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr(a1) + 8 * v32);
      if (v25 != 5) {
        goto LABEL_57;
      }
      unsigned int v34 = mlir::anec::getIndexFromDim(2, 5uLL);
      if (!v35) {
        goto LABEL_69;
      }
      uint64_t v36 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr(a1) + 8 * v34);
LABEL_58:
      uint64_t v56 = v36;
      uint64_t v57 = 1;
      char v58 = 0;
      uint64_t v60 = v24;
      uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v60);
      if (DefiningOp)
      {
        uint64_t v38 = DefiningOp;
        uint64_t v39 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
        LOBYTE(DefiningOp) = (*(uint64_t (**)(void, uint64_t))(**(void **)(v38 + 48) + 32))(*(void *)(v38 + 48), v39);
      }
      char v59 = DefiningOp;
      uint64_t v40 = *(unsigned int *)(a4 + 8);
      unint64_t v41 = *(void *)a4;
      if (v40 >= *(_DWORD *)(a4 + 12))
      {
        unint64_t v48 = v40 + 1;
        BOOL v49 = v41 + (v40 << 6) > (unint64_t)&v53;
        if (v41 <= (unint64_t)&v53 && v49)
        {
          unint64_t v50 = (char *)&v53 - v41;
          llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v52, v48, 64);
          unint64_t v41 = *(void *)a4;
          uint64_t v42 = &v50[*(void *)a4];
          goto LABEL_62;
        }
        llvm::SmallVectorBase<unsigned int>::grow_pod(a4, v52, v48, 64);
        unint64_t v41 = *(void *)a4;
      }
      uint64_t v42 = (char *)&v53;
LABEL_62:
      unint64_t v43 = (_OWORD *)(v41 + ((unint64_t)*(unsigned int *)(a4 + 8) << 6));
      long long v44 = *(_OWORD *)v42;
      long long v45 = *((_OWORD *)v42 + 1);
      long long v46 = *((_OWORD *)v42 + 3);
      void v43[2] = *((_OWORD *)v42 + 2);
      v43[3] = v46;
      *unint64_t v43 = v44;
      v43[1] = v45;
      ++*(_DWORD *)(a4 + 8);
      a1 = (mlir::MemoryMapperInterface *)((char *)a1 + 16);
      v8 -= 16;
      if (!v8) {
        return;
      }
    }
    int64x2_t v54 = vdupq_n_s64(1uLL);
    int64x2_t v55 = v54;
LABEL_57:
    uint64_t v36 = 1;
    goto LABEL_58;
  }
  if (a2) {
    goto LABEL_4;
  }
}

mlir::Diagnostic *mlir::anec::anonymous namespace'::emitOpWarning@<X0>(uint64_t *a1@<X0>, const void ***a2@<X1>, uint64_t a3@<X8>)
{
  v12[23] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (mlir::Attribute *)(a1 + 3);
  mlir::emitWarning(a1[3], (uint64_t)&v11);
  if (v11)
  {
    mlir::Diagnostic::operator<<((uint64_t)v12, "'");
    if (v11)
    {
      mlir::Diagnostic::operator<<((uint64_t)v12, a1[6]);
      if (v11)
      {
        mlir::Diagnostic::operator<<((uint64_t)v12, "' op ");
        if (v11) {
          mlir::Diagnostic::operator<<((uint64_t)v12, a2);
        }
      }
    }
  }
  mlir::InFlightDiagnostic::InFlightDiagnostic(a3, (uint64_t)&v11);
  if (v11) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v11);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v12);
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext(v6);
  BOOL result = (mlir::Diagnostic *)mlir::MLIRContext::shouldPrintOpOnDiagnostic(Context);
  if (result)
  {
    unint64_t v9 = (mlir::Diagnostic *)mlir::Diagnostic::attachNote((uint64_t *)(a3 + 8), a1[3], 1);
    mlir::Diagnostic::operator<<((uint64_t)v9, "see current operation: ");
    mlir::OpPrintingFlags::OpPrintingFlags((mlir::OpPrintingFlags *)&v11);
    uint64_t v10 = (const mlir::OpPrintingFlags *)mlir::OpPrintingFlags::printGenericOpForm((uint64_t)&v11, 1);
    return mlir::Diagnostic::appendOp(v9, (mlir::Operation *)a1, v10);
  }
  return result;
}

uint64_t mlir::anec::Linear::addOpToNetwork(uint64_t *a1, uint64_t a2, mlir::anec::ANECIRWeights *a3)
{
  uint64_t v6 = *a1;
  uint64_t v7 = *(void *)(*a1 + 72);
  uint64_t v8 = *(void *)(v7 + 24);
  uint64_t v117 = *(void *)(v7 + 56);
  LODWORD(v7) = *(_DWORD *)(v6 + 36);
  uint64_t v9 = v6 - 16;
  if (v7) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t v11 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v11) {
    goto LABEL_13;
  }
  uint64_t v12 = *v11;
  unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v14 = *(unsigned int *)(v12 + 16);
  if (!v14) {
    goto LABEL_13;
  }
  BOOL v15 = *(void **)(v12 + 8);
  BOOL v16 = &v15[2 * v14];
  do
  {
    unint64_t v17 = v14 >> 1;
    BOOL v18 = &v15[2 * (v14 >> 1)];
    unint64_t v20 = *v18;
    BOOL v19 = v18 + 2;
    v14 += ~(v14 >> 1);
    if (v20 < v13) {
      BOOL v15 = v19;
    }
    else {
      unint64_t v14 = v17;
    }
  }
  while (v14);
  if (v15 != v16 && *v15 == v13) {
    uint64_t v21 = v15[1];
  }
  else {
LABEL_13:
  }
    uint64_t v21 = 0;
  v116[0] = v11;
  v116[1] = v21;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v116);
  unint64_t v22 = (uint64_t *)(*(void *)(v8 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v22) {
    goto LABEL_23;
  }
  uint64_t v23 = *v22;
  unint64_t v24 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v25 = *(unsigned int *)(v23 + 16);
  if (!v25) {
    goto LABEL_23;
  }
  unint64_t v26 = *(void **)(v23 + 8);
  char v27 = &v26[2 * v25];
  do
  {
    unint64_t v28 = v25 >> 1;
    char v29 = &v26[2 * (v25 >> 1)];
    unint64_t v31 = *v29;
    unsigned int v30 = v29 + 2;
    v25 += ~(v25 >> 1);
    if (v31 < v24) {
      unint64_t v26 = v30;
    }
    else {
      unint64_t v25 = v28;
    }
  }
  while (v25);
  if (v26 != v27 && *v26 == v24) {
    uint64_t v32 = v26[1];
  }
  else {
LABEL_23:
  }
    uint64_t v32 = 0;
  v115[0] = v22;
  v115[1] = v32;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v115);
  char v33 = (uint64_t *)(*(void *)(v117 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v33) {
    goto LABEL_33;
  }
  uint64_t v34 = *v33;
  unint64_t v35 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v36 = *(unsigned int *)(v34 + 16);
  if (!v36) {
    goto LABEL_33;
  }
  unint64_t v37 = *(void **)(v34 + 8);
  uint64_t v38 = &v37[2 * v36];
  do
  {
    unint64_t v39 = v36 >> 1;
    uint64_t v40 = &v37[2 * (v36 >> 1)];
    unint64_t v42 = *v40;
    unint64_t v41 = v40 + 2;
    v36 += ~(v36 >> 1);
    if (v42 < v35) {
      unint64_t v37 = v41;
    }
    else {
      unint64_t v36 = v39;
    }
  }
  while (v36);
  if (v37 != v38 && *v37 == v35) {
    uint64_t v43 = v37[1];
  }
  else {
LABEL_33:
  }
    uint64_t v43 = 0;
  *(void *)&long long v114 = v33;
  *((void *)&v114 + 1) = v43;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v114);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v117);
  uint64_t v45 = mlir::anec::ANECIRWeights::lookupConstant(a3, DefiningOp);
  long long v46 = (char *)operator new(0xF8uLL);
  *((_OWORD *)v46 + 4) = 0u;
  *((_OWORD *)v46 + 5) = 0u;
  *((_OWORD *)v46 + 6) = 0u;
  *((_OWORD *)v46 + 7) = 0u;
  *(_OWORD *)long long v46 = 0u;
  *((_OWORD *)v46 + 1) = 0u;
  *((_OWORD *)v46 + 2) = 0u;
  *((_OWORD *)v46 + 3) = 0u;
  *((_OWORD *)v46 + 8) = 0u;
  *((_OWORD *)v46 + 9) = 0u;
  *((_OWORD *)v46 + 10) = 0u;
  *((_OWORD *)v46 + 11) = 0u;
  *((_OWORD *)v46 + 12) = 0u;
  *((_OWORD *)v46 + 13) = 0u;
  *((_OWORD *)v46 + 14) = 0u;
  *((void *)v46 + 30) = 0;
  *((void *)v46 + 9) = -1;
  *((_DWORD *)v46 + 22) = -1;
  *((void *)v46 + 12) = -1;
  *((_DWORD *)v46 + 26) = -1;
  *((void *)v46 + 14) = -1;
  *((void *)v46 + 21) = 0;
  *(_OWORD *)(v46 + 152) = 0u;
  *(_OWORD *)(v46 + 136) = 0u;
  *(_OWORD *)(v46 + 120) = 0u;
  *((_DWORD *)v46 + 44) = 1;
  *((_DWORD *)v46 + 48) = -1;
  *((void *)v46 + 25) = -1;
  *((_DWORD *)v46 + 52) = -1;
  *((void *)v46 + 27) = -1;
  *((void *)v46 + 28) = 0x3F80000000000006;
  *(void *)long long v46 = &unk_1EC986570;
  *((_DWORD *)v46 + 60) = 5;
  *((_DWORD *)v46 + 60) = 5;
  *((_DWORD *)v46 + 22) = 0;
  *((void *)v46 + 12) = v45;
  long long v118 = v114;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v118);
  unint64_t v48 = *(void **)(*(void *)OperandRange + 136);
  if (v48 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    if (v48 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id)
    {
      int v49 = 4;
    }
    else if (v48 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id)
    {
      int v49 = 6;
    }
    else
    {
      int v49 = 0;
    }
    goto LABEL_48;
  }
  uint64_t v119 = OperandRange;
  int Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&v119);
  if (Width == 16)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v119) == 1)
    {
      int v49 = 3;
      goto LABEL_48;
    }
    goto LABEL_47;
  }
  if (Width != 8)
  {
LABEL_47:
    int v49 = 0;
    goto LABEL_48;
  }
  if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v119) == 2) {
    int v49 = 2;
  }
  else {
    int v49 = 1;
  }
LABEL_48:
  *((_DWORD *)v46 + 20) = 1;
  *((_DWORD *)v46 + 21) = v49;
  if (!mlir::anec::Linear::getKernelScaleAttr((mlir::Operation **)a1)) {
    goto LABEL_90;
  }
  KernelScaleAttr = (uint64_t *)mlir::anec::Linear::getKernelScaleAttr((mlir::Operation **)a1);
  uint64_t v52 = (uint64_t)KernelScaleAttr;
  if (!KernelScaleAttr) {
    goto LABEL_58;
  }
  uint64_t v53 = *KernelScaleAttr;
  unint64_t v54 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v55 = *(unsigned int *)(v53 + 16);
  if (!v55) {
    goto LABEL_58;
  }
  uint64_t v56 = *(void **)(v53 + 8);
  uint64_t v57 = &v56[2 * v55];
  do
  {
    unint64_t v58 = v55 >> 1;
    char v59 = &v56[2 * (v55 >> 1)];
    unint64_t v61 = *v59;
    uint64_t v60 = v59 + 2;
    v55 += ~(v55 >> 1);
    if (v61 < v54) {
      uint64_t v56 = v60;
    }
    else {
      unint64_t v55 = v58;
    }
  }
  while (v55);
  if (v56 != v57 && *v56 == v54) {
    uint64_t v62 = v56[1];
  }
  else {
LABEL_58:
  }
    uint64_t v62 = 0;
  uint64_t SplatFloat = mlir::getSplatFloatValue<float>(v52, v62);
  if ((SplatFloat & 0xFF00000000) != 0)
  {
    *((_DWORD *)v46 + 57) = SplatFloat;
    goto LABEL_90;
  }
  uint64_t v64 = (uint64_t *)mlir::anec::Linear::getKernelScaleAttr((mlir::Operation **)a1);
  uint64_t v65 = (uint64_t)v64;
  if (!v64) {
    goto LABEL_70;
  }
  uint64_t v66 = *v64;
  unint64_t v67 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v68 = *(unsigned int *)(v66 + 16);
  if (!v68) {
    goto LABEL_70;
  }
  unint64_t v69 = *(void **)(v66 + 8);
  unint64_t v70 = &v69[2 * v68];
  do
  {
    unint64_t v71 = v68 >> 1;
    uint64_t v72 = &v69[2 * (v68 >> 1)];
    unint64_t v74 = *v72;
    uint64_t v73 = v72 + 2;
    v68 += ~(v68 >> 1);
    if (v74 < v67) {
      unint64_t v69 = v73;
    }
    else {
      unint64_t v68 = v71;
    }
  }
  while (v68);
  if (v69 != v70 && *v69 == v67) {
    uint64_t v75 = v69[1];
  }
  else {
LABEL_70:
  }
    uint64_t v75 = 0;
  uint64_t v76 = mlir::anec::ANECIRWeights::addConstant((uint64_t *)a3, v65, v75);
  uint64_t v113 = mlir::anec::Linear::getKernelScaleAttr((mlir::Operation **)a1);
  *(void *)&long long v118 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v113);
  *((void *)&v118 + 1) = v77;
  uint64_t v78 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v118);
  char v79 = *(void **)(*(void *)v78 + 136);
  if (v79 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    if (v79 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id)
    {
      int v80 = 4;
    }
    else if (v79 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id)
    {
      int v80 = 6;
    }
    else
    {
      int v80 = 0;
    }
    goto LABEL_89;
  }
  uint64_t v119 = v78;
  int v81 = mlir::IntegerType::getWidth((mlir::IntegerType *)&v119);
  if (v81 != 16)
  {
    if (v81 == 8)
    {
      if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v119) == 2) {
        int v80 = 2;
      }
      else {
        int v80 = 1;
      }
      goto LABEL_89;
    }
    goto LABEL_88;
  }
  if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v119) != 1)
  {
LABEL_88:
    int v80 = 0;
    goto LABEL_89;
  }
  int v80 = 3;
LABEL_89:
  *((_DWORD *)v46 + 56) = v80;
  v46[184] = 1;
  *((_DWORD *)v46 + 48) = 0;
  *((void *)v46 + 25) = v76;
LABEL_90:
  if (mlir::anec::Linear::getKernelZeroPointAttr((mlir::Operation **)a1))
  {
    KernelZeroPointAttr = (uint64_t *)mlir::anec::Linear::getKernelZeroPointAttr((mlir::Operation **)a1);
    uint64_t v83 = (uint64_t)KernelZeroPointAttr;
    if (!KernelZeroPointAttr) {
      goto LABEL_100;
    }
    uint64_t v84 = *KernelZeroPointAttr;
    unint64_t v85 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v86 = *(unsigned int *)(v84 + 16);
    if (!v86) {
      goto LABEL_100;
    }
    uint64_t v87 = *(void **)(v84 + 8);
    uint64_t v88 = &v87[2 * v86];
    do
    {
      unint64_t v89 = v86 >> 1;
      uint64_t v90 = &v87[2 * (v86 >> 1)];
      unint64_t v92 = *v90;
      long long v91 = v90 + 2;
      v86 += ~(v86 >> 1);
      if (v92 < v85) {
        uint64_t v87 = v91;
      }
      else {
        unint64_t v86 = v89;
      }
    }
    while (v86);
    if (v87 != v88 && *v87 == v85) {
      uint64_t v93 = v87[1];
    }
    else {
LABEL_100:
    }
      uint64_t v93 = 0;
    uint64_t SplatInt = mlir::getSplatIntValue<int>(v83, v93);
    if ((SplatInt & 0xFF00000000) != 0)
    {
      *((_DWORD *)v46 + 58) = SplatInt;
    }
    else
    {
      uint64_t v95 = (uint64_t *)mlir::anec::Linear::getKernelZeroPointAttr((mlir::Operation **)a1);
      uint64_t v96 = (uint64_t)v95;
      if (!v95) {
        goto LABEL_112;
      }
      uint64_t v97 = *v95;
      unint64_t v98 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v99 = *(unsigned int *)(v97 + 16);
      if (!v99) {
        goto LABEL_112;
      }
      uint64_t v100 = *(void **)(v97 + 8);
      uint64_t v101 = &v100[2 * v99];
      do
      {
        unint64_t v102 = v99 >> 1;
        uint64_t v103 = &v100[2 * (v99 >> 1)];
        unint64_t v105 = *v103;
        uint64_t v104 = v103 + 2;
        v99 += ~(v99 >> 1);
        if (v105 < v98) {
          uint64_t v100 = v104;
        }
        else {
          unint64_t v99 = v102;
        }
      }
      while (v99);
      if (v100 != v101 && *v100 == v98) {
        uint64_t v106 = v100[1];
      }
      else {
LABEL_112:
      }
        uint64_t v106 = 0;
      uint64_t v107 = mlir::anec::ANECIRWeights::addConstant((uint64_t *)a3, v96, v106);
      v46[185] = 1;
      *((_DWORD *)v46 + 52) = 0;
      *((void *)v46 + 27) = v107;
    }
  }
  __int16 v108 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v108->__shared_owners_ = 0;
  v108->__shared_weak_owners_ = 0;
  v108->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  v108[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v108[1].__shared_owners_;
  if (v46[31] < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *((const std::string::value_type **)v46 + 1), *((void *)v46 + 2));
  }
  else
  {
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = *(_OWORD *)(v46 + 8);
    v108[2].__vftable = (std::__shared_weak_count_vtbl *)*((void *)v46 + 3);
  }
  LODWORD(v108[2].__shared_owners_) = 17;
  v108[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v108[2].__shared_weak_owners_ = (uint64_t)v46;
  LOBYTE(v108[3].__vftable) = 0;
  v108[3].__shared_owners_ = 0;
  v108[3].__shared_weak_owners_ = (uint64_t)&v108[4].__shared_owners_;
  v108[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v108[5].__shared_weak_owners_ = (uint64_t)&v108[6].__shared_owners_;
  v108[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v118 = v108 + 1;
  *((void *)&v118 + 1) = v108;
  uint64_t v110 = *(void **)(a2 + 232);
  if ((unint64_t)v110 >= *(void *)(a2 + 240))
  {
    uint64_t v111 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v118);
    __int16 v108 = (std::__shared_weak_count *)*((void *)&v118 + 1);
    *(void *)(a2 + 232) = v111;
    if (!v108) {
      return 1;
    }
  }
  else
  {
    *uint64_t v110 = v108 + 1;
    v110[1] = v108;
    atomic_fetch_add_explicit(&v108->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v110 + 2;
  }
  if (!atomic_fetch_add(&v108->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v108->__on_zero_shared)(v108);
    std::__shared_weak_count::__release_weak(v108);
  }
  return 1;
}

uint64_t mlir::anec::Deconvolution::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v114[21] = *MEMORY[0x1E4F143B8];
  uint64_t v104 = a6;
  LOBYTE(v105) = 0;
  char v106 = 0;
  uint64_t v107 = a7;
  uint64_t v108 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v104);
    if (v106) {
      char v106 = 0;
    }
    mlir::OperationName::OperationName(&v105, "anec.deconvolution", 18, Context);
    char v106 = 1;
  }
  uint64_t v109 = a4;
  uint64_t v110 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  uint64_t v18 = a3;
  if (a3) {
    uint64_t v19 = (uint64_t)a2;
  }
  else {
    uint64_t v19 = v17;
  }
  if (!mlir::anec::DeconvolutionAdaptor::verify(&v104, v19)) {
    return 0;
  }
  unint64_t v20 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  v95[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(v20);
  v95[1] = v21;
  if (!v95[0])
  {
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v111);
      if (v111)
      {
        unint64_t v24 = "input must be a ShapedType";
        goto LABEL_17;
      }
LABEL_18:
      uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v111);
      if (v111) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v111);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v112);
      return v25;
    }
    return 0;
  }
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v95);
  if (v23 >= 6)
  {
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v111);
      if (v111)
      {
        unint64_t v24 = "input tensor rank of 4 or 5 are supported";
LABEL_17:
        mlir::Diagnostic::operator<<((uint64_t)&v112, v24);
        goto LABEL_18;
      }
      goto LABEL_18;
    }
    return 0;
  }
  char v27 = (uint64_t *)ArgAttrsAttr;
  v102[0] = v103;
  v102[1] = (void *)0x300000000;
  unint64_t v28 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v104) + 32);
  char v29 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v104);
  unsigned int v30 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v28, v29, *(void *)(*(void *)(v105 + 96) + 56));
  if (v31) {
    uint64_t v32 = *((void *)v30 + 1);
  }
  else {
    uint64_t v32 = 0;
  }
  mlir::getValues<unsigned long long>(v32, (uint64_t)v102);
  v100[0] = v101;
  v100[1] = (void *)0x300000000;
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v104);
  uint64_t v34 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v104);
  unint64_t v35 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v34 - 32), *(void *)(*(void *)(v105 + 96) + 8));
  if (v36) {
    uint64_t v37 = *((void *)v35 + 1);
  }
  else {
    uint64_t v37 = 0;
  }
  mlir::getValues<unsigned long long>(v37, (uint64_t)v100);
  v98[0] = v99;
  v98[1] = (void *)0x600000000;
  uint64_t v38 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v104) + 16);
  uint64_t v39 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v104);
  uint64_t v40 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v38, (mlir::CallGraphNode *)(v39 - 16), *(void *)(*(void *)(v105 + 96) + 40));
  if (v41) {
    uint64_t v42 = *((void *)v40 + 1);
  }
  else {
    uint64_t v42 = 0;
  }
  mlir::getValues<unsigned long long>(v42, (uint64_t)v98);
  uint64_t v43 = (void *)mlir::TypeRange::dereference_iterator(a9, 1);
  long long v44 = v43;
  if (!v43) {
    goto LABEL_41;
  }
  uint64_t v45 = *v43;
  unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v47 = *(unsigned int *)(v45 + 16);
  if (!v47) {
    goto LABEL_41;
  }
  unint64_t v48 = *(void **)(v45 + 8);
  int v49 = &v48[2 * v47];
  do
  {
    unint64_t v50 = v47 >> 1;
    uint64_t v51 = &v48[2 * (v47 >> 1)];
    unint64_t v53 = *v51;
    uint64_t v52 = v51 + 2;
    v47 += ~(v47 >> 1);
    if (v53 < v46) {
      unint64_t v48 = v52;
    }
    else {
      unint64_t v47 = v50;
    }
  }
  while (v47);
  if (v48 != v49 && *v48 == v46) {
    uint64_t v54 = v48[1];
  }
  else {
LABEL_41:
  }
    uint64_t v54 = 0;
  v94[0] = v44;
  v94[1] = v54;
  unint64_t v55 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
  if (v56 >= 6)
  {
    if (v18)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v111);
      if (v111) {
        mlir::Diagnostic::operator<<((uint64_t)&v112, "filter must be a tensor of rank 4 or 5");
      }
LABEL_51:
      uint64_t v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v111);
      if (v111) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v111);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v112);
      goto LABEL_71;
    }
    goto LABEL_54;
  }
  uint64_t Groups = (uint64_t)mlir::anec::detail::ConvolutionGenericAdaptorBase::getGroups((mlir::anec::detail::ConvolutionGenericAdaptorBase *)&v104);
  uint64_t v93 = Groups;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v95);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v58);
  if (v60)
  {
    uint64_t v92 = v27[IndexFromDim];
    if (v92 % Groups)
    {
      v88[0] = (uint64_t)"input channels {0} should be divisible by groups {1}";
      v88[1] = 52;
      v88[2] = (uint64_t)v91;
      v88[3] = 2;
      v89[0] = &unk_1EC9A4648;
      v89[1] = &v92;
      v90[0] = &unk_1EC9A4648;
      v90[1] = &v93;
      v91[0] = v89;
      v91[1] = v90;
      if (v18)
      {
        mlir::emitError((uint64_t)a2, (uint64_t)&v111);
        if (v111)
        {
          __int16 v97 = 263;
          uint64_t v96 = (const void **)v88;
          mlir::Diagnostic::operator<<((uint64_t)&v112, &v96);
        }
        goto LABEL_51;
      }
LABEL_54:
      uint64_t v25 = 0;
LABEL_71:
      if (v98[0] != v99) {
        free(v98[0]);
      }
      if (v100[0] != v101) {
        free(v100[0]);
      }
      if (v102[0] != v103) {
        free(v102[0]);
      }
      return v25;
    }
    uint64_t v61 = v55[1];
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v95);
    unint64_t v63 = mlir::anec::getIndexFromDim(3, v62);
    if (v64)
    {
      unint64_t v65 = v63;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v95);
      unint64_t v67 = mlir::anec::getIndexFromDim(4, v66);
      if (v68)
      {
        unint64_t v69 = v67;
        uint64_t v87 = v61 * Groups;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
        uint64_t v71 = v70;
        uint64_t v72 = *((void *)v98[0] + 2) + *((void *)v102[0] + 1) * v27[v65] + *((void *)v98[0] + 3) - v55[2] + 1;
        uint64_t v73 = *((void *)v98[0] + 4) + *((void *)v102[0] + 2) * v27[v69] + *((void *)v98[0] + 5) - v55[3] + 1;
        uint64_t v74 = *v27;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v95);
        unint64_t v76 = mlir::anec::getIndexFromDim(2, v75);
        if (v77)
        {
          uint64_t v78 = 4;
          if (v71 == 4) {
            uint64_t v78 = 0x1FFFFFFFFFFFFFFFLL;
          }
          uint64_t v79 = *(void *)v98[0] + *(void *)v102[0] * v27[v76] + *((void *)v98[0] + 1) - v55[v78] + 1;
        }
        else
        {
          uint64_t v79 = 0;
        }
        uint64_t v111 = &v113;
        uint64_t v113 = v74;
        v114[0] = v87;
        v114[1] = v72;
        v114[2] = v73;
        uint64_t v112 = 0x600000004;
        if (v79)
        {
          v88[0] = v79;
          llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v111, (uint64_t)v114, v88);
          int v80 = (uint64_t *)v111;
          uint64_t v81 = v112;
        }
        else
        {
          uint64_t v81 = 4;
          int v80 = &v113;
        }
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v95);
        uint64_t v83 = mlir::MemRefType::get(v80, (mlir::AffineMap *)v81, OperandRange, 0, 0, 0);
        uint64_t v84 = *(unsigned int *)(a11 + 8);
        if (v84 >= *(_DWORD *)(a11 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v84 + 1, 8);
          LODWORD(v84) = *(_DWORD *)(a11 + 8);
        }
        *(void *)(*(void *)a11 + 8 * v84) = v83;
        ++*(_DWORD *)(a11 + 8);
        if (v111 != &v113) {
          free(v111);
        }
        uint64_t v25 = 1;
        goto LABEL_71;
      }
    }
  }
  unint64_t v85 = (uint64_t *)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::anec::DeconvolutionAdaptor::verify(v85, v86);
}

uint64_t mlir::anec::DeconvolutionAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v89[23] = *MEMORY[0x1E4F143B8];
  uint64_t v83 = *a1;
  uint64_t Value = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v83);
  char v82 = 0;
  if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83))
  {
LABEL_7:
    uint64_t v6 = "'anec.deconvolution' op requires attribute 'dilation'";
LABEL_70:
    uint64_t v79 = (uint64_t *)v6;
    __int16 v81 = 259;
    mlir::emitError(a2, (uint64_t)&v79, (uint64_t)&v88);
    uint64_t v48 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v88);
    if (v88) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v88);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v89);
    return v48;
  }
  uint64_t v5 = 0;
  while (*(void *)(*(void *)(a1[1] + 96) + 8) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      uint64_t v5 = Value[1];
    }
    Value += 2;
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83)) {
      goto LABEL_7;
    }
  }
  char v82 = (uint64_t *)Value[1];
  char v77 = 0;
  uint64_t v78 = 0;
  unint64_t v76 = 0;
  if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83))
  {
LABEL_18:
    uint64_t v6 = "'anec.deconvolution' op requires attribute 'padding'";
    goto LABEL_70;
  }
  uint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  while (*(void *)(*(void *)(a1[1] + 96) + 40) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      uint64_t v9 = (uint64_t *)Value[1];
    }
    else if (*(void *)(*(void *)(a1[1] + 96) + 24) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      uint64_t v8 = (uint64_t *)Value[1];
      char v77 = v8;
    }
    else if (*(void *)(*(void *)(a1[1] + 96) + 32) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      uint64_t v7 = (uint64_t *)Value[1];
      unint64_t v76 = v7;
    }
    Value += 2;
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83)) {
      goto LABEL_18;
    }
  }
  uint64_t v78 = (uint64_t *)Value[1];
  if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83))
  {
LABEL_25:
    uint64_t v6 = "'anec.deconvolution' op requires attribute 'stride'";
    goto LABEL_70;
  }
  uint64_t v10 = 0;
  while (*(void *)(*(void *)(a1[1] + 96) + 56) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (*(void *)(*(void *)(a1[1] + 96) + 48) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      uint64_t v10 = Value[1];
    }
    Value += 2;
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v83)) {
      goto LABEL_25;
    }
  }
  uint64_t v11 = (uint64_t *)Value[1];
  if (v11)
  {
    if (!mlir::DenseIntElementsAttr::classof(Value[1])) {
      goto LABEL_68;
    }
    uint64_t v12 = *v11;
    unint64_t v13 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v14 = *(unsigned int *)(v12 + 16);
    if (!v14) {
      goto LABEL_36;
    }
    BOOL v15 = *(void **)(v12 + 8);
    BOOL v16 = &v15[2 * v14];
    do
    {
      unint64_t v17 = v14 >> 1;
      uint64_t v18 = &v15[2 * (v14 >> 1)];
      unint64_t v20 = *v18;
      uint64_t v19 = v18 + 2;
      v14 += ~(v14 >> 1);
      if (v20 < v13) {
        BOOL v15 = v19;
      }
      else {
        unint64_t v14 = v17;
      }
    }
    while (v14);
    if (v15 != v16 && *v15 == v13) {
      uint64_t v21 = v15[1];
    }
    else {
LABEL_36:
    }
      uint64_t v21 = 0;
    uint64_t v79 = v11;
    uint64_t v80 = v21;
    Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
    unint64_t v23 = Type;
    if (!Type) {
      goto LABEL_46;
    }
    uint64_t v24 = *Type;
    unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v26 = *(unsigned int *)(v24 + 16);
    if (!v26) {
      goto LABEL_46;
    }
    char v27 = *(void **)(v24 + 8);
    unint64_t v28 = &v27[2 * v26];
    do
    {
      unint64_t v29 = v26 >> 1;
      unsigned int v30 = &v27[2 * (v26 >> 1)];
      unint64_t v32 = *v30;
      char v31 = v30 + 2;
      v26 += ~(v26 >> 1);
      if (v32 < v25) {
        char v27 = v31;
      }
      else {
        unint64_t v26 = v29;
      }
    }
    while (v26);
    if (v27 != v28 && *v27 == v25) {
      uint64_t v33 = v27[1];
    }
    else {
LABEL_46:
    }
      uint64_t v33 = 0;
    uint64_t v88 = v23;
    v89[0] = v33;
    uint64_t ArgAttrsAttr = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
    uint64_t v86 = 3;
    if (v35 != 1
      || *ArgAttrsAttr != (uint64_t *)v86
      || (uint64_t v67 = (uint64_t)v11,
          uint64_t v74 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v67),
          uint64_t v75 = v36,
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v74),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
LABEL_68:
      uint64_t v6 = "'anec.deconvolution' op attribute 'stride' failed to satisfy constraint: ui64 elements attribute of shape {3}";
      goto LABEL_70;
    }
  }
  if (v82)
  {
    if (!mlir::DenseIntElementsAttr::classof((uint64_t)v82)) {
      goto LABEL_69;
    }
    uint64_t v79 = mlir::Attribute::cast<mlir::ElementsAttr>(&v82);
    uint64_t v80 = v37;
    uint64_t v86 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
    uint64_t v88 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v86);
    v89[0] = v38;
    uint64_t v39 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
    uint64_t OperandRange = 3;
    if (v40 != 1
      || *v39 != OperandRange
      || (uint64_t v73 = v82,
          uint64_t v74 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v73),
          uint64_t v75 = v41,
          uint64_t v67 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v74),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&v67, 64)))
    {
LABEL_69:
      uint64_t v6 = "'anec.deconvolution' op attribute 'dilation' failed to satisfy constraint: ui64 elements attribute of shape {3}";
      goto LABEL_70;
    }
  }
  if (!v78) {
    goto LABEL_61;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v78)) {
    goto LABEL_74;
  }
  uint64_t v79 = mlir::Attribute::cast<mlir::ElementsAttr>(&v78);
  uint64_t v80 = v42;
  uint64_t v86 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
  uint64_t v88 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v86);
  v89[0] = v43;
  long long v44 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
  uint64_t OperandRange = 6;
  if (v45 != 1) {
    goto LABEL_74;
  }
  if (*v44 == OperandRange
    && (uint64_t v73 = v78,
        uint64_t v74 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v73),
        uint64_t v75 = v46,
        uint64_t v67 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v74),
        mlir::Type::isUnsignedInteger((mlir::Type *)&v67, 64)))
  {
LABEL_61:
    if (v10 && (mlir::anec::PaddingModeAttr::classof(v10) & 1) == 0)
    {
      unint64_t v47 = "'anec.deconvolution' op attribute 'padding_mode' failed to satisfy constraint: valid PaddingMode";
    }
    else if (!v9 {
           || *(_UNKNOWN **)(*v9 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    }
           && (uint64_t v79 = v9,
               uint64_t v88 = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v79),
               mlir::Type::isUnsignedInteger((mlir::Type *)&v88, 64)))
    {
      if (!v5 || *(_UNKNOWN **)(*(void *)v5 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        if (!v8) {
          goto LABEL_97;
        }
        if (!mlir::DenseFPElementsAttr::classof((uint64_t)v8)) {
          goto LABEL_93;
        }
        uint64_t v79 = mlir::Attribute::cast<mlir::ElementsAttr>(&v77);
        uint64_t v80 = v50;
        uint64_t v73 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
        uint64_t v88 = mlir::Type::cast<mlir::ShapedType>(&v73);
        v89[0] = v51;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
        if (v52)
        {
          uint64_t v86 = (uint64_t)mlir::Attribute::cast<mlir::ElementsAttr>(&v77);
          uint64_t v87 = v53;
          uint64_t v72 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v86);
          uint64_t v74 = mlir::Type::cast<mlir::ShapedType>(&v72);
          uint64_t v75 = v54;
          mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v74);
          if (v55 != 1) {
            goto LABEL_93;
          }
        }
        uint64_t v70 = v77;
        uint64_t OperandRange = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
        uint64_t v85 = v56;
        uint64_t v71 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange);
        if (mlir::Type::isF16((mlir::Type *)&v71)
          || (unint64_t v66 = v77,
              uint64_t v67 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v66),
              uint64_t v68 = v57,
              uint64_t v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v67),
              mlir::Type::isF32((mlir::Type *)&v69)))
        {
LABEL_97:
          if (!v7) {
            return 1;
          }
          if (mlir::DenseIntElementsAttr::classof((uint64_t)v7))
          {
            uint64_t v79 = mlir::Attribute::cast<mlir::ElementsAttr>(&v76);
            uint64_t v80 = v58;
            uint64_t v73 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v79);
            uint64_t v88 = mlir::Type::cast<mlir::ShapedType>(&v73);
            v89[0] = v59;
            mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v88);
            if (!v60
              || (uint64_t v86 = (uint64_t)mlir::Attribute::cast<mlir::ElementsAttr>(&v76),
                  uint64_t v87 = v61,
                  uint64_t v72 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v86),
                  uint64_t v74 = mlir::Type::cast<mlir::ShapedType>(&v72),
                  uint64_t v75 = v62,
                  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v74),
                  v63 == 1))
            {
              uint64_t v70 = v76;
              uint64_t OperandRange = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v70);
              uint64_t v85 = v64;
              uint64_t v71 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&OperandRange);
              if (mlir::Type::isSignedInteger((mlir::Type *)&v71, 8)) {
                return 1;
              }
              unint64_t v66 = v76;
              uint64_t v67 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v66);
              uint64_t v68 = v65;
              uint64_t v69 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v67);
              if (mlir::Type::isUnsignedInteger((mlir::Type *)&v69, 8)) {
                return 1;
              }
            }
          }
          unint64_t v47 = "'anec.deconvolution' op attribute 'kernel_zero_point' failed to satisfy constraint: si8 or ui8 elements "
                "attribute of rank 0/1";
        }
        else
        {
LABEL_93:
          unint64_t v47 = "'anec.deconvolution' op attribute 'kernel_scale' failed to satisfy constraint: f16 or f32 elements attri"
                "bute of rank 0/1";
        }
      }
      else
      {
        unint64_t v47 = "'anec.deconvolution' op attribute 'channel_wise' failed to satisfy constraint: unit attribute";
      }
    }
    else
    {
      unint64_t v47 = "'anec.deconvolution' op attribute 'groups' failed to satisfy constraint: 64-bit unsigned integer attribute";
    }
  }
  else
  {
LABEL_74:
    unint64_t v47 = "'anec.deconvolution' op attribute 'padding' failed to satisfy constraint: ui64 elements attribute of shape {6}";
  }
  uint64_t v79 = (uint64_t *)v47;
  __int16 v81 = 259;
  mlir::emitError(a2, (uint64_t)&v79, (uint64_t)&v88);
  uint64_t v48 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v88);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v88);
  return v48;
}

uint64_t mlir::anec::Deconvolution::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  ANECConvLayerDescInitialize();
  uint64_t v6 = *(uint64_t **)a2;
  if (!*(void *)a2) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    unint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v114[0] = v6;
  v114[1] = v16;
  unint64_t v17 = (uint64_t *)*((void *)a2 + 2);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *v17;
  unint64_t v19 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v20 = *(unsigned int *)(v18 + 16);
  if (!v20) {
    goto LABEL_20;
  }
  uint64_t v21 = *(void **)(v18 + 8);
  unint64_t v22 = &v21[2 * v20];
  do
  {
    unint64_t v23 = v20 >> 1;
    uint64_t v24 = &v21[2 * (v20 >> 1)];
    unint64_t v26 = *v24;
    unint64_t v25 = v24 + 2;
    v20 += ~(v20 >> 1);
    if (v26 < v19) {
      uint64_t v21 = v25;
    }
    else {
      unint64_t v20 = v23;
    }
  }
  while (v20);
  if (v21 != v22 && *v21 == v19) {
    uint64_t v27 = v21[1];
  }
  else {
LABEL_20:
  }
    uint64_t v27 = 0;
  v113[0] = v17;
  v113[1] = v27;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v114);
  uint64_t v29 = v28;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v114);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v30);
  if (v32)
  {
    unint64_t v33 = IndexFromDim;
    long long v118 = v120;
    uint64_t v119 = 0x300000000;
    uint64_t v115 = v117;
    uint64_t v116 = 0x300000000;
    uint64_t v121 = v123;
    uint64_t v122 = 0x600000000;
    uint64_t StrideAttr = mlir::anec::Convolution::getStrideAttr(a1);
    mlir::getValues<int>(StrideAttr, (uint64_t)&v118);
    uint64_t KsizeAttr = mlir::anec::AveragePool::getKsizeAttr(a1);
    mlir::getValues<int>(KsizeAttr, (uint64_t)&v115);
    uint64_t PaddingAttr = mlir::anec::Convolution::getPaddingAttr(a1);
    mlir::getValues<int>(PaddingAttr, (uint64_t)&v121);
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v114);
    uint64_t v38 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v113);
    uint64_t v39 = v38;
    uint64_t v40 = *(void **)(ArgAttrsAttr + 8 * v33);
    if (v29 == 5)
    {
      if (v119 <= 2)
      {
        uint64_t v41 = "failed: found 2 strides, but the convolution op is 3d";
LABEL_43:
        v111[0] = (const void **)v41;
        __int16 v112 = 259;
        mlir::OpState::emitOpError((uint64_t **)a1, v111, (uint64_t)&__p);
        mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&__p);
        if (__p) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__p);
        }
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v125);
LABEL_84:
        if (v121 != v123) {
          free(v121);
        }
        if (v115 != v117) {
          free(v115);
        }
        if (v118 != v120) {
          free(v118);
        }
        return mlir::anec::verifyConvolutionWithANEC((uint64_t)v93, (uint64_t)*a1, a2, a3);
      }
      if (v116 <= 2)
      {
        uint64_t v41 = "failed: found 2 dilations, but the convolution op is 3d";
        goto LABEL_43;
      }
      if (v122 <= 5)
      {
        uint64_t v41 = "failed: found 4 paddings, but the convolution op is 3d";
        goto LABEL_43;
      }
      unint64_t v92 = a3;
      uint64_t v42 = (uint64_t *)(v38 + 32);
      uint64_t v43 = (uint64_t *)(v38 + 24);
      uint64_t v44 = *(void *)(v38 + 16);
    }
    else
    {
      unint64_t v92 = a3;
      uint64_t v42 = (uint64_t *)(v38 + 24);
      uint64_t v43 = (uint64_t *)(v38 + 16);
      uint64_t v44 = 1;
    }
    uint64_t v45 = *v42;
    uint64_t v91 = *v43;
    int v90 = *((_DWORD *)v118 + 2);
    int32x2_t v46 = *(int32x2_t *)v118;
    uint64_t v47 = *((int *)v115 + 1);
    uint64_t v48 = *((int *)v115 + 2);
    uint64_t v49 = *(int *)v115;
    uint64_t v50 = *((void *)v121 + 1);
    uint64_t v89 = *((void *)v121 + 2);
    uint64_t v51 = *(void *)v121;
    uint64_t IncPadAttr = mlir::anec::AveragePool::getIncPadAttr(a1);
    uint64_t v53 = @"ChannelWiseDeConv";
    if (!IncPadAttr) {
      uint64_t v53 = @"DeConv";
    }
    v93[0] = v53;
    v93[1] = @"Dense";
    long long __p = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v113);
    if (mlir::Type::isF16((mlir::Type *)&__p))
    {
      uint64_t v54 = @"Float16";
    }
    else if (mlir::Type::isF32((mlir::Type *)&__p))
    {
      uint64_t v54 = @"Float32";
    }
    else if (mlir::Type::isUnsignedInteger((mlir::Type *)&__p, 8))
    {
      uint64_t v54 = @"UInt8";
    }
    else
    {
      mlir::Type::isInteger((mlir::Type *)&__p, 8);
      uint64_t v54 = @"Int8";
    }
    v93[2] = v54;
    long long __p = (void *)mlir::anec::Convolution::getPaddingModeAttr(a1);
    v93[3] = *(&off_1E4FBF0D0 + mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&__p));
    uint64_t v55 = mlir::anec::AveragePool::getIncPadAttr(a1);
    uint64_t v56 = (uint64_t)v40;
    if (!v55)
    {
      uint64_t v57 = *(void *)(v39 + 8);
      v111[0] = (const void **)mlir::anec::Convolution::getGroupsAttr(a1);
      mlir::IntegerAttr::getValue(v111, (llvm::APInt *)&__p);
      if (v125[0] > 0x40u)
      {
        uint64_t v58 = *(void **)__p;
        operator delete[](__p);
      }
      else
      {
        uint64_t v58 = __p;
      }
      uint64_t v56 = (void)v58 * v57;
    }
    v93[4] = v56;
    if (!mlir::anec::AveragePool::getIncPadAttr(a1))
    {
      v111[0] = (const void **)mlir::anec::Convolution::getGroupsAttr(a1);
      mlir::IntegerAttr::getValue(v111, (llvm::APInt *)&__p);
      if (v125[0] > 0x40u)
      {
        uint64_t v40 = *(void **)__p;
        operator delete[](__p);
      }
      else
      {
        uint64_t v40 = __p;
      }
    }
    v93[5] = v40;
    char v94 = 0;
    uint64_t v95 = v45;
    uint64_t v96 = v91;
    uint64_t v97 = v44;
    int v98 = v90;
    *(int32x2_t *)&long long v59 = vrev64_s32(v46);
    *((void *)&v59 + 1) = v89;
    long long v99 = v59;
    uint64_t v100 = v50;
    uint64_t v101 = v51;
    char v102 = 0;
    uint64_t v103 = v48;
    uint64_t v104 = v47;
    uint64_t v105 = v49;
    a3 = v92;
    if (mlir::anec::Convolution::getKernelScaleAttr(a1))
    {
      KernelScaleAttr = (uint64_t *)mlir::anec::Convolution::getKernelScaleAttr(a1);
      uint64_t v61 = (uint64_t)KernelScaleAttr;
      if (!KernelScaleAttr) {
        goto LABEL_66;
      }
      uint64_t v62 = *KernelScaleAttr;
      unint64_t v63 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v64 = *(unsigned int *)(v62 + 16);
      if (!v64) {
        goto LABEL_66;
      }
      uint64_t v65 = *(void **)(v62 + 8);
      unint64_t v66 = &v65[2 * v64];
      do
      {
        unint64_t v67 = v64 >> 1;
        uint64_t v68 = &v65[2 * (v64 >> 1)];
        unint64_t v70 = *v68;
        uint64_t v69 = v68 + 2;
        v64 += ~(v64 >> 1);
        if (v70 < v63) {
          uint64_t v65 = v69;
        }
        else {
          unint64_t v64 = v67;
        }
      }
      while (v64);
      if (v65 != v66 && *v65 == v63) {
        uint64_t v71 = v65[1];
      }
      else {
LABEL_66:
      }
        uint64_t v71 = 0;
      uint64_t SplatFloat = mlir::getSplatFloatValue<float>(v61, v71);
      if ((SplatFloat & 0xFF00000000) != 0)
      {
        int v107 = SplatFloat;
      }
      else
      {
        char v106 = 1;
        uint64_t v73 = (void *)mlir::anec::Convolution::getKernelScaleAttr(a1);
        uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v73);
      }
    }
    if (mlir::anec::Convolution::getKernelZeroPointAttr(a1))
    {
      KernelZeroPointAttr = (uint64_t *)mlir::anec::Convolution::getKernelZeroPointAttr(a1);
      uint64_t v76 = (uint64_t)KernelZeroPointAttr;
      if (!KernelZeroPointAttr) {
        goto LABEL_80;
      }
      uint64_t v77 = *KernelZeroPointAttr;
      unint64_t v78 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v79 = *(unsigned int *)(v77 + 16);
      if (!v79) {
        goto LABEL_80;
      }
      uint64_t v80 = *(void **)(v77 + 8);
      __int16 v81 = &v80[2 * v79];
      do
      {
        unint64_t v82 = v79 >> 1;
        uint64_t v83 = &v80[2 * (v79 >> 1)];
        unint64_t v85 = *v83;
        uint64_t v84 = v83 + 2;
        v79 += ~(v79 >> 1);
        if (v85 < v78) {
          uint64_t v80 = v84;
        }
        else {
          unint64_t v79 = v82;
        }
      }
      while (v79);
      if (v80 != v81 && *v80 == v78) {
        uint64_t v86 = v80[1];
      }
      else {
LABEL_80:
      }
        uint64_t v86 = 0;
      uint64_t SplatInt = mlir::getSplatIntValue<int>(v76, v86);
      if ((SplatInt & 0xFF00000000) != 0) {
        int v110 = SplatInt;
      }
      else {
        char v109 = 1;
      }
    }
    goto LABEL_84;
  }
  uint64_t v121 = "Failed to get channel index for Conv";
  v123[8] = 259;
  mlir::OpState::emitOpError((uint64_t **)a1, (const void ***)&v121, (uint64_t)&__p);
  mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&__p);
  if (__p) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__p);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v125);
  return mlir::anec::verifyConvolutionWithANEC((uint64_t)v93, (uint64_t)*a1, a2, a3);
}

uint64_t mlir::anec::Deconvolution::addOpToNetwork(mlir::Operation **a1, uint64_t a2, mlir::anec::ANECIRWeights *a3)
{
  v160[2] = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *a1;
  uint64_t v5 = *((void *)*a1 + 9);
  uint64_t v6 = *(void *)(v5 + 24);
  uint64_t v146 = *(void **)(v5 + 56);
  uint64_t v147 = v4;
  if (*((_DWORD *)v4 + 9)) {
    uint64_t v7 = (uint64_t)v4 - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  v149[0] = (void *)mlir::anec::Convolution::getGroupsAttr(&v147);
  mlir::IntegerAttr::getValue(v149, (llvm::APInt *)&__p);
  if (v154 > 0x40)
  {
    float v139 = *(void **)__p;
    operator delete[](__p);
  }
  else
  {
    float v139 = __p;
  }
  uint64_t IncPadAttr = mlir::anec::AveragePool::getIncPadAttr(&v147);
  v159[0] = v160;
  v159[1] = (void *)0x200000000;
  uint64_t StrideAttr = mlir::anec::Convolution::getStrideAttr(&v147);
  mlir::getValues<unsigned long long>(StrideAttr, (uint64_t)v159);
  uint64_t v156 = (int32x4_t *)v158;
  uint64_t v157 = 0x200000000;
  uint64_t KsizeAttr = mlir::anec::AveragePool::getKsizeAttr(&v147);
  mlir::getValues<unsigned long long>(KsizeAttr, (uint64_t)&v156);
  long long __p = v155;
  uint64_t v154 = 0x400000000;
  uint64_t PaddingAttr = mlir::anec::Convolution::getPaddingAttr(&v147);
  mlir::getValues<unsigned long long>(PaddingAttr, (uint64_t)&__p);
  unint64_t v12 = (uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v12) {
    goto LABEL_16;
  }
  uint64_t v13 = *v12;
  unint64_t v14 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v15 = *(unsigned int *)(v13 + 16);
  if (!v15) {
    goto LABEL_16;
  }
  uint64_t v16 = *(void **)(v13 + 8);
  unint64_t v17 = &v16[2 * v15];
  do
  {
    unint64_t v18 = v15 >> 1;
    unint64_t v19 = &v16[2 * (v15 >> 1)];
    unint64_t v21 = *v19;
    unint64_t v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14) {
      uint64_t v16 = v20;
    }
    else {
      unint64_t v15 = v18;
    }
  }
  while (v15);
  if (v16 != v17 && *v16 == v14) {
    uint64_t v22 = v16[1];
  }
  else {
LABEL_16:
  }
    uint64_t v22 = 0;
  v145[0] = v12;
  v145[1] = v22;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v145);
  unint64_t v23 = (uint64_t *)(*(void *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v23) {
    goto LABEL_26;
  }
  uint64_t v24 = *v23;
  unint64_t v25 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v26 = *(unsigned int *)(v24 + 16);
  if (!v26) {
    goto LABEL_26;
  }
  uint64_t v27 = *(void **)(v24 + 8);
  uint64_t v28 = &v27[2 * v26];
  do
  {
    unint64_t v29 = v26 >> 1;
    unint64_t v30 = &v27[2 * (v26 >> 1)];
    unint64_t v32 = *v30;
    char v31 = v30 + 2;
    v26 += ~(v26 >> 1);
    if (v32 < v25) {
      uint64_t v27 = v31;
    }
    else {
      unint64_t v26 = v29;
    }
  }
  while (v26);
  if (v27 != v28 && *v27 == v25) {
    uint64_t v33 = v27[1];
  }
  else {
LABEL_26:
  }
    uint64_t v33 = 0;
  v144[0] = v23;
  v144[1] = v33;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v144);
  uint64_t v34 = (uint64_t *)(v146[1] & 0xFFFFFFFFFFFFFFF8);
  if (!v34) {
    goto LABEL_36;
  }
  uint64_t v35 = *v34;
  unint64_t v36 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v37 = *(unsigned int *)(v35 + 16);
  if (!v37) {
    goto LABEL_36;
  }
  uint64_t v38 = *(void **)(v35 + 8);
  uint64_t v39 = &v38[2 * v37];
  do
  {
    unint64_t v40 = v37 >> 1;
    uint64_t v41 = &v38[2 * (v37 >> 1)];
    unint64_t v43 = *v41;
    uint64_t v42 = v41 + 2;
    v37 += ~(v37 >> 1);
    if (v43 < v36) {
      uint64_t v38 = v42;
    }
    else {
      unint64_t v37 = v40;
    }
  }
  while (v37);
  if (v38 != v39 && *v38 == v36) {
    uint64_t v44 = v38[1];
  }
  else {
LABEL_36:
  }
    uint64_t v44 = 0;
  *(void *)&long long v143 = v34;
  *((void *)&v143 + 1) = v44;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v143);
  uint64_t v47 = v46;
  v142[0] = 0;
  v142[1] = 0;
  uint64_t v148 = (uint64_t **)v142;
  v149[0] = v146;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)v149);
  if (DefiningOp) {
    mlir::detail::constant_op_binder<mlir::ElementsAttr>::match(&v148, DefiningOp);
  }
  uint64_t v49 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&v146);
  uint64_t v50 = (uint64_t *)a3;
  uint64_t v51 = mlir::anec::ANECIRWeights::lookupConstant(a3, v49);
  uint64_t v52 = (char *)operator new(0x150uLL);
  *(_OWORD *)uint64_t v52 = 0u;
  *((_OWORD *)v52 + 1) = 0u;
  *((_OWORD *)v52 + 2) = 0u;
  *((_OWORD *)v52 + 3) = 0u;
  *((_OWORD *)v52 + 4) = 0u;
  *((_OWORD *)v52 + 5) = 0u;
  *((_OWORD *)v52 + 6) = 0u;
  *((_OWORD *)v52 + 7) = 0u;
  *((_OWORD *)v52 + 8) = 0u;
  *((_OWORD *)v52 + 9) = 0u;
  *((_OWORD *)v52 + 10) = 0u;
  *((_OWORD *)v52 + 11) = 0u;
  *((_OWORD *)v52 + 12) = 0u;
  *((_OWORD *)v52 + 13) = 0u;
  *((_OWORD *)v52 + 14) = 0u;
  *((_OWORD *)v52 + 15) = 0u;
  *((_OWORD *)v52 + 16) = 0u;
  *((_OWORD *)v52 + 17) = 0u;
  *((_OWORD *)v52 + 18) = 0u;
  *((_OWORD *)v52 + 19) = 0u;
  *((_OWORD *)v52 + 20) = 0u;
  *((void *)v52 + 9) = -1;
  *((_DWORD *)v52 + 22) = -1;
  *((void *)v52 + 12) = -1;
  *((_DWORD *)v52 + 26) = -1;
  *((void *)v52 + 14) = -1;
  *(_OWORD *)(v52 + 120) = 0u;
  *(_OWORD *)(v52 + 136) = 0u;
  *(_OWORD *)(v52 + 152) = 0u;
  *((void *)v52 + 21) = 0;
  *((_DWORD *)v52 + 44) = 1;
  *((_DWORD *)v52 + 48) = -1;
  *((void *)v52 + 25) = -1;
  *((_DWORD *)v52 + 52) = -1;
  *((void *)v52 + 27) = -1;
  *((void *)v52 + 28) = 0x3F80000000000006;
  *(void *)uint64_t v52 = &unk_1EC9958C8;
  int64x2_t v53 = vdupq_n_s64(1uLL);
  *(int64x2_t *)(v52 + 248) = v53;
  *(void *)&long long v54 = 0x100000001;
  *((void *)&v54 + 1) = 0x100000001;
  *(int64x2_t *)(v52 + 264) = v53;
  *(_OWORD *)(v52 + 280) = v54;
  *((void *)v52 + 37) = 0x100000001;
  *((void *)v52 + 38) = 0;
  *((void *)v52 + 39) = 0;
  *((void *)v52 + 40) = 0;
  *((_DWORD *)v52 + 82) = 1;
  v149[0] = v4;
  v149[1] = v151;
  uint64_t v150 = 0x200000000;
  uint64_t v55 = v157;
  if (!v157)
  {
    BOOL v58 = 0;
    BOOL v152 = IncPadAttr != 0;
    long long v59 = v151;
    goto LABEL_53;
  }
  if (v157 < 3)
  {
    uint64_t v56 = v157;
    uint64_t v57 = v151;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v149[1], v151, v157, 8);
    uint64_t v56 = v157;
    if (!v157) {
      goto LABEL_46;
    }
    uint64_t v57 = v149[1];
  }
  memcpy(v57, v156, 8 * v56);
LABEL_46:
  uint64_t v60 = 0;
  LODWORD(v150) = v55;
  long long v59 = v149[1];
  BOOL v152 = IncPadAttr != 0;
  do
  {
    uint64_t v61 = *(void *)((char *)v149[1] + v60);
    BOOL v62 = v61 == 1;
    BOOL v58 = v61 != 1;
    BOOL v62 = !v62 || 8 * v55 - 8 == v60;
    v60 += 8;
  }
  while (!v62);
  unsigned int v4 = (mlir::Operation *)v149[0];
LABEL_53:
  if (*(_UNKNOWN **)(*((void *)v4 + 6) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
  {
    int v63 = 3;
    if (v59 == v151) {
      goto LABEL_56;
    }
    goto LABEL_55;
  }
  if (IncPadAttr) {
    BOOL v67 = v58;
  }
  else {
    BOOL v67 = 0;
  }
  if (v67)
  {
    int v63 = 6;
    if (v59 == v151) {
      goto LABEL_56;
    }
LABEL_55:
    free(v59);
    goto LABEL_56;
  }
  if (v58) {
    int v69 = 5;
  }
  else {
    int v69 = 1;
  }
  if (IncPadAttr) {
    int v63 = 2;
  }
  else {
    int v63 = v69;
  }
  if (v59 != v151) {
    goto LABEL_55;
  }
LABEL_56:
  *((_DWORD *)v52 + 60) = v63;
  v52[244] = 0;
  *((_DWORD *)v52 + 20) = 1;
  *(_OWORD *)uint64_t v149 = v143;
  uint64_t OperandRange = (uint64_t **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v149);
  uint64_t v65 = (void *)(*OperandRange)[17];
  if (v65 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    if (v65 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id)
    {
      int v66 = 4;
    }
    else if (v65 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id)
    {
      int v66 = 6;
    }
    else
    {
      int v66 = 0;
    }
    goto LABEL_84;
  }
  uint64_t v148 = OperandRange;
  int Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&v148);
  if (Width == 16)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v148) == 1)
    {
      int v66 = 3;
      goto LABEL_84;
    }
  }
  else if (Width == 8)
  {
    if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v148) == 2) {
      int v66 = 2;
    }
    else {
      int v66 = 1;
    }
    goto LABEL_84;
  }
  int v66 = 0;
LABEL_84:
  *((void *)v52 + 31) = v139;
  *((_DWORD *)v52 + 21) = v66;
  *((_DWORD *)v52 + 22) = 0;
  *((void *)v52 + 12) = v51;
  *((int8x16_t *)v52 + 16) = vextq_s8(*(int8x16_t *)(ArgAttrsAttr + 8 * v47 - 16), *(int8x16_t *)(ArgAttrsAttr + 8 * v47 - 16), 8uLL);
  if (v47 == 5) {
    uint64_t v70 = *(void *)(ArgAttrsAttr + 16);
  }
  else {
    uint64_t v70 = 1;
  }
  uint64_t v71 = v50;
  *((void *)v52 + 34) = v70;
  uint64_t v72 = v156;
  *((_DWORD *)v52 + 70) = v156[1].i64[0];
  int32x4_t v73 = *v72;
  uint64_t v74 = v159[0];
  *(int32x4_t *)(v52 + 284) = vrev64q_s32(vuzp1q_s32(v73, *(int32x4_t *)((char *)v159[0] + 8)));
  *((_DWORD *)v52 + 75) = *v74;
  uint64_t v75 = (int64x2_t *)__p;
  *((int32x4_t *)v52 + 19) = vuzp1q_s32(*((int32x4_t *)__p + 2), *((int32x4_t *)__p + 1));
  *((int32x2_t *)v52 + 40) = vmovn_s64(*v75);
  v149[0] = (void *)mlir::anec::Convolution::getPaddingModeAttr(&v147);
  *((_DWORD *)v52 + 82) = dword_1810FE3D0[mlir::IntegerAttr::getInt((mlir::IntegerAttr *)v149)];
  v52[180] = 0;
  if (mlir::anec::Convolution::getKernelScaleAttr(&v147))
  {
    KernelScaleAttr = (uint64_t *)mlir::anec::Convolution::getKernelScaleAttr(&v147);
    uint64_t v77 = (uint64_t)KernelScaleAttr;
    if (!KernelScaleAttr) {
      goto LABEL_97;
    }
    uint64_t v78 = *KernelScaleAttr;
    unint64_t v79 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v80 = *(unsigned int *)(v78 + 16);
    if (!v80) {
      goto LABEL_97;
    }
    __int16 v81 = *(void **)(v78 + 8);
    unint64_t v82 = &v81[2 * v80];
    do
    {
      unint64_t v83 = v80 >> 1;
      uint64_t v84 = &v81[2 * (v80 >> 1)];
      unint64_t v86 = *v84;
      unint64_t v85 = v84 + 2;
      v80 += ~(v80 >> 1);
      if (v86 < v79) {
        __int16 v81 = v85;
      }
      else {
        unint64_t v80 = v83;
      }
    }
    while (v80);
    if (v81 != v82 && *v81 == v79) {
      uint64_t v87 = v81[1];
    }
    else {
LABEL_97:
    }
      uint64_t v87 = 0;
    uint64_t SplatFloat = mlir::getSplatFloatValue<float>(v77, v87);
    if ((SplatFloat & 0xFF00000000) != 0)
    {
      *((_DWORD *)v52 + 57) = SplatFloat;
      goto LABEL_129;
    }
    uint64_t v89 = (uint64_t *)mlir::anec::Convolution::getKernelScaleAttr(&v147);
    uint64_t v90 = (uint64_t)v89;
    if (!v89) {
      goto LABEL_109;
    }
    uint64_t v91 = *v89;
    unint64_t v92 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v93 = *(unsigned int *)(v91 + 16);
    if (!v93) {
      goto LABEL_109;
    }
    char v94 = *(void **)(v91 + 8);
    uint64_t v95 = &v94[2 * v93];
    do
    {
      unint64_t v96 = v93 >> 1;
      uint64_t v97 = &v94[2 * (v93 >> 1)];
      unint64_t v99 = *v97;
      int v98 = v97 + 2;
      v93 += ~(v93 >> 1);
      if (v99 < v92) {
        char v94 = v98;
      }
      else {
        unint64_t v93 = v96;
      }
    }
    while (v93);
    if (v94 != v95 && *v94 == v92) {
      uint64_t v100 = v94[1];
    }
    else {
LABEL_109:
    }
      uint64_t v100 = 0;
    uint64_t v101 = mlir::anec::ANECIRWeights::addConstant(v71, v90, v100);
    uint64_t v141 = mlir::anec::Convolution::getKernelScaleAttr(&v147);
    v149[0] = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v141);
    v149[1] = v102;
    uint64_t v103 = (uint64_t **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v149);
    uint64_t v104 = (void *)(*v103)[17];
    if (v104 != &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
    {
      if (v104 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id)
      {
        int v105 = 4;
      }
      else if (v104 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id)
      {
        int v105 = 6;
      }
      else
      {
        int v105 = 0;
      }
      goto LABEL_128;
    }
    uint64_t v148 = v103;
    int v106 = mlir::IntegerType::getWidth((mlir::IntegerType *)&v148);
    if (v106 == 16)
    {
      if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v148) == 1)
      {
        int v105 = 3;
LABEL_128:
        *((_DWORD *)v52 + 56) = v105;
        v52[184] = 1;
        *((_DWORD *)v52 + 48) = 0;
        *((void *)v52 + 25) = v101;
        goto LABEL_129;
      }
    }
    else if (v106 == 8)
    {
      if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&v148) == 2) {
        int v105 = 2;
      }
      else {
        int v105 = 1;
      }
      goto LABEL_128;
    }
    int v105 = 0;
    goto LABEL_128;
  }
LABEL_129:
  if (mlir::anec::Convolution::getKernelZeroPointAttr(&v147))
  {
    KernelZeroPointAttr = (uint64_t *)mlir::anec::Convolution::getKernelZeroPointAttr(&v147);
    uint64_t v108 = (uint64_t)KernelZeroPointAttr;
    if (!KernelZeroPointAttr) {
      goto LABEL_139;
    }
    uint64_t v109 = *KernelZeroPointAttr;
    unint64_t v110 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v111 = *(unsigned int *)(v109 + 16);
    if (!v111) {
      goto LABEL_139;
    }
    __int16 v112 = *(void **)(v109 + 8);
    uint64_t v113 = &v112[2 * v111];
    do
    {
      unint64_t v114 = v111 >> 1;
      uint64_t v115 = &v112[2 * (v111 >> 1)];
      unint64_t v117 = *v115;
      uint64_t v116 = v115 + 2;
      v111 += ~(v111 >> 1);
      if (v117 < v110) {
        __int16 v112 = v116;
      }
      else {
        unint64_t v111 = v114;
      }
    }
    while (v111);
    if (v112 != v113 && *v112 == v110) {
      uint64_t v118 = v112[1];
    }
    else {
LABEL_139:
    }
      uint64_t v118 = 0;
    uint64_t SplatInt = mlir::getSplatIntValue<int>(v108, v118);
    if ((SplatInt & 0xFF00000000) != 0)
    {
      *((_DWORD *)v52 + 58) = SplatInt;
    }
    else
    {
      uint64_t v120 = (uint64_t *)mlir::anec::Convolution::getKernelZeroPointAttr(&v147);
      uint64_t v121 = (uint64_t)v120;
      if (!v120) {
        goto LABEL_151;
      }
      uint64_t v122 = *v120;
      unint64_t v123 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v124 = *(unsigned int *)(v122 + 16);
      if (!v124) {
        goto LABEL_151;
      }
      float v125 = *(void **)(v122 + 8);
      uint64_t v126 = &v125[2 * v124];
      do
      {
        unint64_t v127 = v124 >> 1;
        float v128 = &v125[2 * (v124 >> 1)];
        unint64_t v130 = *v128;
        uint64_t v129 = v128 + 2;
        v124 += ~(v124 >> 1);
        if (v130 < v123) {
          float v125 = v129;
        }
        else {
          unint64_t v124 = v127;
        }
      }
      while (v124);
      if (v125 != v126 && *v125 == v123) {
        uint64_t v131 = v125[1];
      }
      else {
LABEL_151:
      }
        uint64_t v131 = 0;
      uint64_t v132 = mlir::anec::ANECIRWeights::addConstant(v71, v121, v131);
      v52[185] = 1;
      *((_DWORD *)v52 + 52) = 0;
      *((void *)v52 + 27) = v132;
    }
  }
  unsigned int v133 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v133->__shared_owners_ = 0;
  v133->__shared_weak_owners_ = 0;
  v133->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  v133[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v133[1].__shared_owners_;
  if (v52[31] < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *((const std::string::value_type **)v52 + 1), *((void *)v52 + 2));
  }
  else
  {
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = *(_OWORD *)(v52 + 8);
    v133[2].__vftable = (std::__shared_weak_count_vtbl *)*((void *)v52 + 3);
  }
  LODWORD(v133[2].__shared_owners_) = 17;
  v133[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v133[2].__shared_weak_owners_ = (uint64_t)v52;
  LOBYTE(v133[3].__vftable) = 0;
  v133[3].__shared_owners_ = 0;
  v133[3].__shared_weak_owners_ = (uint64_t)&v133[4].__shared_owners_;
  v133[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v133[5].__shared_weak_owners_ = (uint64_t)&v133[6].__shared_owners_;
  v133[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  v149[0] = &v133[1];
  v149[1] = v133;
  uint64_t v135 = *(void **)(a2 + 232);
  if ((unint64_t)v135 >= *(void *)(a2 + 240))
  {
    unint64_t v136 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, (long long *)v149);
    unsigned int v133 = (std::__shared_weak_count *)v149[1];
    *(void *)(a2 + 232) = v136;
    if (!v133) {
      goto LABEL_161;
    }
  }
  else
  {
    *uint64_t v135 = v133 + 1;
    v135[1] = v133;
    atomic_fetch_add_explicit(&v133->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v135 + 2;
  }
  if (!atomic_fetch_add(&v133->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v133->__on_zero_shared)(v133);
    std::__shared_weak_count::__release_weak(v133);
  }
LABEL_161:
  if (__p != v155) {
    free(__p);
  }
  if (v156 != (int32x4_t *)v158) {
    free(v156);
  }
  if (v159[0] != v160) {
    free(v159[0]);
  }
  return 1;
}

uint64_t mlir::anec::Deconvolution::getExecutionCost(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v14 = *v13;
  unint64_t v15 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v16 = *(unsigned int *)(v14 + 16);
  if (!v16) {
    goto LABEL_10;
  }
  unint64_t v17 = *(void **)(v14 + 8);
  unint64_t v18 = &v17[2 * v16];
  do
  {
    unint64_t v19 = v16 >> 1;
    unint64_t v20 = &v17[2 * (v16 >> 1)];
    unint64_t v22 = *v20;
    unint64_t v21 = v20 + 2;
    v16 += ~(v16 >> 1);
    if (v22 < v15) {
      unint64_t v17 = v21;
    }
    else {
      unint64_t v16 = v19;
    }
  }
  while (v16);
  if (v17 != v18 && *v17 == v15) {
    uint64_t v23 = v17[1];
  }
  else {
LABEL_10:
  }
    uint64_t v23 = 0;
  v69[0] = v13;
  v69[1] = v23;
  uint64_t v24 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*a1 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v24) {
    goto LABEL_20;
  }
  uint64_t v25 = *v24;
  unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v27 = *(unsigned int *)(v25 + 16);
  if (!v27) {
    goto LABEL_20;
  }
  uint64_t v28 = *(void **)(v25 + 8);
  unint64_t v29 = &v28[2 * v27];
  do
  {
    unint64_t v30 = v27 >> 1;
    char v31 = &v28[2 * (v27 >> 1)];
    unint64_t v33 = *v31;
    unint64_t v32 = v31 + 2;
    v27 += ~(v27 >> 1);
    if (v33 < v26) {
      uint64_t v28 = v32;
    }
    else {
      unint64_t v27 = v30;
    }
  }
  while (v27);
  if (v28 != v29 && *v28 == v26) {
    uint64_t v34 = v28[1];
  }
  else {
LABEL_20:
  }
    uint64_t v34 = 0;
  v68[0] = v24;
  v68[1] = v34;
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v35 = *a1 - 16;
  }
  else {
    uint64_t v35 = 0;
  }
  unint64_t v36 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v35, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v36) {
    goto LABEL_33;
  }
  uint64_t v37 = *v36;
  unint64_t v38 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v39 = *(unsigned int *)(v37 + 16);
  if (!v39) {
    goto LABEL_33;
  }
  unint64_t v40 = *(void **)(v37 + 8);
  uint64_t v41 = &v40[2 * v39];
  do
  {
    unint64_t v42 = v39 >> 1;
    unint64_t v43 = &v40[2 * (v39 >> 1)];
    unint64_t v45 = *v43;
    uint64_t v44 = v43 + 2;
    v39 += ~(v39 >> 1);
    if (v45 < v38) {
      unint64_t v40 = v44;
    }
    else {
      unint64_t v39 = v42;
    }
  }
  while (v39);
  if (v40 != v41 && *v40 == v38) {
    uint64_t v46 = v40[1];
  }
  else {
LABEL_33:
  }
    uint64_t v46 = 0;
  v67[0] = v36;
  v67[1] = v46;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v68);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v67);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
  mlir::anec::getIndexFromDim(0, v47);
  if (v48
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69),
        mlir::anec::getIndexFromDim(1, v49),
        v50)
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69),
        mlir::anec::getIndexFromDim(3, v51),
        v52)
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69),
        mlir::anec::getIndexFromDim(4, v53),
        v54))
  {
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v69);
    mlir::anec::getIndexFromDim(2, v55);
    uint64_t v56 = *a1;
    uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v69);
  }
  else
  {
    uint64_t v59 = std::__throw_bad_optional_access[abi:nn180100]();
    return mlir::anec::inferElementwiseReturnTypes(v59, v60, v61, v62, v63, v64, v65, v66, a9, a10, a11);
  }
}

uint64_t mlir::anec::inferElementwiseReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v68[4] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v14 = v13;
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v15 = *v13;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_10;
  }
  unint64_t v18 = *(void **)(v15 + 8);
  unint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    unint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    unint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      unint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_10:
  }
    uint64_t v24 = 0;
  __src = v14;
  uint64_t v67 = v24;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__src);
  uint64_t v27 = v25;
  size_t v28 = 8 * v25;
  __src = v68;
  uint64_t v67 = 0x400000000;
  if ((unint64_t)(8 * v25) < 0x21)
  {
    unsigned int v29 = 0;
    if (!v25) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v68, (8 * v25) >> 3, 8);
  unsigned int v29 = v67;
  if (v27)
  {
LABEL_15:
    memcpy((char *)__src + 8 * v29, ArgAttrsAttr, v28);
    unsigned int v29 = v67;
  }
LABEL_16:
  size_t v30 = v28 >> 3;
  uint64_t v63 = v65;
  uint64_t v64 = 0x400000000;
  unsigned int v31 = v29 + (v28 >> 3);
  LODWORD(v67) = v31;
  if (!v31) {
    goto LABEL_23;
  }
  if (v31 < 5)
  {
    unint64_t v33 = v65;
    unsigned int v32 = v29 + v30;
    goto LABEL_21;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v65, v29 + v30, 8);
  unsigned int v32 = v67;
  if (v67)
  {
    unint64_t v33 = v63;
LABEL_21:
    memcpy(v33, __src, 8 * v32);
  }
  LODWORD(v64) = v31;
LABEL_23:
  if (a10 != 1)
  {
    uint64_t v60 = a4;
    uint64_t v61 = a5;
    uint64_t v34 = 1;
    while (1)
    {
      uint64_t v35 = (void *)mlir::TypeRange::dereference_iterator(a9, v34);
      unint64_t v36 = v35;
      uint64_t v37 = (uint64_t *)__src;
      unint64_t v38 = v67;
      if (!v35) {
        goto LABEL_35;
      }
      uint64_t v39 = *v35;
      unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v41 = *(unsigned int *)(v39 + 16);
      if (!v41) {
        goto LABEL_35;
      }
      unint64_t v42 = *(void **)(v39 + 8);
      unint64_t v43 = &v42[2 * v41];
      do
      {
        unint64_t v44 = v41 >> 1;
        unint64_t v45 = &v42[2 * (v41 >> 1)];
        unint64_t v47 = *v45;
        uint64_t v46 = v45 + 2;
        v41 += ~(v41 >> 1);
        if (v47 < v40) {
          unint64_t v42 = v46;
        }
        else {
          unint64_t v41 = v44;
        }
      }
      while (v41);
      if (v42 != v43 && *v42 == v40) {
        uint64_t v48 = v42[1];
      }
      else {
LABEL_35:
      }
        uint64_t v48 = 0;
      v62[0] = v36;
      v62[1] = v48;
      unint64_t v49 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v62);
      if ((mlir::OpTrait::util::getBroadcastedShape(v37, v38, v49, v50, (uint64_t)&v63) & 1) == 0)
      {
        uint64_t MostDefinedTypeForANE = mlir::getMostDefinedTypeForANE(v60, v61);
        goto LABEL_51;
      }
      int v51 = v64;
      uint64_t v52 = v67;
      if (v67 >= v64)
      {
        if (v64) {
          memmove(__src, v63, 8 * v64);
        }
        goto LABEL_25;
      }
      if (HIDWORD(v67) >= v64)
      {
        if (v67)
        {
          memmove(__src, v63, 8 * v67);
          goto LABEL_45;
        }
      }
      else
      {
        LODWORD(v67) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v68, v64, 8);
      }
      uint64_t v52 = 0;
LABEL_45:
      if (v52 != v64) {
        memcpy((char *)__src + 8 * v52, (char *)v63 + 8 * v52, 8 * v64 - 8 * v52);
      }
LABEL_25:
      LODWORD(v67) = v51;
      if (++v34 == a10)
      {
        unsigned int v31 = v64;
        break;
      }
    }
  }
  char v54 = v63;
  unint64_t v55 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v55);
  uint64_t MostDefinedTypeForANE = mlir::MemRefType::get(v54, (mlir::AffineMap *)v31, ElementTypeOrSelf, 0, 0, 0);
LABEL_51:
  uint64_t v57 = MostDefinedTypeForANE;
  unsigned int v58 = *(_DWORD *)(a11 + 8);
  if (v58 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v58 + 1, 8);
    unsigned int v58 = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v58) = v57;
  ++*(_DWORD *)(a11 + 8);
  if (v63 != v65) {
    free(v63);
  }
  if (__src != v68) {
    free(__src);
  }
  return 1;
}

uint64_t mlir::anec::inferElementwiseCompareReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v67[4] = *MEMORY[0x1E4F143B8];
  uint64_t v13 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v14 = v13;
  if (!v13) {
    goto LABEL_10;
  }
  uint64_t v15 = *v13;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_10;
  }
  unint64_t v18 = *(void **)(v15 + 8);
  unint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    unint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    unint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      unint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_10:
  }
    uint64_t v24 = 0;
  __src = v14;
  uint64_t v66 = v24;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__src);
  uint64_t v27 = v25;
  size_t v28 = 8 * v25;
  __src = v67;
  uint64_t v66 = 0x400000000;
  if ((unint64_t)(8 * v25) < 0x21)
  {
    unsigned int v29 = 0;
    if (!v25) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v67, (8 * v25) >> 3, 8);
  unsigned int v29 = v66;
  if (v27)
  {
LABEL_15:
    memcpy((char *)__src + 8 * v29, ArgAttrsAttr, v28);
    unsigned int v29 = v66;
  }
LABEL_16:
  uint64_t v62 = v64;
  uint64_t v63 = 0x400000000;
  unint64_t v30 = v29 + (v28 >> 3);
  LODWORD(v66) = v30;
  if (!v30) {
    goto LABEL_23;
  }
  if (v30 < 5)
  {
    unsigned int v32 = v64;
    unsigned int v31 = v30;
    goto LABEL_21;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v64, v30, 8);
  unsigned int v31 = v66;
  if (v66)
  {
    unsigned int v32 = v62;
LABEL_21:
    memcpy(v32, __src, 8 * v31);
  }
  LODWORD(v63) = v30;
LABEL_23:
  if (a10 != 1)
  {
    uint64_t v58 = a1;
    uint64_t v59 = a5;
    uint64_t v33 = 1;
    while (1)
    {
      uint64_t v34 = (void *)mlir::TypeRange::dereference_iterator(a9, v33);
      uint64_t v35 = v34;
      unint64_t v36 = (uint64_t *)__src;
      unint64_t v37 = v66;
      if (!v34) {
        goto LABEL_35;
      }
      uint64_t v38 = *v34;
      unint64_t v39 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v40 = *(unsigned int *)(v38 + 16);
      if (!v40) {
        goto LABEL_35;
      }
      unint64_t v41 = *(void **)(v38 + 8);
      unint64_t v42 = &v41[2 * v40];
      do
      {
        unint64_t v43 = v40 >> 1;
        unint64_t v44 = &v41[2 * (v40 >> 1)];
        unint64_t v46 = *v44;
        unint64_t v45 = v44 + 2;
        v40 += ~(v40 >> 1);
        if (v46 < v39) {
          unint64_t v41 = v45;
        }
        else {
          unint64_t v40 = v43;
        }
      }
      while (v40);
      if (v41 != v42 && *v41 == v39) {
        uint64_t v47 = v41[1];
      }
      else {
LABEL_35:
      }
        uint64_t v47 = 0;
      v61[0] = v35;
      v61[1] = v47;
      uint64_t v48 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61);
      if ((mlir::OpTrait::util::getBroadcastedShape(v36, v37, v48, v49, (uint64_t)&v62) & 1) == 0)
      {
        uint64_t MostDefinedTypeForANE = mlir::getMostDefinedTypeForANE(a4, v59);
        goto LABEL_51;
      }
      int v50 = v63;
      uint64_t v51 = v66;
      if (v66 >= v63)
      {
        if (v63) {
          memmove(__src, v62, 8 * v63);
        }
        goto LABEL_25;
      }
      if (HIDWORD(v66) >= v63)
      {
        if (v66)
        {
          memmove(__src, v62, 8 * v66);
          goto LABEL_45;
        }
      }
      else
      {
        LODWORD(v66) = 0;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v67, v63, 8);
      }
      uint64_t v51 = 0;
LABEL_45:
      if (v51 != v63) {
        memcpy((char *)__src + 8 * v51, (char *)v62 + 8 * v51, 8 * v63 - 8 * v51);
      }
LABEL_25:
      LODWORD(v66) = v50;
      if (++v33 == a10)
      {
        LODWORD(v30) = v63;
        a1 = v58;
        break;
      }
    }
  }
  unint64_t v53 = v62;
  uint64_t v54 = mlir::IntegerType::get(a1, 8u, 1u);
  uint64_t MostDefinedTypeForANE = mlir::MemRefType::get(v53, (mlir::AffineMap *)v30, v54, 0, 0, 0);
LABEL_51:
  uint64_t v55 = MostDefinedTypeForANE;
  unsigned int v56 = *(_DWORD *)(a11 + 8);
  if (v56 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v56 + 1, 8);
    unsigned int v56 = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v56) = v55;
  ++*(_DWORD *)(a11 + 8);
  if (v62 != v64) {
    free(v62);
  }
  if (__src != v67) {
    free(__src);
  }
  return 1;
}

uint64_t mlir::anec::ElementwiseAdd::canonicalize(uint64_t a1, uint64_t a2, mlir::PatternRewriter *a3)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  uint64_t v104 = 0;
  uint64_t v105 = 0;
  v102[0] = &v105;
  v102[1] = &v104;
  uint64_t v103 = 0;
  if (*(_UNKNOWN **)(*(void *)(a1 + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id
    || (*(unsigned char *)(a1 + 46) & 0x80) == 0
    || *(_DWORD *)(a1 + 68) != 2
    || (v5 = mlir::detail::matchOperandOrValueAtIndex<mlir::detail::RecursivePatternMatcherBinder<mlir::anec::MatMul,mlir::detail::any_value_binder,mlir::detail::op_matcher_with_bind<mlir::mps::ConstantOp>>>(a1, 0, v102), v107 = *(const char **)(*(void *)(a1 + 72) + 56), (DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v107)) == 0)|| (*(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id? (char v7 = v5): (char v7 = 0), (v7 & 1) == 0))
  {
    uint64_t v11 = "does not match pattern";
    goto LABEL_13;
  }
  unint64_t v8 = v103;
  uint64_t v100 = v104;
  uint64_t v101 = v103;
  uint64_t v99 = DefiningOp;
  mlir::anec::MatMul::getBias(&v101, (uint64_t)&v107);
  if ((_BYTE)v110)
  {
    uint64_t v10 = (void *)v108;
    if (llvm::APFloatBase::PPCDoubleDouble(v9) == v10) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v108);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v108);
    }
    uint64_t v11 = "MatMul already has bias";
LABEL_13:
    int v107 = v11;
    __int16 v110 = 259;
    v106[0] = (uint64_t)&v107;
    uint64_t v12 = *(void *)(a2 + 16);
    if (v12 && mlir::RewriterBase::Listener::classof(*(void *)(a2 + 16))) {
      char v13 = (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), uint64_t *))(*(void *)v12 + 64))(v12, *(void *)(a1 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::anec::ElementwiseAdd &>(mlir::anec::ElementwiseAdd &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, v106);
    }
    else {
      char v13 = 0;
    }
    if (v13) {
      return 1;
    }
    else {
  }
    }
  if (*((_DWORD *)v8 + 9)) {
    uint64_t v15 = (uint64_t)v8 - 16;
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t NextResultAtOffset = (void *)mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0);
  if (!*NextResultAtOffset || *(void *)*NextResultAtOffset)
  {
    uint64_t v11 = "MatMul has multiple users";
    goto LABEL_13;
  }
  v98[0] = (uint64_t)mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v100);
  v98[1] = v17;
  v97[0] = (uint64_t)mlir::mps::ConstantOp::getValue((mlir::mps::ConstantOp *)&v99);
  v97[1] = v18;
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v98);
  unint64_t v20 = Type;
  if (!Type) {
    goto LABEL_38;
  }
  uint64_t v21 = *Type;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_38;
  }
  uint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    size_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      uint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    unint64_t v30 = (void *)v24[1];
  }
  else {
LABEL_38:
  }
    unint64_t v30 = 0;
  v96[0] = v20;
  v96[1] = v30;
  unsigned int v31 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v97);
  unsigned int v32 = v31;
  if (!v31) {
    goto LABEL_48;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_48;
  }
  unint64_t v36 = *(void **)(v33 + 8);
  unint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    unint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      unint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    unint64_t v42 = (void *)v36[1];
  }
  else {
LABEL_48:
  }
    unint64_t v42 = 0;
  v95[0] = v32;
  v95[1] = v42;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v96);
  uint64_t v44 = v43;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v95);
  if (v44 != v45
    || (uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(v96[0]), ElementTypeOrSelf != mlir::getElementTypeOrSelf(v95[0])))
  {
    uint64_t v11 = "unsupported kernel and bias fusion";
    goto LABEL_13;
  }
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v96);
  uint64_t v90 = v48;
  uint64_t v49 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v95);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v96);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(4, v50);
  char v53 = v52;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v95);
  unint64_t v55 = mlir::anec::getIndexFromDim(4, v54);
  char v57 = v56;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v96);
  unint64_t v59 = mlir::anec::getIndexFromDim(1, v58);
  if (!v53 || !v57 || !v60 || IndexFromDim != v55)
  {
    uint64_t v11 = "cannot get axes";
    goto LABEL_13;
  }
  unint64_t v61 = v59;
  int v62 = v60;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v96);
  if (v63)
  {
    uint64_t v64 = 0;
    while (1)
    {
      uint64_t v66 = IndexFromDim == v64 ? ArgAttrsAttr[IndexFromDim] : 1;
      if (*(void *)(v49 + 8 * v64) != v66) {
        break;
      }
      if (!v62) {
        goto LABEL_83;
      }
      if (v61 != v64 && IndexFromDim != v64 && ArgAttrsAttr[v64] != 1)
      {
        uint64_t v11 = "unsupported kernel shape";
        goto LABEL_13;
      }
      ++v64;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v96);
      if (v64 == v65) {
        goto LABEL_71;
      }
    }
    uint64_t v11 = "unsupported bias shape";
    goto LABEL_13;
  }
LABEL_71:
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v96);
  if (IndexFromDim != v67 - 1
    || (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v98) & 1) != 0
    || mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v97))
  {
    uint64_t v11 = "unsupported concatenation dimension";
    goto LABEL_13;
  }
  int v107 = v109;
  uint64_t v108 = 0x400000000;
  if ((unint64_t)(8 * v90) < 0x21)
  {
    int v68 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v107, v109, (8 * v90) >> 3, 8);
    int v68 = v108;
  }
  if (v90)
  {
    memcpy((void *)&v107[8 * v68], ArgAttrsAttr, 8 * v90);
    int v68 = v108;
  }
  uint64_t v69 = (v68 + v90);
  LODWORD(v108) = v68 + v90;
  if (v62)
  {
    uint64_t v70 = (uint64_t)v107;
    ++*(void *)&v107[8 * v61];
    uint64_t v71 = mlir::getElementTypeOrSelf(v96[0]);
    uint64_t v72 = (void *)mlir::RankedTensorType::get(v70, v69, v71, 0);
    BufferTensorAttr = (uint64_t *)mlir::mps::getBufferTensorAttr(v72);
    ElementsAttrRawuint64_t Data = (const void *)mlir::getElementsAttrRawData(v98[0]);
    size_t v75 = v74;
    uint64_t v76 = (const void *)mlir::getElementsAttrRawData(v97[0]);
    size_t v78 = v77;
    MutableRawuint64_t Data = (char *)mlir::mps::MPSBufferTensorAttr::getMutableRawData((mlir::mps::MPSBufferTensorAttr *)&BufferTensorAttr);
    memcpy(MutableRawData, ElementsAttrRawData, v75);
    memcpy(&MutableRawData[v75], v76, v78);
    unint64_t v80 = (char *)v107;
    __int16 v81 = (mlir::AffineMap *)v108;
    uint64_t v82 = mlir::getElementTypeOrSelf((void *)(*(void *)(v100 - 8) & 0xFFFFFFFFFFFFFFF8));
    uint64_t v93 = mlir::MemRefType::get(v80, v81, v82, 0, 0, 0);
    unint64_t v92 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::MemRefType &,mlir::mps::MPSBufferTensorAttr &>((mlir::OpBuilder *)(a2 + 8), *(void *)(v100 + 24), &v93, &BufferTensorAttr);
    uint64_t F16Type = mlir::Builder::getF16Type((mlir::Float16Type **)(a2 + 8), v83);
    FloatAttr = mlir::Builder::getFloatAttr(1.0, a2 + 8, F16Type);
    uint64_t v85 = *(void *)(a1 + 24);
    v106[0] = *(void *)(*((void *)v8 + 9) + 24);
    unint64_t v86 = mlir::OpBuilder::create<mlir::anec::MatMul,mlir::detail::TypedValue<mlir::MemRefType>,mlir::mps::ConstantOp &,mlir::FloatAttr &>((mlir::UnknownLoc **)(a2 + 8), v85, v106, &v92, (uint64_t *)&FloatAttr);
    mlir::verify(v86, (mlir::Operation *)1);
  }
LABEL_83:
  uint64_t v87 = (mlir::anec::_anonymous_namespace_ *)std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t mlir::anec::anonymous namespace'::canonicalizeElementwiseToGOC(mlir::anec::_anonymous_namespace_ *this, mlir::Float16Type **a2, mlir::PatternRewriter *a3)
{
  v149[5] = *MEMORY[0x1E4F143B8];
  RawElementsAttr = 0;
  uint64_t v135 = 0;
  char v5 = *(char **)(*((void *)this + 9) + 56);
  uint64_t v141 = &RawElementsAttr;
  uint64_t v144 = v5;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v144);
  if (DefiningOp && mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v141, DefiningOp))
  {
    uint64_t v7 = *((void *)this + 9);
    uint64_t v8 = *(void *)(v7 + 24);
    uint64_t v133 = v8;
    uint64_t v9 = v7 + 56;
    int v10 = 1;
  }
  else
  {
    uint64_t v11 = *(char **)(*((void *)this + 9) + 24);
    uint64_t v141 = &RawElementsAttr;
    uint64_t v144 = v11;
    uint64_t v12 = mlir::Value::getDefiningOp((mlir::Value *)&v144);
    if (!v12 || !mlir::detail::constant_op_binder<mlir::ElementsAttr>::match((uint64_t ***)&v141, v12)) {
      return 0;
    }
    int v10 = 0;
    uint64_t v13 = *((void *)this + 9);
    uint64_t v8 = *(void *)(v13 + 56);
    uint64_t v133 = v8;
    uint64_t v9 = v13 + 24;
  }
  uint64_t v14 = (void *)(*(void *)(*(void *)v9 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v14) {
    goto LABEL_16;
  }
  uint64_t v15 = *v14;
  unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v17 = *(unsigned int *)(v15 + 16);
  if (!v17) {
    goto LABEL_16;
  }
  uint64_t v18 = *(void **)(v15 + 8);
  unint64_t v19 = &v18[2 * v17];
  do
  {
    unint64_t v20 = v17 >> 1;
    uint64_t v21 = &v18[2 * (v17 >> 1)];
    unint64_t v23 = *v21;
    unint64_t v22 = v21 + 2;
    v17 += ~(v17 >> 1);
    if (v23 < v16) {
      uint64_t v18 = v22;
    }
    else {
      unint64_t v17 = v20;
    }
  }
  while (v17);
  if (v18 != v19 && *v18 == v16) {
    uint64_t v24 = v18[1];
  }
  else {
LABEL_16:
  }
    uint64_t v24 = 0;
  uint64_t v131 = v14;
  uint64_t v132 = v24;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v131);
  mlir::anec::getIndexFromDim(1, v25);
  if (v26)
  {
    if ((mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RawElementsAttr) & 1) == 0
      && !mlir::anec::allElementsOnAxis((uint64_t)v131, v132, 1))
    {
      return 0;
    }
    uint64_t v27 = (uint64_t *)(*(void *)(v8 + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v27) {
      goto LABEL_29;
    }
    uint64_t v28 = *v27;
    unint64_t v29 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v30 = *(unsigned int *)(v28 + 16);
    if (!v30) {
      goto LABEL_29;
    }
    unsigned int v31 = *(void **)(v28 + 8);
    unsigned int v32 = &v31[2 * v30];
    do
    {
      unint64_t v33 = v30 >> 1;
      unint64_t v34 = &v31[2 * (v30 >> 1)];
      unint64_t v36 = *v34;
      unint64_t v35 = v34 + 2;
      v30 += ~(v30 >> 1);
      if (v36 < v29) {
        unsigned int v31 = v35;
      }
      else {
        unint64_t v30 = v33;
      }
    }
    while (v30);
    if (v31 != v32 && *v31 == v29) {
      uint64_t v37 = v31[1];
    }
    else {
LABEL_29:
    }
      uint64_t v37 = 0;
    v130[0] = v27;
    v130[1] = v37;
    unint64_t v38 = (uint64_t *)(*((void *)this - 1) & 0xFFFFFFFFFFFFFFF8);
    if (!v38) {
      goto LABEL_39;
    }
    uint64_t v39 = *v38;
    unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v41 = *(unsigned int *)(v39 + 16);
    if (!v41) {
      goto LABEL_39;
    }
    unint64_t v42 = *(void **)(v39 + 8);
    uint64_t v43 = &v42[2 * v41];
    do
    {
      unint64_t v44 = v41 >> 1;
      uint64_t v45 = &v42[2 * (v41 >> 1)];
      unint64_t v47 = *v45;
      unint64_t v46 = v45 + 2;
      v41 += ~(v41 >> 1);
      if (v47 < v40) {
        unint64_t v42 = v46;
      }
      else {
        unint64_t v41 = v44;
      }
    }
    while (v41);
    if (v42 != v43 && *v42 == v40) {
      uint64_t v48 = v42[1];
    }
    else {
LABEL_39:
    }
      uint64_t v48 = 0;
    v129[0] = (uint64_t)v38;
    v129[1] = v48;
    uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v130);
    uint64_t v51 = v50;
    char v52 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v129);
    if (v51 != v53 || memcmp(ArgAttrsAttr, v52, 8 * v51)) {
      return 0;
    }
    char v57 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v131);
    uint64_t v58 = v56;
    uint64_t v147 = (char *)v149;
    uint64_t v148 = 0x500000000;
    size_t v59 = 8 * v56;
    if ((unint64_t)(8 * v56) < 0x29)
    {
      int v60 = 0;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v147, v149, (8 * v56) >> 3, 8);
      int v60 = v148;
    }
    if (v58)
    {
      memcpy(&v147[8 * v60], v57, v59);
      int v60 = v148;
    }
    LODWORD(v148) = v60 + (v59 >> 3);
    if (!mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RawElementsAttr))
    {
LABEL_73:
      uint64_t v70 = v147;
      uint64_t v71 = (mlir::AffineMap *)v148;
      uint64_t F16Type = mlir::Builder::getF16Type(a2 + 1, (mlir::MLIRContext *)v61);
      uint64_t v128 = mlir::MemRefType::get(v70, v71, F16Type, 0, 0, 0);
      Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&RawElementsAttr);
      if (*(_UNKNOWN **)(*(void *)mlir::getElementTypeOrSelf(Type) + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
      {
        uint64_t v144 = (char *)v146;
        uint64_t v145 = 0xC00000000;
        mlir::getIntValues<float>((uint64_t)RawElementsAttr, v135, (uint64_t)&v144, 0);
        uint64_t v101 = (uint64_t)v147;
        uint64_t v102 = v148;
        uint64_t F32Type = mlir::Builder::getF32Type(a2 + 1, v103);
        uint64_t v105 = (void *)mlir::RankedTensorType::get(v101, v102, F32Type, 0);
        RawElementsAttr = (char *)mlir::createRawElementsAttr(v105, v144, (const void *)(4 * v145));
        uint64_t v135 = v106;
        if (v144 != (char *)v146) {
          free(v144);
        }
      }
      else if (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&RawElementsAttr))
      {
        uint64_t v144 = RawElementsAttr;
        uint64_t v74 = (uint64_t)v147;
        uint64_t v75 = v148;
        uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(RawElementsAttr);
        size_t v77 = (uint64_t *)mlir::RankedTensorType::get(v74, v75, ElementTypeOrSelf, 0);
        uint64_t v78 = (uint64_t)v77;
        if (!v77) {
          goto LABEL_84;
        }
        uint64_t v79 = *v77;
        unint64_t v80 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v81 = *(unsigned int *)(v79 + 16);
        if (!v81) {
          goto LABEL_84;
        }
        uint64_t v82 = *(void **)(v79 + 8);
        unint64_t v83 = &v82[2 * v81];
        do
        {
          unint64_t v84 = v81 >> 1;
          uint64_t v85 = &v82[2 * (v81 >> 1)];
          unint64_t v87 = *v85;
          unint64_t v86 = v85 + 2;
          v81 += ~(v81 >> 1);
          if (v87 < v80) {
            uint64_t v82 = v86;
          }
          else {
            unint64_t v81 = v84;
          }
        }
        while (v81);
        if (v82 != v83 && *v82 == v80) {
          uint64_t v88 = v82[1];
        }
        else {
LABEL_84:
        }
          uint64_t v88 = 0;
        uint64_t v89 = (char *)mlir::DenseElementsAttr::reshape((uint64_t *)&v144, v78, v88);
        uint64_t v90 = v89;
        if (!v89) {
          goto LABEL_94;
        }
        uint64_t v91 = *(void *)v89;
        unint64_t v92 = mlir::TypeID::get<mlir::ElementsAttr>();
        unint64_t v93 = *(unsigned int *)(v91 + 16);
        if (!v93) {
          goto LABEL_94;
        }
        char v94 = *(void **)(v91 + 8);
        uint64_t v95 = &v94[2 * v93];
        do
        {
          unint64_t v96 = v93 >> 1;
          uint64_t v97 = &v94[2 * (v93 >> 1)];
          unint64_t v99 = *v97;
          int v98 = v97 + 2;
          v93 += ~(v93 >> 1);
          if (v99 < v92) {
            char v94 = v98;
          }
          else {
            unint64_t v93 = v96;
          }
        }
        while (v93);
        if (v94 != v95 && *v94 == v92) {
          uint64_t v100 = v94[1];
        }
        else {
LABEL_94:
        }
          uint64_t v100 = 0;
        RawElementsAttr = v90;
        uint64_t v135 = v100;
      }
      unint64_t v127 = mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a2 + 1), *((void *)this + 3), &v128, (void **)&RawElementsAttr);
      uint64_t v107 = (uint64_t)v147;
      uint64_t v108 = v148;
      uint64_t v110 = mlir::Builder::getF32Type(a2 + 1, v109);
      uint64_t v111 = (void *)mlir::RankedTensorType::get(v107, v108, v110, 0);
      uint64_t v144 = (char *)v146;
      v146[0] = 0;
      uint64_t v145 = 0xC00000001;
      uint64_t v141 = v143;
      v143[0] = 1065353216;
      uint64_t v142 = 0xC00000001;
      uint64_t v138 = v140;
      v140[0] = -1082130432;
      uint64_t v139 = 0xC00000001;
      uint64_t v112 = *((void *)this + 3);
      uint64_t v122 = mlir::createRawElementsAttr(v111, v140, (const void *)4);
      uint64_t v123 = v113;
      uint64_t v124 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a2 + 1), v112, &v128, &v122)- 16;
      uint64_t v114 = *((void *)this + 3);
      uint64_t v122 = mlir::createRawElementsAttr(v111, v144, (const void *)(4 * v145));
      uint64_t v123 = v115;
      uint64_t v126 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a2 + 1), v114, &v128, &v122)- 16;
      uint64_t v116 = *((void *)this + 3);
      uint64_t v122 = mlir::createRawElementsAttr(v111, v141, (const void *)(4 * v142));
      uint64_t v123 = v117;
      uint64_t v125 = (uint64_t)mlir::OpBuilder::create<mlir::mps::ConstantOp,mlir::Type &,mlir::ElementsAttr &>((mlir::OpBuilder *)(a2 + 1), v116, &v128, &v122)- 16;
      uint64_t v118 = *(void **)(*((void *)this + 6) + 16);
      if (v118 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseAdd,void>::id)
      {
        uint64_t v119 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a2 + 1), *((void *)this + 3), v129, &v133, &v125, &v127);
      }
      else
      {
        if (v118 != &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseMult,void>::id)
        {
          if (v118 == &mlir::detail::TypeIDResolver<mlir::anec::ElementwiseSub,void>::id)
          {
            uint64_t v122 = (void *)((char *)mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a2 + 1), *((void *)this + 3), v129, &v133, &v124, &v126)- 16);
            uint64_t v120 = (char *)mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::Value &,mlir::mps::ConstantOp &>((mlir::OpBuilder *)(a2 + 1), *((void *)this + 3), v129, (uint64_t *)&v122, &v125, &v127)- 16;
            uint64_t v122 = v120;
            if (v10)
            {
              uint64_t v120 = (char *)mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::Value &,mlir::Value &>((mlir::OpBuilder *)(a2 + 1), *((void *)this + 3), v129, (uint64_t *)&v122, &v124, &v126)- 16;
              uint64_t v122 = v120;
            }
            unint64_t v136 = v120;
            uint64_t v54 = 1;
            mlir::ValueRange::ValueRange(v137, (uint64_t)&v136, 1uLL);
            (*((void (**)(mlir::Float16Type **, mlir::anec::_anonymous_namespace_ *, unint64_t, unint64_t))*a2
             + 3))(a2, this, v137[0], v137[1]);
          }
          else
          {
            uint64_t v54 = 0;
          }
          goto LABEL_105;
        }
        uint64_t v119 = mlir::OpBuilder::create<mlir::anec::GOC,mlir::ShapedType &,mlir::Value &,mlir::mps::ConstantOp &,mlir::Value &>((mlir::OpBuilder *)(a2 + 1), *((void *)this + 3), v129, &v133, &v127, &v126);
      }
      (*((void (**)(mlir::Float16Type **, mlir::anec::_anonymous_namespace_ *, mlir::GenericProgramPoint *))*a2
       + 4))(a2, this, v119);
      uint64_t v54 = 1;
LABEL_105:
      if (v138 != v140) {
        free(v138);
      }
      if (v141 != v143) {
        free(v141);
      }
      if (v144 != (char *)v146) {
        free(v144);
      }
      goto LABEL_111;
    }
    int v62 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v130);
    if (mlir::ShapedType::getNumElements(v62, v63) != 1)
    {
      uint64_t v64 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v130);
      uint64_t NumElements = mlir::ShapedType::getNumElements(v64, v65);
      if (NumElements < mlir::ElementsAttr::getNumElements((uint64_t)RawElementsAttr, v135))
      {
        uint64_t v54 = 0;
LABEL_111:
        if (v147 != (char *)v149) {
          free(v147);
        }
        return v54;
      }
    }
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v130);
    unint64_t v67 = v61;
    uint64_t v144 = (char *)v146;
    HIDWORD(v145) = 5;
    if (v61 < 6)
    {
      if (v61) {
        memset_pattern16(v146, &unk_1810FE350, 8 * v61);
      }
      int v68 = v146;
    }
    else
    {
      LODWORD(v145) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v144, v146, v61, 8);
      int v68 = v144;
      memset_pattern16(v144, &unk_1810FE350, 8 * v67);
    }
    LODWORD(v145) = v67;
    uint64_t v69 = v148;
    if (v148 >= v67)
    {
      if (v67) {
        memmove(v147, v68, 8 * v67);
      }
      goto LABEL_71;
    }
    if (HIDWORD(v148) >= v67)
    {
      if (v148)
      {
        memmove(v147, v68, 8 * v148);
        goto LABEL_69;
      }
    }
    else
    {
      LODWORD(v148) = 0;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v147, v149, v67, 8);
    }
    uint64_t v69 = 0;
LABEL_69:
    if (v69 != v145) {
      memcpy(&v147[8 * v69], &v144[8 * v69], 8 * v145 - 8 * v69);
    }
LABEL_71:
    LODWORD(v148) = v67;
    if (v144 != (char *)v146) {
      free(v144);
    }
    goto LABEL_73;
  }
  uint64_t v121 = std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::anec::ElementwiseSub::canonicalize(v121);
}

uint64_t mlir::anec::ElementwiseMax::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  unsigned int v4 = *(const char **)(*(void *)(a1 + 72) + 56);
  unint64_t v17 = (const char **)&v15;
  unint64_t v19 = v4;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v19);
  if (DefiningOp
    && mlir::detail::constant_op_binder<mlir::DenseFPElementsAttr>::match((unint64_t **)&v17, DefiningOp)
    && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v15)
    && (*(_DWORD *)(a1 + 36) ? (uint64_t v6 = a1 - 16) : (uint64_t v6 = 0),
        (*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)))
  {
    uint64_t v16 = *(void *)(*(void *)(a1 + 72) + 24);
    mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v15, (uint64_t)&v19);
    int v10 = llvm::APFloatBase::IEEEhalf(v9);
    LOBYTE(v17) = 0;
    uint64_t v11 = (llvm::APFloatBase *)llvm::APFloat::convert((uint64_t)&v19, v10, 1, &v17);
    uint64_t v12 = v20[0];
    uint64_t v13 = llvm::APFloatBase::PPCDoubleDouble(v11);
    if (v13 == (void *)v12) {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(v18, v12);
    }
    else {
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v18, v12);
    }
    if (v13 == (void *)v18[0]) {
      llvm::detail::DoubleAPFloat::makeLargest((llvm::detail::DoubleAPFloat *)v18, 0);
    }
    else {
      llvm::detail::IEEEFloat::makeLargest((llvm::detail::IEEEFloat *)v18, 0);
    }
    uint64_t v14 = mlir::OpBuilder::create<mlir::anec::ClampedRelu,mlir::Value &,llvm::APFloat &,llvm::APFloat>((mlir::Float16Type **)(a2 + 8), *(void *)(a1 + 24), &v16, (uint64_t)&v19, (uint64_t)&v17);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v14);
    if (v13 == (void *)v18[0]) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
    }
    if (v13 == (void *)v20[0]) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
    }
    return 1;
  }
  else
  {
    unint64_t v19 = "rhs is not a non-broadcasting scalar constant";
    __int16 v21 = 259;
    unint64_t v17 = &v19;
    uint64_t v7 = *(void *)(a2 + 16);
    if (v7)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v7);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v7 + 64))(v7, *(void *)(a1 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::anec::ElementwiseMax &>(mlir::anec::ElementwiseMax &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v17);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>(mlir::DenseElementsAttr *a1@<X0>, uint64_t a2@<X8>)
{
  mlir::DenseElementsAttr::tryGetFloatValues(a1, (uint64_t)v12);
  *(_OWORD *)long long __p = v12[0];
  long long v7 = v12[1];
  long long v8 = v13;
  long long v9 = v14;
  long long v10 = v15;
  long long v11 = v16;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)v12, (llvm::APInt *)__p);
  uint64_t v3 = (void *)v13;
  unsigned int v4 = (llvm::detail::IEEEFloat *)(a2 + 8);
  if (llvm::APFloatBase::PPCDoubleDouble(v5) == v3) {
    llvm::detail::DoubleAPFloat::DoubleAPFloat(v4, (uint64_t)v3, (uint64_t)__p);
  }
  else {
    llvm::detail::IEEEFloat::IEEEFloat(v4, v3, (const llvm::APInt **)__p);
  }
  if (LODWORD(__p[1]) >= 0x41)
  {
    if (__p[0]) {
      operator delete[](__p[0]);
    }
  }
}

uint64_t mlir::anec::ElementwiseMin::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = 0;
  unsigned int v4 = *(const char **)(*(void *)(a1 + 72) + 56);
  unint64_t v17 = (const char **)&v15;
  unint64_t v19 = v4;
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v19);
  if (DefiningOp
    && mlir::detail::constant_op_binder<mlir::DenseFPElementsAttr>::match((unint64_t **)&v17, DefiningOp)
    && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v15)
    && (*(_DWORD *)(a1 + 36) ? (uint64_t v6 = a1 - 16) : (uint64_t v6 = 0),
        (*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8) == (*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8)))
  {
    uint64_t v16 = *(void *)(*(void *)(a1 + 72) + 24);
    mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v15, (uint64_t)&v19);
    long long v10 = llvm::APFloatBase::IEEEhalf(v9);
    LOBYTE(v17) = 0;
    long long v11 = (llvm::APFloatBase *)llvm::APFloat::convert((uint64_t)&v19, v10, 1, &v17);
    uint64_t v12 = v20[0];
    long long v13 = llvm::APFloatBase::PPCDoubleDouble(v11);
    if (v13 == (void *)v12) {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(v18, v12);
    }
    else {
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v18, v12);
    }
    if (v13 == (void *)v18[0]) {
      llvm::detail::DoubleAPFloat::makeLargest((llvm::detail::DoubleAPFloat *)v18, 1);
    }
    else {
      llvm::detail::IEEEFloat::makeLargest((llvm::detail::IEEEFloat *)v18, 1);
    }
    long long v14 = mlir::OpBuilder::create<mlir::anec::ClampedRelu,mlir::Value &,llvm::APFloat,llvm::APFloat&>((mlir::Float16Type **)(a2 + 8), *(void *)(a1 + 24), &v16, (uint64_t)&v17, (uint64_t)&v19);
    (*(void (**)(uint64_t, uint64_t, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v14);
    if (v13 == (void *)v18[0]) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v18);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v18);
    }
    if (v13 == (void *)v20[0]) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v20);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v20);
    }
    return 1;
  }
  else
  {
    unint64_t v19 = "rhs is not a non-broadcasting scalar constant";
    __int16 v21 = 259;
    unint64_t v17 = &v19;
    uint64_t v7 = *(void *)(a2 + 16);
    if (v7)
    {
      uint64_t result = mlir::RewriterBase::Listener::classof(v7);
      if (result) {
        return (*(uint64_t (**)(uint64_t, void, uint64_t (*)(const void ****, uint64_t), const char ***))(*(void *)v7 + 64))(v7, *(void *)(a1 + 24), llvm::function_ref<void ()(mlir::Diagnostic &)>::callback_fn<mlir::LogicalResult mlir::RewriterBase::notifyMatchFailure<mlir::anec::ElementwiseMin &>(mlir::anec::ElementwiseMin &,llvm::Twine const&)::{lambda(mlir::Diagnostic &)#1}>, &v17);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t mlir::anec::Ceil::addOpToNetwork(mlir::anec **a1, uint64_t a2)
{
  v90[4] = *(void **)MEMORY[0x1E4F143B8];
  uint64_t v3 = *a1;
  unsigned int v4 = *(void **)(*((void *)*a1 + 9) + 24);
  if (*((_DWORD *)*a1 + 9)) {
    uint64_t v5 = (uint64_t)*a1 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  mlir::anec::computeOpKeyString(v3, &v83);
  long long __p = v4;
  if (mlir::Value::getDefiningOp((mlir::Value *)&__p))
  {
    uint64_t DefiningOp = (mlir::anec *)mlir::Value::getDefiningOp((mlir::Value *)&__p);
    mlir::anec::computeOpKeyString(DefiningOp, &v82);
  }
  else
  {
    long long v8 = (unsigned int *)__p;
    if ((~*((_DWORD *)__p + 2) & 7) != 0) {
      long long v8 = 0;
    }
    v90[0] = (void *)v8[6];
    unint64_t v87 = (uint64_t *)"__arg";
    v88[1] = v90;
    __int16 v89 = 3331;
    llvm::Twine::str((llvm::Twine *)&v87, &v82);
  }
  long long v9 = *(void **)(*((void *)v3 + 6) + 16);
  if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Ceil,void>::id)
  {
    int v10 = 0;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::ClampedRelu,void>::id)
  {
    int v10 = 1;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Cos,void>::id)
  {
    int v10 = 2;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Degamma,void>::id)
  {
    int v10 = 3;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Dirac,void>::id)
  {
    int v10 = 4;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Elu,void>::id)
  {
    int v10 = 5;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Erf,void>::id)
  {
    int v10 = 6;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id)
  {
    int v10 = 7;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id)
  {
    int v10 = 8;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Gelu,void>::id)
  {
    int v10 = 9;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::HighPrecisionSigmoid,void>::id)
  {
    int v10 = 10;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id)
  {
    int v10 = 11;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::LeakyRelu,void>::id)
  {
    int v10 = 12;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Log2,void>::id)
  {
    int v10 = 13;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::NRelu,void>::id)
  {
    int v10 = 14;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
  {
    int v10 = 15;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::RoundNearest,void>::id)
  {
    int v10 = 16;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Rsqrt,void>::id)
  {
    int v10 = 17;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Sigmoid,void>::id)
  {
    int v10 = 18;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Sign,void>::id)
  {
    int v10 = 19;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Sin,void>::id)
  {
    int v10 = 20;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Sqr,void>::id)
  {
    int v10 = 21;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Sqrt,void>::id)
  {
    int v10 = 22;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Swish,void>::id)
  {
    int v10 = 23;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Tanh,void>::id)
  {
    int v10 = 24;
  }
  else if (v9 == &mlir::detail::TypeIDResolver<mlir::anec::Trunc,void>::id)
  {
    int v10 = 25;
  }
  else
  {
    int v10 = 0;
  }
  long long v11 = (char *)operator new(0xC0uLL);
  *(void *)long long v11 = &unk_1EC9CB3F8;
  uint64_t v12 = (std::string *)(v11 + 8);
  if (SHIBYTE(v83.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v12, v83.__r_.__value_.__l.__data_, v83.__r_.__value_.__l.__size_);
  }
  else
  {
    *(_OWORD *)&v12->__r_.__value_.__l.__data_ = *(_OWORD *)&v83.__r_.__value_.__l.__data_;
    *((void *)v11 + 3) = *((void *)&v83.__r_.__value_.__l + 2);
  }
  *((_DWORD *)v11 + 8) = 4;
  *((void *)v11 + 5) = 0;
  v11[48] = 0;
  *((void *)v11 + 7) = @"Neuron";
  *((void *)v11 + 8) = v11 + 80;
  *((void *)v11 + 9) = 0x100000000;
  *((void *)v11 + 14) = v11 + 128;
  *((void *)v11 + 15) = 0x300000000;
  *(void *)long long v11 = &unk_1EC9CB418;
  *((_DWORD *)v11 + 44) = v10;
  long long v13 = (std::__shared_weak_count *)operator new(0x20uLL);
  v13->__shared_owners_ = 0;
  v13->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0280;
  v13->__shared_weak_owners_ = 0;
  v13[1].__vftable = (std::__shared_weak_count_vtbl *)v11;
  if (!llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(v4[1] & 0xFFFFFFFFFFFFFFF8))) {
    goto LABEL_256;
  }
  uint64_t ANECIRDataType = mlir::anec::getANECIRDataType((uint64_t)v4);
  if ((ANECIRDataType & 0xFF00000000) == 0) {
    goto LABEL_256;
  }
  mlir::anec::ANECIRUnit::AddInput((uint64_t)v11, (uint64_t)&v82, ANECIRDataType);
  uint64_t v15 = *(void **)(*((void *)v3 + 6) + 16);
  if (v15 == &mlir::detail::TypeIDResolver<mlir::anec::Ceil,void>::id) {
    goto LABEL_249;
  }
  if (v15 == &mlir::detail::TypeIDResolver<mlir::anec::ClampedRelu,void>::id)
  {
    uint64_t v80 = NextResultAtOffset;
    unint64_t v86 = v3;
    long long __p = (void *)mlir::anec::ClampedRelu::getMaxValueAttr(&v86);
    uint64_t Value = mlir::FloatAttr::getValue((mlir::FloatAttr *)&__p, (uint64_t)v90);
    uint64_t v18 = v90[1];
    unint64_t v19 = llvm::APFloatBase::PPCDoubleDouble(Value);
    if (v19 == v18) {
      llvm::detail::DoubleAPFloat::DoubleAPFloat(v88, (uint64_t)v19);
    }
    else {
      llvm::detail::IEEEFloat::IEEEFloat((uint64_t)v88, (uint64_t)v18);
    }
    if (v19 == (void *)v88[0]) {
      llvm::detail::DoubleAPFloat::makeLargest((llvm::detail::DoubleAPFloat *)v88, 0);
    }
    else {
      llvm::detail::IEEEFloat::makeLargest((llvm::detail::IEEEFloat *)v88, 0);
    }
    if (v19 == v90[1]) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v90[1]);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v90[1]);
    }
    long long __p = (void *)mlir::anec::ClampedRelu::getMinValueAttr(&v86);
    mlir::FloatAttr::getValue((mlir::FloatAttr *)&__p, (uint64_t)v90);
    if (v19 == (void *)v88[0]) {
      int v20 = llvm::detail::DoubleAPFloat::compare((llvm::detail::DoubleAPFloat *)v88, (const llvm::detail::DoubleAPFloat *)&v90[1]);
    }
    else {
      int v20 = llvm::detail::IEEEFloat::compare((llvm::detail::IEEEFloat *)v88, (const llvm::detail::IEEEFloat *)&v90[1]);
    }
    __int16 v21 = v90;
    if (v20)
    {
      uint64_t v22 = (llvm::detail::DoubleAPFloat *)&v90[1];
    }
    else
    {
      __int16 v21 = (void **)&v87;
      uint64_t v22 = (llvm::detail::DoubleAPFloat *)v88;
    }
    if (v19 == v21[1]) {
      llvm::detail::DoubleAPFloat::bitcastToAPInt(v22, (llvm::APInt *)&__p);
    }
    else {
      llvm::detail::IEEEFloat::bitcastToAPInt(v22, (uint64_t)&__p);
    }
    unsigned int v23 = v85;
    if (v85 < 0x41)
    {
      if ((unint64_t)__p >= 0xFFFF) {
        __int16 v24 = -1;
      }
      else {
        __int16 v24 = (__int16)__p;
      }
      goto LABEL_116;
    }
    if (v23 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      if (*(void *)__p >= 0xFFFFuLL) {
        LOWORD(v28) = -1;
      }
      else {
        uint64_t v28 = *(void *)__p;
      }
      __int16 v24 = v28;
    }
    else
    {
      __int16 v24 = -1;
      if (!__p)
      {
LABEL_116:
        uint64_t v29 = a2;
        if (v19 == v90[1]) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v90[1]);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v90[1]);
        }
        long long __p = (void *)mlir::anec::ClampedRelu::getMaxValueAttr(&v86);
        mlir::FloatAttr::getValue((mlir::FloatAttr *)&__p, (uint64_t)v90);
        if (v19 == (void *)v88[0]) {
          int v30 = llvm::detail::DoubleAPFloat::compare((llvm::detail::DoubleAPFloat *)v88, (const llvm::detail::DoubleAPFloat *)&v90[1]);
        }
        else {
          int v30 = llvm::detail::IEEEFloat::compare((llvm::detail::IEEEFloat *)v88, (const llvm::detail::IEEEFloat *)&v90[1]);
        }
        unsigned int v31 = v90;
        if (v30)
        {
          unsigned int v32 = (llvm::detail::DoubleAPFloat *)&v90[1];
        }
        else
        {
          unsigned int v31 = (void **)&v87;
          unsigned int v32 = (llvm::detail::DoubleAPFloat *)v88;
        }
        if (v19 == v31[1]) {
          llvm::detail::DoubleAPFloat::bitcastToAPInt(v32, (llvm::APInt *)&__p);
        }
        else {
          llvm::detail::IEEEFloat::bitcastToAPInt(v32, (uint64_t)&__p);
        }
        unsigned int v33 = v85;
        if (v85 >= 0x41)
        {
          if (v33 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
          {
            if (*(void *)__p >= 0xFFFFuLL) {
              LOWORD(v34) = -1;
            }
            else {
              uint64_t v34 = *(void *)__p;
            }
          }
          else
          {
            LOWORD(v34) = -1;
            if (!__p) {
              goto LABEL_139;
            }
          }
          operator delete[](__p);
        }
        else if ((unint64_t)__p >= 0xFFFF)
        {
          LOWORD(v34) = -1;
        }
        else
        {
          LOWORD(v34) = (_WORD)__p;
        }
LABEL_139:
        if (v19 == v90[1]) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v90[1]);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v90[1]);
        }
        *((_WORD *)v11 + 93) = v24;
        *((_WORD *)v11 + 92) = v34;
        uint64_t NextResultAtOffset = v80;
        if (v19 == (void *)v88[0]) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v88);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v88);
        }
        a2 = v29;
        goto LABEL_249;
      }
    }
    operator delete[](__p);
    goto LABEL_116;
  }
  if (v15 != &mlir::detail::TypeIDResolver<mlir::anec::Dirac,void>::id
    && v15 != &mlir::detail::TypeIDResolver<mlir::anec::Cos,void>::id
    && v15 != &mlir::detail::TypeIDResolver<mlir::anec::Degamma,void>::id)
  {
    if (v15 == &mlir::detail::TypeIDResolver<mlir::anec::Elu,void>::id)
    {
      unint64_t v86 = v3;
      long long __p = (void *)mlir::anec::Tile::getMultipliersAttr(&v86);
      unint64_t v25 = mlir::FloatAttr::getValue((mlir::FloatAttr *)&__p, (uint64_t)&v87);
      char v26 = (void *)v88[0];
      uint64_t v27 = llvm::APFloatBase::PPCDoubleDouble(v25);
      if (v27 == v26) {
        llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v88, (llvm::APInt *)v90);
      }
      else {
        llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)v88, (uint64_t)v90);
      }
      int v35 = (int)v90[1];
      if (LODWORD(v90[1]) < 0x41)
      {
        if (v90[0] < (void *)0x10000) {
          *((_WORD *)v11 + 94) = v90[0];
        }
        else {
          *((_WORD *)v11 + 94) = -1;
        }
        goto LABEL_175;
      }
      unsigned int v36 = v35 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v90);
      uint64_t v37 = v90[0];
      if (v36 <= 0x40)
      {
        uint64_t v38 = *(void *)v90[0];
        if (*(void *)v90[0] >= 0xFFFFuLL) {
          LOWORD(v38) = -1;
        }
        *((_WORD *)v11 + 94) = v38;
      }
      else
      {
        *((_WORD *)v11 + 94) = -1;
        if (!v37) {
          goto LABEL_175;
        }
      }
      goto LABEL_174;
    }
    if (v15 != &mlir::detail::TypeIDResolver<mlir::anec::HighPrecisionSigmoid,void>::id
      && v15 != &mlir::detail::TypeIDResolver<mlir::anec::Gelu,void>::id
      && v15 != &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id
      && v15 != &mlir::detail::TypeIDResolver<mlir::anec::Erf,void>::id
      && v15 != &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id)
    {
      if (v15 == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id) {
        goto LABEL_160;
      }
      if (v15 != &mlir::detail::TypeIDResolver<mlir::anec::LeakyRelu,void>::id)
      {
        if (v15 != &mlir::detail::TypeIDResolver<mlir::anec::Log2,void>::id)
        {
          if (v15 != &mlir::detail::TypeIDResolver<mlir::anec::NRelu,void>::id)
          {
            if (v15 != &mlir::detail::TypeIDResolver<mlir::anec::Rsqrt,void>::id) {
              goto LABEL_249;
            }
            long long __p = v3;
            v90[0] = (void *)mlir::anec::Tile::getMultipliersAttr((mlir::Operation **)&__p);
            p_p = v90;
LABEL_161:
            unint64_t v42 = mlir::FloatAttr::getValue((mlir::FloatAttr *)p_p, (uint64_t)&v87);
            uint64_t v43 = (void *)v88[0];
            uint64_t v27 = llvm::APFloatBase::PPCDoubleDouble(v42);
            if (v27 == v43) {
              llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v88, (llvm::APInt *)v90);
            }
            else {
              llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)v88, (uint64_t)v90);
            }
            int v44 = (int)v90[1];
            if (LODWORD(v90[1]) < 0x41)
            {
              if (v90[0] < (void *)0x10000) {
                *((_WORD *)v11 + 95) = v90[0];
              }
              else {
                *((_WORD *)v11 + 95) = -1;
              }
              goto LABEL_175;
            }
            unsigned int v45 = v44 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v90);
            uint64_t v37 = v90[0];
            if (v45 <= 0x40)
            {
              uint64_t v46 = *(void *)v90[0];
              if (*(void *)v90[0] >= 0xFFFFuLL) {
                LOWORD(v46) = -1;
              }
              *((_WORD *)v11 + 95) = v46;
            }
            else
            {
              *((_WORD *)v11 + 95) = -1;
              if (!v37)
              {
LABEL_175:
                if (v27 == (void *)v88[0]) {
                  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v88);
                }
                else {
                  llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v88);
                }
                goto LABEL_249;
              }
            }
LABEL_174:
            operator delete[](v37);
            goto LABEL_175;
          }
          long long __p = v3;
          v90[0] = (void *)mlir::anec::ClampedRelu::getMaxValueAttr((mlir::Operation **)&__p);
          unint64_t v47 = mlir::FloatAttr::getValue((mlir::FloatAttr *)v90, (uint64_t)&v87);
          uint64_t v48 = (void *)v88[0];
          uint64_t v49 = llvm::APFloatBase::PPCDoubleDouble(v47);
          if (v49 == v48) {
            llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v88, (llvm::APInt *)v90);
          }
          else {
            llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)v88, (uint64_t)v90);
          }
          int v57 = (int)v90[1];
          if (LODWORD(v90[1]) < 0x41)
          {
            if (v90[0] >= (void *)0xFFFF) {
              LOWORD(v58) = -1;
            }
            else {
              LOWORD(v58) = v90[0];
            }
            goto LABEL_228;
          }
          if (v57 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v90) <= 0x40)
          {
            if (*(void *)v90[0] >= 0xFFFFuLL) {
              LOWORD(v58) = -1;
            }
            else {
              uint64_t v58 = *(void *)v90[0];
            }
          }
          else
          {
            LOWORD(v58) = -1;
            if (!v90[0])
            {
LABEL_228:
              uint64_t v59 = NextResultAtOffset;
              uint64_t v60 = a2;
              if (v49 == (void *)v88[0]) {
                llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v88);
              }
              else {
                llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v88);
              }
              v90[0] = (void *)mlir::anec::ClampedRelu::getMinValueAttr((mlir::Operation **)&__p);
              mlir::FloatAttr::getValue((mlir::FloatAttr *)v90, (uint64_t)&v87);
              if (v49 == (void *)v88[0]) {
                llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v88, (llvm::APInt *)v90);
              }
              else {
                llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)v88, (uint64_t)v90);
              }
              int v61 = (int)v90[1];
              if (LODWORD(v90[1]) >= 0x41)
              {
                if (v61 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v90) <= 0x40)
                {
                  if (*(void *)v90[0] >= 0xFFFFuLL) {
                    LOWORD(v62) = -1;
                  }
                  else {
                    uint64_t v62 = *(void *)v90[0];
                  }
                }
                else
                {
                  LOWORD(v62) = -1;
                  if (!v90[0]) {
                    goto LABEL_245;
                  }
                }
                operator delete[](v90[0]);
              }
              else if (v90[0] >= (void *)0xFFFF)
              {
                LOWORD(v62) = -1;
              }
              else
              {
                LOWORD(v62) = v90[0];
              }
LABEL_245:
              if (v49 == (void *)v88[0]) {
                llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v88);
              }
              else {
                llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v88);
              }
              *((_WORD *)v11 + 91) = v62;
              *((_WORD *)v11 + 92) = v58;
              a2 = v60;
              uint64_t NextResultAtOffset = v59;
              goto LABEL_249;
            }
          }
          operator delete[](v90[0]);
          goto LABEL_228;
        }
LABEL_160:
        unint64_t v86 = v3;
        long long __p = (void *)mlir::anec::Tile::getMultipliersAttr(&v86);
        p_p = &__p;
        goto LABEL_161;
      }
      long long __p = v3;
      v90[0] = (void *)mlir::anec::ClampedRelu::getMaxValueAttr((mlir::Operation **)&__p);
      uint64_t v39 = mlir::FloatAttr::getValue((mlir::FloatAttr *)v90, (uint64_t)&v87);
      unint64_t v40 = (void *)v88[0];
      unint64_t v41 = llvm::APFloatBase::PPCDoubleDouble(v39);
      if (v41 == v40) {
        llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v88, (llvm::APInt *)v90);
      }
      else {
        llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)v88, (uint64_t)v90);
      }
      int v50 = (int)v90[1];
      if (LODWORD(v90[1]) < 0x41)
      {
        __int16 v51 = (__int16)v90[0];
        if (v90[0] >= (void *)0xFFFF) {
          __int16 v51 = -1;
        }
        __int16 v81 = v51;
LABEL_193:
        uint64_t v53 = a2;
        if (v41 == (void *)v88[0]) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v88);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v88);
        }
        v90[0] = (void *)mlir::anec::ClampedRelu::getMinValueAttr((mlir::Operation **)&__p);
        mlir::FloatAttr::getValue((mlir::FloatAttr *)v90, (uint64_t)&v87);
        if (v41 == (void *)v88[0]) {
          llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v88, (llvm::APInt *)v90);
        }
        else {
          llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)v88, (uint64_t)v90);
        }
        int v54 = (int)v90[1];
        uint64_t v55 = NextResultAtOffset;
        if (LODWORD(v90[1]) < 0x41)
        {
          if (v90[0] >= (void *)0xFFFF) {
            LOWORD(v56) = -1;
          }
          else {
            LOWORD(v56) = v90[0];
          }
          a2 = v53;
          goto LABEL_212;
        }
        if (v54 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v90) <= 0x40)
        {
          if (*(void *)v90[0] >= 0xFFFFuLL) {
            LOWORD(v56) = -1;
          }
          else {
            uint64_t v56 = *(void *)v90[0];
          }
          a2 = v53;
        }
        else
        {
          LOWORD(v56) = -1;
          a2 = v53;
          if (!v90[0]) {
            goto LABEL_212;
          }
        }
        operator delete[](v90[0]);
LABEL_212:
        if (v41 == (void *)v88[0]) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v88);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v88);
        }
        *((_WORD *)v11 + 90) = v81;
        *((_WORD *)v11 + 91) = v56;
        uint64_t NextResultAtOffset = v55;
        goto LABEL_249;
      }
      if (v50 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)v90) <= 0x40)
      {
        if (*(void *)v90[0] >= 0xFFFFuLL) {
          LOWORD(v52) = -1;
        }
        else {
          uint64_t v52 = *(void *)v90[0];
        }
        __int16 v81 = v52;
      }
      else
      {
        __int16 v81 = -1;
        if (!v90[0]) {
          goto LABEL_193;
        }
      }
      operator delete[](v90[0]);
      goto LABEL_193;
    }
  }
LABEL_249:
  unint64_t v87 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
  v88[0] = v63;
  if (!v87) {
    goto LABEL_256;
  }
  uint64_t v64 = a2;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v87);
  unsigned int IndexFromDim = mlir::anec::getIndexFromDim(1, v65);
  if (v67)
  {
    unsigned int v68 = IndexFromDim;
    uint64_t v69 = mlir::anec::getANECIRDataType(NextResultAtOffset);
    if ((v69 & 0xFF00000000) != 0)
    {
      unsigned int v70 = v69;
      uint64_t v71 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v87) + 8 * v68);
      uint64_t v72 = *((unsigned int *)v11 + 30);
      if (v72 >= *((_DWORD *)v11 + 31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v11 + 112), v11 + 128, v72 + 1, 16);
        LODWORD(v72) = *((_DWORD *)v11 + 30);
      }
      int32x4_t v73 = (void *)(*((void *)v11 + 14) + 16 * v72);
      void *v73 = v70;
      v73[1] = v71;
      ++*((_DWORD *)v11 + 30);
      v90[0] = v11;
      v90[1] = v13;
      atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
      uint64_t v74 = *(void **)(v64 + 232);
      if ((unint64_t)v74 >= *(void *)(v64 + 240))
      {
        uint64_t v78 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(v64 + 224, (long long *)v90);
        uint64_t v75 = (std::__shared_weak_count *)v90[1];
        *(void *)(v64 + 232) = v78;
        if (!v75)
        {
LABEL_267:
          uint64_t v76 = 1;
LABEL_257:
          if (atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
          {
            if ((SHIBYTE(v82.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
              goto LABEL_259;
            }
          }
          else
          {
            ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
            std::__shared_weak_count::__release_weak(v13);
            if ((SHIBYTE(v82.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
            {
LABEL_259:
              if ((SHIBYTE(v83.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
                return v76;
              }
LABEL_263:
              operator delete(v83.__r_.__value_.__l.__data_);
              return v76;
            }
          }
          operator delete(v82.__r_.__value_.__l.__data_);
          if ((SHIBYTE(v83.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
            return v76;
          }
          goto LABEL_263;
        }
      }
      else
      {
        void *v74 = v11;
        v74[1] = v13;
        atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
        *(void *)(v64 + 232) = v74 + 2;
        uint64_t v75 = v13;
      }
      if (!atomic_fetch_add(&v75->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
      {
        ((void (*)(std::__shared_weak_count *))v75->__on_zero_shared)(v75);
        std::__shared_weak_count::__release_weak(v75);
      }
      goto LABEL_267;
    }
LABEL_256:
    uint64_t v76 = 0;
    goto LABEL_257;
  }
  uint64_t v79 = std::__throw_bad_optional_access[abi:nn180100]();
}

uint64_t mlir::anec::anonymous namespace'::verifyNeuronWithANEC(mlir::MemoryMapperInterface *a1, unint64_t a2, uint64_t *a3)
{
  v35[63] = *MEMORY[0x1E4F143B8];
  unsigned int v4 = *(void **)(a3[6] + 16);
  if (a3 && v4 == &mlir::detail::TypeIDResolver<mlir::anec::Ceil,void>::id)
  {
    uint64_t v5 = @"Ceil";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::ClampedRelu,void>::id)
  {
    uint64_t v5 = @"ClampedReLU";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Cos,void>::id)
  {
    uint64_t v5 = @"Cos";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Degamma,void>::id)
  {
    uint64_t v5 = @"Degamma";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Dirac,void>::id)
  {
    uint64_t v5 = @"Dirac";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Elu,void>::id)
  {
    uint64_t v5 = @"ELU";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Erf,void>::id)
  {
    uint64_t v5 = @"Erf";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Exp2,void>::id)
  {
    uint64_t v5 = @"Exp2";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Floor,void>::id)
  {
    uint64_t v5 = @"Floor";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Gelu,void>::id)
  {
    uint64_t v5 = @"GELU";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::HighPrecisionSigmoid,void>::id)
  {
    uint64_t v5 = @"SigmoidHighPrecision";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Invert,void>::id)
  {
    uint64_t v5 = @"Inv";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::LeakyRelu,void>::id)
  {
    uint64_t v5 = @"LeakyReLU";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Log2,void>::id)
  {
    uint64_t v5 = @"Log2";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::NRelu,void>::id)
  {
    uint64_t v5 = @"ReLUN";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Relu,void>::id)
  {
    uint64_t v5 = @"ReLU";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::RoundNearest,void>::id)
  {
    uint64_t v5 = @"RoundNearest";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Rsqrt,void>::id)
  {
    uint64_t v5 = @"Rsqrt";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Sigmoid,void>::id)
  {
    uint64_t v5 = @"Sigmoid";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Sign,void>::id)
  {
    uint64_t v5 = @"Sign";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Sin,void>::id)
  {
    uint64_t v5 = @"Sin";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Sqr,void>::id)
  {
    uint64_t v5 = @"Sqr";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Sqrt,void>::id)
  {
    uint64_t v5 = @"Sqrt";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Swish,void>::id)
  {
    uint64_t v5 = @"Swish";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Tanh,void>::id)
  {
    uint64_t v5 = @"Tanh";
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::anec::Trunc,void>::id)
  {
    uint64_t v5 = @"Trunc";
  }
  else
  {
    uint64_t v5 = 0;
  }
  long long v23 = 0u;
  long long v22 = 0u;
  __int16 v21 = v5;
  v32[0] = v33;
  v32[1] = (void *)0x100000000;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  uint64_t v6 = 1;
  *(void *)buffer = 1;
  v24[0] = 0;
  ANECUnitValidatorCreate();
  if (ANECValidateNeuronLayer())
  {
    uint64_t v16 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v7 = MEMORY[0x1E4FBA488] + 104;
    v31[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v8 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v25 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v9 = MEMORY[0x1E4FBA408];
    int v10 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v24[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v24 + (unint64_t)*(v24[0] - 3)) = v10;
    v24[1] = 0;
    long long v11 = (std::ios_base *)((char *)v24 + (unint64_t)*(v24[0] - 3));
    std::ios_base::init(v11, &v26);
    v11[1].__vftable = 0;
    v11[1].__fmtflags_ = -1;
    uint64_t v12 = *(void *)(v9 + 40);
    uint64_t v25 = *(void *)(v9 + 32);
    *(uint64_t *)((char *)&v25 + *(void *)(v25 - 24)) = v12;
    v24[0] = *(const void ***)(v9 + 8);
    *(const void ***)((char *)v24 + (unint64_t)*(v24[0] - 3)) = *(const void ***)(v9 + 48);
    v31[0] = v7;
    v24[0] = v16;
    uint64_t v25 = v8;
    std::streambuf::basic_streambuf();
    uint64_t v13 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v26 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v29 = 0u;
    int v30 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v25, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v24[0] = *(const void ***)v9;
    uint64_t v14 = *(void *)(v9 + 72);
    *(const void ***)((char *)v24 + (unint64_t)*(v24[0] - 3)) = *(const void ***)(v9 + 64);
    uint64_t v25 = v14;
    uint64_t v26 = v13;
    if (SBYTE7(v29) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v31);
    __int16 v27 = 260;
    v24[0] = (const void **)&v17;
    uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v35);
    if (v18 < 0) {
      operator delete(v17);
    }
  }
  ANECUnitValidatorDelete();
  if (v32[0] != v33) {
    free(v32[0]);
  }
  return v6;
}

BOOL mlir::anec::ElementwiseAdd::mutateOpForReshapeSwap(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5)
{
  if (!a5) {
    return 0;
  }
  if (a5 == 1)
  {
    LODWORD(v5) = *(_DWORD *)a4;
  }
  else
  {
    uint64_t v5 = *a4;
    if (*a4 == a4[1]) {
      return 1;
    }
  }
  uint64_t v7 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)a1 + 72) + 32 * (v5 ^ 1) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_16;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_16;
  }
  long long v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      long long v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_16:
  }
    uint64_t v17 = 0;
  v20[0] = v7;
  v20[1] = v17;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v20);
  return mlir::ShapedType::getNumElements(ArgAttrsAttr, v19) == 1;
}

uint64_t mlir::anec::Invert::verifyAttributesWithFamily(uint64_t *a1, uint64_t a2)
{
  uint64_t v3 = *a1;
  if ((int)a2 > 1)
  {
  }
  else
  {
    uint64_t ElementTypeOrSelf = *(void *)(*(void *)(v3 + 72) + 24);
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&ElementTypeOrSelf);
    if (DefiningOp
      && (uint64_t v5 = DefiningOp,
          uint64_t v6 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
          (*(unsigned int (**)(void, uint64_t))(**(void **)(v5 + 48) + 32))(*(void *)(v5 + 48), v6)))
    {
      uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(void *)(*(void *)(*a1 + 72) + 24));
      return mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf);
    }
    else
    {
      return 0;
    }
  }
}

uint64_t mlir::anec::detail::VerifyAttributesWithFamilyInterfaceTrait<mlir::anec::Invert>::getParentFamily(uint64_t *a1)
{
  uint64_t v2 = *a1;
  uint64_t v3 = mlir::TypeID::get<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 32))(*(void *)(v2 + 48), v3)) {
    return 6;
  }
  while (1)
  {
    unsigned int v4 = *(mlir::Block **)(v2 + 16);
    if (!v4) {
      break;
    }
    uint64_t ParentOp = mlir::Block::getParentOp(v4);
    if (!ParentOp) {
      break;
    }
    uint64_t v2 = ParentOp;
    uint64_t v6 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)6>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)6>::Impl>(void)::Empty>>();
    if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v2 + 48) + 32))(*(void *)(v2 + 48), v6)) {
      return 6;
    }
  }
  uint64_t v8 = *a1;
  uint64_t v9 = mlir::TypeID::get<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v8 + 48) + 32))(*(void *)(v8 + 48), v9)) {
    return 5;
  }
  while (1)
  {
    unint64_t v10 = *(mlir::Block **)(v8 + 16);
    if (!v10) {
      break;
    }
    uint64_t v11 = mlir::Block::getParentOp(v10);
    if (!v11) {
      break;
    }
    uint64_t v8 = v11;
    uint64_t v12 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)5>::Impl>(void)::Empty>>();
    if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v8 + 48) + 32))(*(void *)(v8 + 48), v12)) {
      return 5;
    }
  }
  uint64_t v13 = *a1;
  uint64_t v14 = mlir::TypeID::get<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v13 + 48) + 32))(*(void *)(v13 + 48), v14)) {
    return 4;
  }
  while (1)
  {
    uint64_t v15 = *(mlir::Block **)(v13 + 16);
    if (!v15) {
      break;
    }
    uint64_t v16 = mlir::Block::getParentOp(v15);
    if (!v16) {
      break;
    }
    uint64_t v13 = v16;
    uint64_t v17 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)4>::Impl>(void)::Empty>>();
    char v18 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v13 + 48) + 32))(*(void *)(v13 + 48), v17);
    uint64_t result = 4;
    if (v18) {
      return result;
    }
  }
  uint64_t v19 = *a1;
  uint64_t v20 = mlir::TypeID::get<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v19 + 48) + 32))(*(void *)(v19 + 48), v20)) {
    return 3;
  }
  while (1)
  {
    __int16 v21 = *(mlir::Block **)(v19 + 16);
    if (!v21) {
      break;
    }
    uint64_t v22 = mlir::Block::getParentOp(v21);
    if (!v22) {
      break;
    }
    uint64_t v19 = v22;
    uint64_t v23 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)3>::Impl>(void)::Empty>>();
    char v24 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v19 + 48) + 32))(*(void *)(v19 + 48), v23);
    uint64_t result = 3;
    if (v24) {
      return result;
    }
  }
  uint64_t v25 = *a1;
  uint64_t v26 = mlir::TypeID::get<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v25 + 48) + 32))(*(void *)(v25 + 48), v26)) {
    return 2;
  }
  while (1)
  {
    __int16 v27 = *(mlir::Block **)(v25 + 16);
    if (!v27) {
      break;
    }
    uint64_t v28 = mlir::Block::getParentOp(v27);
    if (!v28) {
      break;
    }
    uint64_t v25 = v28;
    uint64_t v29 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)2>::Impl>(void)::Empty>>();
    char v30 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v25 + 48) + 32))(*(void *)(v25 + 48), v29);
    uint64_t result = 2;
    if (v30) {
      return result;
    }
  }
  uint64_t v31 = *a1;
  uint64_t v32 = mlir::TypeID::get<mlir::OpTrait::RegionOp<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::RegionOp>(void)::Empty>>();
  if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v31 + 48) + 32))(*(void *)(v31 + 48), v32)) {
    return 1;
  }
  while (1)
  {
    unsigned int v33 = *(mlir::Block **)(v31 + 16);
    if (!v33) {
      break;
    }
    uint64_t v34 = mlir::Block::getParentOp(v33);
    if (!v34) {
      break;
    }
    uint64_t v31 = v34;
    uint64_t v35 = mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)1>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)1>::Impl>(void)::Empty>>();
    char v36 = (*(uint64_t (**)(void, uint64_t))(**(void **)(v31 + 48) + 32))(*(void *)(v31 + 48), v35);
    uint64_t result = 1;
    if (v36) {
      return result;
    }
  }
  mlir::op_definition_impl::verifyTrait<mlir::OpTrait::anec::MinimumFamily<(mlir::anec::Family)0>::Impl<mlir::anec::A11Legacy>>(*a1);
  return 0;
}

BOOL mlir::anec::getExecutionCostFromInputSize(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (uint64_t *)(*(void *)(*(void *)(*(void *)(a2 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    uint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v19[0] = v4;
  v19[1] = v14;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v19);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v16);
  uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v19);
}

float mlir::anec::getPoolExecutionCost<mlir::anec::MaxPool>(uint64_t a1, mlir::Operation *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  char v18 = a2;
  uint64_t KsizeAttr = mlir::anec::L2NormPool::getKsizeAttr(&v18);
  mlir::anec::L2NormPool::getStrideAttr(&v18);
  uint64_t v19 = v21;
  uint64_t v20 = 0x600000000;
  mlir::getValues<unsigned long long>(KsizeAttr, (uint64_t)&v19);
  if (v20)
  {
    uint64_t v5 = (v20 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v5)
    {
      uint64_t v6 = v5 + 1;
      uint64_t v7 = (v5 + 1) & 0x3FFFFFFFFFFFFFFELL;
      uint64_t v8 = (uint64_t *)((char *)v19 + 8 * v7);
      uint64_t v9 = (char *)v19 + 8;
      uint64_t v10 = 1;
      uint64_t v11 = v7;
      uint64_t v12 = 1;
      do
      {
        v10 *= *(v9 - 1);
        v12 *= *v9;
        v9 += 2;
        v11 -= 2;
      }
      while (v11);
      uint64_t v13 = v12 * v10;
      if (v6 == v7) {
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v13 = 1;
      uint64_t v8 = (uint64_t *)v19;
    }
    do
    {
      uint64_t v14 = *v8++;
      v13 *= v14;
    }
    while (v8 != (uint64_t *)((char *)v19 + 8 * v20));
  }
LABEL_10:
  float v16 = v15;
  if (v19 != v21) {
    free(v19);
  }
  return v16;
}

float mlir::anec::getPoolExecutionCost<mlir::anec::AveragePool>(uint64_t a1, mlir::Operation *a2)
{
  v21[6] = *MEMORY[0x1E4F143B8];
  char v18 = a2;
  uint64_t KsizeAttr = mlir::anec::AveragePool::getKsizeAttr(&v18);
  mlir::anec::AveragePool::getStrideAttr(&v18);
  uint64_t v19 = v21;
  uint64_t v20 = 0x600000000;
  mlir::getValues<unsigned long long>(KsizeAttr, (uint64_t)&v19);
  if (v20)
  {
    uint64_t v5 = (v20 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v5)
    {
      uint64_t v6 = v5 + 1;
      uint64_t v7 = (v5 + 1) & 0x3FFFFFFFFFFFFFFELL;
      uint64_t v8 = (uint64_t *)((char *)v19 + 8 * v7);
      uint64_t v9 = (char *)v19 + 8;
      uint64_t v10 = 1;
      uint64_t v11 = v7;
      uint64_t v12 = 1;
      do
      {
        v10 *= *(v9 - 1);
        v12 *= *v9;
        v9 += 2;
        v11 -= 2;
      }
      while (v11);
      uint64_t v13 = v12 * v10;
      if (v6 == v7) {
        goto LABEL_10;
      }
    }
    else
    {
      uint64_t v13 = 1;
      uint64_t v8 = (uint64_t *)v19;
    }
    do
    {
      uint64_t v14 = *v8++;
      v13 *= v14;
    }
    while (v8 != (uint64_t *)((char *)v19 + 8 * v20));
  }
LABEL_10:
  float v16 = v15;
  if (v19 != v21) {
    free(v19);
  }
  return v16;
}

BOOL mlir::anec::anonymous namespace'::getElementWiseOpExecutionCost(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (uint64_t *)(*(void *)(a2 - 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    uint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  v19[0] = v4;
  v19[1] = v14;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v19);
  mlir::ShapedType::getNumElements(ArgAttrsAttr, v16);
  uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v19);
}

float mlir::anec::InstanceNorm::getExecutionCost(uint64_t *a1, uint64_t a2)
{
  unsigned int v4 = (void *)(*(void *)(*(void *)(*(void *)(*a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    uint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    uint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  int v50 = v4;
  uint64_t v51 = v14;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50);
  IntOrFloatBitint Width = mlir::Type::getIntOrFloatBitWidth((mlir::Type *)&OperandRange);
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v50);
  uint64_t NumElements = mlir::ShapedType::getNumElements(ArgAttrsAttr, v17);
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v19 = *a1 - 16;
  }
  else {
    uint64_t v19 = 0;
  }
  uint64_t v20 = (void *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v19, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v20) {
    goto LABEL_23;
  }
  uint64_t v21 = *v20;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_23;
  }
  char v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    __int16 v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      char v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_23:
  }
    uint64_t v30 = 0;
  uint64_t v31 = NumElements * (IntOrFloatBitWidth >> 3);
  float v32 = (float)v31;
  int v50 = v20;
  uint64_t v51 = v30;
  uint64_t v33 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50);
  uint64_t v34 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v50);
  float v36 = (float)mlir::ShapedType::getNumElements(v34, v35);
  if (v31 <= 0x200000) {
    float v32 = 0.0;
  }
  uint64_t OperandRange = v33;
  float v37 = *(float *)(a2 + 40) * 1.0e12;
  BOOL isF16 = mlir::Type::isF16((mlir::Type *)&OperandRange);
  float v39 = v37 + v37;
  if (isF16) {
    float v39 = v37;
  }
  float v40 = v36 / v39;
  float v41 = *(float *)(a2 + 40);
  if (v40 >= (float)(v32 / (float)(*(float *)(a2 + 44) * 1000000000.0))) {
    float v42 = v40;
  }
  else {
    float v42 = v32 / (float)(*(float *)(a2 + 44) * 1000000000.0);
  }
  uint64_t OperandRange = v33;
  float v43 = v41 * 1.0e12;
  BOOL v44 = mlir::Type::isF16((mlir::Type *)&OperandRange);
  float v45 = v43 + v43;
  if (v44) {
    float v45 = v43;
  }
  float v46 = v36 / v45;
  if (v46 < (float)(v32 / (float)(*(float *)(a2 + 44) * 1000000000.0))) {
    float v46 = v32 / (float)(*(float *)(a2 + 44) * 1000000000.0);
  }
  float v47 = v42 + v46;
  return v48 + v47;
}

uint64_t mlir::anec::ElementwiseAdd::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEE50;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    unsigned int v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::anonymous namespace'::generateANECValidateError<ANECElementWiseLayerDescAlternate>(uint64_t a1, uint64_t *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v18 = MEMORY[0x1E4FBA488] + 24;
  uint64_t v3 = MEMORY[0x1E4FBA488] + 104;
  v26[0] = MEMORY[0x1E4FBA488] + 104;
  uint64_t v4 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v21 = MEMORY[0x1E4FBA488] + 64;
  uint64_t v5 = (void *)MEMORY[0x1E4FBA408];
  uint64_t v6 = *(void *)(MEMORY[0x1E4FBA408] + 24);
  v20[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
  *(void *)((char *)v20 + *(void *)(v20[0] - 24)) = v6;
  v20[1] = 0;
  unint64_t v7 = (std::ios_base *)((char *)v20 + *(void *)(v20[0] - 24));
  std::ios_base::init(v7, v22);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  uint64_t v8 = v5[5];
  uint64_t v21 = v5[4];
  *(uint64_t *)((char *)&v22[-1] + *(void *)(v21 - 24)) = v8;
  v20[0] = v5[1];
  *(void *)((char *)v20 + *(void *)(v20[0] - 24)) = v5[6];
  v26[0] = v3;
  v20[0] = v18;
  uint64_t v21 = v4;
  std::streambuf::basic_streambuf();
  uint64_t v19 = MEMORY[0x1E4FBA470] + 16;
  v22[0] = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)long long __p = 0u;
  long long v24 = 0u;
  int v25 = 24;
  std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v21, (uint64_t)"Invalid configuration", 21);
  if (a1)
  {
    if (a2)
    {
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v21, (uint64_t)" for the following reasons: ", 28);
      uint64_t v9 = *a2;
      if (*a2)
      {
        unint64_t v10 = 1;
        do
        {
          CFStringGetCString((CFStringRef)a2[v10], buffer, 512, 0x8000100u);
          size_t v11 = strlen(buffer);
          uint64_t v12 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v21, (uint64_t)buffer, v11);
          if (v10 == v9) {
            long long v13 = "";
          }
          else {
            long long v13 = ", ";
          }
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v12, (uint64_t)v13, 2 * (v10 != v9));
          uint64_t v9 = *a2;
        }
        while (*a2 > v10++);
      }
    }
  }
  std::stringbuf::str();
  v20[0] = *v5;
  uint64_t v15 = v5[9];
  *(void *)((char *)v20 + *(void *)(v20[0] - 24)) = v5[8];
  uint64_t v21 = v15;
  v22[0] = v19;
  if (SBYTE7(v24) < 0) {
    operator delete(__p[0]);
  }
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  return MEMORY[0x1852FDD70](v26);
}

uint64_t mlir::anec::ElementwiseMult::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEE60;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseMin::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEE70;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseMax::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEE80;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseSub::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEE90;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseDiv::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEEA0;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwisePower::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEEB0;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseEqual::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEEC0;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseNotEqual::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEED0;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseLessThan::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEEE0;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseLessThanEqual::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEEF0;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseGreaterThanEqual::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF00;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseGreaterThan::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF10;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseAbs::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF20;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseEqualZero::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF30;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseGreaterThanEqualZero::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF40;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseGreaterThanZero::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF50;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseLessThanEqualZero::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF60;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseLessThanZero::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF70;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseNotEqualZero::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF80;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseSquare::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v17[8] = *MEMORY[0x1E4F143B8];
  long long v13 = xmmword_1E4FBEF90;
  v16[0] = v17;
  v16[1] = (void *)0x100000000;
  uint64_t v14 = 1;
  p_p = 0;
  ANECUnitValidatorCreate();
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  if (ANECValidateElementWiseLayer())
  {
    uint64_t v4 = (uint64_t *)*a1;
    __int16 v10 = 260;
    p_p = &__p;
    uint64_t v5 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v14);
    if (v14) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v14);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v15);
    if (v8 < 0) {
      operator delete(__p);
    }
  }
  else
  {
    uint64_t v5 = 1;
  }
  ANECUnitValidatorDelete();
  if (v16[0] != v17) {
    free(v16[0]);
  }
  return v5;
}

uint64_t mlir::anec::ElementwiseAbs::addOpToNetwork(mlir::anec::_anonymous_namespace_ **a1, uint64_t a2)
{
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  unint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    char v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *unint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

unint64_t mlir::anec::Rsqrt::fold(mlir::Operation **a1, uint64_t a2)
{
  v43[3] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = **(uint64_t ***)(a2 + 40);
  if (!v3)
  {
    float v40 = 0;
    uint64_t v41 = 0;
    return 0;
  }
  uint64_t v5 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible(v3);
  float v40 = v5;
  uint64_t v41 = v4;
  if (!v5) {
    return 0;
  }
  mlir::mps::CPUNDArray::CPUNDArray(v38, v5, v4);
  Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v40);
  unint64_t v7 = Type;
  if (!Type) {
    goto LABEL_12;
  }
  uint64_t v8 = *Type;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_12;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  long long v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_12:
  }
    uint64_t v17 = 0;
  mlir::mps::CPUNDArray::CPUNDArray(v37, v7, v17, 0);
  v36[0] = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)v36, (uint64_t)&v42);
  double v18 = llvm::APFloat::convertToDouble(&v42);
  uint64_t v19 = (llvm::APFloatBase *)mlir::mps::CPUNDArrayArithmeticUnaryKernel::CPUNDArrayArithmeticUnaryKernel((uint64_t)v36, 6, v18);
  uint64_t v20 = (void *)v43[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v19) == v20) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v43);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v43);
  }
  unint64_t v22 = operator new(8uLL);
  float v42 = v22;
  *unint64_t v22 = v38;
  v43[0] = v22 + 1;
  v43[1] = v22 + 1;
  unint64_t v23 = operator new(8uLL);
  uint64_t v33 = v23;
  *unint64_t v23 = v37;
  uint64_t v34 = v23 + 1;
  uint64_t v35 = v23 + 1;
  long long v24 = operator new(8uLL);
  uint64_t v30 = v24;
  *long long v24 = 0;
  uint64_t v31 = v24 + 1;
  float v32 = v24 + 1;
  int v25 = operator new(8uLL);
  long long __p = v25;
  *int v25 = 0;
  uint64_t v28 = v25 + 1;
  unint64_t v29 = v25 + 1;
  mlir::mps::CPUNDArrayKernel::cpuTilingEngine((uint64_t)v36, (uint64_t *)&v42, (uint64_t **)&v33, (uint64_t)&v30, (uint64_t)&__p, 0, v39, (uint64_t)v36);
  if (__p)
  {
    uint64_t v28 = __p;
    operator delete(__p);
  }
  if (v30)
  {
    uint64_t v31 = v30;
    operator delete(v30);
  }
  if (v33)
  {
    uint64_t v34 = v33;
    operator delete(v33);
  }
  if (v42)
  {
    v43[0] = v42;
    operator delete(v42);
  }
  unint64_t v21 = (unint64_t)mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v37, 0, 0) & 0xFFFFFFFFFFFFFFFBLL;
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v37);
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v38);
  return v21;
}

llvm::detail::DoubleAPFloat *mlir::anec::Rsqrt::getEpsilon@<X0>(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(this);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&MultipliersAttr, a2);
}

uint64_t mlir::anec::inferPoolOpReturnTypes(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  v59[22] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = (void *)mlir::TypeRange::dereference_iterator(a7, 0);
  uint64_t v15 = v14;
  if (!v14) {
    goto LABEL_10;
  }
  uint64_t v16 = *v14;
  unint64_t v17 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v18 = *(unsigned int *)(v16 + 16);
  if (!v18) {
    goto LABEL_10;
  }
  uint64_t v19 = *(void **)(v16 + 8);
  uint64_t v20 = &v19[2 * v18];
  do
  {
    unint64_t v21 = v18 >> 1;
    unint64_t v22 = &v19[2 * (v18 >> 1)];
    unint64_t v24 = *v22;
    unint64_t v23 = v22 + 2;
    v18 += ~(v18 >> 1);
    if (v24 < v17) {
      uint64_t v19 = v23;
    }
    else {
      unint64_t v18 = v21;
    }
  }
  while (v18);
  if (v19 != v20 && *v19 == v17) {
    uint64_t v25 = v19[1];
  }
  else {
LABEL_10:
  }
    uint64_t v25 = 0;
  v47[0] = v15;
  v47[1] = v25;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
  if (v26)
  {
    uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
    int v57 = v59;
    uint64_t v58 = 0x600000000;
    mlir::getValues<unsigned long long>(a4, (uint64_t)&v57);
    v55[0] = v56;
    v55[1] = (void *)0x600000000;
    mlir::getValues<unsigned long long>(a5, (uint64_t)v55);
    v53[0] = v54;
    v53[1] = (void *)0x600000000;
    mlir::getValues<unsigned long long>(a6, (uint64_t)v53);
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
    uint64_t v29 = v28;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
    uint64_t v31 = v30;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
    uint64_t v33 = v32;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
    uint64_t v35 = v34;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v47);
    unint64_t v36 = (unint64_t)(*(void *)v57
                           + ArgAttrsAttr[v35 - 2]
                           + *((void *)v57 + 1)
                           - *(void *)v55[0]
                           + *(void *)v53[0])
        / *(void *)v53[0];
    unint64_t v38 = ArgAttrsAttr[v33 - 3];
    unint64_t v39 = (unint64_t)(*((void *)v57 + 2)
                           + ArgAttrsAttr[v37 - 1]
                           + *((void *)v57 + 3)
                           - *((void *)v55[0] + 1)
                           + *((void *)v53[0] + 1))
        / *((void *)v53[0] + 1);
    if (v29 == 5)
    {
      unint64_t v40 = (unint64_t)(*((void *)v57 + 4)
                             + ArgAttrsAttr[v31 - 4]
                             + *((void *)v57 + 5)
                             - *((void *)v55[0] + 2)
                             + *((void *)v53[0] + 2))
          / *((void *)v53[0] + 2);
      uint64_t v48 = *ArgAttrsAttr;
      unint64_t v49 = v40;
      unint64_t v50 = v38;
      unint64_t v51 = v36;
      unint64_t v52 = v39;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v47);
      uint64_t v42 = 5;
    }
    else
    {
      uint64_t v48 = *ArgAttrsAttr;
      unint64_t v49 = v38;
      unint64_t v50 = v36;
      unint64_t v51 = v39;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v47);
      uint64_t v42 = 4;
    }
    uint64_t v44 = mlir::MemRefType::get(&v48, (mlir::AffineMap *)v42, OperandRange, 0, 0, 0);
    uint64_t v45 = *(unsigned int *)(a9 + 8);
    if (v45 >= *(_DWORD *)(a9 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a9, (void *)(a9 + 16), v45 + 1, 8);
      LODWORD(v45) = *(_DWORD *)(a9 + 8);
    }
    *(void *)(*(void *)a9 + 8 * v45) = v44;
    ++*(_DWORD *)(a9 + 8);
    if (v53[0] != v54) {
      free(v53[0]);
    }
    if (v55[0] != v56) {
      free(v55[0]);
    }
    if (v57 != v59) {
      free(v57);
    }
    return 1;
  }
  else if (a2)
  {
    mlir::emitError(a1, (uint64_t)&v57);
    if (v57) {
      mlir::Diagnostic::operator<<((uint64_t)&v58, "input must be a rank 4 tensor of shape [N, Cin, H, W]or rank 5 tensor of shape [N, D, Cin, H, W]");
    }
    uint64_t v43 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v57);
    if (v57) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v57);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v58);
  }
  else
  {
    return 0;
  }
  return v43;
}

uint64_t mlir::anec::MaxPool::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a6;
  LOBYTE(v37) = 0;
  char v38 = 0;
  uint64_t v39 = a7;
  uint64_t v40 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v36);
    if (v38) {
      char v38 = 0;
    }
    mlir::OperationName::OperationName(&v37, "anec.max_pool", 13, Context);
    char v38 = 1;
  }
  uint64_t v41 = a4;
  uint64_t v42 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::MaxPoolAdaptor::verify(&v36, v18)) {
    return 0;
  }
  v43[0] = v41;
  v43[1] = 0;
  mlir::ValueRange::dereference_iterator(v43, 0);
  uint64_t v19 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 16);
  uint64_t v20 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  unint64_t v21 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v19, (mlir::CallGraphNode *)(v20 - 16), *(void *)(*(void *)(v37 + 96) + 8));
  uint64_t v22 = 0;
  if (v23) {
    uint64_t v22 = *((void *)v21 + 1);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36);
  uint64_t v25 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  uint64_t v26 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v25 - 32), **(void **)(v37 + 96));
  if (v27) {
    uint64_t v28 = *((void *)v26 + 1);
  }
  else {
    uint64_t v28 = 0;
  }
  uint64_t v30 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 32);
  uint64_t v31 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  uint64_t v32 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v30, v31, *(void *)(*(void *)(v37 + 96) + 16));
  if (v34) {
    uint64_t v35 = *((void *)v32 + 1);
  }
  else {
    uint64_t v35 = 0;
  }
  return mlir::anec::inferPoolOpReturnTypes((uint64_t)a2, a3, v33, v22, v28, v35, a9, a10, a11);
}

uint64_t mlir::anec::MaxPoolAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  void v59[23] = *MEMORY[0x1E4F143B8];
  uint64_t v55 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v55); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v55))
    {
      uint64_t v5 = "'anec.max_pool' op requires attribute 'ksize'";
      goto LABEL_53;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  long long v6 = (uint64_t *)i[1];
  int v54 = v6;
  while (1)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v55))
    {
      uint64_t v5 = "'anec.max_pool' op requires attribute 'padding'";
      goto LABEL_53;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
    i += 2;
  }
  unint64_t v7 = (uint64_t *)i[1];
  unint64_t v50 = v7;
  while (1)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v55))
    {
      uint64_t v5 = "'anec.max_pool' op requires attribute 'stride'";
      goto LABEL_53;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
    i += 2;
  }
  uint64_t v8 = (uint64_t *)i[1];
  if (!v8) {
    goto LABEL_62;
  }
  if (!mlir::DenseIntElementsAttr::classof(i[1])) {
    goto LABEL_51;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_26;
  }
  long long v12 = *(void **)(v9 + 8);
  unint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    uint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    uint64_t v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      long long v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_26:
  }
    uint64_t v18 = 0;
  unint64_t v51 = v8;
  uint64_t v52 = v18;
  Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v51);
  uint64_t v20 = Type;
  if (!Type) {
    goto LABEL_36;
  }
  uint64_t v21 = *Type;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_36;
  }
  unint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    char v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_36:
  }
    uint64_t v30 = 0;
  uint64_t v58 = v20;
  v59[0] = v30;
  uint64_t ArgAttrsAttr = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
  uint64_t v57 = 3;
  if (v32 != 1) {
    goto LABEL_51;
  }
  if (*ArgAttrsAttr == (uint64_t *)v57
    && (uint64_t OperandRange = (uint64_t)v8,
        uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&OperandRange),
        uint64_t v49 = v33,
        uint64_t v56 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
        mlir::Type::isUnsignedInteger((mlir::Type *)&v56, 64)))
  {
LABEL_62:
    if (!v7) {
      goto LABEL_63;
    }
    if (mlir::DenseIntElementsAttr::classof((uint64_t)v7))
    {
      unint64_t v51 = mlir::Attribute::cast<mlir::ElementsAttr>(&v50);
      uint64_t v52 = v34;
      uint64_t v57 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v51);
      uint64_t v58 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v57);
      v59[0] = v35;
      uint64_t v36 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      uint64_t v56 = 6;
      if (v37 == 1 && *v36 == v56)
      {
        float v46 = v50;
        uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
        uint64_t v49 = v38;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
        {
LABEL_63:
          if (!v6) {
            return 1;
          }
          if (!mlir::DenseIntElementsAttr::classof((uint64_t)v6)) {
            goto LABEL_57;
          }
          unint64_t v51 = mlir::Attribute::cast<mlir::ElementsAttr>(&v54);
          uint64_t v52 = v39;
          uint64_t v57 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v51);
          uint64_t v58 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v57);
          v59[0] = v40;
          uint64_t v41 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
          uint64_t v56 = 3;
          if (v42 != 1) {
            goto LABEL_57;
          }
          if (*v41 == v56)
          {
            float v46 = v54;
            uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
            uint64_t v49 = v43;
            uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
            if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
              return 1;
            }
          }
LABEL_57:
          unint64_t v51 = (uint64_t *)"'anec.max_pool' op attribute 'ksize' failed to satisfy constraint: ui64 elements attribute of shape {3}";
          __int16 v53 = 259;
          mlir::emitError(a2, (uint64_t)&v51, (uint64_t)&v58);
          uint64_t v44 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v58);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v58);
          return v44;
        }
      }
    }
    uint64_t v5 = "'anec.max_pool' op attribute 'padding' failed to satisfy constraint: ui64 elements attribute of shape {6}";
  }
  else
  {
LABEL_51:
    uint64_t v5 = "'anec.max_pool' op attribute 'stride' failed to satisfy constraint: ui64 elements attribute of shape {3}";
  }
LABEL_53:
  unint64_t v51 = (uint64_t *)v5;
  __int16 v53 = 259;
  mlir::emitError(a2, (uint64_t)&v51, (uint64_t)&v58);
  uint64_t v44 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v58);
  if (v58) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v58);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v59);
  return v44;
}

uint64_t mlir::anec::AveragePool::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a6;
  LOBYTE(v37) = 0;
  char v38 = 0;
  uint64_t v39 = a7;
  uint64_t v40 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v36);
    if (v38) {
      char v38 = 0;
    }
    mlir::OperationName::OperationName(&v37, "anec.average_pool", 17, Context);
    char v38 = 1;
  }
  uint64_t v41 = a4;
  uint64_t v42 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::AveragePoolAdaptor::verify(&v36, v18)) {
    return 0;
  }
  v43[0] = v41;
  v43[1] = 0;
  mlir::ValueRange::dereference_iterator(v43, 0);
  uint64_t v19 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 16);
  uint64_t v20 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  uint64_t v21 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v19, (mlir::CallGraphNode *)(v20 - 16), *(void *)(*(void *)(v37 + 96) + 16));
  uint64_t v22 = 0;
  if (v23) {
    uint64_t v22 = *((void *)v21 + 1);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36);
  uint64_t v25 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  unint64_t v26 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v25 - 32), *(void *)(*(void *)(v37 + 96) + 8));
  if (v27) {
    uint64_t v28 = *((void *)v26 + 1);
  }
  else {
    uint64_t v28 = 0;
  }
  uint64_t v30 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 32);
  uint64_t v31 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  uint64_t v32 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v30, v31, *(void *)(*(void *)(v37 + 96) + 24));
  if (v34) {
    uint64_t v35 = *((void *)v32 + 1);
  }
  else {
    uint64_t v35 = 0;
  }
  return mlir::anec::inferPoolOpReturnTypes((uint64_t)a2, a3, v33, v22, v28, v35, a9, a10, a11);
}

uint64_t mlir::anec::AveragePoolAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v61[23] = *MEMORY[0x1E4F143B8];
  uint64_t v57 = *a1;
  uint64_t Value = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
  if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v57))
  {
LABEL_7:
    long long v6 = "'anec.average_pool' op requires attribute 'ksize'";
LABEL_57:
    __int16 v53 = (uint64_t *)v6;
    __int16 v55 = 259;
    mlir::emitError(a2, (uint64_t)&v53, (uint64_t)&v60);
    uint64_t v46 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v60);
    if (v60) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v60);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v61);
    return v46;
  }
  uint64_t v5 = 0;
  while (*(void *)(*(void *)(a1[1] + 96) + 8) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      uint64_t v5 = Value[1];
    }
    Value += 2;
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v57)) {
      goto LABEL_7;
    }
  }
  unint64_t v7 = (uint64_t *)Value[1];
  uint64_t v56 = v7;
  while (1)
  {
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v57))
    {
      long long v6 = "'anec.average_pool' op requires attribute 'padding'";
      goto LABEL_57;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      break;
    }
    Value += 2;
  }
  uint64_t v8 = (uint64_t *)Value[1];
  uint64_t v52 = v8;
  while (1)
  {
    if (Value == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v57))
    {
      long long v6 = "'anec.average_pool' op requires attribute 'stride'";
      goto LABEL_57;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 24) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      break;
    }
    Value += 2;
  }
  uint64_t v9 = (uint64_t *)Value[1];
  if (v9)
  {
    if (!mlir::DenseIntElementsAttr::classof(Value[1])) {
      goto LABEL_55;
    }
    uint64_t v10 = *v9;
    unint64_t v11 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v12 = *(unsigned int *)(v10 + 16);
    if (!v12) {
      goto LABEL_28;
    }
    unint64_t v13 = *(void **)(v10 + 8);
    unint64_t v14 = &v13[2 * v12];
    do
    {
      unint64_t v15 = v12 >> 1;
      uint64_t v16 = &v13[2 * (v12 >> 1)];
      unint64_t v18 = *v16;
      uint64_t v17 = v16 + 2;
      v12 += ~(v12 >> 1);
      if (v18 < v11) {
        unint64_t v13 = v17;
      }
      else {
        unint64_t v12 = v15;
      }
    }
    while (v12);
    if (v13 != v14 && *v13 == v11) {
      uint64_t v19 = v13[1];
    }
    else {
LABEL_28:
    }
      uint64_t v19 = 0;
    __int16 v53 = v9;
    uint64_t v54 = v19;
    Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v53);
    uint64_t v21 = Type;
    if (!Type) {
      goto LABEL_38;
    }
    uint64_t v22 = *Type;
    unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v24 = *(unsigned int *)(v22 + 16);
    if (!v24) {
      goto LABEL_38;
    }
    uint64_t v25 = *(void **)(v22 + 8);
    unint64_t v26 = &v25[2 * v24];
    do
    {
      unint64_t v27 = v24 >> 1;
      uint64_t v28 = &v25[2 * (v24 >> 1)];
      unint64_t v30 = *v28;
      unint64_t v29 = v28 + 2;
      v24 += ~(v24 >> 1);
      if (v30 < v23) {
        uint64_t v25 = v29;
      }
      else {
        unint64_t v24 = v27;
      }
    }
    while (v24);
    if (v25 != v26 && *v25 == v23) {
      uint64_t v31 = v25[1];
    }
    else {
LABEL_38:
    }
      uint64_t v31 = 0;
    uint64_t v60 = v21;
    v61[0] = v31;
    uint64_t ArgAttrsAttr = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
    uint64_t v59 = 3;
    if (v33 != 1
      || *ArgAttrsAttr != (uint64_t *)v59
      || (uint64_t v49 = (uint64_t)v9,
          uint64_t v50 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v49),
          uint64_t v51 = v34,
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
LABEL_55:
      long long v6 = "'anec.average_pool' op attribute 'stride' failed to satisfy constraint: ui64 elements attribute of shape {3}";
      goto LABEL_57;
    }
  }
  if (v8)
  {
    if (!mlir::DenseIntElementsAttr::classof((uint64_t)v8)) {
      goto LABEL_56;
    }
    __int16 v53 = mlir::Attribute::cast<mlir::ElementsAttr>(&v52);
    uint64_t v54 = v35;
    uint64_t v59 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v53);
    uint64_t v60 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v59);
    v61[0] = v36;
    uint64_t v37 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
    uint64_t OperandRange = 6;
    if (v38 != 1
      || *v37 != OperandRange
      || (uint64_t v48 = v52,
          uint64_t v50 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v48),
          uint64_t v51 = v39,
          uint64_t v49 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&v49, 64)))
    {
LABEL_56:
      long long v6 = "'anec.average_pool' op attribute 'padding' failed to satisfy constraint: ui64 elements attribute of shape {6}";
      goto LABEL_57;
    }
  }
  if (!v7) {
    goto LABEL_53;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v7)) {
    goto LABEL_61;
  }
  __int16 v53 = mlir::Attribute::cast<mlir::ElementsAttr>(&v56);
  uint64_t v54 = v40;
  uint64_t v59 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v53);
  uint64_t v60 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v59);
  v61[0] = v41;
  uint64_t v42 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
  uint64_t OperandRange = 3;
  if (v43 != 1) {
    goto LABEL_61;
  }
  if (*v42 == OperandRange
    && (uint64_t v48 = v56,
        uint64_t v50 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v48),
        uint64_t v51 = v44,
        uint64_t v49 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v50),
        mlir::Type::isUnsignedInteger((mlir::Type *)&v49, 64)))
  {
LABEL_53:
    if (!v5 || *(_UNKNOWN **)(*(void *)v5 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
      return 1;
    }
    uint64_t v45 = "'anec.average_pool' op attribute 'inc_pad' failed to satisfy constraint: unit attribute";
  }
  else
  {
LABEL_61:
    uint64_t v45 = "'anec.average_pool' op attribute 'ksize' failed to satisfy constraint: ui64 elements attribute of shape {3}";
  }
  __int16 v53 = (uint64_t *)v45;
  __int16 v55 = 259;
  mlir::emitError(a2, (uint64_t)&v53, (uint64_t)&v60);
  uint64_t v46 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v60);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v60);
  return v46;
}

uint64_t mlir::anec::L2NormPool::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v36 = a6;
  LOBYTE(v37) = 0;
  char v38 = 0;
  uint64_t v39 = a7;
  uint64_t v40 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v36);
    if (v38) {
      char v38 = 0;
    }
    mlir::OperationName::OperationName(&v37, "anec.l2norm_pool", 16, Context);
    char v38 = 1;
  }
  uint64_t v41 = a4;
  uint64_t v42 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::L2NormPoolAdaptor::verify(&v36, v18)) {
    return 0;
  }
  v43[0] = v41;
  v43[1] = 0;
  mlir::ValueRange::dereference_iterator(v43, 0);
  uint64_t v19 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 16);
  uint64_t v20 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  uint64_t v21 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v19, (mlir::CallGraphNode *)(v20 - 16), *(void *)(*(void *)(v37 + 96) + 8));
  uint64_t v22 = 0;
  if (v23) {
    uint64_t v22 = *((void *)v21 + 1);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36);
  uint64_t v25 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  unint64_t v26 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v25 - 32), **(void **)(v37 + 96));
  if (v27) {
    uint64_t v28 = *((void *)v26 + 1);
  }
  else {
    uint64_t v28 = 0;
  }
  unint64_t v30 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v36) + 32);
  uint64_t v31 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v36);
  uint64_t v32 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v30, v31, *(void *)(*(void *)(v37 + 96) + 16));
  if (v34) {
    uint64_t v35 = *((void *)v32 + 1);
  }
  else {
    uint64_t v35 = 0;
  }
  return mlir::anec::inferPoolOpReturnTypes((uint64_t)a2, a3, v33, v22, v28, v35, a9, a10, a11);
}

uint64_t mlir::anec::L2NormPoolAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  void v59[23] = *MEMORY[0x1E4F143B8];
  uint64_t v55 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v55); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v55))
    {
      uint64_t v5 = "'anec.l2norm_pool' op requires attribute 'ksize'";
      goto LABEL_53;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  long long v6 = (uint64_t *)i[1];
  uint64_t v54 = v6;
  while (1)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v55))
    {
      uint64_t v5 = "'anec.l2norm_pool' op requires attribute 'padding'";
      goto LABEL_53;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
    i += 2;
  }
  unint64_t v7 = (uint64_t *)i[1];
  uint64_t v50 = v7;
  while (1)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v55))
    {
      uint64_t v5 = "'anec.l2norm_pool' op requires attribute 'stride'";
      goto LABEL_53;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
    i += 2;
  }
  uint64_t v8 = (uint64_t *)i[1];
  if (!v8) {
    goto LABEL_62;
  }
  if (!mlir::DenseIntElementsAttr::classof(i[1])) {
    goto LABEL_51;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_26;
  }
  unint64_t v12 = *(void **)(v9 + 8);
  unint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    unint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    uint64_t v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      unint64_t v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_26:
  }
    uint64_t v18 = 0;
  uint64_t v51 = v8;
  uint64_t v52 = v18;
  Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v51);
  uint64_t v20 = Type;
  if (!Type) {
    goto LABEL_36;
  }
  uint64_t v21 = *Type;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_36;
  }
  unint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    char v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_36:
  }
    uint64_t v30 = 0;
  uint64_t v58 = v20;
  v59[0] = v30;
  uint64_t ArgAttrsAttr = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
  uint64_t v57 = 3;
  if (v32 != 1) {
    goto LABEL_51;
  }
  if (*ArgAttrsAttr == (uint64_t *)v57
    && (uint64_t OperandRange = (uint64_t)v8,
        uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&OperandRange),
        uint64_t v49 = v33,
        uint64_t v56 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value),
        mlir::Type::isUnsignedInteger((mlir::Type *)&v56, 64)))
  {
LABEL_62:
    if (!v7) {
      goto LABEL_63;
    }
    if (mlir::DenseIntElementsAttr::classof((uint64_t)v7))
    {
      uint64_t v51 = mlir::Attribute::cast<mlir::ElementsAttr>(&v50);
      uint64_t v52 = v34;
      uint64_t v57 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v51);
      uint64_t v58 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v57);
      v59[0] = v35;
      uint64_t v36 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      uint64_t v56 = 6;
      if (v37 == 1 && *v36 == v56)
      {
        uint64_t v46 = v50;
        uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
        uint64_t v49 = v38;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
        {
LABEL_63:
          if (!v6) {
            return 1;
          }
          if (!mlir::DenseIntElementsAttr::classof((uint64_t)v6)) {
            goto LABEL_57;
          }
          uint64_t v51 = mlir::Attribute::cast<mlir::ElementsAttr>(&v54);
          uint64_t v52 = v39;
          uint64_t v57 = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v51);
          uint64_t v58 = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&v57);
          v59[0] = v40;
          uint64_t v41 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
          uint64_t v56 = 3;
          if (v42 != 1) {
            goto LABEL_57;
          }
          if (*v41 == v56)
          {
            uint64_t v46 = v54;
            uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v46);
            uint64_t v49 = v43;
            uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
            if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
              return 1;
            }
          }
LABEL_57:
          uint64_t v51 = (uint64_t *)"'anec.l2norm_pool' op attribute 'ksize' failed to satisfy constraint: ui64 elements attribute of shape {3}";
          __int16 v53 = 259;
          mlir::emitError(a2, (uint64_t)&v51, (uint64_t)&v58);
          uint64_t v44 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v58);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v58);
          return v44;
        }
      }
    }
    uint64_t v5 = "'anec.l2norm_pool' op attribute 'padding' failed to satisfy constraint: ui64 elements attribute of shape {6}";
  }
  else
  {
LABEL_51:
    uint64_t v5 = "'anec.l2norm_pool' op attribute 'stride' failed to satisfy constraint: ui64 elements attribute of shape {3}";
  }
LABEL_53:
  uint64_t v51 = (uint64_t *)v5;
  __int16 v53 = 259;
  mlir::emitError(a2, (uint64_t)&v51, (uint64_t)&v58);
  uint64_t v44 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v58);
  if (v58) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v58);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v59);
  return v44;
}

uint64_t mlir::anec::AveragePool::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  v19[6] = *MEMORY[0x1E4F143B8];
  long long v6 = *a1;
  ANECPoolLayerDescInitialize();
  ZinIrPoolingTypeToCFString(1u);
  v18[0] = v19;
  v18[1] = (void *)0x600000000;
  v16[0] = v17;
  v16[1] = (void *)0x600000000;
  v14[0] = v15;
  v14[1] = (void *)0x600000000;
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  unint64_t v8 = v7;
  uint64_t KsizeAttr = mlir::anec::AveragePool::getKsizeAttr(a1);
  mlir::getValues<unsigned long long>(KsizeAttr, (uint64_t)v18);
  uint64_t StrideAttr = mlir::anec::AveragePool::getStrideAttr(a1);
  mlir::getValues<unsigned long long>(StrideAttr, (uint64_t)v16);
  uint64_t PaddingAttr = mlir::anec::AveragePool::getPaddingAttr(a1);
  mlir::getValues<unsigned long long>(PaddingAttr, (uint64_t)v14);
  mlir::anec::getIndexFromDim(1, v8);
  if (!v12) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  if (v14[0] != v15) {
    free(v14[0]);
  }
  if (v16[0] != v17) {
    free(v16[0]);
  }
  if (v18[0] != v19) {
    free(v18[0]);
  }
  return mlir::anec::verifyPoolWithANEC((uint64_t *)v6, a2, a3);
}

uint64_t mlir::anec::verifyPoolWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v31[63] = *MEMORY[0x1E4F143B8];
  v28[0] = v29;
  v28[1] = (void *)0x100000000;
  uint64_t v19 = 0;
  uint64_t v20 = 0;
  *(void *)buffer = 1;
  v21[0] = 0;
  ANECUnitValidatorCreate();
  if (ANECValidatePoolLayer())
  {
    uint64_t v14 = MEMORY[0x1E4FBA488] + 24;
    uint64_t v4 = MEMORY[0x1E4FBA488] + 104;
    v27[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v5 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v22 = MEMORY[0x1E4FBA488] + 64;
    long long v6 = (void *)MEMORY[0x1E4FBA408];
    uint64_t v7 = *(void *)(MEMORY[0x1E4FBA408] + 24);
    v21[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
    *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = v7;
    v21[1] = 0;
    unint64_t v8 = (std::ios_base *)((char *)v21 + *(void *)(v21[0] - 24));
    std::ios_base::init(v8, v23);
    v8[1].__vftable = 0;
    v8[1].__fmtflags_ = -1;
    uint64_t v9 = v6[5];
    uint64_t v22 = v6[4];
    *(uint64_t *)((char *)&v23[-1] + *(void *)(v22 - 24)) = v9;
    v21[0] = v6[1];
    *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = v6[6];
    v27[0] = v4;
    v21[0] = v14;
    uint64_t v22 = v5;
    std::streambuf::basic_streambuf();
    uint64_t v10 = MEMORY[0x1E4FBA470] + 16;
    v23[0] = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v25 = 0u;
    int v26 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v22, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v21[0] = *v6;
    uint64_t v11 = v6[9];
    *(void *)((char *)v21 + *(void *)(v21[0] - 24)) = v6[8];
    uint64_t v22 = v11;
    v23[0] = v10;
    if (SBYTE7(v25) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v27);
    __int16 v18 = 260;
    unint64_t v17 = &v15;
    uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v31);
    if (v16 < 0) {
      operator delete(v15);
    }
  }
  else
  {
    uint64_t v12 = 1;
  }
  ANECUnitValidatorDelete();
  if (v28[0] != v29) {
    free(v28[0]);
  }
  return v12;
}

uint64_t mlir::anec::MaxPool::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  v19[6] = *MEMORY[0x1E4F143B8];
  long long v6 = *a1;
  ANECPoolLayerDescInitialize();
  ZinIrPoolingTypeToCFString(2u);
  v18[0] = v19;
  v18[1] = (void *)0x600000000;
  v16[0] = v17;
  v16[1] = (void *)0x600000000;
  v14[0] = v15;
  v14[1] = (void *)0x600000000;
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  unint64_t v8 = v7;
  uint64_t KsizeAttr = mlir::anec::L2NormPool::getKsizeAttr(a1);
  mlir::getValues<unsigned long long>(KsizeAttr, (uint64_t)v18);
  uint64_t StrideAttr = mlir::anec::L2NormPool::getStrideAttr(a1);
  mlir::getValues<unsigned long long>(StrideAttr, (uint64_t)v16);
  uint64_t PaddingAttr = mlir::anec::L2NormPool::getPaddingAttr(a1);
  mlir::getValues<unsigned long long>(PaddingAttr, (uint64_t)v14);
  mlir::anec::getIndexFromDim(1, v8);
  if (!v12) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  if (v14[0] != v15) {
    free(v14[0]);
  }
  if (v16[0] != v17) {
    free(v16[0]);
  }
  if (v18[0] != v19) {
    free(v18[0]);
  }
  return mlir::anec::verifyPoolWithANEC((uint64_t *)v6, a2, a3);
}

uint64_t mlir::anec::L2NormPool::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  v19[6] = *MEMORY[0x1E4F143B8];
  long long v6 = *a1;
  ANECPoolLayerDescInitialize();
  ZinIrPoolingTypeToCFString(1u);
  v18[0] = v19;
  v18[1] = (void *)0x600000000;
  v16[0] = v17;
  v16[1] = (void *)0x600000000;
  v14[0] = v15;
  v14[1] = (void *)0x600000000;
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  unint64_t v8 = v7;
  uint64_t KsizeAttr = mlir::anec::L2NormPool::getKsizeAttr(a1);
  mlir::getValues<unsigned long long>(KsizeAttr, (uint64_t)v18);
  uint64_t StrideAttr = mlir::anec::L2NormPool::getStrideAttr(a1);
  mlir::getValues<unsigned long long>(StrideAttr, (uint64_t)v16);
  uint64_t PaddingAttr = mlir::anec::L2NormPool::getPaddingAttr(a1);
  mlir::getValues<unsigned long long>(PaddingAttr, (uint64_t)v14);
  mlir::anec::getIndexFromDim(1, v8);
  if (!v12) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  if (v14[0] != v15) {
    free(v14[0]);
  }
  if (v16[0] != v17) {
    free(v16[0]);
  }
  if (v18[0] != v19) {
    free(v18[0]);
  }
  return mlir::anec::verifyPoolWithANEC((uint64_t *)v6, a2, a3);
}

uint64_t mlir::anec::anonymous namespace'::defaultIsCompatibleReturnType(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 1;
  if (a2 && a4)
  {
    uint64_t v9 = 0;
    while (1)
    {
      uint64_t v10 = (void *)mlir::TypeRange::dereference_iterator(a1, v9);
      uint64_t v11 = (uint64_t *)mlir::TypeRange::dereference_iterator(a3, v9);
      if (!v10) {
        goto LABEL_13;
      }
      uint64_t v12 = *v10;
      unint64_t v13 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v14 = *(unsigned int *)(v12 + 16);
      if (!v14) {
        goto LABEL_13;
      }
      unint64_t v15 = *(void **)(v12 + 8);
      char v16 = &v15[2 * v14];
      do
      {
        unint64_t v17 = v14 >> 1;
        __int16 v18 = &v15[2 * (v14 >> 1)];
        unint64_t v20 = *v18;
        uint64_t v19 = v18 + 2;
        v14 += ~(v14 >> 1);
        if (v20 < v13) {
          unint64_t v15 = v19;
        }
        else {
          unint64_t v14 = v17;
        }
      }
      while (v14);
      if (v15 != v16 && *v15 == v13)
      {
        uint64_t v31 = v15[1];
        uint64_t v40 = v10;
        uint64_t v41 = v31;
        if (!v11) {
          goto LABEL_24;
        }
      }
      else
      {
LABEL_13:
        uint64_t v40 = v10;
        uint64_t v41 = 0;
        if (!v11) {
          goto LABEL_24;
        }
      }
      uint64_t v21 = *v11;
      unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v23 = *(unsigned int *)(v21 + 16);
      if (!v23) {
        goto LABEL_24;
      }
      unint64_t v24 = *(void **)(v21 + 8);
      long long v25 = &v24[2 * v23];
      do
      {
        unint64_t v26 = v23 >> 1;
        char v27 = &v24[2 * (v23 >> 1)];
        unint64_t v29 = *v27;
        uint64_t v28 = v27 + 2;
        v23 += ~(v23 >> 1);
        if (v29 < v22) {
          unint64_t v24 = v28;
        }
        else {
          unint64_t v23 = v26;
        }
      }
      while (v23);
      if (v24 == v25 || *v24 != v22)
      {
LABEL_24:
        uint64_t v30 = 0;
        goto LABEL_25;
      }
      uint64_t v30 = v24[1];
LABEL_25:
      v39[0] = v11;
      v39[1] = v30;
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v40)) {
        return 0;
      }
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v39)) {
        return 0;
      }
      uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v40);
      uint64_t v34 = v33;
      uint64_t v35 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
      if (v34 != v36 || memcmp(ArgAttrsAttr, v35, 8 * v34)) {
        return 0;
      }
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v40);
      BOOL v38 = OperandRange == mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
      uint64_t result = v38;
      if (v38 && ++v9 != a2 && v9 != a4) {
        continue;
      }
      return result;
    }
  }
  return result;
}

uint64_t mlir::anec::verifyANECAveragePoolOp(uint64_t a1)
{
  uint64_t v5 = (mlir::Operation *)a1;
  if (*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  if (*(_DWORD *)(a1 + 36)) {
    uint64_t v2 = a1 - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  if (*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  mlir::anec::AveragePool::getStrideAttr(&v5);
  mlir::anec::AveragePool::getPaddingAttr(&v5);
  mlir::anec::AveragePool::getKsizeAttr(&v5);
}

uint64_t mlir::anec::verifyANECMaxPoolOp(uint64_t a1)
{
  uint64_t v5 = (mlir::Operation *)a1;
  if (*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  if (*(_DWORD *)(a1 + 36)) {
    uint64_t v2 = a1 - 16;
  }
  else {
    uint64_t v2 = 0;
  }
  if (*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  mlir::anec::L2NormPool::getStrideAttr(&v5);
  mlir::anec::L2NormPool::getPaddingAttr(&v5);
  mlir::anec::L2NormPool::getKsizeAttr(&v5);
}

uint64_t mlir::anec::AveragePool::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  unint64_t v24 = *a1;
  uint64_t v3 = v24;
  long long v23 = 0uLL;
  mlir::anec::computeOpKeyString(v24, &__p);
  uint64_t v4 = *(void **)(*((void *)v3 + 9) + 24);
  if (*((_DWORD *)v3 + 9)) {
    uint64_t v5 = (uint64_t)v3 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  uint64_t PaddingAttr = mlir::anec::AveragePool::getPaddingAttr(&v24);
  uint64_t StrideAttr = mlir::anec::AveragePool::getStrideAttr(&v24);
  uint64_t KsizeAttr = mlir::anec::AveragePool::getKsizeAttr(&v24);
  char v10 = mlir::anec::addPoolOpCommon(v3, 1, (uint64_t)&__p, v4, NextResultAtOffset, PaddingAttr, StrideAttr, KsizeAttr, (uint64_t *)&v23);
  char v11 = v10;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v10) {
      goto LABEL_6;
    }
LABEL_10:
    uint64_t v17 = 0;
    __int16 v18 = (std::__shared_weak_count *)*((void *)&v23 + 1);
    if (!*((void *)&v23 + 1)) {
      return v17;
    }
    goto LABEL_19;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v11) {
    goto LABEL_10;
  }
LABEL_6:
  unint64_t v13 = (std::__shared_weak_count *)*((void *)&v23 + 1);
  uint64_t v12 = v23;
  long long v21 = v23;
  if (!*((void *)&v23 + 1))
  {
    uint64_t v19 = *(void **)(a2 + 232);
    unint64_t v15 = (void *)(a2 + 232);
    if ((unint64_t)v19 < *(void *)(a2 + 240))
    {
      *uint64_t v19 = v23;
      v19[1] = 0;
      char v16 = v19 + 2;
      goto LABEL_15;
    }
LABEL_14:
    char v16 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v21);
    unint64_t v13 = (std::__shared_weak_count *)*((void *)&v21 + 1);
    goto LABEL_15;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v23 + 1) + 8), 1uLL, memory_order_relaxed);
  unint64_t v14 = *(void **)(a2 + 232);
  unint64_t v15 = (void *)(a2 + 232);
  if ((unint64_t)v14 >= *(void *)(a2 + 240)) {
    goto LABEL_14;
  }
  *unint64_t v14 = v12;
  v14[1] = v13;
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  char v16 = v14 + 2;
LABEL_15:
  *unint64_t v15 = v16;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v17 = 1;
  __int16 v18 = (std::__shared_weak_count *)*((void *)&v23 + 1);
  if (*((void *)&v23 + 1))
  {
LABEL_19:
    if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  return v17;
}

uint64_t mlir::anec::addPoolOpCommon(mlir::Operation *a1, int a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t *a9)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  mlir::anec::ANECIRPoolUnit::Create(a2, a3, &v51);
  long long v15 = v51;
  long long v51 = 0uLL;
  char v16 = (std::__shared_weak_count *)a9[1];
  *(_OWORD *)a9 = v15;
  if (v16 && !atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  uint64_t v17 = (std::__shared_weak_count *)*((void *)&v51 + 1);
  if (*((void *)&v51 + 1)
    && !atomic_fetch_add((atomic_ullong *volatile)(*((void *)&v51 + 1) + 8), 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
    std::__shared_weak_count::__release_weak(v17);
  }
  uint64_t v45 = a4;
  if (mlir::Value::getDefiningOp((mlir::Value *)&v45))
  {
    uint64_t DefiningOp = (mlir::anec *)mlir::Value::getDefiningOp((mlir::Value *)&v45);
    mlir::anec::computeOpKeyString(DefiningOp, &__p);
  }
  else
  {
    uint64_t v19 = (unsigned int *)v45;
    if ((~*((_DWORD *)v45 + 2) & 7) != 0) {
      uint64_t v19 = 0;
    }
    uint64_t v48 = (void *)v19[6];
    *(void *)&long long v51 = "__arg";
    v52[0] = &v48;
    __int16 v53 = 3331;
    llvm::Twine::str((llvm::Twine *)&v51, &__p);
  }
  v43[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(a4[1] & 0xFFFFFFFFFFFFFFF8));
  v43[1] = v20;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v43);
  uint64_t ANECIRDataType = mlir::anec::getANECIRDataType(OperandRange);
  if ((ANECIRDataType & 0xFF00000000) != 0
    && (mlir::anec::ANECIRUnit::AddInput(*a9, (uint64_t)&__p, ANECIRDataType),
        v42[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(a5 + 8) & 0xFFFFFFFFFFFFFFF8)),
        v42[1] = v23,
        v42[0])
    && (mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v43),
        uint64_t v25 = v24,
        uint64_t v26 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42),
        uint64_t v27 = mlir::anec::getANECIRDataType(v26),
        (v27 & 0xFF00000000) != 0))
  {
    unsigned int v28 = v27;
    uint64_t v29 = *a9;
    uint64_t v30 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42) + 8 * v25 - 24);
    uint64_t v31 = *(unsigned int *)(v29 + 120);
    if (v31 >= *(_DWORD *)(v29 + 124))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(v29 + 112, (void *)(v29 + 128), v31 + 1, 16);
      LODWORD(v31) = *(_DWORD *)(v29 + 120);
    }
    uint64_t v32 = (void *)(*(void *)(v29 + 112) + 16 * v31);
    void *v32 = v28;
    v32[1] = v30;
    ++*(_DWORD *)(v29 + 120);
    *(void *)&long long v51 = v52;
    *((void *)&v51 + 1) = 0x600000000;
    mlir::getValues<unsigned long long>(a6, (uint64_t)&v51);
    uint64_t v48 = v50;
    uint64_t v49 = 0x600000000;
    mlir::getValues<unsigned long long>(a8, (uint64_t)&v48);
    uint64_t v45 = v47;
    uint64_t v46 = 0x600000000;
    mlir::getValues<unsigned long long>(a7, (uint64_t)&v45);
    uint64_t v33 = *a9;
    uint64_t v34 = (_OWORD *)v51;
    if (DWORD2(v51) == 6) {
      *(_OWORD *)(v33 + 232) = *(_OWORD *)(v51 + 32);
    }
    *(_OWORD *)(v33 + 200) = *v34;
    *(_OWORD *)(v33 + 216) = v34[1];
    if (*(_UNKNOWN **)(*((void *)a1 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::AveragePool,void>::id) {
      uint64_t v35 = a1;
    }
    else {
      uint64_t v35 = 0;
    }
    uint64_t v41 = v35;
    if (v35)
    {
      *(unsigned char *)(v33 + 280) = mlir::anec::AveragePool::getIncPadAttr(&v41) != 0;
      uint64_t v33 = *a9;
    }
    uint64_t v36 = (int8x16_t *)v45;
    if (v46 == 3) {
      *(void *)(v33 + 192) = *((void *)v45 + 2);
    }
    *(int8x16_t *)(v33 + 176) = vextq_s8(*v36, *v36, 8uLL);
    uint64_t v37 = (uint64_t *)v48;
    if (v49 == 3) {
      *(void *)(v33 + 272) = *((void *)v48 + 2);
    }
    uint64_t v38 = *v37;
    *(void *)(v33 + 256) = v37[1];
    *(void *)(v33 + 264) = v38;
    if (v36 != (int8x16_t *)v47)
    {
      free(v36);
      uint64_t v37 = (uint64_t *)v48;
    }
    if (v37 != (uint64_t *)v50) {
      free(v37);
    }
    if ((void *)v51 != v52) {
      free((void *)v51);
    }
    uint64_t v39 = 1;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
      goto LABEL_37;
    }
  }
  else
  {
    uint64_t v39 = 0;
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
LABEL_37:
    }
      operator delete(__p.__r_.__value_.__l.__data_);
  }
  return v39;
}

uint64_t mlir::anec::MaxPool::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  uint64_t v24 = *a1;
  uint64_t v3 = v24;
  long long v23 = 0uLL;
  mlir::anec::computeOpKeyString(v24, &__p);
  uint64_t v4 = *(void **)(*((void *)v3 + 9) + 24);
  if (*((_DWORD *)v3 + 9)) {
    uint64_t v5 = (uint64_t)v3 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  uint64_t PaddingAttr = mlir::anec::L2NormPool::getPaddingAttr(&v24);
  uint64_t StrideAttr = mlir::anec::L2NormPool::getStrideAttr(&v24);
  uint64_t KsizeAttr = mlir::anec::L2NormPool::getKsizeAttr(&v24);
  char v10 = mlir::anec::addPoolOpCommon(v3, 0, (uint64_t)&__p, v4, NextResultAtOffset, PaddingAttr, StrideAttr, KsizeAttr, (uint64_t *)&v23);
  char v11 = v10;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v10) {
      goto LABEL_6;
    }
LABEL_10:
    uint64_t v17 = 0;
    __int16 v18 = (std::__shared_weak_count *)*((void *)&v23 + 1);
    if (!*((void *)&v23 + 1)) {
      return v17;
    }
    goto LABEL_19;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v11) {
    goto LABEL_10;
  }
LABEL_6:
  unint64_t v13 = (std::__shared_weak_count *)*((void *)&v23 + 1);
  uint64_t v12 = v23;
  long long v21 = v23;
  if (!*((void *)&v23 + 1))
  {
    uint64_t v19 = *(void **)(a2 + 232);
    long long v15 = (void *)(a2 + 232);
    if ((unint64_t)v19 < *(void *)(a2 + 240))
    {
      *uint64_t v19 = v23;
      v19[1] = 0;
      char v16 = v19 + 2;
      goto LABEL_15;
    }
LABEL_14:
    char v16 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v21);
    unint64_t v13 = (std::__shared_weak_count *)*((void *)&v21 + 1);
    goto LABEL_15;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v23 + 1) + 8), 1uLL, memory_order_relaxed);
  unint64_t v14 = *(void **)(a2 + 232);
  long long v15 = (void *)(a2 + 232);
  if ((unint64_t)v14 >= *(void *)(a2 + 240)) {
    goto LABEL_14;
  }
  *unint64_t v14 = v12;
  v14[1] = v13;
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  char v16 = v14 + 2;
LABEL_15:
  *long long v15 = v16;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v17 = 1;
  __int16 v18 = (std::__shared_weak_count *)*((void *)&v23 + 1);
  if (*((void *)&v23 + 1))
  {
LABEL_19:
    if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  return v17;
}

uint64_t mlir::anec::L2NormPool::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  uint64_t v24 = *a1;
  uint64_t v3 = v24;
  long long v23 = 0uLL;
  mlir::anec::computeOpKeyString(v24, &__p);
  uint64_t v4 = *(void **)(*((void *)v3 + 9) + 24);
  if (*((_DWORD *)v3 + 9)) {
    uint64_t v5 = (uint64_t)v3 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  uint64_t PaddingAttr = mlir::anec::L2NormPool::getPaddingAttr(&v24);
  uint64_t StrideAttr = mlir::anec::L2NormPool::getStrideAttr(&v24);
  uint64_t KsizeAttr = mlir::anec::L2NormPool::getKsizeAttr(&v24);
  char v10 = mlir::anec::addPoolOpCommon(v3, 2, (uint64_t)&__p, v4, NextResultAtOffset, PaddingAttr, StrideAttr, KsizeAttr, (uint64_t *)&v23);
  char v11 = v10;
  if ((SHIBYTE(__p.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v10) {
      goto LABEL_6;
    }
LABEL_10:
    uint64_t v17 = 0;
    __int16 v18 = (std::__shared_weak_count *)*((void *)&v23 + 1);
    if (!*((void *)&v23 + 1)) {
      return v17;
    }
    goto LABEL_19;
  }
  operator delete(__p.__r_.__value_.__l.__data_);
  if (!v11) {
    goto LABEL_10;
  }
LABEL_6:
  unint64_t v13 = (std::__shared_weak_count *)*((void *)&v23 + 1);
  uint64_t v12 = v23;
  long long v21 = v23;
  if (!*((void *)&v23 + 1))
  {
    uint64_t v19 = *(void **)(a2 + 232);
    long long v15 = (void *)(a2 + 232);
    if ((unint64_t)v19 < *(void *)(a2 + 240))
    {
      *uint64_t v19 = v23;
      v19[1] = 0;
      char v16 = v19 + 2;
      goto LABEL_15;
    }
LABEL_14:
    char v16 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v21);
    unint64_t v13 = (std::__shared_weak_count *)*((void *)&v21 + 1);
    goto LABEL_15;
  }
  atomic_fetch_add_explicit((atomic_ullong *volatile)(*((void *)&v23 + 1) + 8), 1uLL, memory_order_relaxed);
  unint64_t v14 = *(void **)(a2 + 232);
  long long v15 = (void *)(a2 + 232);
  if ((unint64_t)v14 >= *(void *)(a2 + 240)) {
    goto LABEL_14;
  }
  *unint64_t v14 = v12;
  v14[1] = v13;
  atomic_fetch_add_explicit(&v13->__shared_owners_, 1uLL, memory_order_relaxed);
  char v16 = v14 + 2;
LABEL_15:
  *long long v15 = v16;
  if (v13 && !atomic_fetch_add(&v13->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v13->__on_zero_shared)(v13);
    std::__shared_weak_count::__release_weak(v13);
  }
  uint64_t v17 = 1;
  __int16 v18 = (std::__shared_weak_count *)*((void *)&v23 + 1);
  if (*((void *)&v23 + 1))
  {
LABEL_19:
    if (!atomic_fetch_add(&v18->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
    {
      ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
      std::__shared_weak_count::__release_weak(v18);
    }
  }
  return v17;
}

uint64_t mlir::anec::inferReductionOpReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v43[22] = *MEMORY[0x1E4F143B8];
  uint64_t v32 = a6;
  unint64_t v13 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  v31[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible(v13);
  v31[1] = v14;
  if (v31[0] && (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v31) & 1) != 0)
  {
    uint64_t v41 = v43;
    uint64_t v42 = 0x600000000;
    uint64_t v15 = mlir::DictionaryAttr::get((uint64_t)&v32, "axes", 4uLL);
    uint64_t v30 = v15;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v38, v15, 0);
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v30);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v33, v15, NumElements);
    while (1)
    {
      BOOL v17 = v38 == v33 && v39 == v34;
      if (v17 && v40[0] == v35) {
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v38, (llvm::APInt *)&__p);
      if (v37 >= 0x41) {
        p_p = (uint64_t *)__p;
      }
      else {
        p_p = (uint64_t *)&__p;
      }
      uint64_t v19 = *p_p;
      uint64_t v20 = v42;
      if (v42 >= (unint64_t)HIDWORD(v42))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v41, v43, v42 + 1, 8);
        uint64_t v20 = v42;
      }
      *((void *)v41 + v20) = v19;
      LODWORD(v42) = v42 + 1;
      if (v37 >= 0x41)
      {
        if (__p) {
          operator delete[](__p);
        }
      }
      ++v40[0];
    }
    uint64_t v38 = v40;
    uint64_t v39 = 0x600000000;
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v31);
    if (mlir::inferReductionOpReturnShape(a2, a3, ArgAttrsAttr, v23, (uint64_t *)v41, v42, 1, (uint64_t)&v38))
    {
      uint64_t v24 = v38;
      uint64_t v25 = (mlir::AffineMap *)v39;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v31);
      uint64_t v27 = mlir::MemRefType::get(v24, v25, OperandRange, 0, 0, 0);
      uint64_t v28 = *(unsigned int *)(a11 + 8);
      if (v28 >= *(_DWORD *)(a11 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v28 + 1, 8);
        LODWORD(v28) = *(_DWORD *)(a11 + 8);
      }
      *(void *)(*(void *)a11 + 8 * v28) = v27;
      ++*(_DWORD *)(a11 + 8);
      uint64_t v21 = 1;
    }
    else
    {
      uint64_t v21 = 0;
    }
    if (v38 != v40) {
      free(v38);
    }
    if (v41 != v43) {
      free(v41);
    }
  }
  else if (a3)
  {
    mlir::emitError(a2, (uint64_t)&v41);
    if (v41) {
      mlir::Diagnostic::operator<<((uint64_t)&v42, "input type must be ranked shaped type");
    }
    uint64_t v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
    if (v41) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v42);
  }
  else
  {
    return 0;
  }
  return v21;
}

uint64_t mlir::anec::anonymous namespace'::TranslateToANECDesc(uint64_t a1, unint64_t a2, __CFString **a3)
{
  v18[6] = *MEMORY[0x1E4F143B8];
  ANECReductionLayerDescInitialize();
  long long v6 = *(void **)(*(void *)(a1 + 48) + 16);
  if (a1 && v6 == &mlir::detail::TypeIDResolver<mlir::anec::ReduceAvg,void>::id)
  {
    unint64_t v7 = @"Avg";
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMax,void>::id)
  {
    unint64_t v7 = @"Max";
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMin,void>::id)
  {
    unint64_t v7 = @"Min";
  }
  else
  {
    if (v6 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceSum,void>::id)
    {
      if (*(unsigned char *)(a1 + 47)) {
        goto LABEL_13;
      }
      goto LABEL_14;
    }
    unint64_t v7 = @"Sum";
  }
  *a3 = v7;
  if (*(unsigned char *)(a1 + 47))
  {
LABEL_13:
    uint64_t InherentAttr = mlir::Operation::getInherentAttr(a1, (uint64_t)"axes", 4);
    if (v9) {
      goto LABEL_15;
    }
  }
LABEL_14:
  uint64_t InherentAttr = mlir::DictionaryAttr::get(a1 + 56, "axes", 4uLL);
LABEL_15:
  char v16 = v18;
  uint64_t v17 = 0x600000000;
  mlir::getValues<unsigned long long>(InherentAttr, (uint64_t)&v16);
  uint64_t v10 = v17;
  a3[3] = (__CFString *)v17;
  char v11 = (mlir::anec::_anonymous_namespace_ **)v16;
  if (v10)
  {
    uint64_t v12 = (uint64_t *)(a3 + 4);
    uint64_t v13 = 8 * v10;
    do
    {
      uint64_t v14 = *v11++;
      v13 -= 8;
    }
    while (v13);
    char v11 = (mlir::anec::_anonymous_namespace_ **)v16;
  }
  a3[1] = @"Bypass";
  if (v11 != v18) {
    free(v11);
  }
  return 1;
}

uint64_t mlir::anec::verifyReductionWithANEC(uint64_t a1, uint64_t a2, mlir::MemoryMapperInterface *a3, unint64_t a4)
{
  v34[63] = *MEMORY[0x1E4F143B8];
  uint64_t v7 = 1;
  *(void *)buffer = 1;
  v23[0] = 0;
  ANECUnitValidatorCreate();
  v31[0] = v32;
  v31[1] = (void *)0x100000000;
  uint64_t v21 = 0;
  uint64_t v22 = 0;
  if (ANECValidateReductionLayer())
  {
    __int16 v18 = (uint64_t *)a2;
    uint64_t v17 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v8 = MEMORY[0x1E4FBA488] + 104;
    v30[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v9 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v24 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v10 = MEMORY[0x1E4FBA408];
    char v11 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v23[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v23 + (unint64_t)*(v23[0] - 3)) = v11;
    v23[1] = 0;
    uint64_t v12 = (std::ios_base *)((char *)v23 + (unint64_t)*(v23[0] - 3));
    std::ios_base::init(v12, &v25);
    v12[1].__vftable = 0;
    v12[1].__fmtflags_ = -1;
    uint64_t v13 = *(void *)(v10 + 40);
    uint64_t v24 = *(void *)(v10 + 32);
    *(uint64_t *)((char *)&v24 + *(void *)(v24 - 24)) = v13;
    v23[0] = *(const void ***)(v10 + 8);
    *(const void ***)((char *)v23 + (unint64_t)*(v23[0] - 3)) = *(const void ***)(v10 + 48);
    v30[0] = v8;
    v23[0] = v17;
    uint64_t v24 = v9;
    std::streambuf::basic_streambuf();
    uint64_t v14 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v25 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v28 = 0u;
    int v29 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v24, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v23[0] = *(const void ***)v10;
    uint64_t v15 = *(void *)(v10 + 72);
    *(const void ***)((char *)v23 + (unint64_t)*(v23[0] - 3)) = *(const void ***)(v10 + 64);
    uint64_t v24 = v15;
    uint64_t v25 = v14;
    if (SBYTE7(v28) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v30);
    __int16 v26 = 260;
    v23[0] = (const void **)&v19;
    uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    if (v20 < 0) {
      operator delete(v19);
    }
  }
  if (v31[0] != v32) {
    free(v31[0]);
  }
  ANECUnitValidatorDelete();
  return v7;
}

uint64_t mlir::anec::ReduceAvg::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a6;
  v27[0] = 0;
  char v28 = 0;
  uint64_t v29 = a7;
  uint64_t v30 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v26);
    if (v28) {
      char v28 = 0;
    }
    mlir::OperationName::OperationName(v27, "anec.reduce_avg", 15, Context);
    char v28 = 1;
  }
  uint64_t v31 = a4;
  uint64_t v32 = a5;
  uint64_t v18 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v19 = (uint64_t)a2;
  }
  else {
    uint64_t v19 = v18;
  }
  uint64_t v20 = mlir::anec::ReduceAvgAdaptor::verify(&v26, v19);
  if ((_BYTE)v20) {
    return mlir::anec::inferReductionOpReturnTypes(v20, (uint64_t)a2, a3, v21, v22, a6, v23, v24, a9, a10, a11);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ReduceAvgAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v65[23] = *MEMORY[0x1E4F143B8];
  uint64_t v63 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v63); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v63))
    {
      uint64_t v5 = "'anec.reduce_avg' op requires attribute 'axes'";
      goto LABEL_52;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  long long v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = *(void **)(v7 + 8);
    char v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        uint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v61[0] = v6;
    v61[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v61);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    uint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v64 = v18;
    v65[0] = v28;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v64);
    if (!v29) {
      goto LABEL_62;
    }
    uint64_t v30 = *v6;
    unint64_t v31 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v32 = *(unsigned int *)(v30 + 16);
    if (!v32) {
      goto LABEL_36;
    }
    uint64_t v33 = *(void **)(v30 + 8);
    unsigned __int8 v34 = &v33[2 * v32];
    do
    {
      unint64_t v35 = v32 >> 1;
      uint64_t v36 = &v33[2 * (v32 >> 1)];
      unint64_t v38 = *v36;
      unsigned int v37 = v36 + 2;
      v32 += ~(v32 >> 1);
      if (v38 < v31) {
        uint64_t v33 = v37;
      }
      else {
        unint64_t v32 = v35;
      }
    }
    while (v32);
    if (v33 != v34 && *v33 == v31) {
      uint64_t v39 = v33[1];
    }
    else {
LABEL_36:
    }
      uint64_t v39 = 0;
    v59[0] = v6;
    v59[1] = v39;
    uint64_t v40 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v59);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_46;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_46;
    }
    uint64_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        uint64_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_46:
    }
      uint64_t v51 = 0;
    v60[0] = v41;
    v60[1] = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v60);
    if (v52 == 1)
    {
LABEL_62:
      if (mlir::hasUniqueValues((uint64_t)v6))
      {
        uint64_t v56 = v6;
        v57[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v56);
        v57[1] = v53;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v57);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
          return 1;
        }
      }
    }
  }
  uint64_t v5 = "'anec.reduce_avg' op attribute 'axes' failed to satisfy constraint: ui64 unique elements attribute of ranks 0/1";
LABEL_52:
  v61[0] = v5;
  __int16 v62 = 259;
  mlir::emitError(a2, (uint64_t)v61, (uint64_t)&v64);
  uint64_t v54 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v64);
  if (v64) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v64);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v65);
  return v54;
}

uint64_t mlir::anec::ReduceAvg::addOpToNetwork(mlir::anec **a1, uint64_t a2)
{
  mlir::anec::getReductionZinIrUnitInfo(*a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    unint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

void mlir::anec::getReductionZinIrUnitInfo(mlir::anec *this@<X0>, void *a2@<X8>)
{
  uint64_t v5 = (char *)operator new(0x68uLL);
  *((void *)v5 + 2) = 0;
  *((void *)v5 + 3) = 0;
  *((_DWORD *)v5 + 8) = 0;
  *(_OWORD *)(v5 + 40) = 0u;
  *(_OWORD *)(v5 + 56) = 0u;
  *((void *)v5 + 9) = -1;
  *(void *)uint64_t v5 = &unk_1EC995C90;
  *((void *)v5 + 1) = 0;
  *((void *)v5 + 10) = 6;
  *((void *)v5 + 11) = 1065353216;
  *((void *)v5 + 12) = 0;
  long long v6 = *(void **)(*((void *)this + 6) + 16);
  if (this && v6 == &mlir::detail::TypeIDResolver<mlir::anec::ReduceAvg,void>::id)
  {
    int v7 = 3;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMax,void>::id)
  {
    int v7 = 2;
  }
  else if (v6 == &mlir::detail::TypeIDResolver<mlir::anec::ReduceMin,void>::id)
  {
    int v7 = 1;
  }
  else
  {
    if (v6 != &mlir::detail::TypeIDResolver<mlir::anec::ReduceSum,void>::id) {
      goto LABEL_11;
    }
    int v7 = 0;
  }
  *((_DWORD *)v5 + 20) = v7;
LABEL_11:
  unint64_t v8 = (uint64_t *)(*(void *)(*(void *)(*((void *)this + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_20;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_20;
  }
  long long v12 = *(void **)(v9 + 8);
  uint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    unint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    uint64_t v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      long long v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_20:
  }
    uint64_t v18 = 0;
  v36[0] = v8;
  v36[1] = v18;
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(this);
  uint64_t v19 = mlir::DictionaryAttr::get((uint64_t)&AttrDictionary, "axes", 4uLL);
  uint64_t v35 = v19;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&AttrDictionary, v19, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v35);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v29, v19, NumElements);
  while (1)
  {
    BOOL v21 = AttrDictionary == v29 && v33 == v30;
    if (v21 && v34 == v31) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&AttrDictionary, (llvm::APInt *)&__p);
    if (v28 >= 0x41) {
      p_p = (mlir::anec **)__p;
    }
    else {
      p_p = (mlir::anec **)&__p;
    }
    uint64_t v23 = *p_p;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
    uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v23, v24);
    if ((DimFromIndex & 0xFF00000000) != 0) {
      int v26 = dword_1810FE490[(int)DimFromIndex];
    }
    else {
      LOBYTE(v26) = 5;
    }
    *((void *)v5 + 12) |= (1 << v26) & 0x1F;
    if (v28 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v34;
  }
  *a2 = v5;
}

uint64_t mlir::anec::ReduceMax::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a6;
  v27[0] = 0;
  char v28 = 0;
  uint64_t v29 = a7;
  uint64_t v30 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v26);
    if (v28) {
      char v28 = 0;
    }
    mlir::OperationName::OperationName(v27, "anec.reduce_max", 15, Context);
    char v28 = 1;
  }
  uint64_t v31 = a4;
  uint64_t v32 = a5;
  uint64_t v18 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v19 = (uint64_t)a2;
  }
  else {
    uint64_t v19 = v18;
  }
  uint64_t v20 = mlir::anec::ReduceMaxAdaptor::verify(&v26, v19);
  if ((_BYTE)v20) {
    return mlir::anec::inferReductionOpReturnTypes(v20, (uint64_t)a2, a3, v21, v22, a6, v23, v24, a9, a10, a11);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ReduceMaxAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v65[23] = *MEMORY[0x1E4F143B8];
  uint64_t v63 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v63); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v63))
    {
      uint64_t v5 = "'anec.reduce_max' op requires attribute 'axes'";
      goto LABEL_52;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  long long v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    unint64_t v10 = *(void **)(v7 + 8);
    unint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      unint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        unint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v61[0] = v6;
    v61[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v61);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    uint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v64 = v18;
    v65[0] = v28;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v64);
    if (!v29) {
      goto LABEL_62;
    }
    uint64_t v30 = *v6;
    unint64_t v31 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v32 = *(unsigned int *)(v30 + 16);
    if (!v32) {
      goto LABEL_36;
    }
    uint64_t v33 = *(void **)(v30 + 8);
    uint64_t v34 = &v33[2 * v32];
    do
    {
      unint64_t v35 = v32 >> 1;
      uint64_t v36 = &v33[2 * (v32 >> 1)];
      unint64_t v38 = *v36;
      unsigned int v37 = v36 + 2;
      v32 += ~(v32 >> 1);
      if (v38 < v31) {
        uint64_t v33 = v37;
      }
      else {
        unint64_t v32 = v35;
      }
    }
    while (v32);
    if (v33 != v34 && *v33 == v31) {
      uint64_t v39 = v33[1];
    }
    else {
LABEL_36:
    }
      uint64_t v39 = 0;
    v59[0] = v6;
    v59[1] = v39;
    uint64_t v40 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v59);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_46;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_46;
    }
    uint64_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        uint64_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_46:
    }
      uint64_t v51 = 0;
    v60[0] = v41;
    v60[1] = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v60);
    if (v52 == 1)
    {
LABEL_62:
      if (mlir::hasUniqueValues((uint64_t)v6))
      {
        uint64_t v56 = v6;
        v57[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v56);
        v57[1] = v53;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v57);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
          return 1;
        }
      }
    }
  }
  uint64_t v5 = "'anec.reduce_max' op attribute 'axes' failed to satisfy constraint: ui64 unique elements attribute of ranks 0/1";
LABEL_52:
  v61[0] = v5;
  __int16 v62 = 259;
  mlir::emitError(a2, (uint64_t)v61, (uint64_t)&v64);
  uint64_t v54 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v64);
  if (v64) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v64);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v65);
  return v54;
}

uint64_t mlir::anec::ReduceMin::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a6;
  v27[0] = 0;
  char v28 = 0;
  uint64_t v29 = a7;
  uint64_t v30 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v26);
    if (v28) {
      char v28 = 0;
    }
    mlir::OperationName::OperationName(v27, "anec.reduce_min", 15, Context);
    char v28 = 1;
  }
  uint64_t v31 = a4;
  uint64_t v32 = a5;
  uint64_t v18 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v19 = (uint64_t)a2;
  }
  else {
    uint64_t v19 = v18;
  }
  uint64_t v20 = mlir::anec::ReduceMinAdaptor::verify(&v26, v19);
  if ((_BYTE)v20) {
    return mlir::anec::inferReductionOpReturnTypes(v20, (uint64_t)a2, a3, v21, v22, a6, v23, v24, a9, a10, a11);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ReduceMinAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v65[23] = *MEMORY[0x1E4F143B8];
  uint64_t v63 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v63); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v63))
    {
      uint64_t v5 = "'anec.reduce_min' op requires attribute 'axes'";
      goto LABEL_52;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  long long v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    unint64_t v10 = *(void **)(v7 + 8);
    unint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      unint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        unint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v61[0] = v6;
    v61[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v61);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    uint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v64 = v18;
    v65[0] = v28;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v64);
    if (!v29) {
      goto LABEL_62;
    }
    uint64_t v30 = *v6;
    unint64_t v31 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v32 = *(unsigned int *)(v30 + 16);
    if (!v32) {
      goto LABEL_36;
    }
    uint64_t v33 = *(void **)(v30 + 8);
    uint64_t v34 = &v33[2 * v32];
    do
    {
      unint64_t v35 = v32 >> 1;
      uint64_t v36 = &v33[2 * (v32 >> 1)];
      unint64_t v38 = *v36;
      unsigned int v37 = v36 + 2;
      v32 += ~(v32 >> 1);
      if (v38 < v31) {
        uint64_t v33 = v37;
      }
      else {
        unint64_t v32 = v35;
      }
    }
    while (v32);
    if (v33 != v34 && *v33 == v31) {
      uint64_t v39 = v33[1];
    }
    else {
LABEL_36:
    }
      uint64_t v39 = 0;
    v59[0] = v6;
    v59[1] = v39;
    uint64_t v40 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v59);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_46;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_46;
    }
    uint64_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        uint64_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_46:
    }
      uint64_t v51 = 0;
    v60[0] = v41;
    v60[1] = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v60);
    if (v52 == 1)
    {
LABEL_62:
      if (mlir::hasUniqueValues((uint64_t)v6))
      {
        uint64_t v56 = v6;
        v57[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v56);
        v57[1] = v53;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v57);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
          return 1;
        }
      }
    }
  }
  uint64_t v5 = "'anec.reduce_min' op attribute 'axes' failed to satisfy constraint: ui64 unique elements attribute of ranks 0/1";
LABEL_52:
  v61[0] = v5;
  __int16 v62 = 259;
  mlir::emitError(a2, (uint64_t)v61, (uint64_t)&v64);
  uint64_t v54 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v64);
  if (v64) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v64);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v65);
  return v54;
}

uint64_t mlir::anec::ReduceSum::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v26 = a6;
  v27[0] = 0;
  char v28 = 0;
  uint64_t v29 = a7;
  uint64_t v30 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v26);
    if (v28) {
      char v28 = 0;
    }
    mlir::OperationName::OperationName(v27, "anec.reduce_sum", 15, Context);
    char v28 = 1;
  }
  uint64_t v31 = a4;
  uint64_t v32 = a5;
  uint64_t v18 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v19 = (uint64_t)a2;
  }
  else {
    uint64_t v19 = v18;
  }
  uint64_t v20 = mlir::anec::ReduceSumAdaptor::verify(&v26, v19);
  if ((_BYTE)v20) {
    return mlir::anec::inferReductionOpReturnTypes(v20, (uint64_t)a2, a3, v21, v22, a6, v23, v24, a9, a10, a11);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ReduceSumAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v65[23] = *MEMORY[0x1E4F143B8];
  uint64_t v63 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v63); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v63))
    {
      uint64_t v5 = "'anec.reduce_sum' op requires attribute 'axes'";
      goto LABEL_52;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  long long v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    unint64_t v10 = *(void **)(v7 + 8);
    unint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      unint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        unint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v61[0] = v6;
    v61[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v61);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    uint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v64 = v18;
    v65[0] = v28;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v64);
    if (!v29) {
      goto LABEL_62;
    }
    uint64_t v30 = *v6;
    unint64_t v31 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v32 = *(unsigned int *)(v30 + 16);
    if (!v32) {
      goto LABEL_36;
    }
    uint64_t v33 = *(void **)(v30 + 8);
    uint64_t v34 = &v33[2 * v32];
    do
    {
      unint64_t v35 = v32 >> 1;
      uint64_t v36 = &v33[2 * (v32 >> 1)];
      unint64_t v38 = *v36;
      unsigned int v37 = v36 + 2;
      v32 += ~(v32 >> 1);
      if (v38 < v31) {
        uint64_t v33 = v37;
      }
      else {
        unint64_t v32 = v35;
      }
    }
    while (v32);
    if (v33 != v34 && *v33 == v31) {
      uint64_t v39 = v33[1];
    }
    else {
LABEL_36:
    }
      uint64_t v39 = 0;
    v59[0] = v6;
    v59[1] = v39;
    uint64_t v40 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v59);
    uint64_t v41 = v40;
    if (!v40) {
      goto LABEL_46;
    }
    uint64_t v42 = *v40;
    unint64_t v43 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v44 = *(unsigned int *)(v42 + 16);
    if (!v44) {
      goto LABEL_46;
    }
    uint64_t v45 = *(void **)(v42 + 8);
    uint64_t v46 = &v45[2 * v44];
    do
    {
      unint64_t v47 = v44 >> 1;
      uint64_t v48 = &v45[2 * (v44 >> 1)];
      unint64_t v50 = *v48;
      uint64_t v49 = v48 + 2;
      v44 += ~(v44 >> 1);
      if (v50 < v43) {
        uint64_t v45 = v49;
      }
      else {
        unint64_t v44 = v47;
      }
    }
    while (v44);
    if (v45 != v46 && *v45 == v43) {
      uint64_t v51 = v45[1];
    }
    else {
LABEL_46:
    }
      uint64_t v51 = 0;
    v60[0] = v41;
    v60[1] = v51;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v60);
    if (v52 == 1)
    {
LABEL_62:
      if (mlir::hasUniqueValues((uint64_t)v6))
      {
        uint64_t v56 = v6;
        v57[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v56);
        v57[1] = v53;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v57);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
          return 1;
        }
      }
    }
  }
  uint64_t v5 = "'anec.reduce_sum' op attribute 'axes' failed to satisfy constraint: ui64 unique elements attribute of ranks 0/1";
LABEL_52:
  v61[0] = v5;
  __int16 v62 = 259;
  mlir::emitError(a2, (uint64_t)v61, (uint64_t)&v64);
  uint64_t v54 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v64);
  if (v64) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v64);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v65);
  return v54;
}

uint64_t mlir::anec::GOC::mutateOpForReshapeSwap(uint64_t a1, const void *a2, uint64_t a3, void *a4, uint64_t a5)
{
  v79[5] = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    uint64_t v8 = 8 * a5;
    while (!*a4)
    {
      ++a4;
      v8 -= 8;
      if (!v8) {
        goto LABEL_5;
      }
    }
    return 0;
  }
LABEL_5:
  unint64_t v9 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)a1 + 72) + 88) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_14;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_14;
  }
  uint64_t v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    uint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    unint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_14:
  }
    uint64_t v19 = 0;
  size_t v77 = v9;
  uint64_t v78 = v19;
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v77);
  if (mlir::ShapedType::getNumElements(ArgAttrsAttr, v21) == 1)
  {
    uint64_t v22 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)a1 + 72) + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v22) {
      goto LABEL_25;
    }
    uint64_t v23 = *v22;
    unint64_t v24 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v25 = *(unsigned int *)(v23 + 16);
    if (!v25) {
      goto LABEL_25;
    }
    uint64_t v26 = *(void **)(v23 + 8);
    unint64_t v27 = &v26[2 * v25];
    do
    {
      unint64_t v28 = v25 >> 1;
      uint64_t v29 = &v26[2 * (v25 >> 1)];
      unint64_t v31 = *v29;
      uint64_t v30 = v29 + 2;
      v25 += ~(v25 >> 1);
      if (v31 < v24) {
        uint64_t v26 = v30;
      }
      else {
        unint64_t v25 = v28;
      }
    }
    while (v25);
    if (v26 != v27 && *v26 == v24) {
      uint64_t v32 = v26[1];
    }
    else {
LABEL_25:
    }
      uint64_t v32 = 0;
    uint64_t v74 = v22;
    uint64_t v75 = v32;
    uint64_t v33 = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v74);
    if (mlir::ShapedType::getNumElements(v33, v34) == 1) {
      return 1;
    }
  }
  uint64_t v36 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v36) {
    goto LABEL_37;
  }
  uint64_t v37 = *v36;
  unint64_t v38 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v39 = *(unsigned int *)(v37 + 16);
  if (!v39) {
    goto LABEL_37;
  }
  uint64_t v40 = *(void **)(v37 + 8);
  uint64_t v41 = &v40[2 * v39];
  do
  {
    unint64_t v42 = v39 >> 1;
    unint64_t v43 = &v40[2 * (v39 >> 1)];
    unint64_t v45 = *v43;
    unint64_t v44 = v43 + 2;
    v39 += ~(v39 >> 1);
    if (v45 < v38) {
      uint64_t v40 = v44;
    }
    else {
      unint64_t v39 = v42;
    }
  }
  while (v39);
  if (v40 != v41 && *v40 == v38) {
    uint64_t v46 = v40[1];
  }
  else {
LABEL_37:
  }
    uint64_t v46 = 0;
  uint64_t v74 = v36;
  uint64_t v75 = v46;
  uint64_t v48 = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v74);
  uint64_t v49 = v47;
  size_t v77 = v79;
  uint64_t v78 = 0x500000000;
  size_t v50 = 8 * v47;
  if ((unint64_t)(8 * v47) < 0x29)
  {
    unsigned int v51 = 0;
    if (!v47) {
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v77, v79, (8 * v47) >> 3, 8);
  unsigned int v51 = v78;
  if (v49)
  {
LABEL_43:
    memcpy((char *)v77 + 8 * v51, v48, v50);
    unsigned int v51 = v78;
  }
LABEL_44:
  unsigned int v52 = v51 + (v50 >> 3);
  LODWORD(v78) = v52;
  if (v52 <= 4) {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v77, (uint64_t)v77, 5 - v52, 1uLL);
  }
  uint64_t v74 = v76;
  uint64_t v75 = 0x500000000;
  if ((unint64_t)(8 * a3) < 0x29)
  {
    unsigned int v53 = 0;
    if (!a3) {
      goto LABEL_51;
    }
    goto LABEL_50;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v76, (8 * a3) >> 3, 8);
  unsigned int v53 = v75;
  if (a3)
  {
LABEL_50:
    memcpy((char *)v74 + 8 * v53, a2, 8 * a3);
    unsigned int v53 = v75;
  }
LABEL_51:
  unsigned int v54 = v53 + a3;
  LODWORD(v75) = v54;
  if (v54 <= 4) {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v74, (uint64_t)v74, 5 - v54, 1uLL);
  }
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v78);
  if (v56)
  {
    unint64_t v57 = IndexFromDim;
    memset_pattern16(&v70, &unk_1810FE350, 0x20uLL);
    uint64_t v58 = v77;
    uint64_t v59 = v70;
    if (v78 && v75)
    {
      unint64_t v60 = 0;
      uint64_t v61 = v72;
      uint64_t v62 = v73;
      uint64_t v63 = v71;
      uint64_t v64 = 8 * v75 - 8;
      uint64_t v65 = 8 * v78 - 8;
      do
      {
        if (v60 >= v57)
        {
          if (v60 > v57)
          {
            v61 *= *((void *)v77 + v60);
            uint64_t v72 = v61;
            v62 *= *((void *)v74 + v60);
            uint64_t v73 = v62;
          }
        }
        else
        {
          v59 *= *((void *)v77 + v60);
          uint64_t v70 = v59;
          v63 *= *((void *)v74 + v60);
          uint64_t v71 = v63;
        }
        if (!v65) {
          break;
        }
        ++v60;
        uint64_t v66 = v64;
        v64 -= 8;
        v65 -= 8;
      }
      while (v66);
    }
    else
    {
      uint64_t v63 = v71;
      uint64_t v61 = v72;
      uint64_t v62 = v73;
    }
    BOOL v35 = v59 == v63 && v61 == v62;
    if (v74 != v76)
    {
      free(v74);
      uint64_t v58 = v77;
    }
    if (v58 != v79) {
      free(v58);
    }
    return v35;
  }
  uint64_t v69 = (mlir::anec::GOC *)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::anec::GOC::getBias(v69);
}

uint64_t mlir::anec::GOC::getBias(mlir::anec::GOC *this)
{
  return *(void *)(*(void *)(*(void *)this + 72) + 88);
}

char *llvm::SmallVectorImpl<long long>::insert(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v7 = *(void *)a1;
  uint64_t v8 = (a2 - *(void *)a1) >> 3;
  uint64_t v10 = *(unsigned int *)(a1 + 8);
  unint64_t v9 = *(unsigned int *)(a1 + 12);
  int v11 = *(_DWORD *)(a1 + 8);
  unint64_t v12 = v10 + a3;
  if (*(void *)a1 + 8 * v10 == a2)
  {
    if (v12 > v9)
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v12, 8);
      uint64_t v10 = *(unsigned int *)(a1 + 8);
      uint64_t v7 = *(void *)a1;
      int v11 = *(_DWORD *)(a1 + 8);
      if (a3) {
        goto LABEL_16;
      }
    }
    else if (a3)
    {
LABEL_16:
      unint64_t v25 = (int64x2_t *)(v7 + 8 * v10);
      uint64_t v26 = (unint64_t *)v25;
      unint64_t v27 = a3;
      if (a3 < 4) {
        goto LABEL_51;
      }
      uint64_t v26 = (unint64_t *)v25 + (a3 & 0xFFFFFFFFFFFFFFFCLL);
      unint64_t v27 = a3 & 3;
      int64x2_t v28 = vdupq_n_s64(a4);
      uint64_t v29 = v25 + 1;
      unint64_t v30 = a3 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v29[-1] = v28;
        int64x2_t *v29 = v28;
        v29 += 2;
        v30 -= 4;
      }
      while (v30);
      if ((a3 & 0xFFFFFFFFFFFFFFFCLL) != a3)
      {
LABEL_51:
        do
        {
          *v26++ = a4;
          --v27;
        }
        while (v27);
      }
    }
    *(_DWORD *)(a1 + 8) = v11 + a3;
    return (char *)(v7 + 8 * v8);
  }
  if (v12 > v9)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v12, 8);
    uint64_t v7 = *(void *)a1;
    uint64_t v10 = *(unsigned int *)(a1 + 8);
    int v11 = *(_DWORD *)(a1 + 8);
  }
  uint64_t v13 = (char *)(v7 + 8 * v8);
  unint64_t v14 = (unint64_t *)(v7 + 8 * v10);
  unint64_t v15 = (char *)v14 - v13;
  unint64_t v16 = ((char *)v14 - v13) >> 3;
  if (a3 > v16)
  {
    unsigned int v17 = v11 + a3;
    *(_DWORD *)(a1 + 8) = v17;
    if (v8 != v10)
    {
      memcpy((void *)(v7 + 8 * v17 - 8 * v16), (const void *)(v7 + 8 * v8), (char *)v14 - v13);
      unint64_t v18 = (unint64_t *)(v7 + 8 * v8);
      uint64_t v19 = ((char *)v14 - v13) >> 3;
      if (v15 < 0x20) {
        goto LABEL_52;
      }
      unint64_t v18 = (unint64_t *)&v13[8 * (v16 & 0xFFFFFFFFFFFFFFFCLL)];
      uint64_t v19 = (v15 >> 3) & 3;
      int64x2_t v20 = vdupq_n_s64(a4);
      uint64_t v21 = (int64x2_t *)(v7 + 8 * v8 + 16);
      unint64_t v22 = v16 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v21[-1] = v20;
        *uint64_t v21 = v20;
        v21 += 2;
        v22 -= 4;
      }
      while (v22);
      if (v16 != (v16 & 0xFFFFFFFFFFFFFFFCLL))
      {
LABEL_52:
        do
        {
          *v18++ = a4;
          --v19;
        }
        while (v19);
      }
    }
    unint64_t v23 = a3 - v16;
    if (a3 != v16)
    {
      if (v23 < 4)
      {
        unint64_t v24 = a3 - v16;
        do
        {
LABEL_30:
          *v14++ = a4;
          --v24;
        }
        while (v24);
        return v13;
      }
      v14 += v23 & 0xFFFFFFFFFFFFFFFCLL;
      unint64_t v24 = v23 & 3;
      int64x2_t v38 = vdupq_n_s64(a4);
      unint64_t v39 = (int64x2_t *)(v7 + 8 * v10 + 16);
      unint64_t v40 = v23 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v39[-1] = v38;
        *unint64_t v39 = v38;
        v39 += 2;
        v40 -= 4;
      }
      while (v40);
      if (v23 != (v23 & 0xFFFFFFFFFFFFFFFCLL)) {
        goto LABEL_30;
      }
    }
    return v13;
  }
  uint64_t v31 = 8 * a3;
  unint64_t v32 = v10 + ((uint64_t)(8 * a3) >> 3);
  uint64_t v33 = v10;
  if (v32 > *(unsigned int *)(a1 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a1, (void *)(a1 + 16), v32, 8);
    uint64_t v33 = *(unsigned int *)(a1 + 8);
    int v11 = *(_DWORD *)(a1 + 8);
  }
  uint64_t v34 = &v14[v31 / 0xFFFFFFFFFFFFFFF8];
  if (a3)
  {
    BOOL v35 = (void *)(*(void *)a1 + 8 * v33);
    unint64_t v36 = (a3 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v36 < 0xF)
    {
      uint64_t v37 = &v14[v31 / 0xFFFFFFFFFFFFFFF8];
      do
      {
LABEL_36:
        uint64_t v48 = *v37++;
        *v35++ = v48;
      }
      while (v37 != v14);
      goto LABEL_37;
    }
    uint64_t v41 = 8 * v33 + *(void *)a1;
    uint64_t v37 = &v14[v31 / 0xFFFFFFFFFFFFFFF8];
    if ((unint64_t)(v31 - (8 * v10 + v7) + v41) < 0x20) {
      goto LABEL_36;
    }
    unint64_t v42 = v36 + 1;
    uint64_t v43 = v42 & 0x3FFFFFFFFFFFFFFCLL;
    BOOL v35 = (void *)((char *)v35 + v43 * 8);
    uint64_t v37 = &v34[v43];
    unint64_t v44 = (long long *)(8 * v10 - v31 + v7 + 16);
    unint64_t v45 = (_OWORD *)(v41 + 16);
    uint64_t v46 = v42 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      long long v47 = *v44;
      *(v45 - 1) = *(v44 - 1);
      *unint64_t v45 = v47;
      v44 += 2;
      v45 += 2;
      v46 -= 4;
    }
    while (v46);
    if (v42 != (v42 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_36;
    }
  }
LABEL_37:
  *(_DWORD *)(a1 + 8) = v11 + a3;
  if (v34 != (unint64_t *)v13) {
    memmove(&v13[v31], (const void *)(v7 + 8 * v8), (char *)&v14[v31 / 0xFFFFFFFFFFFFFFF8] - v13);
  }
  if (a3)
  {
    if (a3 >= 4)
    {
      uint64_t v49 = (unint64_t *)&v13[8 * (a3 & 0xFFFFFFFFFFFFFFFCLL)];
      unint64_t v50 = a3 & 3;
      int64x2_t v51 = vdupq_n_s64(a4);
      unsigned int v52 = (int64x2_t *)(v7 + 8 * v8 + 16);
      unint64_t v53 = a3 & 0xFFFFFFFFFFFFFFFCLL;
      do
      {
        v52[-1] = v51;
        *unsigned int v52 = v51;
        v52 += 2;
        v53 -= 4;
      }
      while (v53);
      if ((a3 & 0xFFFFFFFFFFFFFFFCLL) == a3) {
        return v13;
      }
    }
    else
    {
      uint64_t v49 = (unint64_t *)(v7 + 8 * v8);
      unint64_t v50 = a3;
    }
    do
    {
      *v49++ = a4;
      --v50;
    }
    while (v50);
  }
  return v13;
}

uint64_t mlir::anec::GOC::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v40[63] = *MEMORY[0x1E4F143B8];
  ANECGOCLayerDescInitialize();
  *(void *)buffer = *(void *)(*(void *)(*a1 + 72) + 56);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)buffer);
  if (DefiningOp
    && (uint64_t v7 = DefiningOp,
        uint64_t v8 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>(),
        ((*(uint64_t (**)(void, uint64_t))(**(void **)(v7 + 48) + 32))(*(void *)(v7 + 48), v8) & 1) != 0))
  {
    *(void *)buffer = *(void *)(*(void *)(*a1 + 72) + 88);
    uint64_t v9 = mlir::Value::getDefiningOp((mlir::Value *)buffer);
    if (v9)
    {
      uint64_t v10 = v9;
      uint64_t v11 = mlir::TypeID::get<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>>();
      if ((*(uint64_t (**)(void, uint64_t))(**(void **)(v10 + 48) + 32))(*(void *)(v10 + 48), v11))
      {
        v37[0] = v38;
        v37[1] = (void *)0x100000000;
        uint64_t v12 = 1;
        *(void *)buffer = 1;
        v29[0] = 0;
        ANECUnitValidatorCreate();
        uint64_t v27 = 0;
        uint64_t v28 = 0;
        if (ANECValidateGOCLayer())
        {
          unint64_t v23 = (const void **)(MEMORY[0x1E4FBA488] + 24);
          unint64_t v24 = (uint64_t *)*a1;
          uint64_t v13 = MEMORY[0x1E4FBA488] + 104;
          v36[0] = MEMORY[0x1E4FBA488] + 104;
          uint64_t v14 = MEMORY[0x1E4FBA488] + 64;
          uint64_t v30 = MEMORY[0x1E4FBA488] + 64;
          uint64_t v15 = MEMORY[0x1E4FBA408];
          unint64_t v16 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
          v29[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
          *(const void ***)((char *)v29 + (unint64_t)*(v29[0] - 3)) = v16;
          v29[1] = 0;
          unsigned int v17 = (std::ios_base *)((char *)v29 + (unint64_t)*(v29[0] - 3));
          std::ios_base::init(v17, &v31);
          v17[1].__vftable = 0;
          v17[1].__fmtflags_ = -1;
          uint64_t v18 = *(void *)(v15 + 40);
          uint64_t v30 = *(void *)(v15 + 32);
          *(uint64_t *)((char *)&v30 + *(void *)(v30 - 24)) = v18;
          v29[0] = *(const void ***)(v15 + 8);
          *(const void ***)((char *)v29 + (unint64_t)*(v29[0] - 3)) = *(const void ***)(v15 + 48);
          v36[0] = v13;
          v29[0] = v23;
          uint64_t v30 = v14;
          std::streambuf::basic_streambuf();
          uint64_t v19 = MEMORY[0x1E4FBA470] + 16;
          uint64_t v31 = MEMORY[0x1E4FBA470] + 16;
          long long __p = 0u;
          long long v34 = 0u;
          int v35 = 24;
          std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v30, (uint64_t)"Invalid configuration", 21);
          std::stringbuf::str();
          v29[0] = *(const void ***)v15;
          uint64_t v20 = *(void *)(v15 + 72);
          *(const void ***)((char *)v29 + (unint64_t)*(v29[0] - 3)) = *(const void ***)(v15 + 64);
          uint64_t v30 = v20;
          uint64_t v31 = v19;
          if (SBYTE7(v34) < 0) {
            operator delete((void *)__p);
          }
          std::streambuf::~streambuf();
          std::iostream::~basic_iostream();
          MEMORY[0x1852FDD70](v36);
          __int16 v32 = 260;
          v29[0] = (const void **)&v25;
          uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
          if (*(void *)buffer) {
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
          }
          std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v40);
          if (v26 < 0) {
            operator delete(v25);
          }
        }
        ANECUnitValidatorDelete();
        if (v37[0] != v38) {
          free(v37[0]);
        }
        return v12;
      }
    }
    uint64_t v21 = "failed: bias operand must be a constant";
  }
  else
  {
    uint64_t v21 = "failed: scale operand must be a constant";
  }
  v29[0] = (const void **)v21;
  __int16 v32 = 259;
  mlir::OpState::emitOpError((uint64_t **)a1, v29, (uint64_t)buffer);
  uint64_t v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
  if (*(void *)buffer) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v40);
  return v12;
}

uint64_t mlir::anec::GOC::addOpToNetwork(mlir::anec **a1, uint64_t a2, mlir::anec::ANECIRWeights *a3)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  __p.__r_.__value_.__r.__words[0] = *(void *)(*((void *)*a1 + 9) + 56);
  uint64_t DefiningOp = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&__p);
  uint64_t v6 = mlir::anec::ANECIRWeights::lookupConstant(a3, DefiningOp);
  uint64_t v8 = v7;
  __p.__r_.__value_.__r.__words[0] = *(void *)(*((void *)*a1 + 9) + 88);
  uint64_t v9 = (mlir::Operation *)mlir::Value::getDefiningOp((mlir::Value *)&__p);
  uint64_t v10 = mlir::anec::ANECIRWeights::lookupConstant(a3, v9);
  uint64_t v12 = v11;
  mlir::anec::computeOpKeyString(*a1, &__p);
  uint64_t v13 = (char *)operator new(0xE0uLL);
  *(void *)uint64_t v13 = &unk_1EC9CB3F8;
  uint64_t v14 = (std::string *)(v13 + 8);
  char v15 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
  {
    std::string::__init_copy_ctor_external(v14, __p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_);
    char v15 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  }
  else
  {
    *(_OWORD *)&v14->__r_.__value_.__l.__data_ = *(_OWORD *)&__p.__r_.__value_.__l.__data_;
    *((void *)v13 + 3) = *((void *)&__p.__r_.__value_.__l + 2);
  }
  *((_DWORD *)v13 + 8) = 2;
  *((void *)v13 + 5) = 0;
  v13[48] = 0;
  *((void *)v13 + 7) = @"GOC";
  *((void *)v13 + 8) = v13 + 80;
  *((void *)v13 + 9) = 0x100000000;
  *((void *)v13 + 14) = v13 + 128;
  *((void *)v13 + 15) = 0x300000000;
  *(void *)uint64_t v13 = &unk_1EC9CC1F8;
  *((void *)v13 + 22) = 0x8000000080000000;
  *(_OWORD *)(v13 + 184) = 0u;
  *(_OWORD *)(v13 + 200) = 0u;
  *((_WORD *)v13 + 108) = 0;
  unint64_t v16 = (std::__shared_weak_count *)operator new(0x20uLL);
  v16->__shared_owners_ = 0;
  v16->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D02F0;
  v16->__shared_weak_owners_ = 0;
  v16[1].__vftable = (std::__shared_weak_count_vtbl *)v13;
  if (v15 < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
  uint64_t v52 = 0;
  std::string::size_type v17 = *(void *)(*((void *)*a1 + 9) + 56);
  v50.__r_.__value_.__r.__words[0] = (std::string::size_type)&v52;
  __p.__r_.__value_.__r.__words[0] = v17;
  uint64_t v18 = mlir::Value::getDefiningOp((mlir::Value *)&__p);
  if (v18
    && mlir::detail::constant_op_binder<mlir::DenseFPElementsAttr>::match((unint64_t **)&v50, v18)
    && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v52))
  {
    mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v52, (uint64_t)&__p);
    if (llvm::APFloat::convertToDouble((void **)&__p.__r_.__value_.__l.__data_) == 1.0)
    {
      uint64_t v21 = llvm::APFloatBase::PPCDoubleDouble(v19);
    }
    else
    {
      std::string::size_type size = __p.__r_.__value_.__l.__size_;
      uint64_t v21 = llvm::APFloatBase::PPCDoubleDouble(v19);
      if (v21 == (void *)size) {
        llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)&__p.__r_.__value_.__r.__words[1], (llvm::APInt *)&v50);
      }
      else {
        llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)&__p.__r_.__value_.__r.__words[1], (uint64_t)&v50);
      }
      if (LODWORD(v50.__r_.__value_.__r.__words[1]) > 0x40)
      {
        uint64_t v46 = (void *)v50.__r_.__value_.__r.__words[0];
        *((_DWORD *)v13 + 45) = *(unsigned __int16 *)v50.__r_.__value_.__l.__data_;
        *((void *)v13 + 26) = 2;
        operator delete[](v46);
      }
      else
      {
        *((_DWORD *)v13 + 45) = (unsigned __int16)((uint64_t)(v50.__r_.__value_.__r.__words[0] << -(uint64_t)LODWORD(v50.__r_.__value_.__r.__words[1])) >> -(uint64_t)LODWORD(v50.__r_.__value_.__r.__words[1]));
        *((void *)v13 + 26) = 2;
      }
    }
    if (v21 == (void *)__p.__r_.__value_.__l.__size_) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&__p.__r_.__value_.__r.__words[1]);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p.__r_.__value_.__r.__words[1]);
    }
  }
  else
  {
    *((void *)v13 + 24) = v6;
    *((void *)v13 + 26) = v8;
  }
  uint64_t v51 = 0;
  std::string::size_type v22 = *(void *)(*((void *)*a1 + 9) + 88);
  v50.__r_.__value_.__r.__words[0] = (std::string::size_type)&v51;
  __p.__r_.__value_.__r.__words[0] = v22;
  uint64_t v23 = mlir::Value::getDefiningOp((mlir::Value *)&__p);
  if (v23
    && mlir::detail::constant_op_binder<mlir::DenseFPElementsAttr>::match((unint64_t **)&v50, v23)
    && mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v51))
  {
    mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v51, (uint64_t)&__p);
    if (llvm::APFloat::convertToDouble((void **)&__p.__r_.__value_.__l.__data_) == 0.0)
    {
      char v26 = llvm::APFloatBase::PPCDoubleDouble(v24);
    }
    else
    {
      std::string::size_type v25 = __p.__r_.__value_.__l.__size_;
      char v26 = llvm::APFloatBase::PPCDoubleDouble(v24);
      if (v26 == (void *)v25) {
        llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)&__p.__r_.__value_.__r.__words[1], (llvm::APInt *)&v50);
      }
      else {
        llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)&__p.__r_.__value_.__r.__words[1], (uint64_t)&v50);
      }
      if (LODWORD(v50.__r_.__value_.__r.__words[1]) > 0x40)
      {
        long long v47 = (void *)v50.__r_.__value_.__r.__words[0];
        *((_DWORD *)v13 + 44) = *(unsigned __int16 *)v50.__r_.__value_.__l.__data_;
        *((void *)v13 + 25) = 2;
        operator delete[](v47);
      }
      else
      {
        *((_DWORD *)v13 + 44) = (unsigned __int16)((uint64_t)(v50.__r_.__value_.__r.__words[0] << -(uint64_t)LODWORD(v50.__r_.__value_.__r.__words[1])) >> -(uint64_t)LODWORD(v50.__r_.__value_.__r.__words[1]));
        *((void *)v13 + 25) = 2;
      }
    }
    if (v26 == (void *)__p.__r_.__value_.__l.__size_) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&__p.__r_.__value_.__r.__words[1]);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&__p.__r_.__value_.__r.__words[1]);
    }
  }
  else
  {
    *((void *)v13 + 23) = v10;
    *((void *)v13 + 25) = v12;
  }
  uint64_t v27 = *(void *)(*((void *)*a1 + 9) + 24);
  uint64_t v53 = v27;
  if (mlir::Value::getDefiningOp((mlir::Value *)&v53))
  {
    uint64_t v28 = (mlir::anec *)mlir::Value::getDefiningOp((mlir::Value *)&v53);
    mlir::anec::computeOpKeyString(v28, &v50);
  }
  else
  {
    uint64_t v29 = v53;
    if ((~*(_DWORD *)(v53 + 8) & 7) != 0) {
      uint64_t v29 = 0;
    }
    uint64_t v54 = *(unsigned int *)(v29 + 24);
    __p.__r_.__value_.__r.__words[0] = (std::string::size_type)"__arg";
    __p.__r_.__value_.__r.__words[2] = (std::string::size_type)&v54;
    __int16 v56 = 3331;
    llvm::Twine::str((llvm::Twine *)&__p, &v50);
  }
  uint64_t ANECIRDataType = mlir::anec::getANECIRDataType(v27);
  if ((ANECIRDataType & 0xFF00000000) == 0) {
    goto LABEL_38;
  }
  mlir::anec::ANECIRUnit::AddInput((uint64_t)v13, (uint64_t)&v50, ANECIRDataType);
  uint64_t v31 = *((_DWORD *)*a1 + 9) ? (uint64_t)*a1 - 16 : 0;
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v31, 0);
  __p.__r_.__value_.__r.__words[0] = (std::string::size_type)llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8));
  __p.__r_.__value_.__l.__size_ = v33;
  if (!__p.__r_.__value_.__r.__words[0]
    || (*((_DWORD *)*a1 + 9) ? (uint64_t v34 = (uint64_t)*a1 - 16) : (uint64_t v34 = 0),
        uint64_t v35 = mlir::detail::OpResultImpl::getNextResultAtOffset(v34, 0),
        uint64_t v36 = mlir::anec::getANECIRDataType(v35),
        (v36 & 0xFF00000000) == 0))
  {
LABEL_38:
    uint64_t v43 = 0;
    if ((SHIBYTE(v50.__r_.__value_.__r.__words[2]) & 0x80000000) == 0) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  unsigned int v37 = v36;
  uint64_t v38 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&__p) + 8);
  uint64_t v39 = *((unsigned int *)v13 + 30);
  if (v39 >= *((_DWORD *)v13 + 31))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)(v13 + 112), v13 + 128, v39 + 1, 16);
    LODWORD(v39) = *((_DWORD *)v13 + 30);
  }
  unint64_t v40 = (void *)(*((void *)v13 + 14) + 16 * v39);
  void *v40 = v37;
  v40[1] = v38;
  ++*((_DWORD *)v13 + 30);
  *(void *)&long long v49 = v13;
  *((void *)&v49 + 1) = v16;
  atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
  uint64_t v41 = *(void **)(a2 + 232);
  if ((unint64_t)v41 >= *(void *)(a2 + 240))
  {
    unint64_t v45 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v49);
    unint64_t v42 = (std::__shared_weak_count *)*((void *)&v49 + 1);
    *(void *)(a2 + 232) = v45;
    if (!v42) {
      goto LABEL_46;
    }
  }
  else
  {
    *uint64_t v41 = v13;
    v41[1] = v16;
    atomic_fetch_add_explicit(&v16->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v41 + 2;
    unint64_t v42 = v16;
  }
  if (!atomic_fetch_add(&v42->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v42->__on_zero_shared)(v42);
    std::__shared_weak_count::__release_weak(v42);
  }
LABEL_46:
  uint64_t v43 = 1;
  if (SHIBYTE(v50.__r_.__value_.__r.__words[2]) < 0) {
LABEL_39:
  }
    operator delete(v50.__r_.__value_.__l.__data_);
LABEL_40:
  if (!atomic_fetch_add(&v16->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
    std::__shared_weak_count::__release_weak(v16);
  }
  return v43;
}

void mlir::anec::ANECIRUnit::AddInput(uint64_t a1, uint64_t a2, int a3)
{
  if (*(char *)(a2 + 23) < 0) {
    std::string::__init_copy_ctor_external(&__p, *(const std::string::value_type **)a2, *(void *)(a2 + 8));
  }
  else {
    std::string __p = *(std::string *)a2;
  }
  int v15 = a3;
  uint64_t v5 = *(unsigned int *)(a1 + 72);
  unint64_t v6 = *(void *)(a1 + 64);
  p_p = &__p;
  if (v5 >= *(_DWORD *)(a1 + 76))
  {
    uint64_t v10 = (unint64_t *)(a1 + 64);
    unint64_t v11 = v5 + 1;
    BOOL v12 = v6 + 32 * v5 > (unint64_t)&__p;
    if (v6 <= (unint64_t)&__p && v12)
    {
      uint64_t v13 = (char *)&__p - v6;
      llvm::SmallVectorTemplateBase<std::pair<std::string,mlir::anec::ANECIRDataType>,false>::grow(a1 + 64, v11);
      unint64_t v6 = *v10;
      p_p = (std::string *)&v13[*v10];
    }
    else
    {
      llvm::SmallVectorTemplateBase<std::pair<std::string,mlir::anec::ANECIRDataType>,false>::grow(a1 + 64, v11);
      unint64_t v6 = *v10;
      p_p = &__p;
    }
  }
  uint64_t v8 = v6 + 32 * *(unsigned int *)(a1 + 72);
  long long v9 = *(_OWORD *)&p_p->__r_.__value_.__l.__data_;
  *(void *)(v8 + 16) = *((void *)&p_p->__r_.__value_.__l + 2);
  *(_OWORD *)uint64_t v8 = v9;
  p_p->__r_.__value_.__l.__size_ = 0;
  p_p->__r_.__value_.__r.__words[2] = 0;
  p_p->__r_.__value_.__r.__words[0] = 0;
  *(_DWORD *)(v8 + 24) = p_p[1].__r_.__value_.__l.__data_;
  ++*(_DWORD *)(a1 + 72);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0) {
    operator delete(__p.__r_.__value_.__l.__data_);
  }
}

uint64_t mlir::anec::GOC::getExecutionCost(uint64_t *a1, uint64_t a2)
{
  uint64_t v12 = *(void *)(*(void *)(*a1 + 72) + 24);
  uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)&v12);
  if (!result) {
    goto LABEL_6;
  }
  while (1)
  {
    uint64_t v5 = *(void **)(*(void *)(result + 48) + 16);
    if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::GOC,void>::id) {
      break;
    }
    v11[0] = *(void *)(*(void *)(result + 72) + 24);
    uint64_t result = mlir::Value::getDefiningOp((mlir::Value *)v11);
    if (!result) {
      goto LABEL_6;
    }
  }
  if (v5 != &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
  {
LABEL_6:
    v11[0] = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v12 + 8) & 0xFFFFFFFFFFFFFFF8));
    v11[1] = v6;
    uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v11);
    mlir::ShapedType::getNumElements(ArgAttrsAttr, v8);
    uint64_t v9 = *a1;
    uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v11);
  }
  return result;
}

uint64_t mlir::anec::GOC::fold(uint64_t a1, uint64_t a2)
{
  v19[3] = *MEMORY[0x1E4F143B8];
  unint64_t v4 = *(void *)(*(void *)(*(void *)(*(void *)a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_DWORD *)(*(void *)a1 + 36)) {
    uint64_t v5 = *(void *)a1 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  uint64_t result = 0;
  if (v4 == (*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8))
  {
    uint64_t v8 = *(void *)(*(void *)(a2 + 40) + 8);
    if (!mlir::DenseFPElementsAttr::classof(v8)) {
      uint64_t v8 = 0;
    }
    uint64_t v17 = v8;
    uint64_t v9 = *(void *)(*(void *)(a2 + 40) + 16);
    if (mlir::DenseFPElementsAttr::classof(v9)) {
      uint64_t v10 = v9;
    }
    else {
      uint64_t v10 = 0;
    }
    uint64_t v16 = v10;
    if (!v8 || !mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v17)) {
      return 0;
    }
    mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v17, (uint64_t)&v18);
    float v11 = llvm::APFloat::convertToFloat(&v18);
    uint64_t v12 = (void *)v19[0];
    uint64_t v14 = llvm::APFloatBase::PPCDoubleDouble(v13);
    if (v14 == v12) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
    }
    uint64_t result = 0;
    if (v11 == 1.0 && v10)
    {
      if (mlir::DenseElementsAttr::isSplat((mlir::DenseElementsAttr *)&v16))
      {
        mlir::DenseElementsAttr::getSplatValue<llvm::APFloat>((mlir::DenseElementsAttr *)&v16, (uint64_t)&v18);
        float v15 = llvm::APFloat::convertToFloat(&v18);
        if (v14 == (void *)v19[0]) {
          llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v19);
        }
        else {
          llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v19);
        }
        if (v15 == 0.0) {
          return *(void *)(*(void *)(*(void *)a1 + 72) + 24) | 4;
        }
      }
      return 0;
    }
  }
  return result;
}

BOOL mlir::anec::Softmax::mutateOpForReshapeSwap(mlir::Operation **a1, const void *a2, uint64_t a3)
{
  v92[5] = *MEMORY[0x1E4F143B8];
  uint64_t v6 = (uint64_t *)(*(void *)(*(void *)(*((void *)*a1 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  float v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    uint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  uint64_t v90 = v6;
  uint64_t v91 = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v90);
  unint64_t v18 = v17;
  uint64_t v90 = v92;
  uint64_t v91 = 0x500000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::getValues<long long>(MultipliersAttr, (uint64_t)&v90);
  uint64_t v20 = v91;
  if (v91)
  {
    uint64_t v21 = (char *)v90;
    unint64_t v22 = (v91 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    uint64_t v23 = (char *)v90;
    if (v22 < 3) {
      goto LABEL_16;
    }
    unint64_t v24 = v22 + 1;
    int64x2_t v25 = vdupq_n_s64(v18);
    uint64_t v23 = (char *)v90 + 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
    char v26 = (int64x2_t *)((char *)v90 + 16);
    int64x2_t v27 = vdupq_n_s64(5uLL);
    uint64_t v28 = v24 & 0x3FFFFFFFFFFFFFFCLL;
    do
    {
      int64x2_t v29 = vaddq_s64(vsubq_s64(*v26, v25), v27);
      v26[-1] = vaddq_s64(vsubq_s64(v26[-1], v25), v27);
      *char v26 = v29;
      v26 += 2;
      v28 -= 4;
    }
    while (v28);
    if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL))
    {
LABEL_16:
      uint64_t v30 = &v21[8 * v20];
      do
      {
        *(void *)uint64_t v23 = *(void *)v23 - v18 + 5;
        v23 += 8;
      }
      while (v23 != v30);
    }
  }
  uint64_t v31 = (uint64_t *)(*(void *)(*(void *)(*((void *)*a1 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v31) {
    goto LABEL_27;
  }
  uint64_t v32 = *v31;
  unint64_t v33 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v34 = *(unsigned int *)(v32 + 16);
  if (!v34) {
    goto LABEL_27;
  }
  uint64_t v35 = *(void **)(v32 + 8);
  uint64_t v36 = &v35[2 * v34];
  do
  {
    unint64_t v37 = v34 >> 1;
    uint64_t v38 = &v35[2 * (v34 >> 1)];
    unint64_t v40 = *v38;
    uint64_t v39 = v38 + 2;
    v34 += ~(v34 >> 1);
    if (v40 < v33) {
      uint64_t v35 = v39;
    }
    else {
      unint64_t v34 = v37;
    }
  }
  while (v34);
  if (v35 != v36 && *v35 == v33) {
    uint64_t v41 = v35[1];
  }
  else {
LABEL_27:
  }
    uint64_t v41 = 0;
  unint64_t v84 = v31;
  uint64_t v85 = v41;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v84);
  uint64_t v44 = v42;
  unint64_t v87 = v89;
  uint64_t v88 = 0x500000000;
  size_t v45 = 8 * v42;
  if ((unint64_t)(8 * v42) < 0x29)
  {
    unsigned int v46 = 0;
    if (!v42) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v89, (8 * v42) >> 3, 8);
  unsigned int v46 = v88;
  if (v44)
  {
LABEL_32:
    memcpy((char *)v87 + 8 * v46, ArgAttrsAttr, v45);
    unsigned int v46 = v88;
  }
LABEL_33:
  unsigned int v47 = v46 + (v45 >> 3);
  LODWORD(v88) = v47;
  if (v47 < 5) {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v87, (uint64_t)v87, 5 - v47, 1uLL);
  }
  unint64_t v84 = v86;
  uint64_t v85 = 0x500000000;
  if ((unint64_t)(8 * a3) < 0x29)
  {
    unsigned int v48 = 0;
    if (!a3) {
      goto LABEL_40;
    }
    goto LABEL_39;
  }
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v84, v86, (8 * a3) >> 3, 8);
  unsigned int v48 = v85;
  if (a3)
  {
LABEL_39:
    memcpy((char *)v84 + 8 * v48, a2, 8 * a3);
    unsigned int v48 = v85;
  }
LABEL_40:
  unsigned int v49 = v48 + a3;
  LODWORD(v85) = v49;
  if (v49 <= 4) {
    llvm::SmallVectorImpl<long long>::insert((uint64_t)&v84, (uint64_t)v84, 5 - v49, 1uLL);
  }
  if (!v91)
  {
    int8x8_t v51 = 0;
    int8x8_t v52 = (int8x8_t)4;
    goto LABEL_54;
  }
  unint64_t v50 = (v91 - 1) & 0x1FFFFFFFFFFFFFFFLL;
  if (v50 >= 3)
  {
    unint64_t v54 = v50 + 1;
    uint64_t v55 = (v50 + 1) & 0x3FFFFFFFFFFFFFFCLL;
    uint64_t v53 = (int8x8_t *)((char *)v90 + 8 * v55);
    __int16 v56 = (int64x2_t *)((char *)v90 + 16);
    int64x2_t v57 = vdupq_n_s64(4uLL);
    int64x2_t v58 = 0uLL;
    uint64_t v59 = v55;
    int64x2_t v60 = v57;
    int64x2_t v61 = 0uLL;
    do
    {
      int64x2_t v62 = v56[-1];
      int64x2_t v57 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v57, v62), (int8x16_t)v62, (int8x16_t)v57);
      int64x2_t v60 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v60, *v56), *(int8x16_t *)v56, (int8x16_t)v60);
      int64x2_t v58 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v58, v62), (int8x16_t)v58, (int8x16_t)v62);
      int64x2_t v61 = (int64x2_t)vbslq_s8((int8x16_t)vcgtq_s64(v61, *v56), (int8x16_t)v61, *(int8x16_t *)v56);
      v56 += 2;
      v59 -= 4;
    }
    while (v59);
    int8x16_t v63 = vbslq_s8((int8x16_t)vcgtq_s64(v58, v61), (int8x16_t)v58, (int8x16_t)v61);
    uint64_t v64 = vextq_s8(v63, v63, 8uLL).u64[0];
    int8x8_t v51 = vbsl_s8((int8x8_t)vcgtd_s64(v63.i64[0], v64), *(int8x8_t *)v63.i8, (int8x8_t)v64);
    int8x16_t v65 = vbslq_s8((int8x16_t)vcgtq_s64(v60, v57), (int8x16_t)v57, (int8x16_t)v60);
    uint64_t v66 = vextq_s8(v65, v65, 8uLL).u64[0];
    int8x8_t v52 = vbsl_s8((int8x8_t)vcgtd_s64(v66, v65.i64[0]), *(int8x8_t *)v65.i8, (int8x8_t)v66);
    if (v54 == v55) {
      goto LABEL_54;
    }
  }
  else
  {
    int8x8_t v51 = 0;
    int8x8_t v52 = (int8x8_t)4;
    uint64_t v53 = (int8x8_t *)v90;
  }
  do
  {
    int8x8_t v68 = *v53++;
    int8x8_t v67 = v68;
    if (*(void *)&v68 < *(void *)&v52) {
      int8x8_t v52 = v67;
    }
    if (*(void *)&v51 <= *(void *)&v67) {
      int8x8_t v51 = v67;
    }
  }
  while (v53 != (int8x8_t *)((char *)v90 + 8 * v91));
LABEL_54:
  memset_pattern16(&v80, &unk_1810FE350, 0x20uLL);
  uint64_t v69 = v87;
  uint64_t v70 = v80;
  if (v88 && v85)
  {
    unint64_t v71 = 0;
    uint64_t v72 = v82;
    uint64_t v73 = v83;
    uint64_t v74 = v81;
    uint64_t v75 = 8 * v85 - 8;
    uint64_t v76 = 8 * v88 - 8;
    do
    {
      if (v71 >= *(void *)&v52)
      {
        if (v71 > *(void *)&v51)
        {
          v72 *= *((void *)v87 + v71);
          uint64_t v82 = v72;
          v73 *= *((void *)v84 + v71);
          uint64_t v83 = v73;
        }
      }
      else
      {
        v70 *= *((void *)v87 + v71);
        uint64_t v80 = v70;
        v74 *= *((void *)v84 + v71);
        uint64_t v81 = v74;
      }
      if (!v76) {
        break;
      }
      ++v71;
      uint64_t v77 = v75;
      v75 -= 8;
      v76 -= 8;
    }
    while (v77);
  }
  else
  {
    uint64_t v74 = v81;
    uint64_t v72 = v82;
    uint64_t v73 = v83;
  }
  if (v84 != v86)
  {
    free(v84);
    uint64_t v69 = v87;
  }
  if (v69 != v89) {
    free(v69);
  }
  if (v90 != v92) {
    free(v90);
  }
  return v70 == v74 && v72 == v73;
}

void mlir::getValues<long long>(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v14, a1, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v17);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v11, a1, NumElements);
  while (1)
  {
    BOOL v5 = v14 == v11 && v15 == v12;
    if (v5 && v16 == v13) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v14, (llvm::APInt *)&__p);
    unsigned int v6 = v10;
    if (v10 > 0x40) {
      uint64_t v7 = *(void *)__p;
    }
    else {
      uint64_t v7 = (uint64_t)((void)__p << -(char)v10) >> -(char)v10;
    }
    uint64_t v8 = *(unsigned int *)(a2 + 8);
    if (v8 >= *(_DWORD *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v8 + 1, 8);
      *(void *)(*(void *)a2 + 8 * *(unsigned int *)(a2 + 8)) = v7;
      LODWORD(v8) = *(_DWORD *)(a2 + 8);
      unsigned int v6 = v10;
    }
    else
    {
      *(void *)(*(void *)a2 + 8 * v8) = v7;
    }
    *(_DWORD *)(a2 + 8) = v8 + 1;
    if (v6 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v16;
  }
}

uint64_t mlir::anec::Softmax::getZinIrUnitInfo@<X0>(mlir::anec::Softmax *this@<X0>, void *a2@<X8>)
{
  unint64_t v4 = (char *)operator new(0x80uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *((_OWORD *)v4 + 5) = 0u;
  *(void *)unint64_t v4 = &unk_1EC995BB0;
  *((void *)v4 + 1) = 0;
  *((_OWORD *)v4 + 6) = 0u;
  *((_DWORD *)v4 + 28) = 1065353216;
  v4[120] = 0;
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v5 = *(void *)this - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  unsigned int v6 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_13;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_13;
  }
  unsigned int v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    uint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      unsigned int v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_13:
  }
    uint64_t v16 = 0;
  v36[0] = v6;
  v36[1] = v16;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr((mlir::Operation **)this);
  uint64_t v35 = MultipliersAttr;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v32, MultipliersAttr, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v35);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v29, MultipliersAttr, NumElements);
  while (1)
  {
    BOOL v19 = v32 == v29 && v33 == v30;
    if (v19 && v34 == v31) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v32, (llvm::APInt *)&__p);
    if (v28 >= 0x41) {
      p_p = (mlir::anec **)__p;
    }
    else {
      p_p = (mlir::anec **)&__p;
    }
    uint64_t v21 = *p_p;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v36);
    uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v21, v22);
    if ((DimFromIndex & 0xFF00000000) != 0) {
      int v24 = dword_1810FE490[(int)DimFromIndex];
    }
    else {
      int v24 = 5;
    }
    int v26 = v24;
    std::__hash_table<ZinIrDimension,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,std::allocator<ZinIrDimension>>::__emplace_unique_key_args<ZinIrDimension,ZinIrDimension>((uint64_t)(v4 + 80), &v26, &v26);
    if (v28 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v34;
  }
  uint64_t result = mlir::anec::Concat::getInterleaveAttr((mlir::Operation **)this);
  v4[120] = result != 0;
  *a2 = v4;
  return result;
}

BOOL mlir::anec::Softmax::getSubtractMax(mlir::Operation **this)
{
  return mlir::anec::Concat::getInterleaveAttr(this) != 0;
}

uint64_t mlir::anec::Softmax::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  ANECSoftmaxLayerDescInitialize();
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  v33[0] = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&MultipliersAttr);
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  unint64_t v7 = v6;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(buffer, MultipliersAttr, 0);
  uint64_t v8 = MultipliersAttr;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&MultipliersAttr);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v34, v8, NumElements);
  for (uint64_t i = 1; ; ++i)
  {
    BOOL v11 = *(void *)buffer == v34 && v46[0] == v35;
    if (v11 && v47 == v36) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&__p);
    int v12 = v43;
    if (v43 >= 0x41)
    {
      if (v12 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40) {
        uint64_t v13 = *(void *)__p;
      }
      else {
        uint64_t v13 = -1;
      }
    }
    else
    {
      uint64_t v13 = (uint64_t)__p;
    }
    if (v43 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v47;
  }
  std::string __p = v44;
  uint64_t v43 = 0x100000000;
  *(void *)buffer = 1;
  uint64_t v34 = 0;
  ANECUnitValidatorCreate();
  uint64_t v30 = 0;
  uint64_t v31 = 0;
  if (ANECValidateSoftmaxLayer())
  {
    uint64_t v24 = MEMORY[0x1E4FBA488] + 24;
    int64x2_t v25 = *a1;
    uint64_t v14 = MEMORY[0x1E4FBA488] + 104;
    v41[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v15 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v36 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v16 = (uint64_t *)MEMORY[0x1E4FBA408];
    uint64_t v17 = *(void *)(MEMORY[0x1E4FBA408] + 24);
    uint64_t v34 = *(void *)(MEMORY[0x1E4FBA408] + 16);
    *(uint64_t *)((char *)&v34 + *(void *)(v34 - 24)) = v17;
    uint64_t v35 = 0;
    unint64_t v18 = (std::ios_base *)((char *)&v34 + *(void *)(v34 - 24));
    std::ios_base::init(v18, v37);
    v18[1].__vftable = 0;
    v18[1].__fmtflags_ = -1;
    uint64_t v19 = v16[5];
    uint64_t v36 = v16[4];
    *(uint64_t *)((char *)&v37[-1] + *(void *)(v36 - 24)) = v19;
    uint64_t v34 = v16[1];
    *(uint64_t *)((char *)&v34 + *(void *)(v34 - 24)) = v16[6];
    v41[0] = v14;
    uint64_t v34 = v24;
    uint64_t v36 = v15;
    std::streambuf::basic_streambuf();
    uint64_t v20 = MEMORY[0x1E4FBA470] + 16;
    v37[0] = MEMORY[0x1E4FBA470] + 16;
    long long v38 = 0u;
    long long v39 = 0u;
    int v40 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    uint64_t v34 = *v16;
    uint64_t v21 = v16[9];
    *(uint64_t *)((char *)&v34 + *(void *)(v34 - 24)) = v16[8];
    uint64_t v36 = v21;
    v37[0] = v20;
    if (SBYTE7(v39) < 0) {
      operator delete((void *)v38);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v41);
    __int16 v29 = 260;
    unsigned int v28 = &v26;
    uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v46);
    if (v27 < 0) {
      operator delete(v26);
    }
  }
  else
  {
    uint64_t v22 = 1;
  }
  ANECUnitValidatorDelete();
  if (__p != v44) {
    free(__p);
  }
  return v22;
}

uint64_t mlir::anec::anonymous namespace'::getANECDimension(mlir::anec::_anonymous_namespace_ *this, unint64_t a2)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t DimFromIndex = mlir::anec::getDimFromIndex(this, a2);
  if ((DimFromIndex & 0xFF00000000) != 0) {
    int v3 = dword_1810FE490[(int)DimFromIndex];
  }
  else {
    int v3 = 5;
  }
  {
    void v11[2] = xmmword_1E4FBEFC0;
    v11[3] = unk_1E4FBEFD0;
    v11[4] = xmmword_1E4FBEFE0;
    v11[5] = unk_1E4FBEFF0;
    v11[0] = xmmword_1E4FBEFA0;
    v11[1] = unk_1E4FBEFB0;
  }
  uint64_t v4 = qword_1E8EBEFF0;
  if (qword_1E8EBEFF0)
  {
    while (1)
    {
      while (1)
      {
        unint64_t v6 = (uint64_t *)v4;
        int v7 = *(_DWORD *)(v4 + 32);
        if (v3 >= v7) {
          break;
        }
        uint64_t v4 = *v6;
        uint64_t v5 = v6;
        if (!*v6) {
          goto LABEL_12;
        }
      }
      if (v7 >= v3) {
        break;
      }
      uint64_t v4 = v6[1];
      if (!v4)
      {
        uint64_t v5 = v6 + 1;
        goto LABEL_12;
      }
    }
  }
  else
  {
    uint64_t v5 = &qword_1E8EBEFF0;
    unint64_t v6 = &qword_1E8EBEFF0;
LABEL_12:
    uint64_t v8 = v6;
    unint64_t v6 = (uint64_t *)operator new(0x30uLL);
    *((_DWORD *)v6 + 8) = v3;
    v6[5] = 0;
    uint64_t *v6 = 0;
    v6[1] = 0;
    v6[2] = (uint64_t)v8;
    uint64_t *v5 = (uint64_t)v6;
    unint64_t v9 = v6;
    {
      unint64_t v9 = (uint64_t *)*v5;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>((uint64_t *)qword_1E8EBEFF0, v9);
    ++qword_1E8EBEFF8;
  }
  return v6[5];
}

uint64_t mlir::anec::Softmax::addOpToNetwork(mlir::anec::Softmax *a1, uint64_t a2)
{
  mlir::anec::Softmax::getZinIrUnitInfo(a1, &v11);
  int v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  int v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    int v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *int v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::spaceTransformInferReturnTypesCommon(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, int a7, uint64_t a8)
{
  v55[22] = *MEMORY[0x1E4F143B8];
  v50[0] = a3;
  v50[1] = a4;
  if (a3)
  {
    uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
    unint64_t v12 = v11;
    uint64_t v53 = v55;
    uint64_t v54 = 0x500000000;
    unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v11);
    unint64_t v14 = mlir::anec::getIndexFromDim(1, v12);
    unint64_t v15 = mlir::anec::getIndexFromDim(3, v12);
    unint64_t v16 = mlir::anec::getIndexFromDim(4, v12);
    uint64_t v17 = *(void *)(ArgAttrsAttr + 8 * IndexFromDim);
    uint64_t v18 = *(void *)(ArgAttrsAttr + 8 * v14);
    uint64_t v19 = *(void *)(ArgAttrsAttr + 8 * v15);
    uint64_t v20 = *(void *)(ArgAttrsAttr + 8 * v16);
    v51[0] = v52;
    v51[1] = (void *)0x300000000;
    mlir::getValues<unsigned long long>(a5, (uint64_t)v51);
    uint64_t v21 = *(void *)v51[0];
    uint64_t v22 = *((void *)v51[0] + 1);
    if (*(uint64_t *)v51[0] <= 1) {
      uint64_t v21 = 1;
    }
    if (v22 <= 1) {
      uint64_t v22 = 1;
    }
    if (*((uint64_t *)v51[0] + 2) <= 1) {
      uint64_t v23 = 1;
    }
    else {
      uint64_t v23 = *((void *)v51[0] + 2);
    }
    uint64_t v24 = v22 * v21 * v23;
    if (a7)
    {
      uint64_t v25 = v19 / v22;
      uint64_t v26 = v24 * v18;
      uint64_t v27 = v24 * v17;
      BOOL v28 = (a6 & 1) == 0;
      if (a6) {
        uint64_t v29 = v26;
      }
      else {
        uint64_t v29 = v18;
      }
      if (v28) {
        uint64_t v17 = v27;
      }
      uint64_t v30 = v20 / v21;
    }
    else
    {
      uint64_t v25 = v22 * v19;
      uint64_t v30 = v21 * v20;
      BOOL v32 = (a6 & 1) == 0;
      if (a6) {
        uint64_t v29 = v18 / v24;
      }
      else {
        uint64_t v29 = v18;
      }
      if (v32) {
        v17 /= v24;
      }
    }
    unsigned int v33 = v54;
    if (v54 >= HIDWORD(v54))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v55, v54 + 1, 8);
      unsigned int v33 = v54;
    }
    *((void *)v53 + v33) = v17;
    unsigned int v34 = v54 + 1;
    LODWORD(v54) = v54 + 1;
    if (v12 == 5)
    {
      unint64_t v35 = mlir::anec::getIndexFromDim(2, 5uLL);
      if (!v36)
      {
        uint64_t v31 = 0;
LABEL_50:
        if (v51[0] != v52) {
          free(v51[0]);
        }
        if (v53 != v55) {
          free(v53);
        }
        return v31;
      }
      uint64_t v37 = *(void *)(ArgAttrsAttr + 8 * v35);
      if (a7) {
        uint64_t v38 = v37 / v23;
      }
      else {
        uint64_t v38 = v37 * v23;
      }
      unsigned int v39 = v54;
      if (v54 >= HIDWORD(v54))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v55, v54 + 1, 8);
        unsigned int v39 = v54;
      }
      *((void *)v53 + v39) = v38;
      unsigned int v34 = v54 + 1;
      LODWORD(v54) = v54 + 1;
    }
    if (v34 >= HIDWORD(v54))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v55, v34 + 1, 8);
      unsigned int v34 = v54;
    }
    *((void *)v53 + v34) = v29;
    uint64_t v40 = (v54 + 1);
    LODWORD(v54) = v40;
    if (v40 >= HIDWORD(v54))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v55, v40 + 1, 8);
      LODWORD(v40) = v54;
    }
    *((void *)v53 + v40) = v25;
    uint64_t v41 = (v54 + 1);
    LODWORD(v54) = v41;
    if (v41 >= HIDWORD(v54))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v53, v55, v41 + 1, 8);
      LODWORD(v41) = v54;
    }
    *((void *)v53 + v41) = v30;
    LODWORD(v54) = v54 + 1;
    uint64_t v42 = (mlir::AffineMap *)v54;
    uint64_t v43 = v53;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v50);
    uint64_t v45 = mlir::MemRefType::get(v43, v42, OperandRange, 0, 0, 0);
    uint64_t v46 = *(unsigned int *)(a8 + 8);
    if (v46 >= *(_DWORD *)(a8 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a8, (void *)(a8 + 16), v46 + 1, 8);
      LODWORD(v46) = *(_DWORD *)(a8 + 8);
    }
    *(void *)(*(void *)a8 + 8 * v46) = v45;
    ++*(_DWORD *)(a8 + 8);
    uint64_t v31 = 1;
    goto LABEL_50;
  }
  if (!a2) {
    return 0;
  }
  mlir::emitError(a1, (uint64_t)&v53);
  if (v53) {
    mlir::Diagnostic::operator<<((uint64_t)&v54, "Expected a ShapedType for my input!");
  }
  uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v54);
  return v31;
}

void mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrChannelToSpaceUnitInfo,mlir::anec::ChannelToSpace>(mlir::Operation *a1@<X0>, int32x2_t **a2@<X8>)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  unint64_t v11 = a1;
  uint64_t v4 = (int32x2_t *)operator new(0x60uLL);
  *(_OWORD *)v4[8].i8 = 0u;
  *(_OWORD *)v4[10].i8 = 0u;
  *(_OWORD *)v4[4].i8 = 0u;
  *(_OWORD *)v4[6].i8 = 0u;
  *(_OWORD *)v4->i8 = 0u;
  *(_OWORD *)v4[2].i8 = 0u;
  v4[9] = (int32x2_t)-1;
  int32x2_t *v4 = (int32x2_t)&unk_1EC996020;
  v4[10] = (int32x2_t)0x100000001;
  v4[11].i32[0] = 1;
  uint64_t v5 = *(void **)(*((void *)a1 + 6) + 16);
  if (a1 && v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id)
  {
    int v6 = 36;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id)
  {
    int v6 = 37;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id)
  {
    int v6 = 31;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id)
  {
    int v6 = 32;
  }
  else
  {
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
      int v7 = 35;
    }
    else {
      int v7 = 0;
    }
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
      int v6 = 34;
    }
    else {
      int v6 = v7;
    }
  }
  v12[0] = v13;
  v12[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(&v11);
  mlir::getValues<unsigned long long>(MultipliersAttr, (uint64_t)v12);
  uint64_t v9 = v12[0];
  uint64_t v10 = *((void *)v12[0] + 2);
  v4[10] = vmovn_s64(*(int64x2_t *)v12[0]);
  v4[11].i32[0] = v10;
  v4[9] = 0;
  *a2 = v4;
  if (v9 != v13) {
    free(v9);
  }
}

uint64_t mlir::anec::ChannelToSpace::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = (uint64_t)v19;
  if (!v19) {
    goto LABEL_10;
  }
  uint64_t v22 = *v19;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_10;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    BOOL v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    uint64_t v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_10:
  }
    uint64_t v31 = 0;
  uint64_t v41 = a6;
  LOBYTE(v42) = 0;
  char v43 = 0;
  uint64_t v44 = a7;
  uint64_t v45 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v41);
    if (v43) {
      char v43 = 0;
    }
    mlir::OperationName::OperationName(&v42, "anec.channel_to_space", 21, Context);
    char v43 = 1;
  }
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v33 = mlir::UnknownLoc::get(a1, v20);
  if (a3) {
    uint64_t v34 = a2;
  }
  else {
    uint64_t v34 = v33;
  }
  if (!mlir::anec::ChannelToSpaceAdaptor::verify(&v41, v34)) {
    return 0;
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v41);
  char v36 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v41);
  uint64_t v37 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v36, **(void **)(v42 + 96));
  if (v38) {
    uint64_t v39 = *((void *)v37 + 1);
  }
  else {
    uint64_t v39 = 0;
  }
  return mlir::anec::spaceTransformInferReturnTypesCommon(a2, a3, v21, v31, v39, 1, 0, a11);
}

uint64_t mlir::anec::ChannelToSpaceAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v42[23] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v39); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v39))
    {
      uint64_t v5 = "'anec.channel_to_space' op requires attribute 'factors'";
      goto LABEL_32;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  int v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = *(void **)(v7 + 8);
    unint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      unint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        uint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v37[0] = v6;
    v37[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v37);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    unint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v41 = v18;
    v42[0] = v28;
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
    uint64_t v40 = 3;
    if (v30 == 1 && *ArgAttrsAttr == v40)
    {
      uint64_t v34 = v6;
      v35[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v34);
      v35[1] = v31;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v35);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
        return 1;
      }
    }
  }
  uint64_t v5 = "'anec.channel_to_space' op attribute 'factors' failed to satisfy constraint: ui64 elements attribute of shape {3}";
LABEL_32:
  v37[0] = v5;
  __int16 v38 = 259;
  mlir::emitError(a2, (uint64_t)v37, (uint64_t)&v41);
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v32;
}

uint64_t mlir::anec::ChannelToSpace::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v39[63] = *MEMORY[0x1E4F143B8];
  ANECChannelToSpaceLayerDescInitialize();
  v36[0] = v37;
  v36[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::getValues<long long>(MultipliersAttr, (uint64_t)v36);
  uint64_t v7 = *((void *)v36[0] + 2);
  long long v24 = *(_OWORD *)v36[0];
  uint64_t v25 = v7;
  v34[0] = v35;
  v34[1] = (void *)0x100000000;
  uint64_t v8 = 1;
  *(void *)buffer = 1;
  v26[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (ANECValidateChannelToSpaceLayer())
  {
    uint64_t v18 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v19 = *a1;
    uint64_t v9 = MEMORY[0x1E4FBA488] + 104;
    v33[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v10 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v27 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v11 = MEMORY[0x1E4FBA408];
    unint64_t v12 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v26[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = v12;
    v26[1] = 0;
    uint64_t v13 = (std::ios_base *)((char *)v26 + (unint64_t)*(v26[0] - 3));
    std::ios_base::init(v13, &v28);
    v13[1].__vftable = 0;
    v13[1].__fmtflags_ = -1;
    uint64_t v14 = *(void *)(v11 + 40);
    uint64_t v27 = *(void *)(v11 + 32);
    *(uint64_t *)((char *)&v27 + *(void *)(v27 - 24)) = v14;
    v26[0] = *(const void ***)(v11 + 8);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = *(const void ***)(v11 + 48);
    v33[0] = v9;
    v26[0] = v18;
    uint64_t v27 = v10;
    std::streambuf::basic_streambuf();
    uint64_t v15 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v28 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v31 = 0u;
    int v32 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v26[0] = *(const void ***)v11;
    uint64_t v16 = *(void *)(v11 + 72);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = *(const void ***)(v11 + 64);
    uint64_t v27 = v16;
    uint64_t v28 = v15;
    if (SBYTE7(v31) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v33);
    __int16 v29 = 260;
    v26[0] = (const void **)&v20;
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v39);
    if (v21 < 0) {
      operator delete(v20);
    }
  }
  ANECUnitValidatorDelete();
  if (v34[0] != v35) {
    free(v34[0]);
  }
  if (v36[0] != v37) {
    free(v36[0]);
  }
  return v8;
}

uint64_t mlir::anec::ChannelToSpace::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrChannelToSpaceUnitInfo,mlir::anec::ChannelToSpace>(*a1, &v11);
  int v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (v4[3].i8[7] < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)&v4[1], *(void *)&v4[2]);
  }
  else
  {
    long long v6 = *(_OWORD *)v4[1].i8;
    v3[2].__vftable = (std::__shared_weak_count_vtbl *)v4[3];
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = (uint64_t)v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    int v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_9;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_9:
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  if (v9) {
    (*(void (**)(int32x2_t *))(*(void *)v9 + 8))(v9);
  }
  return 1;
}

void mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrPixelShuffleUnitInfo,mlir::anec::PixelShuffle>(mlir::Operation *a1@<X0>, void *a2@<X8>)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a1;
  uint64_t v4 = (char *)operator new(0x60uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995F30;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 10) = 0x100000001;
  *((_DWORD *)v4 + 22) = 1;
  *((_DWORD *)v4 + 8) = 31;
  uint64_t v5 = *(void **)(*((void *)a1 + 6) + 16);
  if (a1 && v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id)
  {
    int v6 = 36;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id)
  {
    int v6 = 37;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id)
  {
    int v6 = 31;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id)
  {
    int v6 = 32;
  }
  else
  {
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
      int v7 = 35;
    }
    else {
      int v7 = 0;
    }
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
      int v6 = 34;
    }
    else {
      int v6 = v7;
    }
  }
  v12[0] = v13;
  v12[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(&v11);
  mlir::getValues<unsigned long long>(MultipliersAttr, (uint64_t)v12);
  uint64_t v9 = v12[0];
  uint64_t v10 = *((void *)v12[0] + 2);
  *((int32x2_t *)v4 + 10) = vmovn_s64(*(int64x2_t *)v12[0]);
  *((_DWORD *)v4 + 22) = v10;
  *((void *)v4 + 9) = 0;
  *a2 = v4;
  if (v9 != v13) {
    free(v9);
  }
}

uint64_t mlir::anec::PixelShuffle::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = (uint64_t)v19;
  if (!v19) {
    goto LABEL_10;
  }
  uint64_t v22 = *v19;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_10;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    uint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    __int16 v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_10:
  }
    uint64_t v31 = 0;
  uint64_t v41 = a6;
  LOBYTE(v42) = 0;
  char v43 = 0;
  uint64_t v44 = a7;
  uint64_t v45 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v41);
    if (v43) {
      char v43 = 0;
    }
    mlir::OperationName::OperationName(&v42, "anec.pixel_shuffle", 18, Context);
    char v43 = 1;
  }
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v33 = mlir::UnknownLoc::get(a1, v20);
  if (a3) {
    uint64_t v34 = a2;
  }
  else {
    uint64_t v34 = v33;
  }
  if (!mlir::anec::PixelShuffleAdaptor::verify(&v41, v34)) {
    return 0;
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v41);
  char v36 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v41);
  uint64_t v37 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v36, **(void **)(v42 + 96));
  if (v38) {
    uint64_t v39 = *((void *)v37 + 1);
  }
  else {
    uint64_t v39 = 0;
  }
  return mlir::anec::spaceTransformInferReturnTypesCommon(a2, a3, v21, v31, v39, 1, 0, a11);
}

uint64_t mlir::anec::PixelShuffleAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v42[23] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v39); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v39))
    {
      uint64_t v5 = "'anec.pixel_shuffle' op requires attribute 'factors'";
      goto LABEL_32;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  int v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        uint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v37[0] = v6;
    v37[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v37);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    unint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v41 = v18;
    v42[0] = v28;
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
    uint64_t v40 = 3;
    if (v30 == 1 && *ArgAttrsAttr == v40)
    {
      uint64_t v34 = v6;
      v35[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v34);
      v35[1] = v31;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v35);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
        return 1;
      }
    }
  }
  uint64_t v5 = "'anec.pixel_shuffle' op attribute 'factors' failed to satisfy constraint: ui64 elements attribute of shape {3}";
LABEL_32:
  v37[0] = v5;
  __int16 v38 = 259;
  mlir::emitError(a2, (uint64_t)v37, (uint64_t)&v41);
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v32;
}

uint64_t mlir::anec::PixelShuffle::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v39[63] = *MEMORY[0x1E4F143B8];
  ANECPixelShuffleLayerDescInitialize();
  v36[0] = v37;
  v36[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::getValues<long long>(MultipliersAttr, (uint64_t)v36);
  uint64_t v7 = *((void *)v36[0] + 2);
  long long v24 = *(_OWORD *)v36[0];
  uint64_t v25 = v7;
  v34[0] = v35;
  v34[1] = (void *)0x100000000;
  uint64_t v8 = 1;
  *(void *)buffer = 1;
  v26[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (ANECValidatePixelShuffleLayer())
  {
    uint64_t v18 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v19 = *a1;
    uint64_t v9 = MEMORY[0x1E4FBA488] + 104;
    v33[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v10 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v27 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v11 = MEMORY[0x1E4FBA408];
    unint64_t v12 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v26[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = v12;
    v26[1] = 0;
    uint64_t v13 = (std::ios_base *)((char *)v26 + (unint64_t)*(v26[0] - 3));
    std::ios_base::init(v13, &v28);
    v13[1].__vftable = 0;
    v13[1].__fmtflags_ = -1;
    uint64_t v14 = *(void *)(v11 + 40);
    uint64_t v27 = *(void *)(v11 + 32);
    *(uint64_t *)((char *)&v27 + *(void *)(v27 - 24)) = v14;
    v26[0] = *(const void ***)(v11 + 8);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = *(const void ***)(v11 + 48);
    v33[0] = v9;
    v26[0] = v18;
    uint64_t v27 = v10;
    std::streambuf::basic_streambuf();
    uint64_t v15 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v28 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v31 = 0u;
    int v32 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v26[0] = *(const void ***)v11;
    uint64_t v16 = *(void *)(v11 + 72);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = *(const void ***)(v11 + 64);
    uint64_t v27 = v16;
    uint64_t v28 = v15;
    if (SBYTE7(v31) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v33);
    __int16 v29 = 260;
    v26[0] = (const void **)&v20;
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v39);
    if (v21 < 0) {
      operator delete(v20);
    }
  }
  ANECUnitValidatorDelete();
  if (v34[0] != v35) {
    free(v34[0]);
  }
  if (v36[0] != v37) {
    free(v36[0]);
  }
  return v8;
}

uint64_t mlir::anec::PixelShuffle::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrPixelShuffleUnitInfo,mlir::anec::PixelShuffle>(*a1, &v11);
  int v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    int v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_9;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_9:
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  return 1;
}

void mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrPixelUnshuffleUnitInfo,mlir::anec::PixelUnshuffle>(mlir::Operation *a1@<X0>, int32x2_t **a2@<X8>)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a1;
  uint64_t v4 = (int32x2_t *)operator new(0x60uLL);
  *(_OWORD *)v4[8].i8 = 0u;
  *(_OWORD *)v4[10].i8 = 0u;
  *(_OWORD *)v4[4].i8 = 0u;
  *(_OWORD *)v4[6].i8 = 0u;
  *(_OWORD *)v4->i8 = 0u;
  *(_OWORD *)v4[2].i8 = 0u;
  v4[9] = (int32x2_t)-1;
  int32x2_t *v4 = (int32x2_t)&unk_1EC996040;
  v4[10] = (int32x2_t)0x100000001;
  v4[11].i32[0] = 1;
  uint64_t v5 = *(void **)(*((void *)a1 + 6) + 16);
  if (a1 && v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id)
  {
    int v6 = 36;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id)
  {
    int v6 = 37;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id)
  {
    int v6 = 31;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id)
  {
    int v6 = 32;
  }
  else
  {
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
      int v7 = 35;
    }
    else {
      int v7 = 0;
    }
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
      int v6 = 34;
    }
    else {
      int v6 = v7;
    }
  }
  v12[0] = v13;
  v12[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(&v11);
  mlir::getValues<unsigned long long>(MultipliersAttr, (uint64_t)v12);
  uint64_t v9 = v12[0];
  uint64_t v10 = *((void *)v12[0] + 2);
  v4[10] = vmovn_s64(*(int64x2_t *)v12[0]);
  v4[11].i32[0] = v10;
  v4[9] = 0;
  *a2 = v4;
  if (v9 != v13) {
    free(v9);
  }
}

uint64_t mlir::anec::PixelUnshuffle::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = (uint64_t)v19;
  if (!v19) {
    goto LABEL_10;
  }
  uint64_t v22 = *v19;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_10;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    uint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    __int16 v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_10:
  }
    uint64_t v31 = 0;
  uint64_t v41 = a6;
  LOBYTE(v42) = 0;
  char v43 = 0;
  uint64_t v44 = a7;
  uint64_t v45 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v41);
    if (v43) {
      char v43 = 0;
    }
    mlir::OperationName::OperationName(&v42, "anec.pixel_unshuffle", 20, Context);
    char v43 = 1;
  }
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v33 = mlir::UnknownLoc::get(a1, v20);
  if (a3) {
    uint64_t v34 = a2;
  }
  else {
    uint64_t v34 = v33;
  }
  if (!mlir::anec::PixelUnshuffleAdaptor::verify(&v41, v34)) {
    return 0;
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v41);
  char v36 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v41);
  uint64_t v37 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v36, **(void **)(v42 + 96));
  if (v38) {
    uint64_t v39 = *((void *)v37 + 1);
  }
  else {
    uint64_t v39 = 0;
  }
  return mlir::anec::spaceTransformInferReturnTypesCommon(a2, a3, v21, v31, v39, 1, 1, a11);
}

uint64_t mlir::anec::PixelUnshuffleAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v42[23] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v39); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v39))
    {
      uint64_t v5 = "'anec.pixel_unshuffle' op requires attribute 'factors'";
      goto LABEL_32;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  int v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        uint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v37[0] = v6;
    v37[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v37);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    unint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v41 = v18;
    v42[0] = v28;
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
    uint64_t v40 = 3;
    if (v30 == 1 && *ArgAttrsAttr == v40)
    {
      uint64_t v34 = v6;
      v35[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v34);
      v35[1] = v31;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v35);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
        return 1;
      }
    }
  }
  uint64_t v5 = "'anec.pixel_unshuffle' op attribute 'factors' failed to satisfy constraint: ui64 elements attribute of shape {3}";
LABEL_32:
  v37[0] = v5;
  __int16 v38 = 259;
  mlir::emitError(a2, (uint64_t)v37, (uint64_t)&v41);
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v32;
}

uint64_t mlir::anec::PixelUnshuffle::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v39[63] = *MEMORY[0x1E4F143B8];
  ANECPixelUnshuffleLayerDescInitialize();
  v36[0] = v37;
  v36[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::getValues<long long>(MultipliersAttr, (uint64_t)v36);
  uint64_t v7 = *((void *)v36[0] + 2);
  long long v24 = *(_OWORD *)v36[0];
  uint64_t v25 = v7;
  v34[0] = v35;
  v34[1] = (void *)0x100000000;
  uint64_t v8 = 1;
  *(void *)buffer = 1;
  v26[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v22 = 0;
  uint64_t v23 = 0;
  if (ANECValidatePixelUnshuffleLayer())
  {
    uint64_t v18 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v19 = *a1;
    uint64_t v9 = MEMORY[0x1E4FBA488] + 104;
    v33[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v10 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v27 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v11 = MEMORY[0x1E4FBA408];
    unint64_t v12 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v26[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = v12;
    v26[1] = 0;
    uint64_t v13 = (std::ios_base *)((char *)v26 + (unint64_t)*(v26[0] - 3));
    std::ios_base::init(v13, &v28);
    v13[1].__vftable = 0;
    v13[1].__fmtflags_ = -1;
    uint64_t v14 = *(void *)(v11 + 40);
    uint64_t v27 = *(void *)(v11 + 32);
    *(uint64_t *)((char *)&v27 + *(void *)(v27 - 24)) = v14;
    v26[0] = *(const void ***)(v11 + 8);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = *(const void ***)(v11 + 48);
    v33[0] = v9;
    v26[0] = v18;
    uint64_t v27 = v10;
    std::streambuf::basic_streambuf();
    uint64_t v15 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v28 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v31 = 0u;
    int v32 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v27, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v26[0] = *(const void ***)v11;
    uint64_t v16 = *(void *)(v11 + 72);
    *(const void ***)((char *)v26 + (unint64_t)*(v26[0] - 3)) = *(const void ***)(v11 + 64);
    uint64_t v27 = v16;
    uint64_t v28 = v15;
    if (SBYTE7(v31) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v33);
    __int16 v29 = 260;
    v26[0] = (const void **)&v20;
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v39);
    if (v21 < 0) {
      operator delete(v20);
    }
  }
  ANECUnitValidatorDelete();
  if (v34[0] != v35) {
    free(v34[0]);
  }
  if (v36[0] != v37) {
    free(v36[0]);
  }
  return v8;
}

uint64_t mlir::anec::PixelUnshuffle::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrPixelUnshuffleUnitInfo,mlir::anec::PixelUnshuffle>(*a1, &v11);
  int v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (v4[3].i8[7] < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)&v4[1], *(void *)&v4[2]);
  }
  else
  {
    long long v6 = *(_OWORD *)v4[1].i8;
    v3[2].__vftable = (std::__shared_weak_count_vtbl *)v4[3];
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = (uint64_t)v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    int v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_9;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_9:
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  if (v9) {
    (*(void (**)(int32x2_t *))(*(void *)v9 + 8))(v9);
  }
  return 1;
}

void mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrSpaceToChannelUnitInfo,mlir::anec::SpaceToChannel>(mlir::Operation *a1@<X0>, int32x2_t **a2@<X8>)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a1;
  uint64_t v4 = (int32x2_t *)operator new(0x60uLL);
  *(_OWORD *)v4[8].i8 = 0u;
  *(_OWORD *)v4[10].i8 = 0u;
  *(_OWORD *)v4[4].i8 = 0u;
  *(_OWORD *)v4[6].i8 = 0u;
  *(_OWORD *)v4->i8 = 0u;
  *(_OWORD *)v4[2].i8 = 0u;
  v4[9] = (int32x2_t)-1;
  int32x2_t *v4 = (int32x2_t)&unk_1EC996060;
  v4[10] = (int32x2_t)0x100000001;
  v4[11].i32[0] = 1;
  uint64_t v5 = *(void **)(*((void *)a1 + 6) + 16);
  if (a1 && v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id)
  {
    int v6 = 36;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id)
  {
    int v6 = 37;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id)
  {
    int v6 = 31;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id)
  {
    int v6 = 32;
  }
  else
  {
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
      int v7 = 35;
    }
    else {
      int v7 = 0;
    }
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
      int v6 = 34;
    }
    else {
      int v6 = v7;
    }
  }
  v12[0] = v13;
  v12[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(&v11);
  mlir::getValues<unsigned long long>(MultipliersAttr, (uint64_t)v12);
  uint64_t v9 = v12[0];
  uint64_t v10 = *((void *)v12[0] + 2);
  v4[10] = vmovn_s64(*(int64x2_t *)v12[0]);
  v4[11].i32[0] = v10;
  v4[9] = 0;
  *a2 = v4;
  if (v9 != v13) {
    free(v9);
  }
}

uint64_t mlir::anec::SpaceToChannel::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = (uint64_t)v19;
  if (!v19) {
    goto LABEL_10;
  }
  uint64_t v22 = *v19;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_10;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    uint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    __int16 v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_10:
  }
    uint64_t v31 = 0;
  uint64_t v41 = a6;
  LOBYTE(v42) = 0;
  char v43 = 0;
  uint64_t v44 = a7;
  uint64_t v45 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v41);
    if (v43) {
      char v43 = 0;
    }
    mlir::OperationName::OperationName(&v42, "anec.space_to_channel", 21, Context);
    char v43 = 1;
  }
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v33 = mlir::UnknownLoc::get(a1, v20);
  if (a3) {
    uint64_t v34 = a2;
  }
  else {
    uint64_t v34 = v33;
  }
  if (!mlir::anec::SpaceToChannelAdaptor::verify(&v41, v34)) {
    return 0;
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v41);
  char v36 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v41);
  uint64_t v37 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v36, **(void **)(v42 + 96));
  if (v38) {
    uint64_t v39 = *((void *)v37 + 1);
  }
  else {
    uint64_t v39 = 0;
  }
  return mlir::anec::spaceTransformInferReturnTypesCommon(a2, a3, v21, v31, v39, 1, 1, a11);
}

uint64_t mlir::anec::SpaceToChannelAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v42[23] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v39); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v39))
    {
      uint64_t v5 = "'anec.space_to_channel' op requires attribute 'factors'";
      goto LABEL_32;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  int v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        uint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v37[0] = v6;
    v37[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v37);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    unint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v41 = v18;
    v42[0] = v28;
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
    uint64_t v40 = 3;
    if (v30 == 1 && *ArgAttrsAttr == v40)
    {
      uint64_t v34 = v6;
      v35[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v34);
      v35[1] = v31;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v35);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
        return 1;
      }
    }
  }
  uint64_t v5 = "'anec.space_to_channel' op attribute 'factors' failed to satisfy constraint: ui64 elements attribute of shape {3}";
LABEL_32:
  v37[0] = v5;
  __int16 v38 = 259;
  mlir::emitError(a2, (uint64_t)v37, (uint64_t)&v41);
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v32;
}

uint64_t mlir::anec::SpaceToChannel::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  ANECSpaceToChannelLayerDescInitialize();
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(buffer, MultipliersAttr, 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)__p);
  int v7 = (int)__p[1];
  if (LODWORD(__p[1]) < 0x41)
  {
    uint64_t v8 = (uint64_t)__p[0];
    goto LABEL_8;
  }
  if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)__p) <= 0x40)
  {
    uint64_t v8 = *(void *)__p[0];
    goto LABEL_7;
  }
  uint64_t v8 = -1;
  if (__p[0]) {
LABEL_7:
  }
    operator delete[](__p[0]);
LABEL_8:
  uint64_t v9 = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(__p, v9, 0);
  *(_OWORD *)buffer = *(_OWORD *)__p;
  uint64_t v48 = v38;
  uint64_t v47 = v37 + 1;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&v43);
  int v10 = v44;
  if (v44 < 0x41)
  {
    uint64_t v11 = (uint64_t)v43;
    goto LABEL_15;
  }
  if (v10 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v43) <= 0x40)
  {
    uint64_t v11 = *(void *)v43;
    goto LABEL_14;
  }
  uint64_t v11 = -1;
  if (v43) {
LABEL_14:
  }
    operator delete[](v43);
LABEL_15:
  uint64_t v12 = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(__p, v12, 0);
  *(_OWORD *)buffer = *(_OWORD *)__p;
  uint64_t v48 = v38;
  uint64_t v47 = v37 + 2;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&v43);
  int v13 = v44;
  if (v44 < 0x41)
  {
    uint64_t v14 = (uint64_t)v43;
    goto LABEL_22;
  }
  if (v13 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v43) <= 0x40)
  {
    uint64_t v14 = *(void *)v43;
    goto LABEL_21;
  }
  uint64_t v14 = -1;
  if (v43) {
LABEL_21:
  }
    operator delete[](v43);
LABEL_22:
  uint64_t v33 = v8;
  uint64_t v34 = v11;
  uint64_t v35 = v14;
  char v43 = v45;
  uint64_t v44 = 0x100000000;
  *(void *)buffer = 1;
  __p[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (ANECValidateSpaceToChannelLayer())
  {
    uint64_t v25 = (void *)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v26 = *a1;
    uint64_t v15 = MEMORY[0x1E4FBA488] + 104;
    v42[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v16 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v37 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v17 = MEMORY[0x1E4FBA408];
    uint64_t v18 = *(void **)(MEMORY[0x1E4FBA408] + 24);
    __p[0] = *(void **)(MEMORY[0x1E4FBA408] + 16);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = v18;
    __p[1] = 0;
    uint64_t v19 = (std::ios_base *)((char *)__p + *((void *)__p[0] - 3));
    std::ios_base::init(v19, &v38);
    v19[1].__vftable = 0;
    v19[1].__fmtflags_ = -1;
    uint64_t v20 = *(void *)(v17 + 40);
    uint64_t v37 = *(void *)(v17 + 32);
    *(uint64_t *)((char *)&v37 + *(void *)(v37 - 24)) = v20;
    __p[0] = *(void **)(v17 + 8);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = *(void **)(v17 + 48);
    v42[0] = v15;
    __p[0] = v25;
    uint64_t v37 = v16;
    std::streambuf::basic_streambuf();
    uint64_t v21 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v38 = MEMORY[0x1E4FBA470] + 16;
    long long v39 = 0u;
    long long v40 = 0u;
    int v41 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v37, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    __p[0] = *(void **)v17;
    uint64_t v22 = *(void *)(v17 + 72);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = *(void **)(v17 + 64);
    uint64_t v37 = v22;
    uint64_t v38 = v21;
    if (SBYTE7(v40) < 0) {
      operator delete((void *)v39);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v42);
    __int16 v30 = 260;
    __int16 v29 = &v27;
    uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&buffer[8]);
    if (v28 < 0) {
      operator delete(v27);
    }
  }
  else
  {
    uint64_t v23 = 1;
  }
  ANECUnitValidatorDelete();
  if (v43 != v45) {
    free(v43);
  }
  return v23;
}

uint64_t mlir::anec::SpaceToChannel::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrSpaceToChannelUnitInfo,mlir::anec::SpaceToChannel>(*a1, &v11);
  int v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (v4[3].i8[7] < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)&v4[1], *(void *)&v4[2]);
  }
  else
  {
    long long v6 = *(_OWORD *)v4[1].i8;
    v3[2].__vftable = (std::__shared_weak_count_vtbl *)v4[3];
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = (uint64_t)v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  int v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    int v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_9;
    }
  }
  else
  {
    *int v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_9:
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  if (v9) {
    (*(void (**)(int32x2_t *))(*(void *)v9 + 8))(v9);
  }
  return 1;
}

void mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrBatchToSpaceUnitInfo,mlir::anec::BatchToSpace>(mlir::Operation *a1@<X0>, void *a2@<X8>)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a1;
  uint64_t v4 = (char *)operator new(0x60uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995ED8;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 10) = 0x100000001;
  *((_DWORD *)v4 + 22) = 1;
  uint64_t v5 = *(void **)(*((void *)a1 + 6) + 16);
  if (a1 && v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id)
  {
    int v6 = 36;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id)
  {
    int v6 = 37;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id)
  {
    int v6 = 31;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id)
  {
    int v6 = 32;
  }
  else
  {
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
      int v7 = 35;
    }
    else {
      int v7 = 0;
    }
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
      int v6 = 34;
    }
    else {
      int v6 = v7;
    }
  }
  v12[0] = v13;
  v12[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(&v11);
  mlir::getValues<unsigned long long>(MultipliersAttr, (uint64_t)v12);
  uint64_t v9 = v12[0];
  uint64_t v10 = *((void *)v12[0] + 2);
  *((int32x2_t *)v4 + 10) = vmovn_s64(*(int64x2_t *)v12[0]);
  *((_DWORD *)v4 + 22) = v10;
  *((void *)v4 + 9) = 0;
  *a2 = v4;
  if (v9 != v13) {
    free(v9);
  }
}

uint64_t mlir::anec::BatchToSpace::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = (uint64_t)v19;
  if (!v19) {
    goto LABEL_10;
  }
  uint64_t v22 = *v19;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_10;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    char v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    __int16 v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_10:
  }
    uint64_t v31 = 0;
  uint64_t v41 = a6;
  LOBYTE(v42) = 0;
  char v43 = 0;
  uint64_t v44 = a7;
  uint64_t v45 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v41);
    if (v43) {
      char v43 = 0;
    }
    mlir::OperationName::OperationName(&v42, "anec.batch_to_space", 19, Context);
    char v43 = 1;
  }
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v33 = mlir::UnknownLoc::get(a1, v20);
  if (a3) {
    uint64_t v34 = a2;
  }
  else {
    uint64_t v34 = v33;
  }
  if (!mlir::anec::BatchToSpaceAdaptor::verify(&v41, v34)) {
    return 0;
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v41);
  char v36 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v41);
  uint64_t v37 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v36, **(void **)(v42 + 96));
  if (v38) {
    uint64_t v39 = *((void *)v37 + 1);
  }
  else {
    uint64_t v39 = 0;
  }
  return mlir::anec::spaceTransformInferReturnTypesCommon(a2, a3, v21, v31, v39, 0, 0, a11);
}

uint64_t mlir::anec::BatchToSpaceAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v42[23] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v39); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v39))
    {
      uint64_t v5 = "'anec.batch_to_space' op requires attribute 'factors'";
      goto LABEL_32;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  int v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      int v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        uint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v37[0] = v6;
    v37[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v37);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    unint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v41 = v18;
    v42[0] = v28;
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
    uint64_t v40 = 3;
    if (v30 == 1 && *ArgAttrsAttr == v40)
    {
      uint64_t v34 = v6;
      v35[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v34);
      v35[1] = v31;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v35);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
        return 1;
      }
    }
  }
  uint64_t v5 = "'anec.batch_to_space' op attribute 'factors' failed to satisfy constraint: ui64 elements attribute of shape {3}";
LABEL_32:
  v37[0] = v5;
  __int16 v38 = 259;
  mlir::emitError(a2, (uint64_t)v37, (uint64_t)&v41);
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v32;
}

uint64_t mlir::anec::BatchToSpace::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  ANECBatchToSpaceLayerDescInitialize();
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(buffer, MultipliersAttr, 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)__p);
  int v7 = (int)__p[1];
  if (LODWORD(__p[1]) < 0x41)
  {
    uint64_t v8 = (uint64_t)__p[0];
    goto LABEL_8;
  }
  if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)__p) <= 0x40)
  {
    uint64_t v8 = *(void *)__p[0];
    goto LABEL_7;
  }
  uint64_t v8 = -1;
  if (__p[0]) {
LABEL_7:
  }
    operator delete[](__p[0]);
LABEL_8:
  uint64_t v9 = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(__p, v9, 0);
  *(_OWORD *)buffer = *(_OWORD *)__p;
  uint64_t v48 = v38;
  uint64_t v47 = v37 + 1;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&v43);
  int v10 = v44;
  if (v44 < 0x41)
  {
    uint64_t v11 = (uint64_t)v43;
    goto LABEL_15;
  }
  if (v10 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v43) <= 0x40)
  {
    uint64_t v11 = *(void *)v43;
    goto LABEL_14;
  }
  uint64_t v11 = -1;
  if (v43) {
LABEL_14:
  }
    operator delete[](v43);
LABEL_15:
  uint64_t v12 = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(__p, v12, 0);
  *(_OWORD *)buffer = *(_OWORD *)__p;
  uint64_t v48 = v38;
  uint64_t v47 = v37 + 2;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&v43);
  int v13 = v44;
  if (v44 < 0x41)
  {
    uint64_t v14 = (uint64_t)v43;
    goto LABEL_22;
  }
  if (v13 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v43) <= 0x40)
  {
    uint64_t v14 = *(void *)v43;
    goto LABEL_21;
  }
  uint64_t v14 = -1;
  if (v43) {
LABEL_21:
  }
    operator delete[](v43);
LABEL_22:
  uint64_t v33 = v8;
  uint64_t v34 = v11;
  uint64_t v35 = v14;
  char v43 = v45;
  uint64_t v44 = 0x100000000;
  *(void *)buffer = 1;
  __p[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (ANECValidateBatchToSpaceLayer())
  {
    uint64_t v25 = (void *)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v26 = *a1;
    uint64_t v15 = MEMORY[0x1E4FBA488] + 104;
    v42[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v16 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v37 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v17 = MEMORY[0x1E4FBA408];
    uint64_t v18 = *(void **)(MEMORY[0x1E4FBA408] + 24);
    __p[0] = *(void **)(MEMORY[0x1E4FBA408] + 16);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = v18;
    __p[1] = 0;
    uint64_t v19 = (std::ios_base *)((char *)__p + *((void *)__p[0] - 3));
    std::ios_base::init(v19, &v38);
    v19[1].__vftable = 0;
    v19[1].__fmtflags_ = -1;
    uint64_t v20 = *(void *)(v17 + 40);
    uint64_t v37 = *(void *)(v17 + 32);
    *(uint64_t *)((char *)&v37 + *(void *)(v37 - 24)) = v20;
    __p[0] = *(void **)(v17 + 8);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = *(void **)(v17 + 48);
    v42[0] = v15;
    __p[0] = v25;
    uint64_t v37 = v16;
    std::streambuf::basic_streambuf();
    uint64_t v21 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v38 = MEMORY[0x1E4FBA470] + 16;
    long long v39 = 0u;
    long long v40 = 0u;
    int v41 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v37, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    __p[0] = *(void **)v17;
    uint64_t v22 = *(void *)(v17 + 72);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = *(void **)(v17 + 64);
    uint64_t v37 = v22;
    uint64_t v38 = v21;
    if (SBYTE7(v40) < 0) {
      operator delete((void *)v39);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v42);
    __int16 v30 = 260;
    __int16 v29 = &v27;
    uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&buffer[8]);
    if (v28 < 0) {
      operator delete(v27);
    }
  }
  else
  {
    uint64_t v23 = 1;
  }
  ANECUnitValidatorDelete();
  if (v43 != v45) {
    free(v43);
  }
  return v23;
}

uint64_t mlir::anec::BatchToSpace::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrBatchToSpaceUnitInfo,mlir::anec::BatchToSpace>(*a1, &v11);
  int v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  int v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    int v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_9;
    }
  }
  else
  {
    *int v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_9:
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  return 1;
}

void mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrSpaceToBatchUnitInfo,mlir::anec::SpaceToBatch>(mlir::Operation *a1@<X0>, void *a2@<X8>)
{
  v13[3] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = a1;
  uint64_t v4 = (char *)operator new(0x60uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995F50;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 10) = 0x100000001;
  *((_DWORD *)v4 + 22) = 1;
  uint64_t v5 = *(void **)(*((void *)a1 + 6) + 16);
  if (a1 && v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToChannel,void>::id)
  {
    int v6 = 36;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::ChannelToSpace,void>::id)
  {
    int v6 = 37;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelShuffle,void>::id)
  {
    int v6 = 31;
  }
  else if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::PixelUnshuffle,void>::id)
  {
    int v6 = 32;
  }
  else
  {
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::BatchToSpace,void>::id) {
      int v7 = 35;
    }
    else {
      int v7 = 0;
    }
    if (v5 == &mlir::detail::TypeIDResolver<mlir::anec::SpaceToBatch,void>::id) {
      int v6 = 34;
    }
    else {
      int v6 = v7;
    }
  }
  v12[0] = v13;
  v12[1] = (void *)0x300000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(&v11);
  mlir::getValues<unsigned long long>(MultipliersAttr, (uint64_t)v12);
  uint64_t v9 = v12[0];
  uint64_t v10 = *((void *)v12[0] + 2);
  *((int32x2_t *)v4 + 10) = vmovn_s64(*(int64x2_t *)v12[0]);
  *((_DWORD *)v4 + 22) = v10;
  *((void *)v4 + 9) = 0;
  *a2 = v4;
  if (v9 != v13) {
    free(v9);
  }
}

uint64_t mlir::anec::SpaceToBatch::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = (uint64_t)v19;
  if (!v19) {
    goto LABEL_10;
  }
  uint64_t v22 = *v19;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_10;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    char v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    __int16 v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_10:
  }
    uint64_t v31 = 0;
  uint64_t v41 = a6;
  LOBYTE(v42) = 0;
  char v43 = 0;
  uint64_t v44 = a7;
  uint64_t v45 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v41);
    if (v43) {
      char v43 = 0;
    }
    mlir::OperationName::OperationName(&v42, "anec.space_to_batch", 19, Context);
    char v43 = 1;
  }
  uint64_t v46 = a4;
  uint64_t v47 = a5;
  uint64_t v33 = mlir::UnknownLoc::get(a1, v20);
  if (a3) {
    uint64_t v34 = a2;
  }
  else {
    uint64_t v34 = v33;
  }
  if (!mlir::anec::SpaceToBatchAdaptor::verify(&v41, v34)) {
    return 0;
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v41);
  char v36 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v41);
  uint64_t v37 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v36, **(void **)(v42 + 96));
  if (v38) {
    uint64_t v39 = *((void *)v37 + 1);
  }
  else {
    uint64_t v39 = 0;
  }
  return mlir::anec::spaceTransformInferReturnTypesCommon(a2, a3, v21, v31, v39, 0, 1, a11);
}

uint64_t mlir::anec::SpaceToBatchAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v42[23] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v39); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v39))
    {
      uint64_t v5 = "'anec.space_to_batch' op requires attribute 'factors'";
      goto LABEL_32;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  int v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      int v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        uint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v37[0] = v6;
    v37[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v37);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    uint64_t v22 = *(void **)(v19 + 8);
    unint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      uint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        uint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v41 = v18;
    v42[0] = v28;
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
    uint64_t v40 = 3;
    if (v30 == 1 && *ArgAttrsAttr == v40)
    {
      uint64_t v34 = v6;
      v35[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v34);
      v35[1] = v31;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v35);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
        return 1;
      }
    }
  }
  uint64_t v5 = "'anec.space_to_batch' op attribute 'factors' failed to satisfy constraint: ui64 elements attribute of shape {3}";
LABEL_32:
  v37[0] = v5;
  __int16 v38 = 259;
  mlir::emitError(a2, (uint64_t)v37, (uint64_t)&v41);
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v32;
}

uint64_t mlir::anec::SpaceToBatch::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  ANECSpaceToBatchLayerDescInitialize();
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(buffer, MultipliersAttr, 0);
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)__p);
  int v7 = (int)__p[1];
  if (LODWORD(__p[1]) < 0x41)
  {
    uint64_t v8 = (uint64_t)__p[0];
    goto LABEL_8;
  }
  if (v7 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)__p) <= 0x40)
  {
    uint64_t v8 = *(void *)__p[0];
    goto LABEL_7;
  }
  uint64_t v8 = -1;
  if (__p[0]) {
LABEL_7:
  }
    operator delete[](__p[0]);
LABEL_8:
  uint64_t v9 = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(__p, v9, 0);
  *(_OWORD *)buffer = *(_OWORD *)__p;
  uint64_t v48 = v38;
  uint64_t v47 = v37 + 1;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&v43);
  int v10 = v44;
  if (v44 < 0x41)
  {
    uint64_t v11 = (uint64_t)v43;
    goto LABEL_15;
  }
  if (v10 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v43) <= 0x40)
  {
    uint64_t v11 = *(void *)v43;
    goto LABEL_14;
  }
  uint64_t v11 = -1;
  if (v43) {
LABEL_14:
  }
    operator delete[](v43);
LABEL_15:
  uint64_t v12 = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(__p, v12, 0);
  *(_OWORD *)buffer = *(_OWORD *)__p;
  uint64_t v48 = v38;
  uint64_t v47 = v37 + 2;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&v43);
  int v13 = v44;
  if (v44 < 0x41)
  {
    uint64_t v14 = (uint64_t)v43;
    goto LABEL_22;
  }
  if (v13 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v43) <= 0x40)
  {
    uint64_t v14 = *(void *)v43;
    goto LABEL_21;
  }
  uint64_t v14 = -1;
  if (v43) {
LABEL_21:
  }
    operator delete[](v43);
LABEL_22:
  uint64_t v33 = v8;
  uint64_t v34 = v11;
  uint64_t v35 = v14;
  char v43 = v45;
  uint64_t v44 = 0x100000000;
  *(void *)buffer = 1;
  __p[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (ANECValidateSpaceToBatchLayer())
  {
    uint64_t v25 = (void *)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v26 = *a1;
    uint64_t v15 = MEMORY[0x1E4FBA488] + 104;
    v42[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v16 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v37 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v17 = MEMORY[0x1E4FBA408];
    uint64_t v18 = *(void **)(MEMORY[0x1E4FBA408] + 24);
    __p[0] = *(void **)(MEMORY[0x1E4FBA408] + 16);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = v18;
    __p[1] = 0;
    uint64_t v19 = (std::ios_base *)((char *)__p + *((void *)__p[0] - 3));
    std::ios_base::init(v19, &v38);
    v19[1].__vftable = 0;
    v19[1].__fmtflags_ = -1;
    uint64_t v20 = *(void *)(v17 + 40);
    uint64_t v37 = *(void *)(v17 + 32);
    *(uint64_t *)((char *)&v37 + *(void *)(v37 - 24)) = v20;
    __p[0] = *(void **)(v17 + 8);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = *(void **)(v17 + 48);
    v42[0] = v15;
    __p[0] = v25;
    uint64_t v37 = v16;
    std::streambuf::basic_streambuf();
    uint64_t v21 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v38 = MEMORY[0x1E4FBA470] + 16;
    long long v39 = 0u;
    long long v40 = 0u;
    int v41 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v37, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    __p[0] = *(void **)v17;
    uint64_t v22 = *(void *)(v17 + 72);
    *(void **)((char *)__p + *((void *)__p[0] - 3)) = *(void **)(v17 + 64);
    uint64_t v37 = v22;
    uint64_t v38 = v21;
    if (SBYTE7(v40) < 0) {
      operator delete((void *)v39);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v42);
    __int16 v30 = 260;
    __int16 v29 = &v27;
    uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&buffer[8]);
    if (v28 < 0) {
      operator delete(v27);
    }
  }
  else
  {
    uint64_t v23 = 1;
  }
  ANECUnitValidatorDelete();
  if (v43 != v45) {
    free(v43);
  }
  return v23;
}

uint64_t mlir::anec::SpaceToBatch::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  mlir::anec::spaceTransformGetZinIrUnitInfo<ZinIrSpaceToBatchUnitInfo,mlir::anec::SpaceToBatch>(*a1, &v11);
  int v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  int v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    int v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_9;
    }
  }
  else
  {
    *int v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
  }
LABEL_9:
  uint64_t v9 = v11;
  uint64_t v11 = 0;
  if (v9) {
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  }
  return 1;
}

uint64_t mlir::anec::Resize::inferPromotedReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v92[23] = *MEMORY[0x1E4F143B8];
  uint64_t v19 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = v19;
  if (!v19) {
    goto LABEL_10;
  }
  uint64_t v22 = *v19;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_10;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    char v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    __int16 v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_10:
  }
    uint64_t v31 = 0;
  v79[0] = v21;
  v79[1] = v31;
  uint64_t v84 = a6;
  LOBYTE(v85) = 0;
  char v86 = 0;
  uint64_t v87 = a7;
  uint64_t v88 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v84);
    if (v86) {
      char v86 = 0;
    }
    mlir::OperationName::OperationName(&v85, "anec.resize", 11, Context);
    char v86 = 1;
  }
  uint64_t v89 = a4;
  uint64_t v90 = a5;
  uint64_t v33 = mlir::UnknownLoc::get(a1, v20);
  uint64_t v34 = a3;
  if (a3) {
    uint64_t v35 = a2;
  }
  else {
    uint64_t v35 = v33;
  }
  if (!mlir::anec::ResizeAdaptor::verify(&v84, v35)) {
    return 0;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v79);
  unint64_t v37 = v36;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v79);
  uint64_t v81 = v83;
  uint64_t v82 = 0x500000000;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v37);
  unint64_t v40 = mlir::anec::getIndexFromDim(1, v37);
  unint64_t v41 = mlir::anec::getIndexFromDim(3, v37);
  unint64_t v42 = mlir::anec::getIndexFromDim(4, v37);
  uint64_t v43 = *(void *)(ArgAttrsAttr + 8 * IndexFromDim);
  uint64_t v77 = *(void *)(ArgAttrsAttr + 8 * v41);
  uint64_t v78 = *(void *)(ArgAttrsAttr + 8 * v40);
  uint64_t v44 = *(void *)(ArgAttrsAttr + 8 * v42);
  uint64_t v45 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v84) + 48);
  uint64_t v46 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v84);
  uint64_t v47 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v45, (mlir::CallGraphNode *)(v46 - 16), *(void *)(*(void *)(v85 + 96) + 24));
  if (v48)
  {
    uint64_t v49 = *((void *)v47 + 1);
    if (v49 && *(_UNKNOWN **)(*(void *)v49 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
      uint64_t v49 = 0;
    }
  }
  else
  {
    uint64_t v49 = 0;
  }
  uint64_t v80 = v49;
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&v80, (uint64_t)&v91);
  float v51 = llvm::APFloat::convertToFloat(&v91);
  int8x8_t v52 = (void *)v92[0];
  uint64_t v54 = llvm::APFloatBase::PPCDoubleDouble(v53);
  if (v54 == v52) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v92);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v92);
  }
  uint64_t v55 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v84) + 48);
  uint64_t v56 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v84);
  int64x2_t v57 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v55, (mlir::CallGraphNode *)(v56 - 16), *(void *)(*(void *)(v85 + 96) + 32));
  if (v58)
  {
    uint64_t v59 = *((void *)v57 + 1);
    if (v59 && *(_UNKNOWN **)(*(void *)v59 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
      uint64_t v59 = 0;
    }
  }
  else
  {
    uint64_t v59 = 0;
  }
  uint64_t v80 = v59;
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&v80, (uint64_t)&v91);
  float v60 = llvm::APFloat::convertToFloat(&v91);
  if (v54 == (void *)v92[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v92);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v92);
  }
  if (v51 == -1.0 && v60 == -1.0)
  {
    Height = mlir::anec::detail::ResizeGenericAdaptorBase::getHeight((mlir::anec::detail::ResizeGenericAdaptorBase *)&v84);
    int Width = mlir::anec::detail::ResizeGenericAdaptorBase::getWidth((mlir::anec::detail::ResizeGenericAdaptorBase *)&v84);
  }
  else
  {
    if (v51 == -1.0 || v51 <= 0.0 || v60 == -1.0 || v60 <= 0.0)
    {
      if (v34)
      {
        mlir::emitError(a2, (uint64_t)&v91);
        if (v91) {
          mlir::Diagnostic::operator<<((uint64_t)v92, "scale_factor_x and scale_factor_y must be >= 0.0f");
        }
        uint64_t v50 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v91);
        if (v91) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v91);
        }
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v92);
      }
      else
      {
        uint64_t v50 = 0;
      }
      goto LABEL_60;
    }
    int Width = (void *)vcvtms_s32_f32(v51 * (float)v44);
    Height = (void *)vcvtms_s32_f32(v60 * (float)v77);
  }
  unsigned int v63 = v82;
  if (v82 >= HIDWORD(v82))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v83, v82 + 1, 8);
    unsigned int v63 = v82;
  }
  *((void *)v81 + v63) = v43;
  LODWORD(v82) = v82 + 1;
  unint64_t v64 = mlir::anec::getIndexFromDim(2, v37);
  unsigned int v65 = v82;
  if (v66)
  {
    uint64_t v67 = *(void *)(ArgAttrsAttr + 8 * v64);
    uint64_t v68 = v78;
    if (v82 >= HIDWORD(v82))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v83, v82 + 1, 8);
      unsigned int v65 = v82;
    }
    *((void *)v81 + v65) = v67;
    unsigned int v65 = v82 + 1;
    LODWORD(v82) = v82 + 1;
  }
  else
  {
    uint64_t v68 = v78;
  }
  if (v65 >= HIDWORD(v82))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v83, v65 + 1, 8);
    unsigned int v65 = v82;
  }
  *((void *)v81 + v65) = v68;
  uint64_t v69 = (v82 + 1);
  LODWORD(v82) = v69;
  if (v69 >= HIDWORD(v82))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v83, v69 + 1, 8);
    LODWORD(v69) = v82;
  }
  *((void *)v81 + v69) = Height;
  uint64_t v70 = (v82 + 1);
  LODWORD(v82) = v70;
  if (v70 >= HIDWORD(v82))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v81, v83, v70 + 1, 8);
    LODWORD(v70) = v82;
  }
  *((void *)v81 + v70) = Width;
  LODWORD(v82) = v82 + 1;
  unint64_t v71 = (mlir::AffineMap *)v82;
  uint64_t v72 = v81;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v79);
  uint64_t v74 = mlir::MemRefType::get(v72, v71, OperandRange, 0, 0, 0);
  uint64_t v75 = *(unsigned int *)(a11 + 8);
  if (v75 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v75 + 1, 8);
    LODWORD(v75) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v75) = v74;
  ++*(_DWORD *)(a11 + 8);
  uint64_t v50 = 1;
LABEL_60:
  if (v81 != v83) {
    free(v81);
  }
  return v50;
}

uint64_t mlir::anec::ResizeAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v33[23] = *MEMORY[0x1E4F143B8];
  uint64_t v30 = *a1;
  for (uint64_t i = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v30);
        ;
        uint64_t i = (mlir::CallGraphNode *)((char *)i + 16))
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v30))
    {
      uint64_t v5 = "'anec.resize' op requires attribute 'height'";
LABEL_25:
      unint64_t v27 = (uint64_t *)v5;
      __int16 v29 = 259;
      mlir::emitError(a2, (uint64_t)&v27, (uint64_t)&Value);
      uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v33);
      return v11;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
  }
  long long v6 = (uint64_t *)*((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v30))
    {
      uint64_t v5 = "'anec.resize' op requires attribute 'sampling_methods'";
      goto LABEL_25;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  int v7 = (uint64_t *)*((void *)i + 1);
  uint64_t v26 = v7;
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v30))
    {
      uint64_t v5 = "'anec.resize' op requires attribute 'sampling_modes'";
      goto LABEL_25;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v8 = (uint64_t *)*((void *)i + 1);
  uint64_t v25 = v8;
  if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v30))
  {
LABEL_24:
    uint64_t v5 = "'anec.resize' op requires attribute 'width'";
    goto LABEL_25;
  }
  uint64_t v9 = 0;
  int v10 = 0;
  while (*(void *)(*(void *)(a1[1] + 96) + 40) != mlir::CallGraphNode::getCallableRegion(i))
  {
    if (*(void *)(*(void *)(a1[1] + 96) + 24) == mlir::CallGraphNode::getCallableRegion(i))
    {
      uint64_t v9 = (uint64_t *)*((void *)i + 1);
    }
    else if (*(void *)(*(void *)(a1[1] + 96) + 32) == mlir::CallGraphNode::getCallableRegion(i))
    {
      int v10 = (uint64_t *)*((void *)i + 1);
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v30)) {
      goto LABEL_24;
    }
  }
  int v13 = (uint64_t *)*((void *)i + 1);
  if (v6)
  {
    if (*(_UNKNOWN **)(*v6 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
      || (unint64_t v27 = v6,
          uint64_t Value = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v27),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)))
    {
      uint64_t v5 = "'anec.resize' op attribute 'height' failed to satisfy constraint: 64-bit unsigned integer attribute";
      goto LABEL_25;
    }
  }
  if (!v13
    || *(_UNKNOWN **)(*v13 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    && (unint64_t v27 = v13,
        uint64_t Value = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v27),
        mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)))
  {
    if (!v9
      || *(_UNKNOWN **)(*v9 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id
      && (unint64_t v27 = v9,
          uint64_t Value = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v27),
          mlir::Type::isF32((mlir::Type *)&Value)))
    {
      if (!v10
        || *(_UNKNOWN **)(*v10 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id
        && (unint64_t v27 = v10,
            uint64_t Value = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v27),
            mlir::Type::isF32((mlir::Type *)&Value)))
      {
        if (!v7) {
          goto LABEL_59;
        }
        unint64_t v27 = mlir::Attribute::cast<mlir::ElementsAttr>(&v26);
        uint64_t v28 = v14;
        Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v27);
        uint64_t Value = mlir::Type::cast<mlir::ShapedType>(&Type);
        v33[0] = v15;
        uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
        uint64_t v31 = 2;
        if (v17 != 1) {
          goto LABEL_54;
        }
        if (*ArgAttrsAttr == v31
          && (unint64_t v23 = v26,
              (llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_1>((uint64_t *)&v23) & 1) != 0))
        {
LABEL_59:
          if (!v8) {
            return 1;
          }
          unint64_t v27 = mlir::Attribute::cast<mlir::ElementsAttr>(&v25);
          uint64_t v28 = v18;
          Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v27);
          uint64_t Value = mlir::Type::cast<mlir::ShapedType>(&Type);
          v33[0] = v19;
          uint64_t v20 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
          uint64_t v31 = 2;
          if (v21 == 1 && *v20 == v31)
          {
            unint64_t v23 = v25;
            if (llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_2>((uint64_t *)&v23)) {
              return 1;
            }
          }
          uint64_t v22 = "'anec.resize' op attribute 'sampling_modes' failed to satisfy constraint: SamplingGridMode elements attr"
                "ibute of shape {2}";
        }
        else
        {
LABEL_54:
          uint64_t v22 = "'anec.resize' op attribute 'sampling_methods' failed to satisfy constraint: SamplingGridMethod elements "
                "attribute of shape {2}";
        }
      }
      else
      {
        uint64_t v22 = "'anec.resize' op attribute 'scale_factor_y' failed to satisfy constraint: 32-bit float attribute";
      }
    }
    else
    {
      uint64_t v22 = "'anec.resize' op attribute 'scale_factor_x' failed to satisfy constraint: 32-bit float attribute";
    }
  }
  else
  {
    uint64_t v22 = "'anec.resize' op attribute 'width' failed to satisfy constraint: 64-bit unsigned integer attribute";
  }
  unint64_t v27 = (uint64_t *)v22;
  __int16 v29 = 259;
  mlir::emitError(a2, (uint64_t)&v27, (uint64_t)&Value);
  uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
  return v11;
}

void *mlir::anec::detail::ResizeGenericAdaptorBase::getHeight(mlir::anec::detail::ResizeGenericAdaptorBase *this)
{
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue(this);
  uint64_t v3 = mlir::DictionaryAttr::end(this);
  uint64_t v4 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v3 - 48), **(void **)(*((void *)this + 1) + 96));
  if (v5) {
    uint64_t v6 = *((void *)v4 + 1);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  mlir::IntegerAttr::getValue(&v11, (llvm::APInt *)&__p);
  if (v10 <= 0x40) {
    return __p;
  }
  uint64_t v7 = *(void *)__p;
  operator delete[](__p);
  return (void *)v7;
}

void *mlir::anec::detail::ResizeGenericAdaptorBase::getWidth(mlir::anec::detail::ResizeGenericAdaptorBase *this)
{
  uint64_t v2 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue(this) + 48);
  uint64_t v3 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end(this);
  uint64_t v4 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v2, v3, *(void *)(*(void *)(*((void *)this + 1) + 96) + 40));
  if (v5) {
    uint64_t v6 = *((void *)v4 + 1);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  mlir::IntegerAttr::getValue(&v11, (llvm::APInt *)&__p);
  if (v10 <= 0x40) {
    return __p;
  }
  uint64_t v7 = *(void *)__p;
  operator delete[](__p);
  return (void *)v7;
}

void mlir::anec::Resize::getZinIrUnitInfo(mlir::anec::Resize *this@<X0>, void *a2@<X8>)
{
  v77[2] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (char *)operator new(0xD0uLL);
  *((void *)v3 + 2) = 0;
  *((void *)v3 + 3) = 0;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 56) = 0u;
  *((void *)v3 + 9) = -1;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *(_OWORD *)(v3 + 138) = 0u;
  *(void *)uint64_t v3 = &unk_1EC995B28;
  *((void *)v3 + 1) = 0;
  *(void *)(v3 + 156) = 0x100000001;
  __asm { FMOV            V0.2S, #-1.0 }
  *(void *)(v3 + 164) = _D0;
  *((void *)v3 + 22) = 0;
  unint64_t v71 = (char **)(v3 + 176);
  *((void *)v3 + 23) = 0;
  *((void *)v3 + 24) = 0;
  v3[200] = 0;
  *((_DWORD *)v3 + 8) = 41;
  DimensionAttr = (void *)mlir::anec::InputView::getDimensionAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&DimensionAttr, (llvm::APInt *)&__p);
  if (v76 > 0x40)
  {
    uint64_t v9 = *(void *)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v9) = __p;
  }
  *((_DWORD *)v3 + 39) = v9;
  DimensionAttr = (void *)mlir::anec::Resize::getWidthAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&DimensionAttr, (llvm::APInt *)&__p);
  if (v76 > 0x40)
  {
    uint64_t v10 = *(void *)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v10) = __p;
  }
  *((_DWORD *)v3 + 40) = v10;
  DimensionAttr = (void *)mlir::anec::Resize::getScaleFactorXAttr((mlir::Operation **)this);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&DimensionAttr, (uint64_t)&__p);
  *((float *)v3 + 41) = llvm::APFloat::convertToFloat(&__p);
  uint64_t v11 = (void *)v76;
  int v13 = llvm::APFloatBase::PPCDoubleDouble(v12);
  if (v13 == v11) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v76);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v76);
  }
  DimensionAttr = (void *)mlir::anec::Resize::getScaleFactorYAttr((mlir::Operation **)this);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&DimensionAttr, (uint64_t)&__p);
  *((float *)v3 + 42) = llvm::APFloat::convertToFloat(&__p);
  if (v13 == (void *)v76) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v76);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v76);
  }
  long long __p = v77;
  uint64_t v76 = 0x200000000;
  uint64_t v68 = this;
  uint64_t OffsetAttr = mlir::anec::InputView::getOffsetAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(OffsetAttr, (uint64_t)&__p);
  if (v76)
  {
    int v15 = 0;
    uint64_t v16 = (char *)__p;
    uint64_t v17 = (char *)__p + 8 * v76;
    uint64_t v18 = (uint64_t *)*((void *)v3 + 17);
    uint64_t v69 = v17;
    while (1)
    {
      uint64_t v20 = (v15 + 3);
      uint64_t v21 = *(void *)v16;
      unint64_t v22 = *((void *)v3 + 18);
      if ((unint64_t)v18 >= v22) {
        break;
      }
      *uint64_t v18 = v20 | (v21 << 32);
      uint64_t v19 = v18 + 1;
LABEL_16:
      *((void *)v3 + 17) = v19;
      ++v15;
      v16 += 8;
      uint64_t v18 = v19;
      if (v16 == v17) {
        goto LABEL_46;
      }
    }
    unint64_t v23 = (char *)*((void *)v3 + 16);
    uint64_t v24 = ((char *)v18 - v23) >> 3;
    unint64_t v25 = v24 + 1;
    if ((unint64_t)(v24 + 1) >> 61) {
LABEL_85:
    }
      abort();
    uint64_t v26 = v22 - (void)v23;
    if (v26 >> 2 > v25) {
      unint64_t v25 = v26 >> 2;
    }
    if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v27 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v27 = v25;
    }
    if (v27)
    {
      if (v27 >> 61) {
LABEL_86:
      }
        std::__throw_bad_array_new_length[abi:nn180100]();
      uint64_t v28 = (char *)operator new(8 * v27);
    }
    else
    {
      uint64_t v28 = 0;
    }
    __int16 v29 = &v28[8 * v24];
    *(void *)__int16 v29 = v20 | (v21 << 32);
    uint64_t v19 = (uint64_t *)(v29 + 8);
    if (v18 == (uint64_t *)v23)
    {
LABEL_33:
      *((void *)v3 + 16) = v29;
      *((void *)v3 + 17) = v19;
      *((void *)v3 + 18) = &v28[8 * v27];
      if (v18) {
        operator delete(v18);
      }
      uint64_t v17 = v69;
      goto LABEL_16;
    }
    unint64_t v30 = (char *)v18 - v23 - 8;
    if (v30 >= 0x168)
    {
      unint64_t v33 = ((char *)(v18 - 1) - v23) & 0xFFFFFFFFFFFFFFF8;
      if (&v28[(char *)v18 - v23 - 8 - v33] > &v28[(char *)v18 - v23 - 8])
      {
        uint64_t v31 = (char *)v18;
      }
      else if ((uint64_t *)((char *)v18 - v33 - 8) > v18 - 1)
      {
        uint64_t v31 = (char *)v18;
      }
      else if ((unint64_t)(v23 - v28) >= 0x20)
      {
        uint64_t v34 = (v30 >> 3) + 1;
        uint64_t v35 = 8 * (v34 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v31 = (char *)&v18[v35 / 0xFFFFFFFFFFFFFFF8];
        v29 -= v35;
        unint64_t v36 = &v28[8 * v24 - 16];
        unint64_t v37 = (long long *)(v18 - 2);
        uint64_t v38 = v34 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v39 = *v37;
          *((_OWORD *)v36 - 1) = *(v37 - 1);
          *(_OWORD *)unint64_t v36 = v39;
          v36 -= 32;
          v37 -= 2;
          v38 -= 4;
        }
        while (v38);
        if (v34 == (v34 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_32;
        }
      }
      else
      {
        uint64_t v31 = (char *)v18;
      }
    }
    else
    {
      uint64_t v31 = (char *)v18;
    }
    do
    {
      uint64_t v32 = *((void *)v31 - 1);
      v31 -= 8;
      *((void *)v29 - 1) = v32;
      v29 -= 8;
    }
    while (v31 != v23);
LABEL_32:
    uint64_t v18 = (uint64_t *)*((void *)v3 + 16);
    goto LABEL_33;
  }
LABEL_46:
  DimensionAttr = v74;
  uint64_t v73 = 0x200000000;
  uint64_t SizeAttr = mlir::anec::InputView::getSizeAttr((mlir::Operation **)v68);
  mlir::getValues<unsigned long long>(SizeAttr, (uint64_t)&DimensionAttr);
  unint64_t v41 = (char *)DimensionAttr;
  if (!v73) {
    goto LABEL_80;
  }
  int v42 = 0;
  uint64_t v43 = (char *)*((void *)v3 + 23);
  uint64_t v44 = (char *)DimensionAttr + 8 * v73;
  uint64_t v70 = v44;
  do
  {
    uint64_t v46 = (v42 + 3);
    uint64_t v47 = *(void *)v41;
    unint64_t v48 = *((void *)v3 + 24);
    if ((unint64_t)v43 < v48)
    {
      *(void *)uint64_t v43 = v46 | (v47 << 32);
      uint64_t v45 = v43 + 8;
      goto LABEL_49;
    }
    uint64_t v49 = *v71;
    uint64_t v50 = v43 - *v71;
    uint64_t v51 = v50 >> 3;
    unint64_t v52 = (v50 >> 3) + 1;
    if (v52 >> 61) {
      goto LABEL_85;
    }
    uint64_t v53 = v48 - (void)v49;
    if (v53 >> 2 > v52) {
      unint64_t v52 = v53 >> 2;
    }
    if ((unint64_t)v53 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v54 = 0x1FFFFFFFFFFFFFFFLL;
    }
    else {
      unint64_t v54 = v52;
    }
    if (v54)
    {
      if (v54 >> 61) {
        goto LABEL_86;
      }
      uint64_t v55 = operator new(8 * v54);
    }
    else
    {
      uint64_t v55 = 0;
    }
    uint64_t v56 = (uint64_t *)&v55[8 * v51];
    *uint64_t v56 = v46 | (v47 << 32);
    uint64_t v45 = (char *)(v56 + 1);
    if (v43 != v49)
    {
      unint64_t v57 = v43 - v49 - 8;
      if (v57 >= 0x168)
      {
        unint64_t v60 = (v43 - 8 - v49) & 0xFFFFFFFFFFFFFFF8;
        if (&v55[v50 - 8 - v60] > &v55[v50 - 8])
        {
          char v58 = v43;
        }
        else if (&v43[-v60 - 8] > v43 - 8)
        {
          char v58 = v43;
        }
        else if ((unint64_t)(v43 - v55 - v50) >= 0x20)
        {
          uint64_t v61 = (v57 >> 3) + 1;
          uint64_t v62 = 8 * (v61 & 0x3FFFFFFFFFFFFFFCLL);
          char v58 = &v43[-v62];
          uint64_t v56 = (uint64_t *)((char *)v56 - v62);
          unsigned int v63 = &v55[8 * v51 - 16];
          unint64_t v64 = v43 - 16;
          uint64_t v65 = v61 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v66 = *(_OWORD *)v64;
            *(v63 - 1) = *((_OWORD *)v64 - 1);
            _OWORD *v63 = v66;
            v63 -= 2;
            v64 -= 32;
            v65 -= 4;
          }
          while (v65);
          if (v61 == (v61 & 0x3FFFFFFFFFFFFFFCLL)) {
            goto LABEL_65;
          }
        }
        else
        {
          char v58 = v43;
        }
      }
      else
      {
        char v58 = v43;
      }
      do
      {
        uint64_t v59 = *((void *)v58 - 1);
        v58 -= 8;
        *--uint64_t v56 = v59;
      }
      while (v58 != v49);
LABEL_65:
      uint64_t v43 = *v71;
    }
    *((void *)v3 + 22) = v56;
    *((void *)v3 + 23) = v45;
    *((void *)v3 + 24) = &v55[8 * v54];
    if (v43) {
      operator delete(v43);
    }
    uint64_t v44 = v70;
LABEL_49:
    *((void *)v3 + 23) = v45;
    ++v42;
    v41 += 8;
    uint64_t v43 = v45;
  }
  while (v41 != v44);
  unint64_t v41 = (char *)DimensionAttr;
LABEL_80:
  *a2 = v3;
  if (v41 != v74) {
    free(v41);
  }
  if (__p != v77) {
    free(__p);
  }
}

void *mlir::anec::Resize::getHeight(mlir::Operation **this)
{
  uint64_t DimensionAttr = mlir::anec::InputView::getDimensionAttr(this);
  mlir::IntegerAttr::getValue(&DimensionAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return __p;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return (void *)v1;
}

void *mlir::anec::Resize::getWidth(mlir::Operation **this)
{
  uint64_t WidthAttr = mlir::anec::Resize::getWidthAttr(this);
  mlir::IntegerAttr::getValue(&WidthAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return __p;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return (void *)v1;
}

llvm::detail::DoubleAPFloat *mlir::anec::Resize::getScaleFactorX@<X0>(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t ScaleFactorXAttr = mlir::anec::Resize::getScaleFactorXAttr(this);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&ScaleFactorXAttr, a2);
}

llvm::detail::DoubleAPFloat *mlir::anec::Resize::getScaleFactorY@<X0>(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t ScaleFactorYAttr = mlir::anec::Resize::getScaleFactorYAttr(this);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&ScaleFactorYAttr, a2);
}

uint64_t mlir::anec::Resize::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  v72[63] = *MEMORY[0x1E4F143B8];
  ANECResizeLayerDescInitialize();
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  unint64_t v7 = v6;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(3, v6);
  if (!v9 || (uint64_t v10 = (mlir::anec::_anonymous_namespace_ *)IndexFromDim, v11 = mlir::anec::getIndexFromDim(4, v7), !v12)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v68 = v70;
  v70[0] = v10;
  v70[1] = v11;
  uint64_t v69 = 0x200000002;
  unint64_t v64 = &ANECDimension;
  uint64_t v67 = 0;
  uint64_t ANECDimension = 0;
  uint64_t v65 = 0x200000002;
  v62[0] = v63;
  v62[1] = (void *)0x600000000;
  uint64_t SizeAttr = mlir::anec::InputView::getSizeAttr(a1);
  mlir::getValues<unsigned long long>(SizeAttr, (uint64_t)v62);
  v60[0] = v61;
  v60[1] = (void *)0x600000000;
  uint64_t OffsetAttr = mlir::anec::InputView::getOffsetAttr(a1);
  mlir::getValues<unsigned long long>(OffsetAttr, (uint64_t)v60);
  uint64_t v46 = *(void *)v64;
  uint64_t v47 = (uint64_t)*(&off_1E4FBF0A0 + *(void *)v62[0]);
  uint64_t v42 = *(void *)v64;
  if (*(void *)v60[0]) {
    int v15 = @"NearestNeighbor";
  }
  else {
    int v15 = @"Linear";
  }
  uint64_t v43 = v15;
  uint64_t v48 = *((void *)v64 + 1);
  uint64_t v49 = (uint64_t)*(&off_1E4FBF0A0 + *((void *)v62[0] + 1));
  uint64_t v44 = *((void *)v64 + 1);
  if (*((void *)v60[0] + 1)) {
    uint64_t v16 = @"NearestNeighbor";
  }
  else {
    uint64_t v16 = @"Linear";
  }
  uint64_t v45 = v16;
  v50[0] = (const void **)mlir::anec::Resize::getWidthAttr(a1);
  mlir::IntegerAttr::getValue(v50, (llvm::APInt *)&__p);
  if (LODWORD(v72[0]) > 0x40)
  {
    uint64_t v17 = *(void *)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v17) = __p;
  }
  int v38 = v17;
  v50[0] = (const void **)mlir::anec::InputView::getDimensionAttr(a1);
  mlir::IntegerAttr::getValue(v50, (llvm::APInt *)&__p);
  if (LODWORD(v72[0]) > 0x40)
  {
    uint64_t v18 = *(void *)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v18) = __p;
  }
  int v39 = v18;
  v50[0] = (const void **)mlir::anec::Resize::getScaleFactorXAttr(a1);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)v50, (uint64_t)&__p);
  float v40 = llvm::APFloat::convertToFloat(&__p);
  uint64_t v19 = (void *)v72[0];
  uint64_t v21 = llvm::APFloatBase::PPCDoubleDouble(v20);
  if (v21 == v19) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v72);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v72);
  }
  v50[0] = (const void **)mlir::anec::Resize::getScaleFactorYAttr(a1);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)v50, (uint64_t)&__p);
  float v41 = llvm::APFloat::convertToFloat(&__p);
  if (v21 == (void *)v72[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v72);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v72);
  }
  v58[0] = v59;
  v58[1] = (void *)0x100000000;
  uint64_t v22 = 1;
  long long __p = (void *)1;
  v50[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v36 = 0;
  uint64_t v37 = 0;
  if (ANECValidateResizeLayer())
  {
    uint64_t v32 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    unint64_t v33 = *a1;
    uint64_t v23 = MEMORY[0x1E4FBA488] + 104;
    v57[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v24 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v51 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v25 = MEMORY[0x1E4FBA408];
    uint64_t v26 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v50[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v50 + (unint64_t)*(v50[0] - 3)) = v26;
    v50[1] = 0;
    unint64_t v27 = (std::ios_base *)((char *)v50 + (unint64_t)*(v50[0] - 3));
    std::ios_base::init(v27, &v52);
    v27[1].__vftable = 0;
    v27[1].__fmtflags_ = -1;
    uint64_t v28 = *(void *)(v25 + 40);
    uint64_t v51 = *(void *)(v25 + 32);
    *(uint64_t *)((char *)&v51 + *(void *)(v51 - 24)) = v28;
    v50[0] = *(const void ***)(v25 + 8);
    *(const void ***)((char *)v50 + (unint64_t)*(v50[0] - 3)) = *(const void ***)(v25 + 48);
    v57[0] = v23;
    v50[0] = v32;
    uint64_t v51 = v24;
    std::streambuf::basic_streambuf();
    uint64_t v29 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v52 = MEMORY[0x1E4FBA470] + 16;
    long long v54 = 0u;
    long long v55 = 0u;
    int v56 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v51, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v50[0] = *(const void ***)v25;
    uint64_t v30 = *(void *)(v25 + 72);
    *(const void ***)((char *)v50 + (unint64_t)*(v50[0] - 3)) = *(const void ***)(v25 + 64);
    uint64_t v51 = v30;
    uint64_t v52 = v29;
    if (SBYTE7(v55) < 0) {
      operator delete((void *)v54);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v57);
    __int16 v53 = 260;
    v50[0] = (const void **)&v34;
    uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&__p);
    if (__p) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__p);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v72);
    if (v35 < 0) {
      operator delete(v34);
    }
  }
  ANECUnitValidatorDelete();
  if (v58[0] != v59) {
    free(v58[0]);
  }
  if (v60[0] != v61) {
    free(v60[0]);
  }
  if (v62[0] != v63) {
    free(v62[0]);
  }
  if (v64 != &ANECDimension) {
    free(v64);
  }
  if (v68 != v70) {
    free(v68);
  }
  return v22;
}

uint64_t mlir::anec::Resize::verifyAttributesWithFamily(uint64_t *a1, uint64_t a2)
{
}

uint64_t mlir::anec::Resize::addOpToNetwork(mlir::anec::Resize *a1, uint64_t a2)
{
  mlir::anec::Resize::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  unint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *unint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::InputView::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v76[22] = *MEMORY[0x1E4F143B8];
  uint64_t v67 = a6;
  v68[0] = 0;
  char v69 = 0;
  uint64_t v70 = a7;
  uint64_t v71 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v67);
    if (v69) {
      char v69 = 0;
    }
    mlir::OperationName::OperationName(v68, "anec.input_view", 15, Context);
    char v69 = 1;
  }
  uint64_t v72 = a4;
  uint64_t v73 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  uint64_t v18 = a3;
  if (a3) {
    uint64_t v19 = (uint64_t)a2;
  }
  else {
    uint64_t v19 = v17;
  }
  if (!mlir::anec::InputViewAdaptor::verify(&v67, v19)) {
    return 0;
  }
  uint64_t v20 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = v20;
  if (!v20) {
    goto LABEL_18;
  }
  uint64_t v22 = *v20;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_18;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  uint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    uint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    uint64_t v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_18:
  }
    uint64_t v31 = 0;
  v64[0] = v21;
  v64[1] = v31;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v64);
  uint64_t v34 = v33;
  unint64_t Height = (unint64_t)mlir::anec::detail::ResizeGenericAdaptorBase::getHeight((mlir::anec::detail::ResizeGenericAdaptorBase *)&v67);
  if (Height >= (unint64_t)v34)
  {
    uint64_t v46 = "'anec.input_view' op attribute 'dimension = {0}' is not consistent with input rank size = {1}";
    uint64_t v47 = 93;
    uint64_t v48 = &v54;
    uint64_t v49 = 2;
    uint64_t v50 = &unk_1EC9A4678;
    p_unint64_t Height = (void **)&Height;
    uint64_t v52 = &unk_1EC9A46D8;
    p_Size = v34;
    long long v54 = &v50;
    p_Step = &v52;
    if (!v18) {
      return 0;
    }
LABEL_24:
    mlir::emitError((uint64_t)a2, (uint64_t)&v74);
    if (v74)
    {
      __int16 v66 = 263;
      uint64_t v65 = &v46;
      mlir::Diagnostic::operator<<((uint64_t)&v75, (const void ***)&v65);
    }
    uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v74);
    if (v74) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v74);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v75);
    return v35;
  }
  Offset = mlir::anec::detail::InputViewGenericAdaptorBase::getOffset((mlir::anec::detail::InputViewGenericAdaptorBase *)&v67);
  Size = mlir::anec::detail::InputViewGenericAdaptorBase::getSize((mlir::anec::detail::InputViewGenericAdaptorBase *)&v67);
  Step = mlir::anec::detail::InputViewGenericAdaptorBase::getStep((mlir::anec::detail::InputViewGenericAdaptorBase *)&v67);
  unint64_t v59 = *(void *)(ArgAttrsAttr + 8 * Height);
  if ((unint64_t)Offset + ((uint64_t)Size - 1) * (void)Step + 1 > v59)
  {
    uint64_t v46 = "'anec.input_view' with offset {0}, size {1} and stride {2} is out of bounds for dimension {3} of size {4}";
    uint64_t v47 = 105;
    uint64_t v48 = (void ***)v58;
    uint64_t v49 = 5;
    uint64_t v50 = &unk_1EC9A4678;
    p_unint64_t Height = &Offset;
    uint64_t v52 = &unk_1EC9A4678;
    p_Size = &Size;
    long long v54 = (void **)&unk_1EC9A4678;
    p_Step = &Step;
    v56[0] = &unk_1EC9A4678;
    v56[1] = &Height;
    v57[0] = &unk_1EC9A4648;
    v57[1] = &v59;
    v58[0] = &v50;
    v58[1] = &v52;
    v58[2] = &v54;
    v58[3] = v56;
    v58[4] = v57;
    if (!v18) {
      return 0;
    }
    goto LABEL_24;
  }
  LODWORD(v36) = 0;
  uint64_t v37 = 0;
  uint64_t v74 = v76;
  uint64_t v75 = 0x500000000;
  uint64_t v38 = 8 * (void)v34;
  do
  {
    if (v37 == (char *)Height) {
      int v39 = &Size;
    }
    else {
      int v39 = (void **)ArgAttrsAttr;
    }
    float v40 = *v39;
    if (v36 >= HIDWORD(v75))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v76, v36 + 1, 8);
      LODWORD(v36) = v75;
    }
    *((void *)v74 + v36) = v40;
    uint64_t v36 = (mlir::AffineMap *)(v75 + 1);
    LODWORD(v75) = v75 + 1;
    ++v37;
    ArgAttrsAttr += 8;
    v38 -= 8;
  }
  while (v38);
  float v41 = v74;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
  uint64_t v43 = mlir::MemRefType::get(v41, v36, OperandRange, 0, 0, 0);
  uint64_t v44 = *(unsigned int *)(a11 + 8);
  if (v44 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v44 + 1, 8);
    LODWORD(v44) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v44) = v43;
  ++*(_DWORD *)(a11 + 8);
  if (v74 != v76) {
    free(v74);
  }
  return 1;
}

uint64_t mlir::anec::InputViewAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v17[23] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = *a1;
  for (uint64_t i = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v15);
        ;
        uint64_t i = (mlir::CallGraphNode *)((char *)i + 16))
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v15))
    {
      char v5 = "'anec.input_view' op requires attribute 'dimension'";
LABEL_21:
      v13[0] = v5;
      __int16 v14 = 259;
      mlir::emitError(a2, (uint64_t)v13, (uint64_t)&Value);
      uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v17);
      return v9;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
  }
  uint64_t v6 = *((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v15))
    {
      char v5 = "'anec.input_view' op requires attribute 'offset'";
      goto LABEL_21;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v7 = *((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v15))
    {
      char v5 = "'anec.input_view' op requires attribute 'size'";
      goto LABEL_21;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v8 = *((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v15))
    {
      char v5 = "'anec.input_view' op requires attribute 'step'";
      goto LABEL_21;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 24) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v11 = *((void *)i + 1);
  if (v6)
  {
    if (*(_UNKNOWN **)(*(void *)v6 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
      || (v13[0] = v6,
          uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v13),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)))
    {
      char v5 = "'anec.input_view' op attribute 'dimension' failed to satisfy constraint: 64-bit unsigned integer attribute";
      goto LABEL_21;
    }
  }
  if (!v7
    || *(_UNKNOWN **)(*(void *)v7 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    && (v13[0] = v7,
        uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v13),
        mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)))
  {
    if (!v8
      || *(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
      && (v13[0] = v8,
          uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v13),
          mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)))
    {
      if (!v11) {
        return 1;
      }
      if (*(_UNKNOWN **)(*(void *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        v13[0] = v11;
        uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v13);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)) {
          return 1;
        }
      }
      long long v12 = "'anec.input_view' op attribute 'step' failed to satisfy constraint: 64-bit unsigned integer attribute";
    }
    else
    {
      long long v12 = "'anec.input_view' op attribute 'size' failed to satisfy constraint: 64-bit unsigned integer attribute";
    }
  }
  else
  {
    long long v12 = "'anec.input_view' op attribute 'offset' failed to satisfy constraint: 64-bit unsigned integer attribute";
  }
  v13[0] = v12;
  __int16 v14 = 259;
  mlir::emitError(a2, (uint64_t)v13, (uint64_t)&Value);
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
  return v9;
}

void *mlir::anec::detail::InputViewGenericAdaptorBase::getOffset(mlir::anec::detail::InputViewGenericAdaptorBase *this)
{
  uint64_t v2 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue(this) + 16);
  uint64_t v3 = mlir::DictionaryAttr::end(this);
  uint64_t v4 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v2, (mlir::CallGraphNode *)(v3 - 32), *(void *)(*(void *)(*((void *)this + 1) + 96) + 8));
  if (v5) {
    uint64_t v6 = *((void *)v4 + 1);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  mlir::IntegerAttr::getValue(&v11, (llvm::APInt *)&__p);
  if (v10 <= 0x40) {
    return __p;
  }
  uint64_t v7 = *(void *)__p;
  operator delete[](__p);
  return (void *)v7;
}

void *mlir::anec::detail::InputViewGenericAdaptorBase::getSize(mlir::anec::detail::InputViewGenericAdaptorBase *this)
{
  uint64_t v2 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue(this) + 32);
  uint64_t v3 = mlir::DictionaryAttr::end(this);
  uint64_t v4 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v2, (mlir::CallGraphNode *)(v3 - 16), *(void *)(*(void *)(*((void *)this + 1) + 96) + 16));
  if (v5) {
    uint64_t v6 = *((void *)v4 + 1);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  mlir::IntegerAttr::getValue(&v11, (llvm::APInt *)&__p);
  if (v10 <= 0x40) {
    return __p;
  }
  uint64_t v7 = *(void *)__p;
  operator delete[](__p);
  return (void *)v7;
}

void *mlir::anec::detail::InputViewGenericAdaptorBase::getStep(mlir::anec::detail::InputViewGenericAdaptorBase *this)
{
  uint64_t v2 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue(this) + 48);
  uint64_t v3 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end(this);
  uint64_t v4 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v2, v3, *(void *)(*(void *)(*((void *)this + 1) + 96) + 24));
  if (v5) {
    uint64_t v6 = *((void *)v4 + 1);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  mlir::IntegerAttr::getValue(&v11, (llvm::APInt *)&__p);
  if (v10 <= 0x40) {
    return __p;
  }
  uint64_t v7 = *(void *)__p;
  operator delete[](__p);
  return (void *)v7;
}

uint64_t mlir::anec::InputView::addOpToNetwork(mlir::anec::InputView *a1, uint64_t a2)
{
  mlir::anec::InputView::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

void mlir::anec::InputView::getZinIrUnitInfo(mlir::anec::InputView *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x60uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995C70;
  *((void *)v4 + 1) = 0;
  *((_OWORD *)v4 + 5) = xmmword_1810FE2D0;
  char v5 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  unsigned int v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    long long v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    int v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v24[0] = v5;
  v24[1] = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v24);
  unint64_t v17 = v16;
  uint64_t OffsetAttr = mlir::anec::InputView::getOffsetAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&OffsetAttr, (llvm::APInt *)&__p);
  if (v26 > 0x40)
  {
    uint64_t v18 = *(mlir::anec **)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v18) = __p;
  }
  *((_DWORD *)v4 + 20) = v18;
  uint64_t OffsetAttr = mlir::anec::InputView::getSizeAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&OffsetAttr, (llvm::APInt *)&__p);
  if (v26 > 0x40)
  {
    uint64_t v19 = *(mlir::anec **)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v19) = __p;
  }
  *((_DWORD *)v4 + 21) = v19;
  uint64_t OffsetAttr = mlir::anec::InputView::getDimensionAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&OffsetAttr, (llvm::APInt *)&__p);
  if (v26 > 0x40)
  {
    uint64_t v20 = *(mlir::anec **)__p;
    operator delete[](__p);
  }
  else
  {
    uint64_t v20 = (mlir::anec *)__p;
  }
  uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v20, v17);
  if ((DimFromIndex & 0xFF00000000) != 0) {
    int v22 = dword_1810FE490[(int)DimFromIndex];
  }
  else {
    int v22 = 5;
  }
  *((_DWORD *)v4 + 23) = v22;
  uint64_t OffsetAttr = mlir::anec::InputView::getStepAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&OffsetAttr, (llvm::APInt *)&__p);
  if (v26 > 0x40)
  {
    unint64_t v23 = *(mlir::anec **)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v23) = __p;
  }
  *((_DWORD *)v4 + 22) = v23;
  *a2 = v4;
}

uint64_t mlir::anec::InputView::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  ANECInputViewLayerDescInitialize();
  v33[0] = mlir::anec::InputView::getOffsetAttr(a1);
  mlir::IntegerAttr::getValue(v33, (llvm::APInt *)&__p);
  if (v43[0] > 0x40)
  {
    uint64_t v6 = *(mlir::anec::_anonymous_namespace_ **)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v6) = __p;
  }
  v33[0] = mlir::anec::InputView::getSizeAttr(a1);
  mlir::IntegerAttr::getValue(v33, (llvm::APInt *)&__p);
  if (v43[0] > 0x40)
  {
    unint64_t v7 = *(mlir::anec::_anonymous_namespace_ **)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v7) = __p;
  }
  v33[0] = mlir::anec::InputView::getStepAttr(a1);
  mlir::IntegerAttr::getValue(v33, (llvm::APInt *)&__p);
  if (v43[0] > 0x40)
  {
    unint64_t v8 = *(mlir::anec::_anonymous_namespace_ **)__p;
    operator delete[](__p);
  }
  else
  {
    LODWORD(v8) = __p;
  }
  v33[0] = mlir::anec::InputView::getDimensionAttr(a1);
  mlir::IntegerAttr::getValue(v33, (llvm::APInt *)&__p);
  if (v43[0] > 0x40)
  {
    uint64_t v9 = *(mlir::anec::_anonymous_namespace_ **)__p;
    operator delete[](__p);
  }
  else
  {
    uint64_t v9 = (mlir::anec::_anonymous_namespace_ *)__p;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  int v29 = (int)v6;
  int v30 = (int)v7;
  int v31 = (int)v8;
  v40[0] = v41;
  v40[1] = (void *)0x100000000;
  long long __p = (void *)1;
  v33[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v27 = 0;
  uint64_t v28 = 0;
  if (ANECValidateInputViewLayer())
  {
    uint64_t v21 = MEMORY[0x1E4FBA488] + 24;
    int v22 = *a1;
    uint64_t v11 = MEMORY[0x1E4FBA488] + 104;
    v39[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v12 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v34 = MEMORY[0x1E4FBA488] + 64;
    int v13 = (void *)MEMORY[0x1E4FBA408];
    uint64_t v14 = *(void *)(MEMORY[0x1E4FBA408] + 24);
    v33[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
    *(void *)((char *)v33 + *(void *)(v33[0] - 24)) = v14;
    v33[1] = 0;
    uint64_t v15 = (std::ios_base *)((char *)v33 + *(void *)(v33[0] - 24));
    std::ios_base::init(v15, v35);
    v15[1].__vftable = 0;
    v15[1].__fmtflags_ = -1;
    uint64_t v16 = v13[5];
    uint64_t v34 = v13[4];
    *(uint64_t *)((char *)&v35[-1] + *(void *)(v34 - 24)) = v16;
    v33[0] = v13[1];
    *(void *)((char *)v33 + *(void *)(v33[0] - 24)) = v13[6];
    v39[0] = v11;
    v33[0] = v21;
    uint64_t v34 = v12;
    std::streambuf::basic_streambuf();
    uint64_t v17 = MEMORY[0x1E4FBA470] + 16;
    v35[0] = MEMORY[0x1E4FBA470] + 16;
    long long v36 = 0u;
    long long v37 = 0u;
    int v38 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v34, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v33[0] = *v13;
    uint64_t v18 = v13[9];
    *(void *)((char *)v33 + *(void *)(v33[0] - 24)) = v13[8];
    uint64_t v34 = v18;
    v35[0] = v17;
    if (SBYTE7(v37) < 0) {
      operator delete((void *)v36);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v39);
    __int16 v26 = 260;
    uint64_t v25 = &v23;
    uint64_t v19 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&__p);
    if (__p) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__p);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v43);
    if (v24 < 0) {
      operator delete(v23);
    }
  }
  else
  {
    uint64_t v19 = 1;
  }
  ANECUnitValidatorDelete();
  if (v40[0] != v41) {
    free(v40[0]);
  }
  return v19;
}

void *mlir::anec::InputView::getOffset(mlir::Operation **this)
{
  uint64_t OffsetAttr = mlir::anec::InputView::getOffsetAttr(this);
  mlir::IntegerAttr::getValue(&OffsetAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return __p;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return (void *)v1;
}

void *mlir::anec::InputView::getSize(mlir::Operation **this)
{
  uint64_t SizeAttr = mlir::anec::InputView::getSizeAttr(this);
  mlir::IntegerAttr::getValue(&SizeAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return __p;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return (void *)v1;
}

void *mlir::anec::InputView::getStep(mlir::Operation **this)
{
  uint64_t StepAttr = mlir::anec::InputView::getStepAttr(this);
  mlir::IntegerAttr::getValue(&StepAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return __p;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return (void *)v1;
}

uint64_t mlir::anec::Transpose::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v59 = a6;
  LOBYTE(v60) = 0;
  char v61 = 0;
  uint64_t v62 = a7;
  uint64_t v63 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v59);
    if (v61) {
      char v61 = 0;
    }
    mlir::OperationName::OperationName(&v60, "anec.transpose", 14, Context);
    char v61 = 1;
  }
  uint64_t v64 = a4;
  uint64_t v65 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::TransposeAdaptor::verify(&v59, v18)) {
    return 0;
  }
  uint64_t v19 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v20 = v19;
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v21 = *v19;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_18;
  }
  char v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      char v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_18:
  }
    uint64_t v30 = 0;
  v52[0] = v20;
  v52[1] = v30;
  uint64_t ArgAttrsAttr = (const void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v52);
  uint64_t v33 = v32;
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
  uint64_t v35 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v59);
  long long v36 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v35, **(void **)(v60 + 96));
  if (v37) {
    uint64_t v38 = *((void *)v36 + 1);
  }
  else {
    uint64_t v38 = 0;
  }
  uint64_t v51 = v38;
  int v56 = v58;
  uint64_t v57 = 0x500000000;
  if ((unint64_t)(8 * v33) >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v58, (8 * v33) >> 3, 8);
    unsigned int v40 = v57;
    uint64_t v41 = a11;
    if (!v33) {
      goto LABEL_28;
    }
    goto LABEL_27;
  }
  unsigned int v40 = 0;
  uint64_t v41 = a11;
  if (v33)
  {
LABEL_27:
    memcpy((char *)v56 + 8 * v40, ArgAttrsAttr, 8 * v33);
    unsigned int v40 = v57;
  }
LABEL_28:
  LODWORD(v57) = v40 + v33;
  __int16 v53 = v55;
  uint64_t v54 = 0x500000000;
  mlir::getListOfPairs<long long>(&v51, (uint64_t)&v53);
  uint64_t v42 = v56;
  if (v54)
  {
    uint64_t v43 = (char *)v53;
    uint64_t v44 = (char *)v53 + 16 * v54;
    do
    {
      uint64_t v45 = *(void *)v43;
      uint64_t v46 = *((void *)v43 + 1);
      v43 += 16;
      v42[v46] = *((void *)ArgAttrsAttr + v45);
    }
    while (v43 != v44);
  }
  uint64_t v47 = (mlir::AffineMap *)v57;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v52);
  uint64_t v49 = mlir::MemRefType::get(v42, v47, OperandRange, 0, 0, 0);
  uint64_t v50 = *(unsigned int *)(v41 + 8);
  if (v50 >= *(_DWORD *)(v41 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v41, (void *)(v41 + 16), v50 + 1, 8);
    LODWORD(v50) = *(_DWORD *)(v41 + 8);
  }
  *(void *)(*(void *)v41 + 8 * v50) = v49;
  ++*(_DWORD *)(v41 + 8);
  if (v53 != v55) {
    free(v53);
  }
  if (v56 != v58) {
    free(v56);
  }
  return 1;
}

uint64_t mlir::anec::TransposeAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v54[23] = *MEMORY[0x1E4F143B8];
  uint64_t v52 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v52); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v52))
    {
      char v5 = "'anec.transpose' op requires attribute 'transpose_list'";
      goto LABEL_42;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  uint64_t v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    unint64_t v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      int v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        unint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v50[0] = v6;
    v50[1] = v16;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v50);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    unint64_t v22 = *(void **)(v19 + 8);
    unint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      unint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        unint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    __int16 v53 = v18;
    v54[0] = v28;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v53);
    if (v29 == 2)
    {
      uint64_t v48 = v6;
      uint64_t Value = (void *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v48);
      int v31 = Value;
      if (!Value) {
        goto LABEL_37;
      }
      uint64_t v32 = *Value;
      unint64_t v33 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v34 = *(unsigned int *)(v32 + 16);
      if (!v34) {
        goto LABEL_37;
      }
      uint64_t v35 = *(void **)(v32 + 8);
      long long v36 = &v35[2 * v34];
      do
      {
        unint64_t v37 = v34 >> 1;
        uint64_t v38 = &v35[2 * (v34 >> 1)];
        unint64_t v40 = *v38;
        int v39 = v38 + 2;
        v34 += ~(v34 >> 1);
        if (v40 < v33) {
          uint64_t v35 = v39;
        }
        else {
          unint64_t v34 = v37;
        }
      }
      while (v34);
      if (v35 != v36 && *v35 == v33) {
        uint64_t v41 = v35[1];
      }
      else {
LABEL_37:
      }
        uint64_t v41 = 0;
      v49[0] = v31;
      v49[1] = v41;
      if (*(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v49) + 8) == 2)
      {
        uint64_t v45 = v6;
        v46[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v45);
        v46[1] = v42;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v46);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
          return 1;
        }
      }
    }
  }
  char v5 = "'anec.transpose' op attribute 'transpose_list' failed to satisfy constraint: list of 64-bits unsigned integer pairs";
LABEL_42:
  v50[0] = v5;
  __int16 v51 = 259;
  mlir::emitError(a2, (uint64_t)v50, (uint64_t)&v53);
  uint64_t v43 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v54);
  return v43;
}

void *mlir::getListOfPairs<long long>(uint64_t *a1, uint64_t a2)
{
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v20, *a1, 0);
  while (1)
  {
    uint64_t v4 = *a1;
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
    uint64_t result = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v18, v4, NumElements);
    if ((void)v20 != (void)v18 || BYTE8(v20) != BYTE8(v18))
    {
      uint64_t v8 = v21;
      goto LABEL_8;
    }
    uint64_t v8 = v21;
    if ((void)v21 == (void)v19) {
      return result;
    }
LABEL_8:
    long long v18 = v20;
    long long v19 = v21;
    *(void *)&long long v21 = v8 + 1;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v18, (llvm::APInt *)&v16);
    if (v17 > 0x40) {
      uint64_t v9 = *(void *)v16;
    }
    else {
      uint64_t v9 = (uint64_t)((void)v16 << -(uint64_t)v17) >> -(uint64_t)v17;
    }
    v13[0] = v20;
    v13[1] = v21;
    *(void *)&long long v21 = v21 + 1;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)v13, (llvm::APInt *)&__p);
    if (v15 > 0x40) {
      uint64_t v10 = *(void *)__p;
    }
    else {
      uint64_t v10 = (uint64_t)((void)__p << -(uint64_t)v15) >> -(uint64_t)v15;
    }
    unint64_t v11 = *(unsigned int *)(a2 + 8);
    if (v11 >= *(unsigned int *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v11 + 1, 16);
      unint64_t v11 = *(unsigned int *)(a2 + 8);
    }
    unint64_t v12 = (uint64_t *)(*(void *)a2 + 16 * v11);
    uint64_t *v12 = v9;
    v12[1] = v10;
    ++*(_DWORD *)(a2 + 8);
    if (v15 >= 0x41 && __p) {
      operator delete[](__p);
    }
    if (v17 >= 0x41)
    {
      if (v16) {
        operator delete[](v16);
      }
    }
  }
}

void mlir::anec::Transpose::getZinIrUnitInfo(mlir::anec::Transpose *this@<X0>, void *a2@<X8>)
{
  v59[10] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0x68uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995CB0;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 10) = 0;
  __int16 v53 = (char **)(v4 + 80);
  *((void *)v4 + 11) = 0;
  *((void *)v4 + 12) = 0;
  char v5 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  uint64_t v52 = a2;
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    unint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    int v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v55[0] = v5;
  v55[1] = v15;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  unint64_t v17 = v16;
  uint64_t v57 = v59;
  uint64_t v58 = 0x500000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr((mlir::Operation **)this);
  mlir::getListOfPairs<long long>(&MultipliersAttr, (uint64_t)&v57);
  if (v58)
  {
    long long v18 = (mlir::anec **)v57;
    long long v19 = (mlir::anec **)((char *)v57 + 16 * v58);
    while (1)
    {
      uint64_t DimFromIndex = mlir::anec::getDimFromIndex(*v18, v17);
      uint64_t v22 = (DimFromIndex & 0xFF00000000) != 0 ? qword_1810FE468[(int)DimFromIndex] : 5;
      uint64_t v23 = mlir::anec::getDimFromIndex(v18[1], v17);
      uint64_t v24 = (v23 & 0xFF00000000) != 0 ? qword_1810FE3F0[(int)v23] : 0x500000000;
      unint64_t v26 = (char *)*((void *)v4 + 11);
      unint64_t v25 = *((void *)v4 + 12);
      if ((unint64_t)v26 >= v25) {
        break;
      }
      *(void *)unint64_t v26 = v24 | v22;
      long long v20 = v26 + 8;
LABEL_14:
      *((void *)v4 + 11) = v20;
      v18 += 2;
      if (v18 == v19) {
        goto LABEL_43;
      }
    }
    unint64_t v27 = v17;
    uint64_t v28 = v19;
    uint64_t v29 = *v53;
    uint64_t v30 = v26 - *v53;
    uint64_t v31 = v30 >> 3;
    unint64_t v32 = (v30 >> 3) + 1;
    if (v32 >> 61) {
      abort();
    }
    uint64_t v33 = v25 - (void)v29;
    if (v33 >> 2 > v32) {
      unint64_t v32 = v33 >> 2;
    }
    if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v32 = 0x1FFFFFFFFFFFFFFFLL;
    }
    unint64_t v54 = v32;
    if (v32)
    {
      if (v32 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      unint64_t v34 = operator new(8 * v32);
    }
    else
    {
      unint64_t v34 = 0;
    }
    uint64_t v35 = (uint64_t *)&v34[8 * v31];
    *uint64_t v35 = v24 | v22;
    long long v20 = v35 + 1;
    if (v26 == v29)
    {
      long long v19 = v28;
      unint64_t v17 = v27;
      goto LABEL_41;
    }
    unint64_t v36 = v26 - v29 - 8;
    if (v36 >= 0x58)
    {
      unint64_t v37 = v26 - &v34[v30];
      long long v19 = v28;
      unint64_t v17 = v27;
      if (v37 >= 0x20)
      {
        uint64_t v38 = (v36 >> 3) + 1;
        uint64_t v39 = 8 * (v38 & 0x3FFFFFFFFFFFFFFCLL);
        unint64_t v40 = &v26[-v39];
        uint64_t v35 = (uint64_t *)((char *)v35 - v39);
        uint64_t v41 = &v34[8 * v31 - 16];
        uint64_t v42 = v26 - 16;
        uint64_t v43 = v38 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v44 = *(_OWORD *)v42;
          *(v41 - 1) = *((_OWORD *)v42 - 1);
          *uint64_t v41 = v44;
          v41 -= 2;
          v42 -= 32;
          v43 -= 4;
        }
        while (v43);
        unint64_t v26 = v40;
        if (v38 == (v38 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_40;
        }
      }
    }
    else
    {
      long long v19 = v28;
      unint64_t v17 = v27;
    }
    do
    {
      uint64_t v45 = *((void *)v26 - 1);
      v26 -= 8;
      *--uint64_t v35 = v45;
    }
    while (v26 != v29);
LABEL_40:
    unint64_t v26 = *v53;
LABEL_41:
    *((void *)v4 + 10) = v35;
    *((void *)v4 + 11) = v20;
    *((void *)v4 + 12) = &v34[8 * v54];
    if (v26) {
      operator delete(v26);
    }
    goto LABEL_14;
  }
LABEL_43:
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v55);
  uint64_t v47 = *(void **)(*(void *)OperandRange + 136);
  if (v47 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id)
  {
    uint64_t MultipliersAttr = OperandRange;
    int Width = mlir::IntegerType::getWidth((mlir::IntegerType *)&MultipliersAttr);
    uint64_t v50 = v52;
    if (Width == 16)
    {
      if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&MultipliersAttr) == 2) {
        int v49 = 10;
      }
      else {
        int v49 = 9;
      }
    }
    else if (Width == 8)
    {
      if (mlir::IntegerType::getSignedness((mlir::IntegerType *)&MultipliersAttr) == 2) {
        int v49 = 2;
      }
      else {
        int v49 = 1;
      }
    }
    else
    {
      int v49 = 0;
    }
  }
  else
  {
    if (v47 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id) {
      int v48 = 11;
    }
    else {
      int v48 = 0;
    }
    if (v47 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id) {
      int v49 = 3;
    }
    else {
      int v49 = v48;
    }
    uint64_t v50 = v52;
  }
  *((_DWORD *)v4 + 17) = v49;
  *uint64_t v50 = v4;
  if (v57 != v59) {
    free(v57);
  }
}

uint64_t mlir::anec::Transpose::addOpToNetwork(mlir::anec::Transpose *a1, uint64_t a2)
{
  mlir::anec::Transpose::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  unint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    unint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *unint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::Transpose::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  v49[63] = *MEMORY[0x1E4F143B8];
  uint64_t v45 = v47;
  uint64_t v46 = 0x500000000;
  *(void *)buffer = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::getListOfPairs<long long>((uint64_t *)buffer, (uint64_t)&v45);
  ANECTransposeLayerDescInitialize();
  uint64_t v6 = v46;
  unint64_t v7 = v45;
  if (!v46)
  {
LABEL_5:
    uint64_t v9 = 1;
    if (v45 == v47) {
      return v9;
    }
LABEL_6:
    free(v7);
    return v9;
  }
  unint64_t v8 = v45;
  while (*v8 == v8[1])
  {
    v8 += 2;
    if (v8 == (void *)((char *)v45 + 16 * v46)) {
      goto LABEL_5;
    }
  }
  unint64_t v11 = 0;
  uint64_t v12 = 16 * v46;
  do
  {
    int v13 = *(mlir::anec::_anonymous_namespace_ **)((char *)v45 + v11);
    mlir::CallableOpInterface::getArgAttrsAttr(a2);
    unint64_t v16 = *(mlir::anec::_anonymous_namespace_ **)((char *)v45 + v11 + 8);
    mlir::CallableOpInterface::getArgAttrsAttr(a2);
    long long v19 = &v34[v11 / 8];
    v19[1] = ANECDimension;
    void v19[2] = v18;
    v11 += 16;
  }
  while (v12 != v11);
  v34[0] = v6;
  v43[0] = v44;
  v43[1] = (void *)0x100000000;
  uint64_t v9 = 1;
  *(void *)buffer = 1;
  v35[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v32 = 0;
  uint64_t v33 = 0;
  if (ANECValidateTransposeLayer())
  {
    uint64_t v29 = *a1;
    uint64_t v28 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v20 = MEMORY[0x1E4FBA488] + 104;
    v42[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v21 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v36 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v22 = MEMORY[0x1E4FBA408];
    uint64_t v23 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v35[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v35 + (unint64_t)*(v35[0] - 3)) = v23;
    v35[1] = 0;
    uint64_t v24 = (std::ios_base *)((char *)v35 + (unint64_t)*(v35[0] - 3));
    std::ios_base::init(v24, &v37);
    v24[1].__vftable = 0;
    v24[1].__fmtflags_ = -1;
    uint64_t v25 = *(void *)(v22 + 40);
    uint64_t v36 = *(void *)(v22 + 32);
    *(uint64_t *)((char *)&v36 + *(void *)(v36 - 24)) = v25;
    v35[0] = *(const void ***)(v22 + 8);
    *(const void ***)((char *)v35 + (unint64_t)*(v35[0] - 3)) = *(const void ***)(v22 + 48);
    v42[0] = v20;
    v35[0] = v28;
    uint64_t v36 = v21;
    std::streambuf::basic_streambuf();
    uint64_t v26 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v37 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v40 = 0u;
    int v41 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v36, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v35[0] = *(const void ***)v22;
    uint64_t v27 = *(void *)(v22 + 72);
    *(const void ***)((char *)v35 + (unint64_t)*(v35[0] - 3)) = *(const void ***)(v22 + 64);
    uint64_t v36 = v27;
    uint64_t v37 = v26;
    if (SBYTE7(v40) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v42);
    __int16 v38 = 260;
    v35[0] = (const void **)&v30;
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v49);
    if (v31 < 0) {
      operator delete(v30);
    }
  }
  ANECUnitValidatorDelete();
  if (v43[0] != v44) {
    free(v43[0]);
  }
  unint64_t v7 = v45;
  if (v45 != v47) {
    goto LABEL_6;
  }
  return v9;
}

unint64_t mlir::anec::Transpose::fold(mlir::Operation **a1, uint64_t a2)
{
  v74[10] = *MEMORY[0x1E4F143B8];
  uint64_t v72 = (char *)v74;
  uint64_t v73 = 0x500000000;
  v68[0] = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::getListOfPairs<unsigned long long>(v68, (uint64_t)&v72);
  if (!v73)
  {
LABEL_5:
    unint64_t v5 = *(void *)(*((void *)*a1 + 9) + 24) | 4;
    goto LABEL_6;
  }
  uint64_t v4 = v72;
  while (*(void *)v4 == *((void *)v4 + 1))
  {
    v4 += 16;
    if (v4 == &v72[16 * v73]) {
      goto LABEL_5;
    }
  }
  unint64_t v7 = *(uint64_t ***)(a2 + 40);
  if (*((_DWORD *)*a1 + 9)) {
    uint64_t v8 = (uint64_t)*a1 - 16;
  }
  else {
    uint64_t v8 = 0;
  }
  uint64_t v9 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v9) {
    goto LABEL_21;
  }
  uint64_t v10 = *v9;
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *(unsigned int *)(v10 + 16);
  if (!v12) {
    goto LABEL_21;
  }
  int v13 = *(void **)(v10 + 8);
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    unint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    unint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      int v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_21:
  }
    uint64_t v19 = 0;
  v71[0] = v9;
  v71[1] = v19;
  if (!*v7)
  {
    char v69 = 0;
    uint64_t v70 = 0;
    goto LABEL_37;
  }
  char v69 = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible(*v7);
  uint64_t v70 = v20;
  if (!v69)
  {
LABEL_37:
    unint64_t v5 = 0;
    goto LABEL_6;
  }
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v71);
  uint64_t v23 = v22;
  v68[0] = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v69);
  v68[1] = v24;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v68);
  uint64_t v26 = (uint64_t *)mlir::RankedTensorType::get(ArgAttrsAttr, v23, OperandRange, 0);
  if (mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69))
  {
    uint64_t v27 = (uint64_t)v69;
    uint64_t v28 = v70;
    if (!v26) {
      goto LABEL_34;
    }
    uint64_t v29 = *v26;
    unint64_t v30 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v31 = *(unsigned int *)(v29 + 16);
    if (!v31) {
      goto LABEL_34;
    }
    uint64_t v32 = *(void **)(v29 + 8);
    uint64_t v33 = &v32[2 * v31];
    do
    {
      unint64_t v34 = v31 >> 1;
      uint64_t v35 = &v32[2 * (v31 >> 1)];
      unint64_t v37 = *v35;
      uint64_t v36 = v35 + 2;
      v31 += ~(v31 >> 1);
      if (v37 < v30) {
        uint64_t v32 = v36;
      }
      else {
        unint64_t v31 = v34;
      }
    }
    while (v31);
    if (v32 != v33 && *v32 == v30) {
      uint64_t v38 = v32[1];
    }
    else {
LABEL_34:
    }
      uint64_t v38 = 0;
    unint64_t v5 = (unint64_t)mlir::reshapeElementsAttr(v27, v28, (uint64_t)v26, v38) & 0xFFFFFFFFFFFFFFFBLL;
    goto LABEL_6;
  }
  mlir::mps::CPUNDArray::CPUNDArray(v68, v69, v70);
  v67[0] = 0;
  v67[1] = 0;
  if (!v26) {
    goto LABEL_47;
  }
  uint64_t v39 = *v26;
  unint64_t v40 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v41 = *(unsigned int *)(v39 + 16);
  if (!v41) {
    goto LABEL_47;
  }
  uint64_t v42 = *(void **)(v39 + 8);
  uint64_t v43 = &v42[2 * v41];
  do
  {
    unint64_t v44 = v41 >> 1;
    uint64_t v45 = &v42[2 * (v41 >> 1)];
    unint64_t v47 = *v45;
    uint64_t v46 = v45 + 2;
    v41 += ~(v41 >> 1);
    if (v47 < v40) {
      uint64_t v42 = v46;
    }
    else {
      unint64_t v41 = v44;
    }
  }
  while (v41);
  if (v42 != v43 && *v42 == v40) {
    uint64_t v48 = v42[1];
  }
  else {
LABEL_47:
  }
    uint64_t v48 = 0;
  mlir::mps::CPUNDArray::tryMakeAliasedArray((uint64_t)v26, v48, (uint64_t)v67, v66);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v71);
  if (v49)
  {
    if (v49 >> 61) {
      abort();
    }
    size_t v50 = 8 * v49;
    __int16 v51 = (int64x2_t *)operator new(8 * v49);
    bzero(v51, v50);
    uint64_t v52 = &v51->i64[v50 / 8];
    if (v50 - 8 >= 0x18)
    {
      unint64_t v55 = ((v50 - 8) >> 3) + 1;
      uint64_t v53 = v55 & 0x3FFFFFFFFFFFFFFCLL;
      unint64_t v54 = &v51->i64[v55 & 0x3FFFFFFFFFFFFFFCLL];
      int64x2_t v56 = (int64x2_t)xmmword_1810FE2E0;
      uint64_t v57 = v51 + 1;
      int64x2_t v58 = vdupq_n_s64(2uLL);
      int64x2_t v59 = vdupq_n_s64(4uLL);
      uint64_t v60 = v55 & 0x3FFFFFFFFFFFFFFCLL;
      do
      {
        v57[-1] = v56;
        *uint64_t v57 = vaddq_s64(v56, v58);
        int64x2_t v56 = vaddq_s64(v56, v59);
        v57 += 2;
        v60 -= 4;
      }
      while (v60);
      if (v55 == v53) {
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v53 = 0;
      unint64_t v54 = (uint64_t *)v51;
    }
    do
      *v54++ = v53++;
    while (v54 != v52);
  }
  else
  {
    __int16 v51 = 0;
    uint64_t v52 = 0;
  }
LABEL_57:
  if (v73)
  {
    char v61 = v72;
    uint64_t v62 = &v72[16 * v73];
    do
    {
      uint64_t v63 = *(void *)v61;
      uint64_t v64 = *((void *)v61 + 1);
      v61 += 16;
      v51->i64[v64] = v63;
    }
    while (v61 != v62);
  }
  mlir::mps::transpose((mlir::AffineBinaryOpExpr *)v68, (uint64_t)v66, (uint64_t)v51, ((char *)v52 - (char *)v51) >> 3);
  unint64_t ElementsAttr = v67[0];
  if (!v67[0]) {
    unint64_t ElementsAttr = (unint64_t)mlir::mps::CPUNDArray::getElementsAttr((mlir::mps::CPUNDArray *)v66, 0, 0);
  }
  unint64_t v5 = ElementsAttr & 0xFFFFFFFFFFFFFFFBLL;
  if (v51) {
    operator delete(v51);
  }
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v66);
  mlir::mps::CPUNDArray::~CPUNDArray((mlir::mps::CPUNDArray *)v68);
LABEL_6:
  if (v72 != (char *)v74) {
    free(v72);
  }
  return v5;
}

void *mlir::getListOfPairs<unsigned long long>(uint64_t *a1, uint64_t a2)
{
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v22, *a1, 0);
  while (1)
  {
    uint64_t v4 = *a1;
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
    uint64_t result = mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v20, v4, NumElements);
    if ((void)v22 != (void)v20 || BYTE8(v22) != BYTE8(v20))
    {
      uint64_t v8 = v23;
      goto LABEL_8;
    }
    uint64_t v8 = v23;
    if ((void)v23 == (void)v21) {
      return result;
    }
LABEL_8:
    long long v20 = v22;
    long long v21 = v23;
    *(void *)&long long v23 = v8 + 1;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v20, (llvm::APInt *)&v18);
    if (v19 >= 0x41) {
      uint64_t v9 = (uint64_t *)v18;
    }
    else {
      uint64_t v9 = (uint64_t *)&v18;
    }
    uint64_t v10 = *v9;
    v15[0] = v22;
    v15[1] = v23;
    *(void *)&long long v23 = v23 + 1;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)v15, (llvm::APInt *)&__p);
    if (v17 >= 0x41) {
      p_p = (uint64_t *)__p;
    }
    else {
      p_p = (uint64_t *)&__p;
    }
    uint64_t v12 = *p_p;
    unint64_t v13 = *(unsigned int *)(a2 + 8);
    if (v13 >= *(unsigned int *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v13 + 1, 16);
      unint64_t v13 = *(unsigned int *)(a2 + 8);
    }
    unint64_t v14 = (void *)(*(void *)a2 + 16 * v13);
    *unint64_t v14 = v10;
    v14[1] = v12;
    ++*(_DWORD *)(a2 + 8);
    if (v17 >= 0x41 && __p) {
      operator delete[](__p);
    }
    if (v19 >= 0x41)
    {
      if (v18) {
        operator delete[](v18);
      }
    }
  }
}

uint64_t mlir::anec::Transpose::canonicalize(uint64_t *a1, uint64_t a2)
{
  v138[10] = *MEMORY[0x1E4F143B8];
  uint64_t v128 = (mlir::Operation *)a1;
  unint64_t v136 = (char *)v138;
  uint64_t v137 = 0x500000000;
  uint64_t MultipliersAttr = (void *)mlir::anec::Tile::getMultipliersAttr(&v128);
  mlir::getListOfPairs<unsigned long long>((uint64_t *)&MultipliersAttr, (uint64_t)&v136);
  uint64_t v4 = (uint64_t *)(*(void *)(*(void *)(a1[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    unint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    uint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  uint64_t MultipliersAttr = v4;
  uint64_t v134 = v14;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&MultipliersAttr);
  if (v137)
  {
    unint64_t v17 = (v137 - 1) & 0xFFFFFFFFFFFFFFFLL;
    if (v17 >= 4)
    {
      unint64_t v20 = v17 + 1;
      uint64_t v21 = v20 & 3;
      if ((v20 & 3) == 0) {
        uint64_t v21 = 4;
      }
      unint64_t v22 = v20 - v21;
      unsigned int v19 = &v136[16 * v22];
      int8x16_t v23 = (int8x16_t)vdupq_n_s64(v16);
      uint64_t v24 = (const double *)(v136 + 32);
      int8x16_t v25 = 0uLL;
      int8x16_t v26 = v23;
      int8x16_t v27 = 0uLL;
      do
      {
        uint64_t v28 = v24 - 4;
        unsigned long long v29 = (unsigned __int128)vld2q_f64(v28);
        unsigned long long v30 = (unsigned __int128)vld2q_f64(v24);
        int8x16_t v23 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v23, (uint64x2_t)v29), (int8x16_t)v29, v23);
        int8x16_t v26 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v26, (uint64x2_t)v30), (int8x16_t)v30, v26);
        int8x16_t v25 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v25, (uint64x2_t)v29), v25, (int8x16_t)v29);
        int8x16_t v27 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v27, (uint64x2_t)v30), v27, (int8x16_t)v30);
        v24 += 8;
        v22 -= 4;
      }
      while (v22);
      int8x16_t v31 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v25, (uint64x2_t)v27), v25, v27);
      unint64_t v32 = vextq_s8(v31, v31, 8uLL).u64[0];
      int8x8_t v18 = vbsl_s8((int8x8_t)vcgtd_u64(v31.u64[0], v32), *(int8x8_t *)v31.i8, (int8x8_t)v32);
      int8x16_t v33 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v26, (uint64x2_t)v23), v23, v26);
      unint64_t v34 = vextq_s8(v33, v33, 8uLL).u64[0];
      unint64_t v16 = (unint64_t)vbsl_s8((int8x8_t)vcgtd_u64(v34, v33.u64[0]), *(int8x8_t *)v33.i8, (int8x8_t)v34);
    }
    else
    {
      int8x8_t v18 = 0;
      unsigned int v19 = v136;
    }
    do
    {
      unint64_t v36 = *(void *)v19;
      v19 += 16;
      unint64_t v35 = v36;
      if (v36 < v16) {
        unint64_t v16 = v35;
      }
      if (*(void *)&v18 <= v35) {
        int8x8_t v18 = (int8x8_t)v35;
      }
    }
    while (v19 != &v136[16 * v137]);
  }
  else
  {
    int8x8_t v18 = 0;
  }
  unint64_t v37 = ArgAttrsAttr + 8 * v16;
  uint64_t v38 = ArgAttrsAttr + 8 * *(void *)&v18;
  if (v37 == v38 + 8) {
    goto LABEL_76;
  }
  unint64_t v39 = (*(void *)&v18 - v16) & 0x1FFFFFFFFFFFFFFFLL;
  if (v39 >= 3)
  {
    unint64_t v41 = v39 + 1;
    v37 += 8 * (v41 & 0x3FFFFFFFFFFFFFFCLL);
    uint64_t v42 = (int64x2_t *)(ArgAttrsAttr + 8 * v16 + 16);
    int64x2_t v43 = 0uLL;
    int64x2_t v44 = vdupq_n_s64(1uLL);
    uint64_t v45 = v41 & 0x3FFFFFFFFFFFFFFCLL;
    int64x2_t v46 = 0uLL;
    do
    {
      int64x2_t v43 = vsubq_s64(v43, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(v42[-1], v44)));
      int64x2_t v46 = vsubq_s64(v46, (int64x2_t)vmvnq_s8((int8x16_t)vceqq_s64(*v42, v44)));
      v42 += 2;
      v45 -= 4;
    }
    while (v45);
    unint64_t v40 = vaddvq_s64(vaddq_s64(v46, v43));
    if (v41 == (v41 & 0x3FFFFFFFFFFFFFFCLL)) {
      goto LABEL_35;
    }
  }
  else
  {
    unint64_t v40 = 0;
  }
  unint64_t v47 = v37 - 8;
  do
  {
    uint64_t v48 = *(void *)(v47 + 8);
    v47 += 8;
    if (v48 != 1) {
      ++v40;
    }
  }
  while (v47 != v38);
LABEL_35:
  if (v40 <= 1)
  {
LABEL_76:
    v131[0] = (void *)(*(a1 - 1) & 0xFFFFFFFFFFFFFFF8);
    uint64_t v124 = *(llvm **)(a1[9] + 24);
    uint64_t v71 = mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a2 + 8), a1[3], (uint64_t *)v131, (uint64_t *)&v124);
    (*(void (**)(uint64_t, uint64_t *, mlir::GenericProgramPoint *))(*(void *)a2 + 32))(a2, a1, v71);
    uint64_t v72 = 1;
    goto LABEL_155;
  }
  uint64_t MultipliersAttr = *(void **)(a1[9] + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&MultipliersAttr);
  if (DefiningOp)
  {
    size_t v50 = *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id
        ? (mlir::Operation *)DefiningOp
        : 0;
    unint64_t v127 = v50;
    if (v50)
    {
      uint64_t MultipliersAttr = &v135;
      uint64_t v134 = 0x500000000;
      v131[0] = (void *)mlir::anec::Tile::getMultipliersAttr(&v127);
      mlir::getListOfPairs<unsigned long long>((uint64_t *)v131, (uint64_t)&MultipliersAttr);
      uint64_t v124 = 0;
      uint64_t v125 = 0;
      unsigned int v126 = 0;
      v122[0] = 0;
      v122[1] = 0;
      unsigned int v123 = 0;
      if (v134)
      {
        __int16 v51 = (char *)MultipliersAttr;
        uint64_t v52 = (char *)MultipliersAttr + 16 * v134;
        do
        {
          *(_OWORD *)uint64_t v131 = *(_OWORD *)v51;
          int64x2_t v56 = v131[1];
          if (v126)
          {
            uint64_t v57 = v131[0];
            unsigned int v58 = (37 * LODWORD(v131[0])) & (v126 - 1);
            inserted = (uint64_t *)((char *)v124 + 16 * v58);
            uint64_t v60 = (void *)*inserted;
            if (v131[0] == (void *)*inserted) {
              goto LABEL_58;
            }
            char v61 = 0;
            int v62 = 1;
            while (v60 != (void *)-1)
            {
              if (v61) {
                BOOL v63 = 0;
              }
              else {
                BOOL v63 = v60 == (void *)-2;
              }
              if (v63) {
                char v61 = inserted;
              }
              unsigned int v64 = v58 + v62++;
              unsigned int v58 = v64 & (v126 - 1);
              inserted = (uint64_t *)((char *)v124 + 16 * v58);
              uint64_t v60 = (void *)*inserted;
              if (v131[0] == (void *)*inserted) {
                goto LABEL_58;
              }
            }
            if (v61) {
              uint64_t v65 = v61;
            }
            else {
              uint64_t v65 = inserted;
            }
          }
          else
          {
            uint64_t v65 = 0;
          }
          inserted = llvm::DenseMapBase<llvm::DenseMap<unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>,unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>::InsertIntoBucket<unsigned long long const&>((uint64_t)&v124, v65, (uint64_t *)v131);
          uint64_t v57 = v131[0];
LABEL_58:
          inserted[1] = (uint64_t)v56;
          if (!v123)
          {
            uint64_t v66 = 0;
LABEL_60:
            unint64_t v54 = llvm::DenseMapBase<llvm::DenseMap<unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>,unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>::InsertIntoBucket<unsigned long long const&>((uint64_t)v122, v66, (uint64_t *)&v131[1]);
            goto LABEL_44;
          }
          unsigned int v53 = (37 * LODWORD(v131[1])) & (v123 - 1);
          unint64_t v54 = (uint64_t *)((char *)v122[0] + 16 * v53);
          unint64_t v55 = (void *)*v54;
          if (v131[1] != (void *)*v54)
          {
            uint64_t v67 = 0;
            int v68 = 1;
            while (v55 != (void *)-1)
            {
              if (v67) {
                BOOL v69 = 0;
              }
              else {
                BOOL v69 = v55 == (void *)-2;
              }
              if (v69) {
                uint64_t v67 = v54;
              }
              unsigned int v70 = v53 + v68++;
              unsigned int v53 = v70 & (v123 - 1);
              unint64_t v54 = (uint64_t *)((char *)v122[0] + 16 * v53);
              unint64_t v55 = (void *)*v54;
              if (v131[1] == (void *)*v54) {
                goto LABEL_44;
              }
            }
            if (v67) {
              uint64_t v66 = v67;
            }
            else {
              uint64_t v66 = v54;
            }
            goto LABEL_60;
          }
LABEL_44:
          v54[1] = (uint64_t)v57;
          v51 += 16;
        }
        while (v51 != v52);
      }
      if (!v137)
      {
LABEL_124:
        v131[0] = v132;
        v131[1] = (void *)0x500000000;
        if (!v125) {
          goto LABEL_139;
        }
        if (v126)
        {
          uint64_t v97 = 16 * v126;
          int v98 = v124;
          while (*(void *)v98 >= 0xFFFFFFFFFFFFFFFELL)
          {
            int v98 = (llvm *)((char *)v98 + 16);
            v97 -= 16;
            if (!v97) {
              goto LABEL_139;
            }
          }
        }
        else
        {
          int v98 = v124;
        }
        unint64_t v99 = (llvm *)((char *)v124 + 16 * v126);
        if (v98 == v99)
        {
LABEL_139:
          uint64_t v101 = 0;
        }
        else
        {
          do
          {
            uint64_t v100 = *((void *)v98 + 1);
            if (*(void *)v98 != v100)
            {
              __src = *(void **)v98;
              uint64_t v130 = v100;
              llvm::SmallVectorImpl<mlir::Attribute>::insert<mlir::Attribute const*,void>((uint64_t)v131, (uint64_t)v131[0] + 8 * LODWORD(v131[1]), (char *)&__src, (char *)v131);
            }
            do
            {
              int v98 = (llvm *)((char *)v98 + 16);
              if (v98 == v99) {
                goto LABEL_138;
              }
            }
            while (*(void *)v98 >= 0xFFFFFFFFFFFFFFFELL);
          }
          while (v98 != v99);
LABEL_138:
          uint64_t v101 = (void *)((unint64_t)LODWORD(v131[1]) >> 1);
        }
        __src = v101;
        uint64_t v130 = 2;
        uint64_t v102 = (mlir::Attribute *)(a1 + 3);
        uint64_t Context = mlir::Attribute::getContext(v102);
        uint64_t v104 = mlir::IntegerType::get(Context, 0x40u, 2u);
        uint64_t v105 = (void *)mlir::RankedTensorType::get((uint64_t)&__src, 2, v104, 0);
        uint64_t v106 = v105;
        if (!v105) {
          goto LABEL_149;
        }
        uint64_t v107 = *v105;
        unint64_t v108 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v109 = *(unsigned int *)(v107 + 16);
        if (!v109) {
          goto LABEL_149;
        }
        uint64_t v110 = *(void **)(v107 + 8);
        uint64_t v111 = &v110[2 * v109];
        do
        {
          unint64_t v112 = v109 >> 1;
          uint64_t v113 = &v110[2 * (v109 >> 1)];
          unint64_t v115 = *v113;
          uint64_t v114 = v113 + 2;
          v109 += ~(v109 >> 1);
          if (v115 < v108) {
            uint64_t v110 = v114;
          }
          else {
            unint64_t v109 = v112;
          }
        }
        while (v109);
        if (v110 != v111 && *v110 == v108) {
          uint64_t v116 = v110[1];
        }
        else {
LABEL_149:
        }
          uint64_t v116 = 0;
        uint64_t v121 = mlir::DenseElementsAttr::getFromRawBuffer(v106, v116, v131[0], 8 * LODWORD(v131[1]), 8, 1, 0);
        uint64_t v117 = *(void *)v102;
        __src = *(void **)(*((void *)v50 + 9) + 24);
        uint64_t v118 = mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value,mlir::DenseIntElementsAttr &>((mlir::UnknownLoc **)(a2 + 8), v117, (uint64_t *)&__src, &v121);
        uint64_t ParentFamily = mlir::anec::detail::VerifyAttributesWithFamilyInterfaceTrait<mlir::anec::Invert>::getParentFamily((uint64_t *)&v128);
        if (v131[0] != v132) {
          free(v131[0]);
        }
        llvm::deallocate_buffer(v122[0], (void *)(16 * v123));
      }
      uint64_t v73 = v136;
      uint64_t v74 = &v136[16 * v137];
      while (1)
      {
        *(_OWORD *)uint64_t v131 = *v73;
        uint64_t v78 = v131[0];
        __src = v131[0];
        if (v123)
        {
          LODWORD(v79) = (v123 - 1) & (37 * LODWORD(v131[0]));
          uint64_t v80 = (void *)*((void *)v122[0] + 2 * v79);
          if (v131[0] == v80)
          {
            if (v79 != v123) {
              goto LABEL_102;
            }
            goto LABEL_104;
          }
          int v85 = 1;
          while (v80 != (void *)-1)
          {
            int v86 = v79 + v85++;
            uint64_t v79 = v86 & (v123 - 1);
            uint64_t v80 = (void *)*((void *)v122[0] + 2 * v79);
            if (v131[0] == v80) {
              goto LABEL_100;
            }
          }
        }
        uint64_t v79 = v123;
LABEL_100:
        if (v79 != v123)
        {
          if (v123)
          {
LABEL_102:
            unsigned int v87 = (v123 - 1) & (37 * LODWORD(v131[0]));
            uint64_t v88 = (uint64_t *)((char *)v122[0] + 16 * v87);
            uint64_t v89 = (void *)*v88;
            if (v131[0] == (void *)*v88)
            {
LABEL_103:
              uint64_t v78 = (void *)v88[1];
              __src = v78;
              goto LABEL_104;
            }
            unint64_t v93 = 0;
            int v94 = 1;
            while (v89 != (void *)-1)
            {
              if (v93) {
                BOOL v95 = 0;
              }
              else {
                BOOL v95 = v89 == (void *)-2;
              }
              if (v95) {
                unint64_t v93 = v88;
              }
              unsigned int v96 = v87 + v94++;
              unsigned int v87 = v96 & (v123 - 1);
              uint64_t v88 = (uint64_t *)((char *)v122[0] + 16 * v87);
              uint64_t v89 = (void *)*v88;
              if (v131[0] == (void *)*v88) {
                goto LABEL_103;
              }
            }
            if (v93) {
              unint64_t v92 = v93;
            }
            else {
              unint64_t v92 = v88;
            }
          }
          else
          {
            unint64_t v92 = 0;
          }
          uint64_t v88 = llvm::DenseMapBase<llvm::DenseMap<unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>,unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>::InsertIntoBucket<unsigned long long const&>((uint64_t)v122, v92, (uint64_t *)v131);
          goto LABEL_103;
        }
LABEL_104:
        uint64_t v90 = v131[1];
        if (!v126)
        {
          uint64_t v91 = 0;
LABEL_106:
          uint64_t v76 = llvm::DenseMapBase<llvm::DenseMap<unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>,unsigned long long,unsigned long long,llvm::DenseMapInfo<unsigned long long,void>,llvm::detail::DenseMapPair<unsigned long long,unsigned long long>>::InsertIntoBucket<unsigned long long const&>((uint64_t)&v124, v91, (uint64_t *)&__src);
          goto LABEL_81;
        }
        unsigned int v75 = (37 * v78) & (v126 - 1);
        uint64_t v76 = (uint64_t *)((char *)v124 + 16 * v75);
        uint64_t v77 = *v76;
        if (v78 != (void *)*v76)
        {
          uint64_t v81 = 0;
          int v82 = 1;
          while (v77 != -1)
          {
            if (v81) {
              BOOL v83 = 0;
            }
            else {
              BOOL v83 = v77 == -2;
            }
            if (v83) {
              uint64_t v81 = v76;
            }
            unsigned int v84 = v75 + v82++;
            unsigned int v75 = v84 & (v126 - 1);
            uint64_t v76 = (uint64_t *)((char *)v124 + 16 * v75);
            uint64_t v77 = *v76;
            if (v78 == (void *)*v76) {
              goto LABEL_81;
            }
          }
          if (v81) {
            uint64_t v91 = v81;
          }
          else {
            uint64_t v91 = v76;
          }
          goto LABEL_106;
        }
LABEL_81:
        v76[1] = (uint64_t)v90;
        if (++v73 == (_OWORD *)v74) {
          goto LABEL_124;
        }
      }
    }
  }
  uint64_t v72 = 0;
LABEL_155:
  if (v136 != (char *)v138) {
    free(v136);
  }
  return v72;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Transpose,mlir::Value,mlir::DenseIntElementsAttr &>(mlir::UnknownLoc **a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v19[38] = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.transpose", (const unsigned __int8 *)0xE, Context);
  if (!v10)
  {
    __int16 v18 = 1283;
    v17[2] = (uint64_t)"anec.transpose";
    v17[3] = 14;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v16 = 259;
    llvm::operator+(v17, (uint64_t *)&v15, (uint64_t)v19);
    llvm::report_fatal_error((llvm::Twine *)v19, 1);
  }
  mlir::OperationState::OperationState(v19, a2, v9);
  mlir::anec::Transpose::build(a1, (uint64_t)v19, *a3, *a4);
  unint64_t v11 = mlir::OpBuilder::create((mlir::OpBuilder *)a1, (const mlir::OperationState *)v19);
  if (*(_UNKNOWN **)(*((void *)v11 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Transpose,void>::id) {
    uint64_t v12 = v11;
  }
  else {
    uint64_t v12 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v19);
  return v12;
}

BOOL mlir::anec::Transpose::getExecutionCost(uint64_t *a1, uint64_t a2)
{
  if (*(_DWORD *)(*a1 + 36)) {
    uint64_t v4 = *a1 - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_13;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_13;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  char v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    unint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_13:
  }
    uint64_t v15 = 0;
  v19[0] = v5;
  v19[1] = v15;
  uint64_t v16 = *a1;
  uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v19);
}

uint64_t mlir::anec::Padding::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v80[23] = *MEMORY[0x1E4F143B8];
  uint64_t v72 = a6;
  LOBYTE(v73) = 0;
  char v74 = 0;
  uint64_t v75 = a7;
  uint64_t v76 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v72);
    if (v74) {
      char v74 = 0;
    }
    mlir::OperationName::OperationName(&v73, "anec.padding", 12, Context);
    char v74 = 1;
  }
  uint64_t v77 = a4;
  uint64_t v78 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  uint64_t v18 = a3;
  if (a3) {
    uint64_t v19 = (uint64_t)a2;
  }
  else {
    uint64_t v19 = v17;
  }
  if (!mlir::anec::PaddingAdaptor::verify(&v72, v19)) {
    return 0;
  }
  unint64_t v20 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v21 = v20;
  if (!v20) {
    goto LABEL_18;
  }
  uint64_t v22 = *v20;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_18;
  }
  int8x16_t v25 = *(void **)(v22 + 8);
  int8x16_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    uint64_t v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    unsigned long long v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      int8x16_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_18:
  }
    uint64_t v31 = 0;
  v63[0] = v21;
  v63[1] = v31;
  uint64_t ArgAttrsAttr = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v63);
  uint64_t v33 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v63);
  unint64_t v35 = (unsigned char *)(v33 + 8 * v34);
  BOOL v69 = v71;
  uint64_t v70 = 0x500000000;
  uint64_t v36 = v35 - ArgAttrsAttr;
  if ((unint64_t)(v35 - ArgAttrsAttr) >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v69, v71, v36 >> 3, 8);
    unsigned int v37 = v70;
    if (v35 == ArgAttrsAttr) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  unsigned int v37 = 0;
  if (v35 != ArgAttrsAttr)
  {
LABEL_24:
    memcpy((char *)v69 + 8 * v37, ArgAttrsAttr, v35 - ArgAttrsAttr);
    unsigned int v37 = v70;
  }
LABEL_25:
  LODWORD(v70) = v37 + ((unint64_t)v36 >> 3);
  uint64_t v66 = v68;
  uint64_t v67 = 0x500000000;
  v64[0] = v65;
  v64[1] = (void *)0x500000000;
  unint64_t v39 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v72) + 16);
  uint64_t v40 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v72);
  unint64_t v41 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v39, (mlir::CallGraphNode *)(v40 - 16), *(void *)(*(void *)(v73 + 96) + 8));
  if (v42) {
    uint64_t v43 = *((void *)v41 + 1);
  }
  else {
    uint64_t v43 = 0;
  }
  mlir::getValues<long long>(v43, (uint64_t)&v66);
  int64x2_t v44 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v72) + 32);
  uint64_t v45 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v72);
  int64x2_t v46 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v44, v45, *(void *)(*(void *)(v73 + 96) + 16));
  if (v47) {
    uint64_t v48 = *((void *)v46 + 1);
  }
  else {
    uint64_t v48 = 0;
  }
  mlir::getValues<long long>(v48, (uint64_t)v64);
  if (v67)
  {
    uint64_t v49 = 0;
    size_t v50 = 0;
    __int16 v51 = v66;
    uint64_t v52 = 16 * v67;
    do
    {
      if (v51[(void)v50] != 8)
      {
        unint64_t v53 = v67;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v63);
        unint64_t ReferenceFormatIndex = mlir::anec::getReferenceFormatIndex(v50, v53, v54);
        if (!v56)
        {
          if (v18)
          {
            mlir::emitError((uint64_t)a2, (uint64_t)&v79);
            if (v79) {
              mlir::Diagnostic::operator<<((uint64_t)v80, "'anec.padding' op attributes are inconsistent with input rank");
            }
            uint64_t v38 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v79);
            if (v79) {
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v79);
            }
            std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v80);
          }
          else
          {
            uint64_t v38 = 0;
          }
          goto LABEL_46;
        }
        *((void *)v69 + ReferenceFormatIndex) += *(void *)((char *)v64[0] + v49 + 8)
                                                 + *(void *)((char *)v64[0] + v49);
      }
      size_t v50 = (mlir::anec *)((char *)v50 + 1);
      v49 += 16;
    }
    while (v52 != v49);
  }
  uint64_t v57 = v69;
  unsigned int v58 = (mlir::AffineMap *)v70;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
  uint64_t v60 = mlir::MemRefType::get(v57, v58, OperandRange, 0, 0, 0);
  uint64_t v61 = *(unsigned int *)(a11 + 8);
  if (v61 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v61 + 1, 8);
    LODWORD(v61) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v61) = v60;
  ++*(_DWORD *)(a11 + 8);
  uint64_t v38 = 1;
LABEL_46:
  if (v64[0] != v65) {
    free(v64[0]);
  }
  if (v66 != v68) {
    free(v66);
  }
  if (v69 != v71) {
    free(v69);
  }
  return v38;
}

uint64_t mlir::anec::PaddingAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v53 = *a1;
  for (uint64_t i = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v53);
        ;
        uint64_t i = (mlir::CallGraphNode *)((char *)i + 16))
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v53))
    {
      uint64_t v5 = "'anec.padding' op requires attribute 'background_value'";
      goto LABEL_65;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
  }
  uint64_t v6 = (uint64_t *)*((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v53))
    {
      uint64_t v5 = "'anec.padding' op requires attribute 'padding_modes'";
      goto LABEL_65;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  unint64_t v7 = (uint64_t *)*((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v53))
    {
      uint64_t v5 = "'anec.padding' op requires attribute 'padding_sizes'";
      goto LABEL_65;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  unint64_t v8 = (uint64_t *)*((void *)i + 1);
  uint64_t v48 = v8;
  if (v7)
  {
    uint64_t v9 = *v7;
    unint64_t v10 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v11 = *(unsigned int *)(v9 + 16);
    if (!v11) {
      goto LABEL_25;
    }
    uint64_t v12 = *(void **)(v9 + 8);
    unint64_t v13 = &v12[2 * v11];
    do
    {
      unint64_t v14 = v11 >> 1;
      uint64_t v15 = &v12[2 * (v11 >> 1)];
      unint64_t v17 = *v15;
      uint64_t v16 = v15 + 2;
      v11 += ~(v11 >> 1);
      if (v17 < v10) {
        uint64_t v12 = v16;
      }
      else {
        unint64_t v11 = v14;
      }
    }
    while (v11);
    if (v12 != v13 && *v12 == v10) {
      uint64_t v18 = (uint64_t *)v12[1];
    }
    else {
LABEL_25:
    }
      uint64_t v18 = 0;
    v45[0] = v7;
    v45[1] = v18;
    Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
    unint64_t v20 = Type;
    if (!Type) {
      goto LABEL_35;
    }
    uint64_t v21 = *Type;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_35;
    }
    unint64_t v24 = *(void **)(v21 + 8);
    int8x16_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      unint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      uint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        unint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_35:
    }
      uint64_t v30 = 0;
    uint64_t Value = (uint64_t)v20;
    uint64_t v47 = v30;
    uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
    uint64_t OperandRange = 5;
    if (v32 != 1 || *ArgAttrsAttr != OperandRange)
    {
LABEL_38:
      uint64_t v5 = "'anec.padding' op attribute 'padding_modes' failed to satisfy constraint: PaddingMode elements attribute of shape {5}";
      goto LABEL_65;
    }
    int64x2_t v44 = v7;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v55, (uint64_t)v7, 0);
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)v7, NumElements);
    while (1)
    {
      BOOL v35 = v55 == v49 && v56 == v50;
      if (v35 && v57 == v51) {
        break;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v55, (llvm::APInt *)&v58);
      if (DWORD2(v58) > 0x40)
      {
        unint64_t v34 = *(void *)v58;
        operator delete[]((void *)v58);
        if (v34 > 8) {
          goto LABEL_38;
        }
      }
      else if ((unint64_t)((uint64_t)((void)v58 << -BYTE8(v58)) >> -BYTE8(v58)) > 8)
      {
        goto LABEL_38;
      }
      ++v57;
    }
  }
  if (!v8) {
    goto LABEL_74;
  }
  if (mlir::DenseIntElementsAttr::classof((uint64_t)v8))
  {
    uint64_t v49 = mlir::Attribute::cast<mlir::ElementsAttr>(&v48);
    uint64_t v50 = v36;
    v45[0] = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v49);
    unint64_t v55 = mlir::Type::cast<mlir::ShapedType>(v45);
    uint64_t v56 = v37;
    uint64_t v38 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v55);
    long long v58 = xmmword_1810FE2F0;
    if (v39 == 2 && *v38 == (void)v58 && v38[1] == *((void *)&v58 + 1))
    {
      int64x2_t v44 = v48;
      uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v44);
      uint64_t v47 = v41;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&Value);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      {
LABEL_74:
        if (!v6) {
          return 1;
        }
        if (*(_UNKNOWN **)(*v6 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
        {
          uint64_t v49 = v6;
          unint64_t v55 = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v49);
          if (mlir::Type::isF16((mlir::Type *)&v55)) {
            return 1;
          }
        }
        uint64_t v49 = (uint64_t *)"'anec.padding' op attribute 'background_value' failed to satisfy constraint: 16-bit float attribute";
        __int16 v52 = 259;
        mlir::emitError(a2, (uint64_t)&v49, (uint64_t)&v55);
        uint64_t v42 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v55);
        mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v55);
        return v42;
      }
    }
  }
  uint64_t v5 = "'anec.padding' op attribute 'padding_sizes' failed to satisfy constraint: ui64 elements attribute of shape {5, 2}";
LABEL_65:
  uint64_t v49 = (uint64_t *)v5;
  __int16 v52 = 259;
  mlir::emitError(a2, (uint64_t)&v49, (uint64_t)&v55);
  uint64_t v42 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v55);
  if (v55) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v55);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v56);
  return v42;
}

void mlir::anec::Padding::getZinIrUnitInfo(mlir::anec::Padding *this@<X0>, void *a2@<X8>)
{
  void v68[6] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (char *)operator new(0xE8uLL);
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *((_OWORD *)v3 + 10) = 0u;
  *((_OWORD *)v3 + 11) = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 12) = 0u;
  *((_OWORD *)v3 + 13) = 0u;
  *((void *)v3 + 27) = 0;
  *((void *)v3 + 28) = 0;
  *((void *)v3 + 9) = -1;
  *(_OWORD *)(v3 + 138) = 0u;
  *(void *)uint64_t v3 = &unk_1EC995778;
  *(_OWORD *)(v3 + 156) = 0u;
  *(_OWORD *)(v3 + 172) = 0u;
  *(void *)(v3 + 188) = 0;
  *((void *)v3 + 25) = 0;
  uint64_t v56 = (char **)(v3 + 200);
  *((_WORD *)v3 + 112) = 0;
  *((void *)v3 + 26) = 0;
  uint64_t v66 = (char *)v68;
  uint64_t v67 = 0x600000000;
  uint64_t PaddingAttr = mlir::anec::L2NormPool::getPaddingAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(PaddingAttr, (uint64_t)&v66);
  BOOL v63 = v65;
  uint64_t v64 = 0x300000000;
  uint64_t StrideAttr = mlir::anec::L2NormPool::getStrideAttr((mlir::Operation **)this);
  mlir::getListOfPairs<unsigned long long>(&StrideAttr, (uint64_t)&v63);
  uint64_t v5 = (int32x4_t *)((char *)v63 + 16 * v64);
  *(int32x4_t *)(v3 + 156) = vuzp1q_s32(v5[-1], v5[-2]);
  *(int32x2_t *)(v3 + 180) = vmovn_s64((int64x2_t)v5[-3]);
  unint64_t v55 = this;
  uint64_t v6 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  unint64_t v10 = *(void **)(v7 + 8);
  unint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    unint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      unint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v60[0] = v6;
  v60[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v60);
  unint64_t v17 = (int64x2_t *)v63;
  if (v18 == 5) {
    *(int32x2_t *)(v3 + 172) = vmovn_s64(*((int64x2_t *)v63 + v64 - 4));
  }
  *(int32x2_t *)(v3 + 188) = vmovn_s64(*v17);
  if (v67)
  {
    uint64_t v19 = 0;
    unint64_t v20 = v66;
    uint64_t v21 = &v66[8 * v67];
    while (1)
    {
      if (*v20 == 8) {
        goto LABEL_17;
      }
      uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v19, v67);
      uint64_t v24 = (DimFromIndex & 0xFF00000000) != 0 ? qword_1810FE468[(int)DimFromIndex] : 5;
      uint64_t v25 = qword_1810FE428[*v20];
      unint64_t v27 = (char *)*((void *)v3 + 26);
      unint64_t v26 = *((void *)v3 + 27);
      if ((unint64_t)v27 >= v26) {
        break;
      }
      *(void *)unint64_t v27 = v25 | v24;
      unint64_t v22 = v27 + 8;
LABEL_16:
      *((void *)v3 + 26) = v22;
LABEL_17:
      uint64_t v19 = (mlir::anec *)((char *)v19 + 1);
      if (++v20 == (void *)v21) {
        goto LABEL_44;
      }
    }
    uint64_t v28 = v3;
    unint64_t v29 = v21;
    uint64_t v30 = *v56;
    uint64_t v31 = v27 - *v56;
    uint64_t v32 = v31 >> 3;
    unint64_t v33 = (v31 >> 3) + 1;
    if (v33 >> 61) {
      abort();
    }
    uint64_t v34 = v26 - (void)v30;
    if (v34 >> 2 > v33) {
      unint64_t v33 = v34 >> 2;
    }
    if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v33 = 0x1FFFFFFFFFFFFFFFLL;
    }
    unint64_t v57 = v33;
    if (v33)
    {
      if (v33 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      BOOL v35 = operator new(8 * v33);
    }
    else
    {
      BOOL v35 = 0;
    }
    uint64_t v36 = (uint64_t *)&v35[8 * v32];
    uint64_t *v36 = v25 | v24;
    unint64_t v22 = v36 + 1;
    if (v27 == v30)
    {
      uint64_t v21 = v29;
      uint64_t v3 = v28;
      goto LABEL_42;
    }
    unint64_t v37 = v27 - v30 - 8;
    if (v37 >= 0x58)
    {
      unint64_t v38 = v27 - v35 - v31;
      uint64_t v21 = v29;
      uint64_t v3 = v28;
      if (v38 >= 0x20)
      {
        uint64_t v39 = (v37 >> 3) + 1;
        uint64_t v40 = 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v41 = &v27[-v40];
        uint64_t v36 = (uint64_t *)((char *)v36 - v40);
        uint64_t v42 = &v35[8 * v32 - 16];
        uint64_t v43 = v27 - 16;
        uint64_t v44 = v39 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v45 = *(_OWORD *)v43;
          *(v42 - 1) = *((_OWORD *)v43 - 1);
          *uint64_t v42 = v45;
          v42 -= 2;
          v43 -= 32;
          v44 -= 4;
        }
        while (v44);
        unint64_t v27 = v41;
        if (v39 == (v39 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_41;
        }
      }
    }
    else
    {
      uint64_t v21 = v29;
      uint64_t v3 = v28;
    }
    do
    {
      uint64_t v46 = *((void *)v27 - 1);
      v27 -= 8;
      *--uint64_t v36 = v46;
    }
    while (v27 != v30);
LABEL_41:
    unint64_t v27 = *v56;
LABEL_42:
    *((void *)v3 + 25) = v36;
    *((void *)v3 + 26) = v22;
    *((void *)v3 + 27) = &v35[8 * v57];
    if (v27) {
      operator delete(v27);
    }
    goto LABEL_16;
  }
LABEL_44:
  long long __p = (void *)mlir::anec::L2NormPool::getKsizeAttr((mlir::Operation **)v55);
  uint64_t Value = mlir::FloatAttr::getValue((mlir::FloatAttr *)&__p, (uint64_t)&StrideAttr);
  uint64_t v48 = (void *)v62[0];
  uint64_t v49 = llvm::APFloatBase::PPCDoubleDouble(Value);
  if (v49 == v48) {
    llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v62, (llvm::APInt *)&__p);
  }
  else {
    llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)v62, (uint64_t)&__p);
  }
  unsigned int v50 = v59;
  if (v59 < 0x41)
  {
    uint64_t v51 = a2;
    if ((unint64_t)__p < 0x10000) {
      *((_WORD *)v3 + 112) = (_WORD)__p;
    }
    else {
      *((_WORD *)v3 + 112) = -1;
    }
    goto LABEL_58;
  }
  unsigned int v52 = v50 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p);
  uint64_t v53 = __p;
  if (v52 <= 0x40)
  {
    uint64_t v51 = a2;
    if (*(void *)__p < 0x10000uLL) {
      *((_WORD *)v3 + 112) = *(void *)__p;
    }
    else {
      *((_WORD *)v3 + 112) = -1;
    }
    goto LABEL_57;
  }
  *((_WORD *)v3 + 112) = -1;
  uint64_t v51 = a2;
  if (v53) {
LABEL_57:
  }
    operator delete[](v53);
LABEL_58:
  if (v49 == (void *)v62[0]) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v62);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v62);
  }
  void *v51 = v3;
  if (v63 != v65) {
    free(v63);
  }
  if (v66 != (char *)v68) {
    free(v66);
  }
}

llvm::detail::DoubleAPFloat *mlir::anec::Padding::getBackgroundValue@<X0>(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t KsizeAttr = mlir::anec::L2NormPool::getKsizeAttr(this);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&KsizeAttr, a2);
}

uint64_t mlir::anec::Padding::addOpToNetwork(mlir::anec::Padding *a1, uint64_t a2)
{
  mlir::anec::Padding::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    unint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::Padding::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v63[63] = *MEMORY[0x1E4F143B8];
  unsigned int v59 = v61;
  uint64_t v60 = 0x600000000;
  uint64_t PaddingAttr = mlir::anec::L2NormPool::getPaddingAttr(a1);
  mlir::getValues<unsigned long long>(PaddingAttr, (uint64_t)&v59);
  v57[0] = v58;
  v57[1] = (void *)0x300000000;
  *(void *)buffer = mlir::anec::L2NormPool::getStrideAttr(a1);
  mlir::getListOfPairs<unsigned long long>((uint64_t *)buffer, (uint64_t)v57);
  ANECPadLayerDescInitialize();
  long long __p = (void *)mlir::anec::L2NormPool::getKsizeAttr(a1);
  uint64_t Value = mlir::FloatAttr::getValue((mlir::FloatAttr *)&__p, (uint64_t)buffer);
  unint64_t v8 = (void *)v63[0];
  uint64_t v9 = llvm::APFloatBase::PPCDoubleDouble(Value);
  if (v9 == v8) {
    llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)v63, (llvm::APInt *)&__p);
  }
  else {
    llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)v63, (uint64_t)&__p);
  }
  int v10 = v48;
  if (v48 >= 0x41)
  {
    if (v10 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      _H0 = *(void *)__p;
      __asm { FCVT            S0, H0 }
      if (*(void *)__p >> 16) {
        _S0 = NAN;
      }
      int v46 = LODWORD(_S0);
    }
    else
    {
      int v46 = -8192;
      if (!__p) {
        goto LABEL_15;
      }
    }
    operator delete[](__p);
    goto LABEL_15;
  }
  if ((unint64_t)__p < 0x10000)
  {
    _H0 = (__int16)__p;
    __asm { FCVT            S0, H0 }
    int v46 = _S0;
  }
  else
  {
    int v46 = -8192;
  }
LABEL_15:
  if (v9 != (void *)v63[0])
  {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v63);
    unint64_t v19 = v60;
    if (v60) {
      goto LABEL_17;
    }
LABEL_22:
    int v21 = 0;
    goto LABEL_23;
  }
  llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v63);
  unint64_t v19 = v60;
  if (!v60) {
    goto LABEL_22;
  }
LABEL_17:
  unint64_t v20 = 0;
  int v21 = 0;
  unint64_t v22 = v59;
  do
  {
    if (v22[v20] != 8)
    {
      unint64_t v22 = v59;
      int32x2_t v24 = (int32x2_t)*(&off_1E4FBF0D0 + *((void *)v59 + v20));
      uint64_t v25 = (int64x2_t *)v57[0];
      unint64_t v26 = (int32x2_t *)&v45[3 * v21];
      v26[1] = (int32x2_t)ANECDimension;
      void v26[2] = v24;
      v26[3] = vmovn_s64(v25[v20]);
      unint64_t v19 = v60;
      ++v21;
    }
    ++v20;
  }
  while (v20 < v19);
LABEL_23:
  v45[0] = v21;
  v55[0] = v56;
  v55[1] = (void *)0x100000000;
  *(void *)buffer = 1;
  long long __p = 0;
  ANECUnitValidatorCreate();
  uint64_t v43 = 0;
  uint64_t v44 = 0;
  if (ANECValidatePadLayer())
  {
    unint64_t v37 = (void *)(MEMORY[0x1E4FBA488] + 24);
    unint64_t v38 = *a1;
    uint64_t v27 = MEMORY[0x1E4FBA488] + 104;
    v54[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v28 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v49 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v29 = MEMORY[0x1E4FBA408];
    uint64_t v30 = *(void **)(MEMORY[0x1E4FBA408] + 24);
    long long __p = *(void **)(MEMORY[0x1E4FBA408] + 16);
    *(void **)((char *)&__p + *((void *)__p - 3)) = v30;
    uint64_t v48 = 0;
    uint64_t v31 = (std::ios_base *)((char *)&__p + *((void *)__p - 3));
    std::ios_base::init(v31, v50);
    v31[1].__vftable = 0;
    v31[1].__fmtflags_ = -1;
    uint64_t v32 = *(void *)(v29 + 40);
    uint64_t v49 = *(void *)(v29 + 32);
    *(uint64_t *)((char *)&v50[-1] + *(void *)(v49 - 24)) = v32;
    long long __p = *(void **)(v29 + 8);
    *(void **)((char *)&__p + *((void *)__p - 3)) = *(void **)(v29 + 48);
    v54[0] = v27;
    long long __p = v37;
    uint64_t v49 = v28;
    std::streambuf::basic_streambuf();
    uint64_t v33 = MEMORY[0x1E4FBA470] + 16;
    v50[0] = MEMORY[0x1E4FBA470] + 16;
    long long v51 = 0u;
    long long v52 = 0u;
    int v53 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v49, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    long long __p = *(void **)v29;
    uint64_t v34 = *(void *)(v29 + 72);
    *(void **)((char *)&__p + *((void *)__p - 3)) = *(void **)(v29 + 64);
    uint64_t v49 = v34;
    v50[0] = v33;
    if (SBYTE7(v52) < 0) {
      operator delete((void *)v51);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v54);
    __int16 v42 = 260;
    uint64_t v41 = &v39;
    uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v63);
    if (v40 < 0) {
      operator delete(v39);
    }
  }
  else
  {
    uint64_t v35 = 1;
  }
  ANECUnitValidatorDelete();
  if (v55[0] != v56) {
    free(v55[0]);
  }
  if (v57[0] != v58) {
    free(v57[0]);
  }
  if (v59 != v61) {
    free(v59);
  }
  return v35;
}

uint64_t mlir::anec::MatMul::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  uint64_t v72 = a6;
  v73[0] = 0;
  char v74 = 0;
  uint64_t v75 = a7;
  uint64_t v76 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v72);
    if (v74) {
      char v74 = 0;
    }
    mlir::OperationName::OperationName(v73, "anec.matmul", 11, Context);
    char v74 = 1;
  }
  uint64_t v77 = a4;
  uint64_t v78 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::MatMulAdaptor::verify(&v72, v18)) {
    return 0;
  }
  unint64_t v19 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  unint64_t v20 = v19;
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v21 = *v19;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_18;
  }
  int32x2_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      int32x2_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_18:
  }
    uint64_t v30 = 0;
  v67[0] = v20;
  v67[1] = v30;
  uint64_t v31 = (void *)mlir::TypeRange::dereference_iterator(a9, 1);
  uint64_t v32 = v31;
  if (!v31) {
    goto LABEL_28;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_28;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  unint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    uint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    char v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_28:
  }
    uint64_t v42 = 0;
  v66[0] = v32;
  v66[1] = v42;
  uint64_t ArgAttrsAttr = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v67);
  uint64_t v44 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v66);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v67);
  unint64_t v46 = v45;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(0, v45);
  unint64_t v48 = mlir::anec::getIndexFromDim(2, v46);
  char v50 = v49;
  int v51 = 1;
  unint64_t v52 = mlir::anec::getIndexFromDim(1, v46);
  unint64_t v53 = mlir::anec::getIndexFromDim(3, v46);
  unint64_t v54 = mlir::anec::getIndexFromDim(4, v46);
  int v68 = v71;
  unsigned int v70 = 5;
  if (*(void *)(ArgAttrsAttr + 8 * IndexFromDim) == 1) {
    uint64_t v55 = v44;
  }
  else {
    uint64_t v55 = ArgAttrsAttr;
  }
  v71[0] = *(void *)(v55 + 8 * IndexFromDim);
  if (v50)
  {
    v71[1] = *(void *)(ArgAttrsAttr + 8 * v48);
    int v51 = 2;
  }
  uint64_t v56 = *(void *)(ArgAttrsAttr + 8 * v53);
  v71[v51] = *(void *)(ArgAttrsAttr + 8 * v52);
  if (v56 == 1) {
    uint64_t v57 = v44;
  }
  else {
    uint64_t v57 = ArgAttrsAttr;
  }
  v71[v51 + 1] = *(void *)(v57 + 8 * v53);
  uint64_t v58 = (v51 + 2);
  int v69 = v58;
  uint64_t v59 = *(void *)(v44 + 8 * v54);
  if (v58 >= v70)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v58 + 1, 8);
    LODWORD(v58) = v69;
  }
  *((void *)v68 + v58) = v59;
  uint64_t v60 = (mlir::AffineMap *)++v69;
  uint64_t v61 = v68;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v67);
  uint64_t v63 = mlir::MemRefType::get(v61, v60, OperandRange, 0, 0, 0);
  uint64_t v64 = *(unsigned int *)(a11 + 8);
  if (v64 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v64 + 1, 8);
    LODWORD(v64) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v64) = v63;
  ++*(_DWORD *)(a11 + 8);
  if (v68 != v71) {
    free(v68);
  }
  return 1;
}

uint64_t mlir::anec::MatMulAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v12[23] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = *a1;
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v10);
  if (Value == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v10)) {
    return 1;
  }
  uint64_t v5 = 0;
  do
  {
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(Value)) {
      uint64_t v5 = *((void *)Value + 1);
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
  }
  while (Value != (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v10));
  if (!v5) {
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v5 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v8[0] = v5;
    uint64_t v11 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v8);
    if (mlir::Type::isF16((mlir::Type *)&v11)) {
      return 1;
    }
  }
  v8[0] = "'anec.matmul' op attribute 'bias' failed to satisfy constraint: 16-bit float attribute";
  __int16 v9 = 259;
  mlir::emitError(a2, (uint64_t)v8, (uint64_t)&v11);
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v11);
  if (v11) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v11);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v12);
  return v6;
}

void mlir::anec::MatMul::getZinIrUnitInfo(mlir::anec::MatMul *this@<X0>, void *a2@<X8>)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0x58uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995D40;
  *((void *)v4 + 1) = 0;
  v4[80] = 0;
  v4[80] = 0;
  mlir::anec::MatMul::getBias((mlir::Operation **)this, (uint64_t)&v16);
  if (v18)
  {
    uint64_t v6 = (void *)v17[0];
    uint64_t v7 = llvm::APFloatBase::PPCDoubleDouble(v5);
    if (v7 == v6) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v17);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v17);
    }
    v4[80] = 1;
    if (*(_DWORD *)(*(void *)this + 36)) {
      uint64_t v8 = *(void *)this - 16;
    }
    else {
      uint64_t v8 = 0;
    }
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
    uint64_t ElementTypeOrSelf = mlir::getElementTypeOrSelf(NextResultAtOffset);
    if (mlir::Type::isF16((mlir::Type *)&ElementTypeOrSelf))
    {
      mlir::anec::MatMul::getBias((mlir::Operation **)this, (uint64_t)&v16);
      _S0 = llvm::APFloat::convertToFloat(&v16);
      __asm { FCVT            H0, S0 }
      *((_WORD *)v4 + 41) = LOWORD(_S0);
      if (!v18) {
        goto LABEL_17;
      }
      goto LABEL_14;
    }
    if (!mlir::Type::isSignedInteger((mlir::Type *)&ElementTypeOrSelf, 8)) {
      mlir::Type::isUnsignedInteger((mlir::Type *)&ElementTypeOrSelf, 8);
    }
    mlir::anec::MatMul::getBias((mlir::Operation **)this, (uint64_t)&v16);
    v4[82] = (int)llvm::APFloat::convertToFloat(&v16);
    if (v18)
    {
LABEL_14:
      if (v7 == (void *)v17[0]) {
        llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v17);
      }
      else {
        llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v17);
      }
    }
  }
LABEL_17:
  *a2 = v4;
}

void mlir::anec::MatMul::getBias(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v8[3] = *MEMORY[0x1E4F143B8];
  uint64_t BiasAttr = mlir::anec::MatMul::getBiasAttr(this);
  if (BiasAttr)
  {
    uint64_t Value = mlir::FloatAttr::getValue((mlir::FloatAttr *)&BiasAttr, (uint64_t)v7);
    uint64_t v4 = (void *)v8[0];
    uint64_t v5 = llvm::APFloatBase::PPCDoubleDouble(Value);
    if (v5 == v4) {
      llvm::detail::DoubleAPFloat::DoubleAPFloat((void *)(a2 + 8), v8);
    }
    else {
      llvm::detail::IEEEFloat::IEEEFloat(a2 + 8, (uint64_t)v8);
    }
    *(unsigned char *)(a2 + 32) = 1;
    if (v5 == (void *)v8[0]) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v8);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v8);
    }
  }
  else
  {
    *(unsigned char *)a2 = 0;
    *(unsigned char *)(a2 + 32) = 0;
  }
}

uint64_t mlir::anec::MatMul::addOpToNetwork(mlir::anec::MatMul *a1, uint64_t a2)
{
  mlir::anec::MatMul::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

BOOL mlir::anec::MatMul::getExecutionCost(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(*a1 + 72);
  uint64_t v5 = *(void *)(v4 + 56);
  long long v6 = (uint64_t *)(*(void *)(*(void *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    unint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v34[0] = v6;
  v34[1] = v16;
  uint64_t v17 = (uint64_t *)(*(void *)(v5 + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v17) {
    goto LABEL_20;
  }
  uint64_t v18 = *v17;
  unint64_t v19 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v20 = *(unsigned int *)(v18 + 16);
  if (!v20) {
    goto LABEL_20;
  }
  uint64_t v21 = *(void **)(v18 + 8);
  unint64_t v22 = &v21[2 * v20];
  do
  {
    unint64_t v23 = v20 >> 1;
    int32x2_t v24 = &v21[2 * (v20 >> 1)];
    unint64_t v26 = *v24;
    uint64_t v25 = v24 + 2;
    v20 += ~(v20 >> 1);
    if (v26 < v19) {
      uint64_t v21 = v25;
    }
    else {
      unint64_t v20 = v23;
    }
  }
  while (v20);
  if (v21 != v22 && *v21 == v19) {
    uint64_t v27 = v21[1];
  }
  else {
LABEL_20:
  }
    uint64_t v27 = 0;
  v33[0] = v17;
  v33[1] = v27;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v33);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v34);
  unint64_t v29 = v28;
  mlir::anec::getIndexFromDim(0, v28);
  mlir::anec::getIndexFromDim(1, v29);
  mlir::anec::getIndexFromDim(3, v29);
  mlir::anec::getIndexFromDim(4, v29);
  uint64_t v30 = *a1;
  uint64_t OperandRange = (void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v34);
}

uint64_t mlir::anec::MatMul::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  ANECMatrixMultLayerDescInitialize();
  if (*((_DWORD *)*a1 + 9)) {
    uint64_t v6 = (uint64_t)*a1 - 16;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_13;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_13;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  unint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_13:
  }
    uint64_t v17 = 0;
  v41[0] = v7;
  v41[1] = v17;
  mlir::anec::MatMul::getBias(a1, (uint64_t)buffer);
  char v42 = v55;
  if (v55)
  {
    unint64_t v19 = (void *)v54[0];
    if (llvm::APFloatBase::PPCDoubleDouble(v18) == v19) {
      llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v54);
    }
    else {
      llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v54);
    }
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v41);
  unsigned int IndexFromDim = mlir::anec::getIndexFromDim(1, v20);
  if (!v22) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v43 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v41) + 8 * IndexFromDim);
  v51[0] = v52;
  v51[1] = (void *)0x100000000;
  *(void *)buffer = 1;
  v44[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v39 = 0;
  uint64_t v40 = 0;
  if (ANECValidateMatrixMultLayer())
  {
    uint64_t v33 = MEMORY[0x1E4FBA488] + 24;
    unint64_t v34 = *a1;
    uint64_t v23 = MEMORY[0x1E4FBA488] + 104;
    v50[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v24 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v45 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v25 = (void *)MEMORY[0x1E4FBA408];
    uint64_t v26 = *(void *)(MEMORY[0x1E4FBA408] + 24);
    v44[0] = *(void *)(MEMORY[0x1E4FBA408] + 16);
    *(void *)((char *)v44 + *(void *)(v44[0] - 24)) = v26;
    v44[1] = 0;
    uint64_t v27 = (std::ios_base *)((char *)v44 + *(void *)(v44[0] - 24));
    std::ios_base::init(v27, v46);
    v27[1].__vftable = 0;
    v27[1].__fmtflags_ = -1;
    uint64_t v28 = v25[5];
    uint64_t v45 = v25[4];
    *(uint64_t *)((char *)&v46[-1] + *(void *)(v45 - 24)) = v28;
    v44[0] = v25[1];
    *(void *)((char *)v44 + *(void *)(v44[0] - 24)) = v25[6];
    v50[0] = v23;
    v44[0] = v33;
    uint64_t v45 = v24;
    std::streambuf::basic_streambuf();
    uint64_t v29 = MEMORY[0x1E4FBA470] + 16;
    v46[0] = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v48 = 0u;
    int v49 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v45, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v44[0] = *v25;
    uint64_t v30 = v25[9];
    *(void *)((char *)v44 + *(void *)(v44[0] - 24)) = v25[8];
    uint64_t v45 = v30;
    v46[0] = v29;
    if (SBYTE7(v48) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v50);
    __int16 v38 = 260;
    unint64_t v37 = &v35;
    uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v54);
    if (v36 < 0) {
      operator delete(v35);
    }
  }
  else
  {
    uint64_t v31 = 1;
  }
  ANECUnitValidatorDelete();
  if (v51[0] != v52) {
    free(v51[0]);
  }
  return v31;
}

uint64_t mlir::anec::Flatten::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  uint64_t v64 = a6;
  v65[0] = 0;
  char v66 = 0;
  uint64_t v67 = a7;
  uint64_t v68 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v64);
    if (v66) {
      char v66 = 0;
    }
    mlir::OperationName::OperationName(v65, "anec.flatten", 12, Context);
    char v66 = 1;
  }
  uint64_t v69 = a4;
  uint64_t v70 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::FlattenAdaptor::verify(&v64, v18)) {
    return 0;
  }
  unint64_t v19 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  unint64_t v20 = v19;
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v21 = *v19;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_18;
  }
  uint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      uint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_18:
  }
    uint64_t v30 = 0;
  v57[0] = v20;
  v57[1] = v30;
  uint64_t ArgAttrsAttr = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v57);
  uint64_t v32 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v57);
  unint64_t v34 = (unsigned char *)(v32 + 8 * v33);
  uint64_t v61 = v63;
  uint64_t v62 = 0x500000000;
  uint64_t v35 = v34 - ArgAttrsAttr;
  if ((unint64_t)(v34 - ArgAttrsAttr) >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v35 >> 3, 8);
    unsigned int v36 = v62;
    if (v34 == ArgAttrsAttr) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  unsigned int v36 = 0;
  if (v34 != ArgAttrsAttr)
  {
LABEL_24:
    memcpy((char *)v61 + 8 * v36, ArgAttrsAttr, v34 - ArgAttrsAttr);
    unsigned int v36 = v62;
  }
LABEL_25:
  LODWORD(v62) = v36 + ((unint64_t)v35 >> 3);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v57);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v38);
  if (!v40)
  {
    char v55 = (uint64_t *)std::__throw_bad_optional_access[abi:nn180100]();
    return mlir::anec::FlattenAdaptor::verify(v55, v56);
  }
  unint64_t v41 = IndexFromDim;
  mlir::anec::getAllDims((uint64_t)&v58);
  char v42 = (unsigned int *)v58;
  if (!v59) {
    goto LABEL_35;
  }
  uint64_t v43 = 4 * v59;
  uint64_t v44 = 8 * v41;
  do
  {
    unsigned int v46 = *v42;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v57);
    unint64_t v48 = mlir::anec::getIndexFromDim(v46, v47);
    if (v46 == 2)
    {
      if (!v49) {
        goto LABEL_30;
      }
LABEL_29:
      uint64_t v45 = v61;
      *(void *)((char *)v61 + v44) *= *((void *)v61 + v48);
      v45[v48] = 1;
      goto LABEL_30;
    }
    if (v46 >= 2) {
      goto LABEL_29;
    }
LABEL_30:
    ++v42;
    v43 -= 4;
  }
  while (v43);
  char v42 = (unsigned int *)v58;
LABEL_35:
  if (v42 != (unsigned int *)&v60) {
    free(v42);
  }
  char v50 = v61;
  int v51 = (mlir::AffineMap *)v62;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v57);
  uint64_t v53 = mlir::MemRefType::get(v50, v51, OperandRange, 0, 0, 0);
  uint64_t v54 = *(unsigned int *)(a11 + 8);
  if (v54 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v54 + 1, 8);
    LODWORD(v54) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v54) = v53;
  ++*(_DWORD *)(a11 + 8);
  if (v61 != v63) {
    free(v61);
  }
  return 1;
}

uint64_t mlir::anec::FlattenAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v15[23] = *MEMORY[0x1E4F143B8];
  uint64_t v11 = *a1;
  for (uint64_t i = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v11);
        ;
        uint64_t i = (mlir::CallGraphNode *)((char *)i + 16))
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v11))
    {
      uint64_t v5 = "'anec.flatten' op requires attribute 'flatten_mode'";
      goto LABEL_6;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
  }
  uint64_t v8 = *((void *)i + 1);
  if (!v8) {
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v9[0] = *((void *)i + 1);
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v9);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&Value, 64))
    {
      uint64_t v13 = v8;
      if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v13) == 1) {
        return 1;
      }
      uint64_t v12 = v8;
      if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v12) == 2) {
        return 1;
      }
    }
  }
  uint64_t v5 = "'anec.flatten' op attribute 'flatten_mode' failed to satisfy constraint: valid FlattenMode";
LABEL_6:
  v9[0] = v5;
  __int16 v10 = 259;
  mlir::emitError(a2, (uint64_t)v9, (uint64_t)&Value);
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v15);
  return v6;
}

uint64_t mlir::anec::Flatten::getFlattenMode(mlir::Operation **this)
{
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(this);
  return mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&MultipliersAttr);
}

uint64_t mlir::anec::Flatten::addOpToNetwork(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = (char *)operator new(0x58uLL);
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995B70;
  *((_DWORD *)v4 + 20) = 0;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr((mlir::Operation **)a1);
  if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&MultipliersAttr) == 1) {
    int v5 = 1;
  }
  else {
    int v5 = 2;
  }
  *((_DWORD *)v4 + 20) = v5;
  uint64_t v6 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v6->__shared_owners_ = 0;
  v6->__shared_weak_owners_ = 0;
  v6->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v6[1].__shared_owners_;
  if (v4[31] < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *((const std::string::value_type **)v4 + 1), *((void *)v4 + 2));
  }
  else
  {
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = *(_OWORD *)(v4 + 8);
    v6[2].__vftable = (std::__shared_weak_count_vtbl *)*((void *)v4 + 3);
  }
  LODWORD(v6[2].__shared_owners_) = 17;
  v6[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v6[2].__shared_weak_owners_ = (uint64_t)v4;
  LOBYTE(v6[3].__vftable) = 0;
  v6[3].__shared_owners_ = 0;
  v6[3].__shared_weak_owners_ = (uint64_t)&v6[4].__shared_owners_;
  v6[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v6[5].__shared_weak_owners_ = (uint64_t)&v6[6].__shared_owners_;
  v6[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v11 = v6 + 1;
  *((void *)&v11 + 1) = v6;
  uint64_t v8 = *(void **)(a2 + 232);
  if ((unint64_t)v8 >= *(void *)(a2 + 240))
  {
    unint64_t v9 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v11);
    uint64_t v6 = (std::__shared_weak_count *)*((void *)&v11 + 1);
    *(void *)(a2 + 232) = v9;
    if (!v6) {
      return 1;
    }
  }
  else
  {
    void *v8 = v6 + 1;
    v8[1] = v6;
    atomic_fetch_add_explicit(&v6->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v8 + 2;
  }
  if (!atomic_fetch_add(&v6->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
    std::__shared_weak_count::__release_weak(v6);
  }
  return 1;
}

uint64_t mlir::anec::Flatten::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  ANECFlattenLayerDescInitialize();
  *(void *)buffer = mlir::anec::Tile::getMultipliersAttr(a1);
  uint64_t Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)buffer);
  *(_OWORD *)buffer = xmmword_1E4FBF000;
  v61[0] = unk_1E4FBF010;
  char v50 = 0;
  uint64_t v51 = 0;
  char v49 = (void **)&v50;
  uint64_t v7 = std::__tree<std::__value_type<ZinIrDimension,__CFString const*>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,__CFString const*>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,__CFString const*>>>::__find_equal<ZinIrDimension>(&v49, (uint64_t *)&v50, (uint64_t **)v58, (uint64_t **)v44, (int *)buffer);
  if (!*v7)
  {
    uint64_t v8 = v7;
    unint64_t v9 = operator new(0x30uLL);
    v9[2] = *(_OWORD *)buffer;
    __int16 v10 = v58[0];
    *(void *)unint64_t v9 = 0;
    *((void *)v9 + 1) = 0;
    *((void *)v9 + 2) = v10;
    uint64_t *v8 = (uint64_t)v9;
    if (*v49)
    {
      char v49 = (void **)*v49;
      long long v11 = (uint64_t *)*v8;
    }
    else
    {
      long long v11 = (uint64_t *)v9;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v50, v11);
    ++v51;
  }
  uint64_t v12 = std::__tree<std::__value_type<ZinIrDimension,__CFString const*>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,__CFString const*>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,__CFString const*>>>::__find_equal<ZinIrDimension>(&v49, (uint64_t *)&v50, (uint64_t **)v58, (uint64_t **)v44, (int *)v61);
  if (!*v12)
  {
    uint64_t v13 = v12;
    unint64_t v14 = operator new(0x30uLL);
    uint64_t v14[2] = v61[0];
    unint64_t v15 = v58[0];
    *(void *)unint64_t v14 = 0;
    *((void *)v14 + 1) = 0;
    *((void *)v14 + 2) = v15;
    *uint64_t v13 = (uint64_t)v14;
    if (*v49)
    {
      char v49 = (void **)*v49;
      unint64_t v16 = (uint64_t *)*v13;
    }
    else
    {
      unint64_t v16 = (uint64_t *)v14;
    }
    std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(v50, v16);
    ++v51;
  }
  if (Int == 1) {
    int v17 = 1;
  }
  else {
    int v17 = 2;
  }
  if (!v50) {
    goto LABEL_24;
  }
  uint64_t v18 = &v50;
  unint64_t v19 = v50;
  do
  {
    unint64_t v20 = v19;
    uint64_t v21 = v18;
    int v22 = *((_DWORD *)v19 + 8);
    if (v22 >= v17) {
      uint64_t v18 = (uint64_t **)v19;
    }
    else {
      ++v19;
    }
    unint64_t v19 = (uint64_t *)*v19;
  }
  while (v19);
  if (v18 == &v50) {
    goto LABEL_24;
  }
  if (v22 < v17) {
    unint64_t v20 = (uint64_t *)v21;
  }
  if (v17 < *((_DWORD *)v20 + 8)) {
LABEL_24:
  }
    uint64_t v18 = &v50;
  unint64_t v23 = v18[5];
  std::__tree<std::__value_type<ZinIrDimension,char>,std::__map_value_compare<ZinIrDimension,std::__value_type<ZinIrDimension,char>,std::less<ZinIrDimension>,true>,std::allocator<std::__value_type<ZinIrDimension,char>>>::destroy((uint64_t)&v49, v50);
  unint64_t v48 = v23;
  v58[0] = v59;
  v58[1] = (void *)0x100000000;
  uint64_t v24 = 1;
  *(void *)buffer = 1;
  char v49 = 0;
  ANECUnitValidatorCreate();
  uint64_t v46 = 0;
  unint64_t v47 = 0;
  if (ANECValidateFlattenLayer())
  {
    uint64_t v25 = v47;
    unint64_t v41 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v42 = v46;
    uint64_t v43 = *a1;
    uint64_t v26 = MEMORY[0x1E4FBA488] + 104;
    v57[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v27 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v51 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v28 = MEMORY[0x1E4FBA408];
    unint64_t v29 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    char v49 = *(void ***)(MEMORY[0x1E4FBA408] + 16);
    *(void ***)((char *)&v49 + (void)*(v49 - 3)) = (void **)v29;
    char v50 = 0;
    uint64_t v30 = (std::ios_base *)((char *)&v49 + (void)*(v49 - 3));
    std::ios_base::init(v30, &v52);
    v30[1].__vftable = 0;
    v30[1].__fmtflags_ = -1;
    uint64_t v31 = *(void *)(v28 + 40);
    uint64_t v51 = *(void *)(v28 + 32);
    *(uint64_t *)((char *)&v51 + *(void *)(v51 - 24)) = v31;
    char v49 = *(void ***)(v28 + 8);
    *(void ***)((char *)&v49 + (void)*(v49 - 3)) = *(void ***)(v28 + 48);
    v57[0] = v26;
    char v49 = (void **)v41;
    uint64_t v51 = v27;
    std::streambuf::basic_streambuf();
    uint64_t v32 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v52 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v55 = 0u;
    int v56 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v51, (uint64_t)"Invalid configuration", 21);
    if (v42)
    {
      if (v25)
      {
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v51, (uint64_t)" for the following reasons: ", 28);
        unint64_t v33 = *v25;
        if (*v25)
        {
          unint64_t v34 = 0;
          do
          {
            unint64_t v35 = v33 - 1;
            CFStringGetCString((CFStringRef)v25[v34 + 1], buffer, 512, 0x8000100u);
            size_t v36 = strlen(buffer);
            unint64_t v37 = std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v51, (uint64_t)buffer, v36);
            if (v34 == v35) {
              unint64_t v38 = "";
            }
            else {
              unint64_t v38 = ", ";
            }
            std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(v37, (uint64_t)v38, 2 * (v34++ != v35));
            unint64_t v33 = *v25;
          }
          while (*v25 > v34);
        }
      }
    }
    std::stringbuf::str();
    char v49 = *(void ***)v28;
    uint64_t v39 = *(void *)(v28 + 72);
    *(void ***)((char *)&v49 + (void)*(v49 - 3)) = *(void ***)(v28 + 64);
    uint64_t v51 = v39;
    uint64_t v52 = v32;
    if (SBYTE7(v55) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v57);
    __int16 v53 = 260;
    char v49 = v44;
    uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&buffer[8]);
    if (v45 < 0) {
      operator delete(v44[0]);
    }
  }
  ANECUnitValidatorDelete();
  if (v58[0] != v59) {
    free(v58[0]);
  }
  return v24;
}

uint64_t mlir::anec::Unflatten::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  uint64_t v60 = a6;
  LOBYTE(v61) = 0;
  char v62 = 0;
  uint64_t v63 = a7;
  uint64_t v64 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v60);
    if (v62) {
      char v62 = 0;
    }
    mlir::OperationName::OperationName(&v61, "anec.unflatten", 14, Context);
    char v62 = 1;
  }
  uint64_t v65 = a4;
  uint64_t v66 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::UnflattenAdaptor::verify(&v60, v18)) {
    return 0;
  }
  unint64_t v19 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  unint64_t v20 = v19;
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v21 = *v19;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_18;
  }
  uint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      uint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_18:
  }
    uint64_t v30 = 0;
  v55[0] = v20;
  v55[1] = v30;
  uint64_t v57 = v59;
  uint64_t v58 = 0x500000000;
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v60);
  uint64_t v32 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v60);
  unint64_t v33 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v32 - 16), **(void **)(v61 + 96));
  if (v34) {
    uint64_t v35 = *((void *)v33 + 1);
  }
  else {
    uint64_t v35 = 0;
  }
  mlir::getValues<long long>(v35, (uint64_t)&v57);
  unint64_t v37 = v57;
  if (v58)
  {
    uint64_t v38 = (v58 - 1) & 0x1FFFFFFFFFFFFFFFLL;
    if (v38)
    {
      uint64_t v39 = v38 + 1;
      uint64_t v40 = (v38 + 1) & 0x3FFFFFFFFFFFFFFELL;
      unint64_t v41 = (uint64_t *)((char *)v57 + 8 * v40);
      uint64_t v42 = (char *)v57 + 8;
      uint64_t v43 = 1;
      uint64_t v44 = v40;
      uint64_t v45 = 1;
      do
      {
        v43 *= *(v42 - 1);
        v45 *= *v42;
        v42 += 2;
        v44 -= 2;
      }
      while (v44);
      unint64_t v46 = v45 * v43;
      if (v39 == v40) {
        goto LABEL_32;
      }
    }
    else
    {
      unint64_t v46 = 1;
      unint64_t v41 = (uint64_t *)v57;
    }
    do
    {
      uint64_t v47 = *v41++;
      v46 *= v47;
    }
    while (v41 != (uint64_t *)((char *)v57 + 8 * v58));
  }
  else
  {
    unint64_t v46 = 1;
  }
LABEL_32:
  uint64_t ArgAttrsAttr = (uint64_t *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  unint64_t v56 = mlir::ShapedType::getNumElements(ArgAttrsAttr, v49) / v46;
  llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v57, (uint64_t)v37, (uint64_t *)&v56);
  char v50 = v57;
  uint64_t v51 = (mlir::AffineMap *)v58;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v55);
  uint64_t v53 = mlir::MemRefType::get(v50, v51, OperandRange, 0, 0, 0);
  uint64_t v54 = *(unsigned int *)(a11 + 8);
  if (v54 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v54 + 1, 8);
    LODWORD(v54) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v54) = v53;
  ++*(_DWORD *)(a11 + 8);
  if (v57 != v59) {
    free(v57);
  }
  return 1;
}

uint64_t mlir::anec::UnflattenAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v43[1] = *MEMORY[0x1E4F143B8];
  uint64_t v40 = *a1;
  for (uint64_t i = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v40);
        ;
        uint64_t i = (mlir::CallGraphNode *)((char *)i + 16))
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v40))
    {
      int v5 = "'anec.unflatten' op requires attribute 'destination_size'";
      goto LABEL_11;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
  }
  uint64_t v6 = (void *)*((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v40))
    {
      int v5 = "'anec.unflatten' op requires attribute 'flatten_mode'";
      goto LABEL_11;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v9 = *((void *)i + 1);
  if (!v9
    || *(_UNKNOWN **)(*(void *)v9 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    && (v38[0] = *((void *)i + 1),
        uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v38),
        mlir::Type::isSignlessInteger((mlir::Type *)&Value, 64))
    && ((v36[0] = v9, mlir::IntegerAttr::getInt((mlir::IntegerAttr *)v36) == 1)
     || (v43[0] = v9, mlir::IntegerAttr::getInt((mlir::IntegerAttr *)v43) == 2)))
  {
    if (!v6) {
      return 1;
    }
    if (mlir::DenseIntElementsAttr::classof((uint64_t)v6))
    {
      uint64_t v10 = *v6;
      unint64_t v11 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v12 = *(unsigned int *)(v10 + 16);
      if (!v12) {
        goto LABEL_30;
      }
      uint64_t v13 = *(void **)(v10 + 8);
      unint64_t v14 = &v13[2 * v12];
      do
      {
        unint64_t v15 = v12 >> 1;
        unint64_t v16 = &v13[2 * (v12 >> 1)];
        unint64_t v18 = *v16;
        uint64_t v17 = v16 + 2;
        v12 += ~(v12 >> 1);
        if (v18 < v11) {
          uint64_t v13 = v17;
        }
        else {
          unint64_t v12 = v15;
        }
      }
      while (v12);
      if (v13 != v14 && *v13 == v11) {
        uint64_t v19 = v13[1];
      }
      else {
LABEL_30:
      }
        uint64_t v19 = 0;
      v38[0] = v6;
      v38[1] = v19;
      Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v38);
      uint64_t v21 = Type;
      if (!Type) {
        goto LABEL_40;
      }
      uint64_t v22 = *Type;
      unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v24 = *(unsigned int *)(v22 + 16);
      if (!v24) {
        goto LABEL_40;
      }
      uint64_t v25 = *(void **)(v22 + 8);
      unint64_t v26 = &v25[2 * v24];
      do
      {
        unint64_t v27 = v24 >> 1;
        uint64_t v28 = &v25[2 * (v24 >> 1)];
        unint64_t v30 = *v28;
        unint64_t v29 = v28 + 2;
        v24 += ~(v24 >> 1);
        if (v30 < v23) {
          uint64_t v25 = v29;
        }
        else {
          unint64_t v24 = v27;
        }
      }
      while (v24);
      if (v25 != v26 && *v25 == v23) {
        uint64_t v31 = v25[1];
      }
      else {
LABEL_40:
      }
        uint64_t v31 = 0;
      uint64_t Value = (uint64_t)v21;
      v42[0] = v31;
      uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
      v43[0] = 3;
      if (v33 == 1 && *ArgAttrsAttr == v43[0])
      {
        uint64_t v35 = v6;
        v36[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v35);
        v36[1] = v34;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v36);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
          return 1;
        }
      }
    }
    int v5 = "'anec.unflatten' op attribute 'destination_size' failed to satisfy constraint: ui64 elements attribute of shape {3}";
  }
  else
  {
    int v5 = "'anec.unflatten' op attribute 'flatten_mode' failed to satisfy constraint: valid FlattenMode";
  }
LABEL_11:
  v38[0] = v5;
  __int16 v39 = 259;
  mlir::emitError(a2, (uint64_t)v38, (uint64_t)&Value);
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v7;
}

uint64_t mlir::anec::Unflatten::verifyAttributesWithFamily(uint64_t **a1, int a2)
{
  v57[23] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (uint64_t *)(*(void *)(*(void *)((*a1)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v4) {
    goto LABEL_10;
  }
  uint64_t v5 = *v4;
  unint64_t v6 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v7 = *(unsigned int *)(v5 + 16);
  if (!v7) {
    goto LABEL_10;
  }
  uint64_t v8 = *(void **)(v5 + 8);
  uint64_t v9 = &v8[2 * v7];
  do
  {
    unint64_t v10 = v7 >> 1;
    unint64_t v11 = &v8[2 * (v7 >> 1)];
    unint64_t v13 = *v11;
    unint64_t v12 = v11 + 2;
    v7 += ~(v7 >> 1);
    if (v13 < v6) {
      uint64_t v8 = v12;
    }
    else {
      unint64_t v7 = v10;
    }
  }
  while (v7);
  if (v8 != v9 && *v8 == v6) {
    uint64_t v14 = v8[1];
  }
  else {
LABEL_10:
  }
    uint64_t v14 = 0;
  if (*((_DWORD *)*a1 + 9)) {
    uint64_t v15 = (uint64_t)(*a1 - 2);
  }
  else {
    uint64_t v15 = 0;
  }
  unint64_t v16 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v16) {
    goto LABEL_23;
  }
  uint64_t v17 = *v16;
  unint64_t v18 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v19 = *(unsigned int *)(v17 + 16);
  if (!v19) {
    goto LABEL_23;
  }
  unint64_t v20 = *(void **)(v17 + 8);
  uint64_t v21 = &v20[2 * v19];
  do
  {
    unint64_t v22 = v19 >> 1;
    unint64_t v23 = &v20[2 * (v19 >> 1)];
    unint64_t v25 = *v23;
    unint64_t v24 = v23 + 2;
    v19 += ~(v19 >> 1);
    if (v25 < v18) {
      unint64_t v20 = v24;
    }
    else {
      unint64_t v19 = v22;
    }
  }
  while (v19);
  if (v20 != v21 && *v20 == v18) {
    uint64_t v26 = v20[1];
  }
  else {
LABEL_23:
  }
    uint64_t v26 = 0;
  if (!mlir::anec::verifyCompatibilityWithUnflatten((uint64_t)v4, v14, (uint64_t)v16, v26))
  {
    uint64_t v28 = "failed: input/output shapes are incompatible with unflatten op, (NxCx1x1) -> (NxCxHxW)";
    goto LABEL_28;
  }
  if (a2 > 1) {
    return 1;
  }
  if (*((_DWORD *)*a1 + 9)) {
    uint64_t v30 = (uint64_t)(*a1 - 2);
  }
  else {
    uint64_t v30 = 0;
  }
  uint64_t v31 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v30, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v31) {
    goto LABEL_41;
  }
  uint64_t v32 = *v31;
  unint64_t v33 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v34 = *(unsigned int *)(v32 + 16);
  if (!v34) {
    goto LABEL_41;
  }
  uint64_t v35 = *(void **)(v32 + 8);
  size_t v36 = &v35[2 * v34];
  do
  {
    unint64_t v37 = v34 >> 1;
    uint64_t v38 = &v35[2 * (v34 >> 1)];
    unint64_t v40 = *v38;
    __int16 v39 = v38 + 2;
    v34 += ~(v34 >> 1);
    if (v40 < v33) {
      uint64_t v35 = v39;
    }
    else {
      unint64_t v34 = v37;
    }
  }
  while (v34);
  if (v35 != v36 && *v35 == v33) {
    uint64_t v41 = v35[1];
  }
  else {
LABEL_41:
  }
    uint64_t v41 = 0;
  v55[0] = v31;
  v55[1] = v41;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55);
  unsigned int IndexFromDim = mlir::anec::getIndexFromDim(4, v42);
  if (v44)
  {
    uint64_t v54 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v55) + 8 * IndexFromDim);
    if ((unint64_t)(v54 - 65) <= 0xFFFFFFFFFFFFFFC0)
    {
      v49[0] = "output width dimension std::string::size_type size = {0} failed to satisfy constraint: 2 <= size <= 64";
      v49[1] = 79;
      void v49[2] = &v51;
      v49[3] = 1;
      v50[0] = &unk_1EC9A4648;
      v50[1] = &v54;
      uint64_t v51 = v50;
      v52[0] = v49;
      __int16 v53 = 263;
      unint64_t v29 = (const void ***)v52;
      goto LABEL_45;
    }
    uint64_t v56 = *(void *)((*a1)[9] + 24);
    uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v56);
    if (DefiningOp
      && *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Convolution,void>::id)
    {
      return 1;
    }
    uint64_t v56 = *(void *)((*a1)[9] + 24);
    uint64_t v47 = mlir::Value::getDefiningOp((mlir::Value *)&v56);
    if (v47)
    {
      if (mlir::detail::RecursivePatternTraitMatcher<mlir::OpTrait::anec::NeuronOpTrait,mlir::detail::RecursivePatternMatcher<mlir::anec::GOC,mlir::detail::op_matcher<mlir::anec::Convolution>,mlir::detail::AnyValueMatcher,mlir::detail::AnyValueMatcher>>::match((uint64_t)v52, v47))return 1; {
    }
      }
    uint64_t v28 = "must be preceded by a convolution or a sequence of convolution, goc, and neuron activation for A12/A13 class ANEs";
LABEL_28:
    v49[0] = v28;
    LOWORD(v50[0]) = 259;
    unint64_t v29 = (const void ***)v49;
LABEL_45:
    mlir::OpState::emitOpError(a1, v29, (uint64_t)&v56);
    uint64_t v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v56);
    if (v56) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v56);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v57);
    return v27;
  }
  unint64_t v48 = (mlir::anec::Unflatten *)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::anec::Unflatten::getZinIrUnitInfo(v48);
}

void mlir::anec::Unflatten::getZinIrUnitInfo(mlir::Operation **this@<X0>, void *a2@<X8>)
{
  v10[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0x60uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *((void *)v4 + 10) = 0;
  *(void *)uint64_t v4 = &unk_1EC995CD0;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 11) = 0;
  uint64_t v8 = *this;
  v9[0] = (void *)mlir::anec::ClampedRelu::getMinValueAttr(&v8);
  if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)v9) == 1) {
    int v5 = 1;
  }
  else {
    int v5 = 2;
  }
  *((_DWORD *)v4 + 20) = v5;
  v9[0] = v10;
  v9[1] = (void *)0x300000000;
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMaxValueAttr(this);
  mlir::getValues<long long>(MaxValueAttr, (uint64_t)v9);
  unint64_t v7 = v9[0];
  *((_DWORD *)v4 + 23) = *(void *)v9[0];
  *((_DWORD *)v4 + 22) = v7[1];
  *((_DWORD *)v4 + 21) = v7[2];
  *a2 = v4;
  if (v7 != v10) {
    free(v7);
  }
}

uint64_t mlir::anec::Unflatten::getFlattenMode(mlir::Operation **this)
{
  uint64_t MinValueAttr = mlir::anec::ClampedRelu::getMinValueAttr(this);
  return mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&MinValueAttr);
}

uint64_t mlir::anec::Unflatten::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  mlir::anec::Unflatten::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  unint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *unint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::Reshape::getZinIrUnitInfo@<X0>(mlir::anec::Reshape *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x90uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *(void *)uint64_t v4 = &unk_1EC995B90;
  *((void *)v4 + 1) = 0;
  *(_OWORD *)(v4 + 72) = xmmword_1810FE300;
  int64x2_t v5 = vdupq_n_s64(1uLL);
  *(int64x2_t *)(v4 + 88) = v5;
  *(int64x2_t *)(v4 + 104) = v5;
  long long v6 = operator new(0x14uLL);
  *((void *)v4 + 16) = v6 + 5;
  *((void *)v4 + 17) = v6 + 5;
  void v6[4] = 4;
  *(_OWORD *)long long v6 = xmmword_1810FE3BC;
  *((void *)v4 + 15) = v6;
  *((_DWORD *)v4 + 8) = 22;
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t v7 = *(void *)this - 16;
  }
  else {
    uint64_t v7 = 0;
  }
  uint64_t v8 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v8) {
    goto LABEL_13;
  }
  uint64_t v9 = *v8;
  unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v11 = *(unsigned int *)(v9 + 16);
  if (!v11) {
    goto LABEL_13;
  }
  long long v12 = *(void **)(v9 + 8);
  unint64_t v13 = &v12[2 * v11];
  do
  {
    unint64_t v14 = v11 >> 1;
    uint64_t v15 = &v12[2 * (v11 >> 1)];
    unint64_t v17 = *v15;
    unint64_t v16 = v15 + 2;
    v11 += ~(v11 >> 1);
    if (v17 < v10) {
      long long v12 = v16;
    }
    else {
      unint64_t v11 = v14;
    }
  }
  while (v11);
  if (v12 != v13 && *v12 == v10) {
    uint64_t v18 = v12[1];
  }
  else {
LABEL_13:
  }
    uint64_t v18 = 0;
  v32[0] = v8;
  v32[1] = v18;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  unsigned int IndexFromDim = mlir::anec::getIndexFromDim(0, v19);
  *((void *)v4 + 10) = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32)
                                   + 8 * IndexFromDim);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  unsigned int v22 = mlir::anec::getIndexFromDim(2, v21);
  if (v23) {
    uint64_t v24 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32) + 8 * v22);
  }
  else {
    uint64_t v24 = 1;
  }
  *((void *)v4 + 14) = v24;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  unsigned int v26 = mlir::anec::getIndexFromDim(1, v25);
  *((void *)v4 + 11) = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32)
                                   + 8 * v26);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  unsigned int v28 = mlir::anec::getIndexFromDim(3, v27);
  *((void *)v4 + 12) = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32)
                                   + 8 * v28);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  unsigned int v30 = mlir::anec::getIndexFromDim(4, v29);
  uint64_t result = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v32);
  *((void *)v4 + 13) = *(void *)(result + 8 * v30);
  *a2 = v4;
  return result;
}

uint64_t mlir::anec::Reshape::addOpToNetwork(mlir::anec::Reshape *a1, uint64_t a2)
{
  mlir::anec::Reshape::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::Reshape::verifyWithANEC(uint64_t *a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v77[63] = *MEMORY[0x1E4F143B8];
  ANECReshapeLayerDescInitialize();
  long long v60 = *(_OWORD *)a2;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
  if (v6 < 1)
  {
LABEL_6:
    if (*(_DWORD *)(*a1 + 36)) {
      uint64_t v13 = *a1 - 16;
    }
    else {
      uint64_t v13 = 0;
    }
    unint64_t v14 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v14) {
      goto LABEL_18;
    }
    uint64_t v15 = *v14;
    unint64_t v16 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v17 = *(unsigned int *)(v15 + 16);
    if (!v17) {
      goto LABEL_18;
    }
    uint64_t v18 = *(void **)(v15 + 8);
    unint64_t v19 = &v18[2 * v17];
    do
    {
      unint64_t v20 = v17 >> 1;
      unint64_t v21 = &v18[2 * (v17 >> 1)];
      unint64_t v23 = *v21;
      unsigned int v22 = v21 + 2;
      v17 += ~(v17 >> 1);
      if (v23 < v16) {
        uint64_t v18 = v22;
      }
      else {
        unint64_t v17 = v20;
      }
    }
    while (v17);
    if (v18 != v19 && *v18 == v16) {
      uint64_t v24 = v18[1];
    }
    else {
LABEL_18:
    }
      uint64_t v24 = 0;
    v59[0] = v14;
    v59[1] = v24;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v59);
    unint64_t v26 = v25;
    unsigned int IndexFromDim = mlir::anec::getIndexFromDim(2, v25);
    if (v28) {
      uint64_t v29 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v59) + 8 * IndexFromDim);
    }
    else {
      uint64_t v29 = 1;
    }
    unsigned int v32 = mlir::anec::getIndexFromDim(0, v26);
    if (!v33
      || (uint64_t v34 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v59) + 8 * v32),
          unsigned int v35 = mlir::anec::getIndexFromDim(1, v26),
          !v36)
      || (uint64_t v37 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v59) + 8 * v35),
          unsigned int v38 = mlir::anec::getIndexFromDim(3, v26),
          !v39)
      || (uint64_t v40 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v59) + 8 * v38),
          unsigned int v41 = mlir::anec::getIndexFromDim(4, v26),
          !v42))
    {
LABEL_40:
      std::__throw_bad_optional_access[abi:nn180100]();
    }
    uint64_t v43 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v59) + 8 * v41);
    uint64_t v61 = v34;
    uint64_t v62 = v37;
    uint64_t v63 = v40;
    uint64_t v64 = v43;
    uint64_t v65 = v29;
    v74[0] = v75;
    v74[1] = (void *)0x100000000;
    uint64_t v31 = 1;
    *(void *)buffer = 1;
    v66[0] = 0;
    ANECUnitValidatorCreate();
    uint64_t v57 = 0;
    uint64_t v58 = 0;
    if (ANECValidateReshapeLayer())
    {
      __int16 v53 = (const void **)(MEMORY[0x1E4FBA488] + 24);
      uint64_t v54 = (uint64_t *)*a1;
      uint64_t v44 = MEMORY[0x1E4FBA488] + 104;
      v73[0] = MEMORY[0x1E4FBA488] + 104;
      uint64_t v45 = MEMORY[0x1E4FBA488] + 64;
      uint64_t v67 = MEMORY[0x1E4FBA488] + 64;
      uint64_t v46 = MEMORY[0x1E4FBA408];
      uint64_t v47 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
      v66[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
      *(const void ***)((char *)v66 + (unint64_t)*(v66[0] - 3)) = v47;
      v66[1] = 0;
      unint64_t v48 = (std::ios_base *)((char *)v66 + (unint64_t)*(v66[0] - 3));
      std::ios_base::init(v48, &v68);
      v48[1].__vftable = 0;
      v48[1].__fmtflags_ = -1;
      uint64_t v49 = *(void *)(v46 + 40);
      uint64_t v67 = *(void *)(v46 + 32);
      *(uint64_t *)((char *)&v67 + *(void *)(v67 - 24)) = v49;
      v66[0] = *(const void ***)(v46 + 8);
      *(const void ***)((char *)v66 + (unint64_t)*(v66[0] - 3)) = *(const void ***)(v46 + 48);
      v73[0] = v44;
      v66[0] = v53;
      uint64_t v67 = v45;
      std::streambuf::basic_streambuf();
      uint64_t v50 = MEMORY[0x1E4FBA470] + 16;
      uint64_t v68 = MEMORY[0x1E4FBA470] + 16;
      long long __p = 0u;
      long long v71 = 0u;
      int v72 = 24;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v67, (uint64_t)"Invalid configuration", 21);
      std::stringbuf::str();
      v66[0] = *(const void ***)v46;
      uint64_t v51 = *(void *)(v46 + 72);
      *(const void ***)((char *)v66 + (unint64_t)*(v66[0] - 3)) = *(const void ***)(v46 + 64);
      uint64_t v67 = v51;
      uint64_t v68 = v50;
      if (SBYTE7(v71) < 0) {
        operator delete((void *)__p);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x1852FDD70](v73);
      __int16 v69 = 260;
      v66[0] = (const void **)&v55;
      uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
      if (*(void *)buffer) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v77);
      if (v56 < 0) {
        operator delete(v55);
      }
    }
    ANECUnitValidatorDelete();
    if (v74[0] != v75) {
      free(v74[0]);
    }
  }
  else
  {
    uint64_t v7 = 0;
    while (1)
    {
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
      uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v7, v8);
      if ((DimFromIndex & 0xFF00000000) == 0) {
        goto LABEL_40;
      }
      unsigned int v10 = DimFromIndex;
      uint64_t v11 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60)
                      + 8 * v7);
      if (v11 > mlir::anec::getMaximumDimSize(v10)) {
        break;
      }
      uint64_t v7 = (mlir::anec *)((char *)v7 + 1);
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
      if ((uint64_t)v7 >= v12) {
        goto LABEL_6;
      }
    }
    unsigned int v30 = (uint64_t *)*a1;
    v66[0] = (const void **)"failed: input tensor dimensions are not supported on ANEs.";
    __int16 v69 = 259;
    uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v77);
  }
  return v31;
}

uint64_t *mlir::anec::Reshape::fold(uint64_t a1, uint64_t a2)
{
  unint64_t v4 = *(void *)(*(void *)(*(void *)(*(void *)a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  if (*(_DWORD *)(*(void *)a1 + 36)) {
    uint64_t v5 = *(void *)a1 - 16;
  }
  else {
    uint64_t v5 = 0;
  }
  if (v4 == (*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0) + 8) & 0xFFFFFFFFFFFFFFF8)) {
    return (uint64_t *)(*(void *)(*(void *)(*(void *)a1 + 72) + 24) | 4);
  }
  if (*(_DWORD *)(*(void *)a1 + 36)) {
    uint64_t v6 = *(void *)a1 - 16;
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v7 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v7) {
    goto LABEL_17;
  }
  uint64_t v8 = *v7;
  unint64_t v9 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_17;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_17:
  }
    uint64_t v17 = 0;
  v42[0] = v7;
  v42[1] = v17;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v42)) {
    return 0;
  }
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
  if (v19)
  {
    uint64_t v20 = 8 * v19;
    while (*ArgAttrsAttr != 0x8000000000000000)
    {
      ++ArgAttrsAttr;
      v20 -= 8;
      if (!v20) {
        goto LABEL_23;
      }
    }
    return 0;
  }
LABEL_23:
  uint64_t result = **(uint64_t ***)(a2 + 40);
  if (result)
  {
    uint64_t result = llvm::DefaultDoCastIfPossible<mlir::ElementsAttr,mlir::Attribute const,llvm::CastInfo<mlir::ElementsAttr,mlir::Attribute const,void>>::doCastIfPossible(result);
    uint64_t v40 = result;
    uint64_t v41 = v22;
    if (result)
    {
      Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v40);
      uint64_t v24 = (uint64_t)Type;
      if (!Type) {
        goto LABEL_38;
      }
      uint64_t v25 = *Type;
      unint64_t v26 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v27 = *(unsigned int *)(v25 + 16);
      if (!v27) {
        goto LABEL_38;
      }
      char v28 = *(void **)(v25 + 8);
      uint64_t v29 = &v28[2 * v27];
      do
      {
        unint64_t v30 = v27 >> 1;
        uint64_t v31 = &v28[2 * (v27 >> 1)];
        unint64_t v33 = *v31;
        unsigned int v32 = v31 + 2;
        v27 += ~(v27 >> 1);
        if (v33 < v26) {
          char v28 = v32;
        }
        else {
          unint64_t v27 = v30;
        }
      }
      while (v27);
      if (v28 != v29 && *v28 == v26) {
        uint64_t v34 = v28[1];
      }
      else {
LABEL_38:
      }
        uint64_t v34 = 0;
      v39[0] = v24;
      v39[1] = v34;
      *(void *)&long long v43 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v42);
      *((void *)&v43 + 1) = v35;
      char v44 = 1;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
      uint64_t v37 = mlir::ShapedType::cloneWith(v39, &v43, OperandRange);
      return (uint64_t *)((unint64_t)mlir::reshapeElementsAttr((uint64_t)v40, v41, v37, v38) & 0xFFFFFFFFFFFFFFFBLL);
    }
  }
  else
  {
    uint64_t v40 = 0;
    uint64_t v41 = 0;
  }
  return result;
}

uint64_t mlir::anec::Reshape::canonicalize(uint64_t a1, uint64_t a2)
{
  v22[1] = *MEMORY[0x1E4F143B8];
  if (*(void *)(*(void *)(*(void *)(a1 + 72) + 24) + 8) >= 8uLL) {
    mlir::TypeID::get<mlir::ShapedType>();
  }
  if (*(_DWORD *)(a1 + 36)) {
    uint64_t v4 = a1 - 16;
  }
  else {
    uint64_t v4 = 0;
  }
  uint64_t v5 = (uint64_t *)(*(void *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_15;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_15;
  }
  unint64_t v9 = *(void **)(v6 + 8);
  unint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    unint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      unint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_15:
  }
    uint64_t v15 = 0;
  v19[0] = (uint64_t)v5;
  v19[1] = v15;
  uint64_t v20 = *(void *)(*(void *)(a1 + 72) + 24);
  uint64_t DefiningOp = mlir::Value::getDefiningOp((mlir::Value *)&v20);
  if (!DefiningOp
    || *(_UNKNOWN **)(*(void *)(DefiningOp + 48) + 16) != &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id)
  {
    return 0;
  }
  v22[0] = *(void *)(*(void *)(a1 + 72) + 24);
  uint64_t v20 = *(void *)(*(void *)(mlir::Value::getDefiningOp((mlir::Value *)v22) + 72) + 24);
  v22[0] = (char *)mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>((mlir::OpBuilder *)(a2 + 8), *(void *)(a1 + 24), v19, &v20)- 16;
  uint64_t v17 = 1;
  mlir::ValueRange::ValueRange(v21, (uint64_t)v22, 1uLL);
  (*(void (**)(uint64_t, uint64_t, unint64_t, unint64_t))(*(void *)a2 + 24))(a2, a1, v21[0], v21[1]);
  return v17;
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::Reshape,mlir::ShapedType &,mlir::Value &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  v25[28] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  uint64_t v9 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.reshape", (const unsigned __int8 *)0xC, Context);
  if (!v10)
  {
    __int16 v20 = 1283;
    uint64_t v19[2] = (uint64_t)"anec.reshape";
    v19[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v18 = 259;
    llvm::operator+(v19, (uint64_t *)&v17, (uint64_t)v21);
    llvm::report_fatal_error((llvm::Twine *)v21, 1);
  }
  mlir::OperationState::OperationState(v21, a2, v9);
  uint64_t v11 = *a3;
  v19[0] = *a4;
  mlir::OperationState::addOperands((uint64_t)v21, (uint64_t)v19, 1);
  unsigned int v12 = v23;
  if (v23 >= v24)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v22, v25, v23 + 1, 8);
    unsigned int v12 = v23;
  }
  *(void *)(v22 + 8 * v12) = v11;
  ++v23;
  unint64_t v13 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v21);
  if (*(_UNKNOWN **)(*((void *)v13 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::Reshape,void>::id) {
    unint64_t v14 = v13;
  }
  else {
    unint64_t v14 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v21);
  return v14;
}

uint64_t mlir::anec::Concat::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v106[22] = *MEMORY[0x1E4F143B8];
  uint64_t v97 = a6;
  v98[0] = 0;
  char v99 = 0;
  uint64_t v100 = a7;
  uint64_t v101 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v97);
    if (v99) {
      char v99 = 0;
    }
    mlir::OperationName::OperationName(v98, "anec.concat", 11, Context);
    char v99 = 1;
  }
  uint64_t v102 = a4;
  uint64_t v103 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  uint64_t v18 = a3;
  if (a3) {
    uint64_t v19 = (uint64_t)a2;
  }
  else {
    uint64_t v19 = v17;
  }
  if (!mlir::anec::ConcatAdaptor::verify(&v97, v19))
  {
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v104);
      if (v104) {
        mlir::Diagnostic::operator<<((uint64_t)&v105, "Failed to verify adaptor");
      }
      goto LABEL_42;
    }
    return 0;
  }
  __int16 v20 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  unint64_t v21 = v20;
  if (!v20) {
    goto LABEL_18;
  }
  uint64_t v22 = *v20;
  unint64_t v23 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v24 = *(unsigned int *)(v22 + 16);
  if (!v24) {
    goto LABEL_18;
  }
  uint64_t v25 = *(void **)(v22 + 8);
  unint64_t v26 = &v25[2 * v24];
  do
  {
    unint64_t v27 = v24 >> 1;
    char v28 = &v25[2 * (v24 >> 1)];
    unint64_t v30 = *v28;
    uint64_t v29 = v28 + 2;
    v24 += ~(v24 >> 1);
    if (v30 < v23) {
      uint64_t v25 = v29;
    }
    else {
      unint64_t v24 = v27;
    }
  }
  while (v24);
  if (v25 != v26 && *v25 == v23) {
    uint64_t v31 = v25[1];
  }
  else {
LABEL_18:
  }
    uint64_t v31 = 0;
  v94[0] = v21;
  v94[1] = v31;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v94);
  unint64_t Axis = (unint64_t)mlir::anec::detail::ConcatGenericAdaptorBase::getAxis((mlir::anec::detail::ConcatGenericAdaptorBase *)&v97);
  unint64_t v93 = Axis;
  if ((Axis & 0x8000000000000000) == 0)
  {
    int64_t v33 = Axis;
    if (a10)
    {
      uint64_t v34 = 0;
      while (1)
      {
        uint64_t v35 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, v34);
        char v36 = v35;
        if (!v35) {
          goto LABEL_31;
        }
        uint64_t v37 = *v35;
        unint64_t v38 = mlir::TypeID::get<mlir::ShapedType>();
        unint64_t v39 = *(unsigned int *)(v37 + 16);
        if (!v39) {
          goto LABEL_31;
        }
        uint64_t v40 = *(void **)(v37 + 8);
        uint64_t v41 = &v40[2 * v39];
        do
        {
          unint64_t v42 = v39 >> 1;
          long long v43 = &v40[2 * (v39 >> 1)];
          unint64_t v45 = *v43;
          char v44 = v43 + 2;
          v39 += ~(v39 >> 1);
          if (v45 < v38) {
            uint64_t v40 = v44;
          }
          else {
            unint64_t v39 = v42;
          }
        }
        while (v39);
        if (v40 != v41 && *v40 == v38) {
          uint64_t v46 = v40[1];
        }
        else {
LABEL_31:
        }
          uint64_t v46 = 0;
        uint64_t v104 = v36;
        uint64_t v105 = v46;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v104);
        if (v33 >= v47) {
          goto LABEL_39;
        }
        if (++v34 == a10)
        {
          uint64_t v73 = 0;
          for (uint64_t i = 0; i != a10; ++i)
          {
            uint64_t v75 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, i);
            uint64_t v76 = v75;
            if (!v75) {
              goto LABEL_77;
            }
            uint64_t v77 = *v75;
            unint64_t v78 = mlir::TypeID::get<mlir::ShapedType>();
            unint64_t v79 = *(unsigned int *)(v77 + 16);
            if (!v79) {
              goto LABEL_77;
            }
            uint64_t v80 = *(void **)(v77 + 8);
            uint64_t v81 = &v80[2 * v79];
            do
            {
              unint64_t v82 = v79 >> 1;
              BOOL v83 = &v80[2 * (v79 >> 1)];
              unint64_t v85 = *v83;
              unsigned int v84 = v83 + 2;
              v79 += ~(v79 >> 1);
              if (v85 < v78) {
                uint64_t v80 = v84;
              }
              else {
                unint64_t v79 = v82;
              }
            }
            while (v79);
            if (v80 != v81 && *v80 == v78) {
              uint64_t v86 = v80[1];
            }
            else {
LABEL_77:
            }
              uint64_t v86 = 0;
            uint64_t v104 = v76;
            uint64_t v105 = v86;
            v73 += *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v104)
                             + 8 * v33);
          }
          goto LABEL_47;
        }
      }
    }
    uint64_t v73 = 0;
LABEL_47:
    uint64_t v49 = (const char *)mlir::TypeRange::dereference_iterator(a9, 0);
    uint64_t v50 = v49;
    if (!v49) {
      goto LABEL_56;
    }
    uint64_t v51 = *(void *)v49;
    unint64_t v52 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v53 = *(unsigned int *)(v51 + 16);
    if (!v53) {
      goto LABEL_56;
    }
    uint64_t v54 = *(void **)(v51 + 8);
    long long v55 = &v54[2 * v53];
    do
    {
      unint64_t v56 = v53 >> 1;
      uint64_t v57 = &v54[2 * (v53 >> 1)];
      unint64_t v59 = *v57;
      uint64_t v58 = v57 + 2;
      v53 += ~(v53 >> 1);
      if (v59 < v52) {
        uint64_t v54 = v58;
      }
      else {
        unint64_t v53 = v56;
      }
    }
    while (v53);
    if (v54 != v55 && *v54 == v52) {
      uint64_t v60 = v54[1];
    }
    else {
LABEL_56:
    }
      uint64_t v60 = 0;
    unsigned int v87 = v50;
    uint64_t v88 = v60;
    uint64_t ArgAttrsAttr = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v87);
    uint64_t v62 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v87);
    uint64_t v64 = (unsigned char *)(v62 + 8 * v63);
    uint64_t v104 = v106;
    uint64_t v105 = 0x500000000;
    uint64_t v65 = v64 - ArgAttrsAttr;
    if ((unint64_t)(v64 - ArgAttrsAttr) < 0x29)
    {
      int v66 = 0;
      uint64_t v67 = v106;
      if (v64 == ArgAttrsAttr)
      {
LABEL_62:
        uint64_t v68 = (mlir::AffineMap *)(v66 + ((unint64_t)v65 >> 3));
        LODWORD(v105) = v68;
        v67[v33] = v73;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v87);
        uint64_t v70 = mlir::MemRefType::get(v67, v68, OperandRange, 0, 0, 0);
        uint64_t v71 = *(unsigned int *)(a11 + 8);
        if (v71 >= *(_DWORD *)(a11 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v71 + 1, 8);
          LODWORD(v71) = *(_DWORD *)(a11 + 8);
        }
        *(void *)(*(void *)a11 + 8 * v71) = v70;
        ++*(_DWORD *)(a11 + 8);
        if (v104 != v106) {
          free(v104);
        }
        return 1;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v104, v106, v65 >> 3, 8);
      int v66 = v105;
      uint64_t v67 = v104;
      if (v64 == ArgAttrsAttr) {
        goto LABEL_62;
      }
    }
    memcpy(&v67[v66], ArgAttrsAttr, v64 - ArgAttrsAttr);
    int v66 = v105;
    uint64_t v67 = v104;
    goto LABEL_62;
  }
LABEL_39:
  unsigned int v87 = "failed: Axis value {0} is out of bounds for input operands";
  uint64_t v88 = 58;
  uint64_t v89 = &v92;
  uint64_t v90 = 1;
  v91[0] = &unk_1EC9A4648;
  v91[1] = &v93;
  unint64_t v92 = v91;
  if (!v18) {
    return 0;
  }
  mlir::emitError((uint64_t)a2, (uint64_t)&v104);
  if (v104)
  {
    __int16 v96 = 263;
    BOOL v95 = &v87;
    mlir::Diagnostic::operator<<((uint64_t)&v105, (const void ***)&v95);
  }
LABEL_42:
  uint64_t v48 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v104);
  if (v104) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v104);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v105);
  return v48;
}

uint64_t mlir::anec::ConcatAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v14[23] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *a1;
  for (uint64_t i = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v12);
        ;
        uint64_t i = (mlir::CallGraphNode *)((char *)i + 16))
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v12))
    {
      uint64_t v5 = "'anec.concat' op requires attribute 'axis'";
      goto LABEL_6;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
  }
  uint64_t v8 = *((void *)i + 1);
  if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v12))
  {
    uint64_t v9 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    do
    {
      if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(i)) {
        uint64_t v9 = *((void *)i + 1);
      }
      uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
    }
    while (i != (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v12));
  }
  if (!v8
    || *(_UNKNOWN **)(*(void *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    && (v10[0] = v8,
        uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v10),
        mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)))
  {
    if (!v9 || *(_UNKNOWN **)(*(void *)v9 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
      return 1;
    }
    uint64_t v5 = "'anec.concat' op attribute 'interleave' failed to satisfy constraint: unit attribute";
  }
  else
  {
    uint64_t v5 = "'anec.concat' op attribute 'axis' failed to satisfy constraint: 64-bit unsigned integer attribute";
  }
LABEL_6:
  v10[0] = v5;
  __int16 v11 = 259;
  mlir::emitError(a2, (uint64_t)v10, (uint64_t)&Value);
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v14);
  return v6;
}

void *mlir::anec::detail::ConcatGenericAdaptorBase::getAxis(mlir::anec::detail::ConcatGenericAdaptorBase *this)
{
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue(this);
  uint64_t v3 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end(this);
  uint64_t v4 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v3, **(void **)(*((void *)this + 1) + 96));
  if (v5) {
    uint64_t v6 = *((void *)v4 + 1);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  mlir::IntegerAttr::getValue(&v11, (llvm::APInt *)&__p);
  if (v10 <= 0x40) {
    return __p;
  }
  uint64_t v7 = *(void *)__p;
  operator delete[](__p);
  return (void *)v7;
}

uint64_t mlir::anec::Concat::getZinIrUnitInfo@<X0>(mlir::Operation **this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x58uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995AE0;
  *((void *)v4 + 1) = 0;
  *((_DWORD *)v4 + 20) = 2;
  v4[84] = 0;
  *((_DWORD *)v4 + 8) = 3;
  uint64_t v22 = *this;
  char v5 = (uint64_t *)(*(void *)(*(void *)(*((void *)v22 + 9) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  unsigned int v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    unint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v21[0] = v5;
  v21[1] = v15;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(&v22);
  mlir::IntegerAttr::getValue(&MultipliersAttr, (llvm::APInt *)&__p);
  if (v24 > 0x40)
  {
    uint64_t v16 = *(mlir::anec **)__p;
    operator delete[](__p);
  }
  else
  {
    uint64_t v16 = (mlir::anec *)__p;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v21);
  uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v16, v17);
  if ((DimFromIndex & 0xFF00000000) != 0) {
    int v19 = dword_1810FE490[(int)DimFromIndex];
  }
  else {
    int v19 = 5;
  }
  *((_DWORD *)v4 + 20) = v19;
  uint64_t result = mlir::anec::Concat::getInterleaveAttr(&v22);
  v4[84] = result != 0;
  *a2 = v4;
  return result;
}

void *mlir::anec::Concat::getAxis(mlir::Operation **this)
{
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(this);
  mlir::IntegerAttr::getValue(&MultipliersAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return __p;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return (void *)v1;
}

uint64_t mlir::anec::Concat::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  ANECConcatLayerDescInitialize();
  v28[0] = (const void **)mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::IntegerAttr::getValue(v28, (llvm::APInt *)&__p);
  if (v39[0] > 0x40)
  {
    uint64_t v6 = *(mlir::anec::_anonymous_namespace_ **)__p;
    operator delete[](__p);
  }
  else
  {
    uint64_t v6 = (mlir::anec::_anonymous_namespace_ *)__p;
  }
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  uint64_t InterleaveAttr = mlir::anec::Concat::getInterleaveAttr(a1);
  uint64_t v9 = (uint64_t *)MEMORY[0x1E4F1CFD0];
  if (!InterleaveAttr) {
    uint64_t v9 = (uint64_t *)MEMORY[0x1E4F1CFC8];
  }
  uint64_t v27 = *v9;
  v36[0] = v37;
  v36[1] = (void *)0x100000000;
  uint64_t v10 = 1;
  long long __p = (void *)1;
  v28[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v24 = 0;
  uint64_t v25 = 0;
  if (ANECValidateConcatLayer())
  {
    __int16 v20 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    unint64_t v21 = *a1;
    uint64_t v11 = MEMORY[0x1E4FBA488] + 104;
    v35[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v12 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v29 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v13 = MEMORY[0x1E4FBA408];
    unint64_t v14 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v28[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v28 + (unint64_t)*(v28[0] - 3)) = v14;
    v28[1] = 0;
    uint64_t v15 = (std::ios_base *)((char *)v28 + (unint64_t)*(v28[0] - 3));
    std::ios_base::init(v15, &v30);
    v15[1].__vftable = 0;
    v15[1].__fmtflags_ = -1;
    uint64_t v16 = *(void *)(v13 + 40);
    uint64_t v29 = *(void *)(v13 + 32);
    *(uint64_t *)((char *)&v29 + *(void *)(v29 - 24)) = v16;
    v28[0] = *(const void ***)(v13 + 8);
    *(const void ***)((char *)v28 + (unint64_t)*(v28[0] - 3)) = *(const void ***)(v13 + 48);
    v35[0] = v11;
    v28[0] = v20;
    uint64_t v29 = v12;
    std::streambuf::basic_streambuf();
    uint64_t v17 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v30 = MEMORY[0x1E4FBA470] + 16;
    long long v32 = 0u;
    long long v33 = 0u;
    int v34 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v29, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v28[0] = *(const void ***)v13;
    uint64_t v18 = *(void *)(v13 + 72);
    *(const void ***)((char *)v28 + (unint64_t)*(v28[0] - 3)) = *(const void ***)(v13 + 64);
    uint64_t v29 = v18;
    uint64_t v30 = v17;
    if (SBYTE7(v33) < 0) {
      operator delete((void *)v32);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v35);
    __int16 v31 = 260;
    v28[0] = (const void **)&v22;
    uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&__p);
    if (__p) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__p);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v39);
    if (v23 < 0) {
      operator delete(v22);
    }
  }
  ANECUnitValidatorDelete();
  if (v36[0] != v37) {
    free(v36[0]);
  }
  return v10;
}

uint64_t mlir::anec::Concat::addOpToNetwork(mlir::Operation **a1, uint64_t a2)
{
  mlir::anec::Concat::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  unint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    unint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *unint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::InstanceNorm::inferPromotedReturnTypes(mlir::Float16Type *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  void v31[2] = *MEMORY[0x1E4F143B8];
  v31[0] = a4;
  v31[1] = a5;
  long long v12 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(v31, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v12) {
    goto LABEL_10;
  }
  uint64_t v13 = *v12;
  unint64_t v14 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v15 = *(unsigned int *)(v13 + 16);
  if (!v15) {
    goto LABEL_10;
  }
  uint64_t v16 = *(void **)(v13 + 8);
  uint64_t v17 = &v16[2 * v15];
  do
  {
    unint64_t v18 = v15 >> 1;
    int v19 = &v16[2 * (v15 >> 1)];
    unint64_t v21 = *v19;
    __int16 v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14) {
      uint64_t v16 = v20;
    }
    else {
      unint64_t v15 = v18;
    }
  }
  while (v15);
  if (v16 != v17 && *v16 == v14) {
    uint64_t v22 = v16[1];
  }
  else {
LABEL_10:
  }
    uint64_t v22 = 0;
  v28[0] = (uint64_t)v12;
  v28[1] = v22;
  *(void *)&long long v29 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v28);
  if (mlir::Type::isF16((mlir::Type *)&v29))
  {
    uint64_t v24 = v28[0];
  }
  else
  {
    uint64_t v25 = mlir::Float16Type::get(a1, v23);
    LOBYTE(v29) = 0;
    char v30 = 0;
    uint64_t v24 = mlir::ShapedType::cloneWith(v28, &v29, v25);
  }
  unsigned int v26 = *(_DWORD *)(a11 + 8);
  if (v26 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v26 + 1, 8);
    unsigned int v26 = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v26) = v24;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

void mlir::anec::InstanceNorm::getZinIrUnitInfo(mlir::anec::InstanceNorm *this@<X0>, void *a2@<X8>)
{
  v32[6] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = operator new(0x80uLL);
  v4[3] = 0u;
  v4[4] = 0u;
  _OWORD *v4 = 0u;
  v4[1] = 0u;
  v4[2] = 0u;
  v4[6] = 0u;
  v4[7] = 0u;
  v4[5] = 0u;
  *((void *)v4 + 9) = -1;
  *((_DWORD *)v4 + 28) = 1065353216;
  *((_DWORD *)v4 + 30) = 730643660;
  *(void *)uint64_t v4 = &unk_1EC995EF8;
  char v5 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  uint64_t v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    long long v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v26[0] = v5;
  v26[1] = v15;
  char v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMaxValueAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(MaxValueAttr, (uint64_t)&v30);
  if (v31)
  {
    uint64_t v17 = (mlir::anec **)v30;
    uint64_t v18 = 8 * v31;
    do
    {
      __int16 v20 = *v17;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v26);
      uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v20, v21);
      if ((DimFromIndex & 0xFF00000000) != 0) {
        int v19 = dword_1810FE490[(int)DimFromIndex];
      }
      else {
        int v19 = 5;
      }
      LODWORD(v28) = v19;
      std::__hash_table<ZinIrDimension,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,std::allocator<ZinIrDimension>>::__emplace_unique_key_args<ZinIrDimension,ZinIrDimension>((uint64_t)(v4 + 5), (int *)&v28, &v28);
      ++v17;
      v18 -= 8;
    }
    while (v18);
  }
  uint64_t MinValueAttr = mlir::anec::ClampedRelu::getMinValueAttr((mlir::Operation **)this);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&MinValueAttr, (uint64_t)&v28);
  float v24 = llvm::APFloat::convertToFloat(&v28);
  if (v24 < 0.00000011921) {
    float v24 = 0.00000011921;
  }
  *((float *)v4 + 30) = v24;
  uint64_t v25 = (void *)v29[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v23) == v25) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v29);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v29);
  }
  *a2 = v4;
  if (v30 != v32) {
    free(v30);
  }
}

llvm::detail::DoubleAPFloat *mlir::anec::InstanceNorm::getEpsilon@<X0>(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t MinValueAttr = mlir::anec::ClampedRelu::getMinValueAttr(this);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&MinValueAttr, a2);
}

uint64_t mlir::anec::InstanceNorm::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  ANECInstanceNormLayerDescInitialize();
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMaxValueAttr(a1);
  v34[0] = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&MaxValueAttr);
  uint64_t MinValueAttr = (const void **)mlir::anec::ClampedRelu::getMinValueAttr(a1);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&MinValueAttr, (uint64_t)buffer);
  float v7 = llvm::APFloat::convertToFloat((void **)buffer);
  if (v7 < 0.00000011921) {
    float v7 = 0.00000011921;
  }
  float v35 = v7;
  unint64_t v8 = v49;
  if (llvm::APFloatBase::PPCDoubleDouble(v6) == v8) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)&v49);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)&v49);
  }
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  unint64_t v10 = v9;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(buffer, MaxValueAttr, 0);
  uint64_t v11 = MaxValueAttr;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&MaxValueAttr);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&MinValueAttr, v11, NumElements);
  for (uint64_t i = 1; ; ++i)
  {
    BOOL v14 = *(const void ***)buffer == MinValueAttr && v49 == v37;
    if (v14 && v50 == v38) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&__p);
    int v15 = v46;
    if (v46 >= 0x41)
    {
      if (v15 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40) {
        uint64_t v16 = *(void *)__p;
      }
      else {
        uint64_t v16 = -1;
      }
    }
    else
    {
      uint64_t v16 = (uint64_t)__p;
    }
    if (v46 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v50;
  }
  uint64_t v17 = 1;
  *(void *)buffer = 1;
  uint64_t MinValueAttr = 0;
  ANECUnitValidatorCreate();
  long long __p = v47;
  uint64_t v46 = 0x100000000;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (ANECValidateInstanceNormLayer())
  {
    uint64_t v27 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    char v28 = *a1;
    uint64_t v18 = MEMORY[0x1E4FBA488] + 104;
    v44[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v19 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v38 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v20 = MEMORY[0x1E4FBA408];
    unint64_t v21 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    uint64_t MinValueAttr = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)&MinValueAttr + (void)*(MinValueAttr - 3)) = v21;
    uint64_t v37 = 0;
    uint64_t v22 = (std::ios_base *)((char *)&MinValueAttr + (void)*(MinValueAttr - 3));
    std::ios_base::init(v22, &v39);
    v22[1].__vftable = 0;
    v22[1].__fmtflags_ = -1;
    uint64_t v23 = *(void *)(v20 + 40);
    uint64_t v38 = *(void *)(v20 + 32);
    *(uint64_t *)((char *)&v38 + *(void *)(v38 - 24)) = v23;
    uint64_t MinValueAttr = *(const void ***)(v20 + 8);
    *(const void ***)((char *)&MinValueAttr + (void)*(MinValueAttr - 3)) = *(const void ***)(v20 + 48);
    v44[0] = v18;
    uint64_t MinValueAttr = v27;
    uint64_t v38 = v19;
    std::streambuf::basic_streambuf();
    uint64_t v24 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v39 = MEMORY[0x1E4FBA470] + 16;
    long long v41 = 0u;
    long long v42 = 0u;
    int v43 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v38, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    uint64_t MinValueAttr = *(const void ***)v20;
    uint64_t v25 = *(void *)(v20 + 72);
    *(const void ***)((char *)&MinValueAttr + (void)*(MinValueAttr - 3)) = *(const void ***)(v20 + 64);
    uint64_t v38 = v25;
    uint64_t v39 = v24;
    if (SBYTE7(v42) < 0) {
      operator delete((void *)v41);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v44);
    __int16 v40 = 260;
    uint64_t MinValueAttr = (const void **)&v29;
    uint64_t v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v49);
    if (v30 < 0) {
      operator delete(v29);
    }
  }
  if (__p != v47) {
    free(__p);
  }
  ANECUnitValidatorDelete();
  return v17;
}

uint64_t mlir::anec::InstanceNorm::addOpToNetwork(mlir::anec::InstanceNorm *a1, uint64_t a2)
{
  mlir::anec::InstanceNorm::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  float v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    unint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *float v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::CropResize::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  uint64_t v81 = a6;
  LOBYTE(v82) = 0;
  char v83 = 0;
  uint64_t v84 = a7;
  uint64_t v85 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v81);
    if (v83) {
      char v83 = 0;
    }
    mlir::OperationName::OperationName(&v82, "anec.crop_resize", 16, Context);
    char v83 = 1;
  }
  uint64_t v86 = a4;
  uint64_t v87 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::CropResizeAdaptor::verify(&v81, v18)) {
    return 0;
  }
  uint64_t v19 = (void *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v20 = v19;
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v21 = *v19;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_18;
  }
  uint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    uint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    char v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      uint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_18:
  }
    uint64_t v30 = 0;
  v75[0] = v20;
  v75[1] = v30;
  uint64_t ArgAttrsAttr = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v75);
  uint64_t v32 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v75);
  int v34 = (unsigned char *)(v32 + 8 * v33);
  unint64_t v78 = v80;
  uint64_t v79 = 0x500000000;
  uint64_t v35 = v34 - ArgAttrsAttr;
  if ((unint64_t)(v34 - ArgAttrsAttr) >= 0x29)
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v78, v80, v35 >> 3, 8);
    unsigned int v36 = v79;
    if (v34 == ArgAttrsAttr) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  unsigned int v36 = 0;
  if (v34 != ArgAttrsAttr)
  {
LABEL_24:
    memcpy((char *)v78 + 8 * v36, ArgAttrsAttr, v34 - ArgAttrsAttr);
    unsigned int v36 = v79;
  }
LABEL_25:
  LODWORD(v79) = v36 + ((unint64_t)v35 >> 3);
  v76[0] = v77;
  v76[1] = (void *)0x200000000;
  uint64_t v38 = (mlir::CallGraphNode *)(mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v81) + 64);
  uint64_t v39 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v81);
  __int16 v40 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v38, (mlir::CallGraphNode *)(v39 - 48), *(void *)(*(void *)(v82 + 96) + 40));
  if (v41) {
    uint64_t v42 = *((void *)v40 + 1);
  }
  else {
    uint64_t v42 = 0;
  }
  mlir::getValues<long long>(v42, (uint64_t)v76);
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v75);
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(3, v43);
  if (!v45) {
    goto LABEL_50;
  }
  unint64_t v46 = IndexFromDim;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v75);
  unint64_t v48 = mlir::anec::getIndexFromDim(4, v47);
  if (!v49
    || (uint64_t v50 = v76[0],
        uint64_t v51 = v78,
        *((void *)v78 + v46) = *(void *)v76[0],
        v51[v48] = v50[1],
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v75),
        unint64_t v53 = mlir::anec::getIndexFromDim(0, v52),
        !v54))
  {
LABEL_50:
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  unint64_t v55 = v53;
  unint64_t v56 = (void *)mlir::TypeRange::dereference_iterator(a9, 1);
  uint64_t v57 = v56;
  if (!v56) {
    goto LABEL_40;
  }
  uint64_t v58 = *v56;
  unint64_t v59 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v60 = *(unsigned int *)(v58 + 16);
  if (!v60) {
    goto LABEL_40;
  }
  uint64_t v61 = *(void **)(v58 + 8);
  uint64_t v62 = &v61[2 * v60];
  do
  {
    unint64_t v63 = v60 >> 1;
    uint64_t v64 = &v61[2 * (v60 >> 1)];
    unint64_t v66 = *v64;
    uint64_t v65 = v64 + 2;
    v60 += ~(v60 >> 1);
    if (v66 < v59) {
      uint64_t v61 = v65;
    }
    else {
      unint64_t v60 = v63;
    }
  }
  while (v60);
  if (v61 != v62 && *v61 == v59) {
    uint64_t v67 = v61[1];
  }
  else {
LABEL_40:
  }
    uint64_t v67 = 0;
  v74[0] = v57;
  v74[1] = v67;
  uint64_t v68 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v74);
  __int16 v69 = v78;
  *((void *)v78 + v55) = *(void *)(v68 + 8 * v55);
  uint64_t v70 = (mlir::AffineMap *)v79;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v75);
  uint64_t v72 = mlir::MemRefType::get(v69, v70, OperandRange, 0, 0, 0);
  uint64_t v73 = *(unsigned int *)(a11 + 8);
  if (v73 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v73 + 1, 8);
    LODWORD(v73) = *(_DWORD *)(a11 + 8);
  }
  *(void *)(*(void *)a11 + 8 * v73) = v72;
  ++*(_DWORD *)(a11 + 8);
  if (v76[0] != v77) {
    free(v76[0]);
  }
  if (v78 != v80) {
    free(v78);
  }
  return 1;
}

uint64_t mlir::anec::CropResizeAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v62[23] = *MEMORY[0x1E4F143B8];
  uint64_t v58 = *a1;
  for (uint64_t i = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v58);
        ;
        uint64_t i = (mlir::CallGraphNode *)((char *)i + 16))
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58))
    {
      char v5 = "'anec.crop_resize' op requires attribute 'background_value'";
LABEL_28:
      unint64_t v55 = (uint64_t *)v5;
      __int16 v57 = 259;
      mlir::emitError(a2, (uint64_t)&v55, (uint64_t)&Value);
      uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
      if (Value) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v62);
      return v9;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
  }
  long long v6 = (uint64_t *)*((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58))
    {
      char v5 = "'anec.crop_resize' op requires attribute 'box_coordinate_mode'";
      goto LABEL_28;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v7 = *((void *)i + 1);
  char v54 = 0;
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58))
    {
      char v5 = "'anec.crop_resize' op requires attribute 'coordinate_mode'";
      goto LABEL_28;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  unint64_t v8 = (uint64_t *)*((void *)i + 1);
  unint64_t v53 = 0;
  char v54 = v8;
  unint64_t v52 = 0;
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58))
    {
      char v5 = "'anec.crop_resize' op requires attribute 'normalized_range'";
      goto LABEL_28;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 32) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 24) == mlir::CallGraphNode::getCallableRegion(i)) {
      unint64_t v52 = (uint64_t *)*((void *)i + 1);
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  unint64_t v53 = (uint64_t *)*((void *)i + 1);
  uint64_t v51 = 0;
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58))
    {
      char v5 = "'anec.crop_resize' op requires attribute 'output_dims'";
      goto LABEL_28;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 40) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v51 = (uint64_t *)*((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58))
    {
      uint64_t v11 = "'anec.crop_resize' op requires attribute 'padding_modes'";
      goto LABEL_92;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 48) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  long long v12 = (uint64_t *)*((void *)i + 1);
  uint64_t v50 = v12;
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58))
    {
      uint64_t v11 = "'anec.crop_resize' op requires attribute 'sampling_method'";
      goto LABEL_92;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 56) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v13 = (uint64_t *)*((void *)i + 1);
  unint64_t v48 = 0;
  char v49 = v13;
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58))
    {
      uint64_t v11 = "'anec.crop_resize' op requires attribute 'sampling_mode'";
      goto LABEL_92;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 64) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  unint64_t v48 = (uint64_t *)*((void *)i + 1);
  if (!v51) {
    goto LABEL_95;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v51)) {
    goto LABEL_83;
  }
  unint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>(&v51);
  uint64_t v56 = v14;
  uint64_t Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v55);
  uint64_t Value = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&Type);
  v62[0] = v15;
  uint64_t ArgAttrsAttr = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
  uint64_t v59 = 2;
  if (v17 != 1) {
    goto LABEL_83;
  }
  if (*ArgAttrsAttr == (uint64_t *)v59
    && (char v44 = v51,
        char v45 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v44),
        uint64_t v46 = v18,
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v45),
        mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
  {
LABEL_95:
    if (!v52) {
      goto LABEL_58;
    }
    if (!mlir::DenseIntElementsAttr::classof((uint64_t)v52)) {
      goto LABEL_84;
    }
    unint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>(&v52);
    uint64_t v56 = v19;
    uint64_t Type = mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v55);
    uint64_t Value = mlir::Type::cast<mlir::ShapedType>((uint64_t **)&Type);
    v62[0] = v20;
    uint64_t v21 = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
    uint64_t v59 = 2;
    if (v22 != 1) {
      goto LABEL_84;
    }
    if (*v21 == (uint64_t *)v59
      && (char v44 = v52,
          char v45 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v44),
          uint64_t v46 = v23,
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v45),
          mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
LABEL_58:
      if (v7 && (mlir::anec::BoxCoordinateModeAttr::classof(v7) & 1) == 0)
      {
        uint64_t v11 = "'anec.crop_resize' op attribute 'box_coordinate_mode' failed to satisfy constraint: valid BoxCoordinateMode";
      }
      else
      {
        if (!v54) {
          goto LABEL_96;
        }
        unint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>(&v54);
        uint64_t v56 = v24;
        char v45 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v55);
        uint64_t Value = mlir::Type::cast<mlir::ShapedType>(&v45);
        v62[0] = v25;
        unint64_t v26 = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
        uint64_t Type = 5;
        if (v27 != 1) {
          goto LABEL_85;
        }
        if (*v26 == (uint64_t *)Type
          && (uint64_t v59 = (uint64_t)v54,
              (llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_0>(&v59) & 1) != 0))
        {
LABEL_96:
          if (!v53) {
            goto LABEL_97;
          }
          unint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>(&v53);
          uint64_t v56 = v28;
          char v45 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v55);
          uint64_t Value = mlir::Type::cast<mlir::ShapedType>(&v45);
          v62[0] = v29;
          uint64_t v30 = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
          uint64_t Type = 5;
          if (v31 != 1) {
            goto LABEL_87;
          }
          if (*v30 == (uint64_t *)Type
            && (uint64_t v59 = (uint64_t)v53,
                (llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_1>(&v59) & 1) != 0))
          {
LABEL_97:
            if (!v48) {
              goto LABEL_98;
            }
            unint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>(&v48);
            uint64_t v56 = v32;
            char v45 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v55);
            uint64_t Value = mlir::Type::cast<mlir::ShapedType>(&v45);
            v62[0] = v33;
            int v34 = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
            uint64_t Type = 5;
            if (v35 != 1) {
              goto LABEL_88;
            }
            if (*v34 == (uint64_t *)Type
              && (uint64_t v59 = (uint64_t)v48,
                  (llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_2>(&v59) & 1) != 0))
            {
LABEL_98:
              if (!v13) {
                goto LABEL_99;
              }
              unint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>(&v49);
              uint64_t v56 = v36;
              char v45 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v55);
              uint64_t Value = mlir::Type::cast<mlir::ShapedType>(&v45);
              v62[0] = v37;
              uint64_t v38 = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
              uint64_t Type = 5;
              if (v39 != 1) {
                goto LABEL_89;
              }
              if (*v38 == (uint64_t *)Type
                && (uint64_t v59 = (uint64_t)v49,
                    (llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_1>(&v59) & 1) != 0))
              {
LABEL_99:
                if (!v12) {
                  goto LABEL_100;
                }
                unint64_t v55 = mlir::Attribute::cast<mlir::ElementsAttr>(&v50);
                uint64_t v56 = v40;
                char v45 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v55);
                uint64_t Value = mlir::Type::cast<mlir::ShapedType>(&v45);
                v62[0] = v41;
                uint64_t v42 = (uint64_t **)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&Value);
                uint64_t Type = 5;
                if (v43 != 1) {
                  goto LABEL_90;
                }
                if (*v42 == (uint64_t *)Type
                  && (uint64_t v59 = (uint64_t)v50,
                      (llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_4>(&v59) & 1) != 0))
                {
LABEL_100:
                  if (!v6) {
                    return 1;
                  }
                  if (*(_UNKNOWN **)(*v6 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
                  {
                    unint64_t v55 = v6;
                    uint64_t Value = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v55);
                    if (mlir::Type::isF16((mlir::Type *)&Value)) {
                      return 1;
                    }
                  }
                  uint64_t v11 = "'anec.crop_resize' op attribute 'background_value' failed to satisfy constraint: 16-bit float attribute";
                }
                else
                {
LABEL_90:
                  uint64_t v11 = "'anec.crop_resize' op attribute 'padding_modes' failed to satisfy constraint: PaddingMode elemen"
                        "ts attribute of shape {5}";
                }
              }
              else
              {
LABEL_89:
                uint64_t v11 = "'anec.crop_resize' op attribute 'sampling_method' failed to satisfy constraint: SamplingGridMethod"
                      " elements attribute of shape {5}";
              }
            }
            else
            {
LABEL_88:
              uint64_t v11 = "'anec.crop_resize' op attribute 'sampling_mode' failed to satisfy constraint: SamplingGridMode eleme"
                    "nts attribute of shape {5}";
            }
          }
          else
          {
LABEL_87:
            uint64_t v11 = "'anec.crop_resize' op attribute 'normalized_range' failed to satisfy constraint: NormalizedCoordinateR"
                  "ange elements attribute of shape {5}";
          }
        }
        else
        {
LABEL_85:
          uint64_t v11 = "'anec.crop_resize' op attribute 'coordinate_mode' failed to satisfy constraint: CoordinateMode elements "
                "attribute of shape {5}";
        }
      }
    }
    else
    {
LABEL_84:
      uint64_t v11 = "'anec.crop_resize' op attribute 'crop_dims' failed to satisfy constraint: ui64 elements attribute of shape {2}";
    }
  }
  else
  {
LABEL_83:
    uint64_t v11 = "'anec.crop_resize' op attribute 'output_dims' failed to satisfy constraint: ui64 elements attribute of shape {2}";
  }
LABEL_92:
  unint64_t v55 = (uint64_t *)v11;
  __int16 v57 = 259;
  mlir::emitError(a2, (uint64_t)&v55, (uint64_t)&Value);
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&Value);
  return v9;
}

void mlir::anec::CropResize::getZinIrUnitInfo(mlir::anec::CropResize *this@<X0>, void *a2@<X8>)
{
  uint64_t v162 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = (char *)operator new(0xC8uLL);
  *((_OWORD *)v3 + 3) = 0u;
  *((_OWORD *)v3 + 4) = 0u;
  *((_OWORD *)v3 + 8) = 0u;
  *((_OWORD *)v3 + 9) = 0u;
  *(_OWORD *)uint64_t v3 = 0u;
  *((_OWORD *)v3 + 1) = 0u;
  *((_OWORD *)v3 + 2) = 0u;
  *((_OWORD *)v3 + 6) = 0u;
  *((_OWORD *)v3 + 7) = 0u;
  *((_OWORD *)v3 + 5) = 0u;
  uint64_t v144 = v3 + 80;
  *((void *)v3 + 9) = -1;
  *(_OWORD *)(v3 + 138) = 0u;
  *(void *)uint64_t v3 = &unk_1EC995D18;
  *((void *)v3 + 20) = 0;
  uint64_t v145 = (uint64_t **)(v3 + 160);
  *((_DWORD *)v3 + 39) = 5;
  *((void *)v3 + 21) = 0;
  *((void *)v3 + 22) = 0;
  *(void *)&long long v4 = 0x100000001;
  *((void *)&v4 + 1) = 0x100000001;
  *(_OWORD *)(v3 + 184) = v4;
  v158[0] = v159;
  v158[1] = (void *)0x500000000;
  uint64_t CoordinateModeAttr = mlir::anec::CropResize::getCoordinateModeAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(CoordinateModeAttr, (uint64_t)v158);
  v156[0] = v157;
  v156[1] = (void *)0x500000000;
  uint64_t NormalizedRangeAttr = mlir::anec::CropResize::getNormalizedRangeAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(NormalizedRangeAttr, (uint64_t)v156);
  v154[0] = v155;
  v154[1] = (void *)0x500000000;
  uint64_t PaddingModesAttr = mlir::anec::CropResize::getPaddingModesAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(PaddingModesAttr, (uint64_t)v154);
  v152[0] = v153;
  v152[1] = (void *)0x500000000;
  uint64_t SamplingMethodAttr = mlir::anec::CropResize::getSamplingMethodAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(SamplingMethodAttr, (uint64_t)v152);
  long long v143 = this;
  long long __p = (void *)mlir::anec::CropResize::getBackgroundValueAttr((mlir::Operation **)this);
  uint64_t Value = mlir::FloatAttr::getValue((mlir::FloatAttr *)&__p, (uint64_t)&v160);
  unint64_t v10 = (void *)*((void *)&v160 + 1);
  uint64_t v11 = llvm::APFloatBase::PPCDoubleDouble(Value);
  if (v11 == v10) {
    llvm::detail::DoubleAPFloat::bitcastToAPInt((llvm::detail::DoubleAPFloat *)((char *)&v160 + 8), (llvm::APInt *)&__p);
  }
  else {
    llvm::detail::IEEEFloat::bitcastToAPInt((llvm::detail::IEEEFloat *)((char *)&v160 + 8), (uint64_t)&__p);
  }
  int v12 = v150;
  if (v150 >= 0x41)
  {
    if (v12 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40)
    {
      uint64_t v14 = *(void *)__p;
      if (*(void *)__p >= 0xFFFFuLL) {
        LOWORD(v14) = -1;
      }
      __int16 v142 = v14;
    }
    else
    {
      __int16 v142 = -1;
      if (!__p) {
        goto LABEL_15;
      }
    }
    operator delete[](__p);
  }
  else
  {
    __int16 v13 = (__int16)__p;
    if ((unint64_t)__p >= 0xFFFF) {
      __int16 v13 = -1;
    }
    __int16 v142 = v13;
  }
LABEL_15:
  if (v11 == *((void **)&v160 + 1)) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)((char *)&v160 + 8));
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)((char *)&v160 + 8));
  }
  uint64_t v15 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v15) {
    goto LABEL_27;
  }
  uint64_t v16 = *v15;
  unint64_t v17 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v18 = *(unsigned int *)(v16 + 16);
  if (!v18) {
    goto LABEL_27;
  }
  uint64_t v19 = *(void **)(v16 + 8);
  uint64_t v20 = &v19[2 * v18];
  do
  {
    unint64_t v21 = v18 >> 1;
    uint64_t v22 = &v19[2 * (v18 >> 1)];
    unint64_t v24 = *v22;
    uint64_t v23 = v22 + 2;
    v18 += ~(v18 >> 1);
    if (v24 < v17) {
      uint64_t v19 = v23;
    }
    else {
      unint64_t v18 = v21;
    }
  }
  while (v18);
  if (v19 != v20 && *v19 == v17) {
    uint64_t v25 = v19[1];
  }
  else {
LABEL_27:
  }
    uint64_t v25 = 0;
  *(void *)&long long v160 = v15;
  *((void *)&v160 + 1) = v25;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v160);
  if (v26)
  {
    unint64_t v27 = v26;
    for (uint64_t i = 0; i != (mlir::anec *)v27; uint64_t i = (mlir::anec *)((char *)i + 1))
    {
      uint64_t DimFromIndex = mlir::anec::getDimFromIndex(i, v27);
      if ((DimFromIndex & 0xFF00000000) != 0) {
        uint64_t v31 = dword_1810FE490[(int)DimFromIndex];
      }
      else {
        uint64_t v31 = 5;
      }
      BOOL v32 = *((void *)v156[0] + i) != 0;
      int v33 = dword_1810FE418[*((void *)v158[0] + i)];
      uint64_t v35 = (_DWORD *)*((void *)v3 + 11);
      unint64_t v34 = *((void *)v3 + 12);
      if ((unint64_t)v35 >= v34)
      {
        uint64_t v37 = (_DWORD *)*v144;
        unint64_t v38 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v35 - *v144) >> 2);
        unint64_t v39 = v38 + 1;
        if (v38 + 1 > 0x1555555555555555) {
          goto LABEL_190;
        }
        unint64_t v40 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v34 - (void)v37) >> 2);
        if (2 * v40 > v39) {
          unint64_t v39 = 2 * v40;
        }
        if (v40 >= 0xAAAAAAAAAAAAAAALL) {
          unint64_t v41 = 0x1555555555555555;
        }
        else {
          unint64_t v41 = v39;
        }
        if (v41)
        {
          if (v41 > 0x1555555555555555) {
            goto LABEL_191;
          }
          uint64_t v42 = (char *)operator new(12 * v41);
        }
        else
        {
          uint64_t v42 = 0;
        }
        uint64_t v43 = &v42[12 * v38];
        *(_DWORD *)uint64_t v43 = v31;
        *((_DWORD *)v43 + 1) = v32;
        *((_DWORD *)v43 + 2) = v33;
        char v44 = v43;
        if (v35 != v37)
        {
          do
          {
            uint64_t v45 = *(void *)(v35 - 3);
            v35 -= 3;
            int v46 = v35[2];
            *(void *)(v44 - 12) = v45;
            v44 -= 12;
            *((_DWORD *)v44 + 2) = v46;
          }
          while (v35 != v37);
          uint64_t v35 = (_DWORD *)*v144;
        }
        uint64_t v36 = v43 + 12;
        *((void *)v3 + 10) = v44;
        *((void *)v3 + 11) = v43 + 12;
        *((void *)v3 + 12) = &v42[12 * v41];
        if (v35) {
          operator delete(v35);
        }
      }
      else
      {
        *uint64_t v35 = v31;
        v35[1] = v32;
        uint64_t v36 = v35 + 3;
        void v35[2] = v33;
      }
      *((void *)v3 + 11) = v36;
      uint64_t v47 = qword_1810FE428[*((void *)v154[0] + i)];
      char v49 = (uint64_t *)*((void *)v3 + 14);
      unint64_t v48 = *((void *)v3 + 15);
      if ((unint64_t)v49 >= v48)
      {
        uint64_t v51 = (char *)*((void *)v3 + 13);
        uint64_t v52 = ((char *)v49 - v51) >> 3;
        unint64_t v53 = v52 + 1;
        if ((unint64_t)(v52 + 1) >> 61) {
          goto LABEL_190;
        }
        uint64_t v54 = v48 - (void)v51;
        if (v54 >> 2 > v53) {
          unint64_t v53 = v54 >> 2;
        }
        if ((unint64_t)v54 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v55 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v55 = v53;
        }
        if (v55)
        {
          if (v55 >> 61) {
            goto LABEL_191;
          }
          uint64_t v56 = (char *)operator new(8 * v55);
        }
        else
        {
          uint64_t v56 = 0;
        }
        __int16 v57 = (uint64_t *)&v56[8 * v52];
        *__int16 v57 = v47 | v31;
        uint64_t v50 = v57 + 1;
        if (v49 != (uint64_t *)v51)
        {
          unint64_t v58 = (char *)v49 - v51 - 8;
          if (v58 < 0x58) {
            goto LABEL_194;
          }
          if ((unint64_t)(v51 - v56) < 0x20) {
            goto LABEL_194;
          }
          uint64_t v59 = (v58 >> 3) + 1;
          uint64_t v60 = 8 * (v59 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v61 = &v49[v60 / 0xFFFFFFFFFFFFFFF8];
          __int16 v57 = (uint64_t *)((char *)v57 - v60);
          uint64_t v62 = &v56[8 * v52 - 16];
          unint64_t v63 = v49 - 2;
          uint64_t v64 = v59 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v65 = *(_OWORD *)v63;
            *((_OWORD *)v62 - 1) = *((_OWORD *)v63 - 1);
            *(_OWORD *)uint64_t v62 = v65;
            v62 -= 32;
            v63 -= 4;
            v64 -= 4;
          }
          while (v64);
          char v49 = v61;
          if (v59 != (v59 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_194:
            do
            {
              uint64_t v66 = *--v49;
              *--__int16 v57 = v66;
            }
            while (v49 != (uint64_t *)v51);
          }
          char v49 = (uint64_t *)*((void *)v3 + 13);
        }
        *((void *)v3 + 13) = v57;
        *((void *)v3 + 14) = v50;
        *((void *)v3 + 15) = &v56[8 * v55];
        if (v49) {
          operator delete(v49);
        }
      }
      else
      {
        uint64_t *v49 = v47 | v31;
        uint64_t v50 = v49 + 1;
      }
      *((void *)v3 + 14) = v50;
      uint64_t v67 = *((void *)v152[0] + i);
      __int16 v69 = (unint64_t *)*((void *)v3 + 17);
      unint64_t v68 = *((void *)v3 + 18);
      if ((unint64_t)v69 < v68)
      {
        unint64_t *v69 = v31 | ((unint64_t)(v67 != 0) << 32);
        uint64_t v29 = v69 + 1;
      }
      else
      {
        uint64_t v70 = (char *)*((void *)v3 + 16);
        uint64_t v71 = ((char *)v69 - v70) >> 3;
        unint64_t v72 = v71 + 1;
        if ((unint64_t)(v71 + 1) >> 61) {
LABEL_190:
        }
          abort();
        uint64_t v73 = v68 - (void)v70;
        if (v73 >> 2 > v72) {
          unint64_t v72 = v73 >> 2;
        }
        if ((unint64_t)v73 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v74 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v74 = v72;
        }
        if (v74)
        {
          if (v74 >> 61) {
LABEL_191:
          }
            std::__throw_bad_array_new_length[abi:nn180100]();
          uint64_t v75 = (char *)operator new(8 * v74);
        }
        else
        {
          uint64_t v75 = 0;
        }
        uint64_t v76 = (unint64_t *)&v75[8 * v71];
        *uint64_t v76 = v31 | ((unint64_t)(v67 != 0) << 32);
        uint64_t v29 = v76 + 1;
        if (v69 != (unint64_t *)v70)
        {
          unint64_t v77 = (char *)v69 - v70 - 8;
          if (v77 < 0x58) {
            goto LABEL_195;
          }
          if ((unint64_t)(v70 - v75) < 0x20) {
            goto LABEL_195;
          }
          uint64_t v78 = (v77 >> 3) + 1;
          uint64_t v79 = 8 * (v78 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v80 = &v69[v79 / 0xFFFFFFFFFFFFFFF8];
          uint64_t v76 = (unint64_t *)((char *)v76 - v79);
          uint64_t v81 = &v75[8 * v71 - 16];
          uint64_t v82 = v69 - 2;
          uint64_t v83 = v78 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v84 = *(_OWORD *)v82;
            *((_OWORD *)v81 - 1) = *((_OWORD *)v82 - 1);
            *(_OWORD *)uint64_t v81 = v84;
            v81 -= 32;
            v82 -= 4;
            v83 -= 4;
          }
          while (v83);
          __int16 v69 = v80;
          if (v78 != (v78 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_195:
            do
            {
              unint64_t v85 = *--v69;
              *--uint64_t v76 = v85;
            }
            while (v69 != (unint64_t *)v70);
          }
          __int16 v69 = (unint64_t *)*((void *)v3 + 16);
        }
        *((void *)v3 + 16) = v76;
        *((void *)v3 + 17) = v29;
        *((void *)v3 + 18) = &v75[8 * v74];
        if (v69) {
          operator delete(v69);
        }
      }
      *((void *)v3 + 17) = v29;
    }
  }
  *((_WORD *)v3 + 76) = v142;
  *(void *)&long long v160 = mlir::anec::CropResize::getBoxCoordinateModeAttr((mlir::Operation **)v143);
  *((_DWORD *)v3 + 39) = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v160);
  uint64_t v86 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)v143 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v86) {
    goto LABEL_104;
  }
  uint64_t v87 = *v86;
  unint64_t v88 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v89 = *(unsigned int *)(v87 + 16);
  if (!v89) {
    goto LABEL_104;
  }
  uint64_t v90 = *(void **)(v87 + 8);
  uint64_t v91 = &v90[2 * v89];
  do
  {
    unint64_t v92 = v89 >> 1;
    unint64_t v93 = &v90[2 * (v89 >> 1)];
    unint64_t v95 = *v93;
    int v94 = v93 + 2;
    v89 += ~(v89 >> 1);
    if (v95 < v88) {
      uint64_t v90 = v94;
    }
    else {
      unint64_t v89 = v92;
    }
  }
  while (v89);
  if (v90 != v91 && *v90 == v88) {
    uint64_t v96 = v90[1];
  }
  else {
LABEL_104:
  }
    uint64_t v96 = 0;
  *(void *)&long long v160 = v86;
  *((void *)&v160 + 1) = v96;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v160);
  unint64_t v98 = v97;
  long long __p = v151;
  uint64_t v150 = 0x500000000;
  uint64_t SamplingModeAttr = mlir::anec::CropResize::getSamplingModeAttr((mlir::Operation **)v143);
  mlir::getValues<unsigned long long>(SamplingModeAttr, (uint64_t)&__p);
  if (v98)
  {
    for (uint64_t j = 0; j != (mlir::anec *)v98; uint64_t j = (mlir::anec *)((char *)j + 1))
    {
      uint64_t v102 = mlir::anec::getDimFromIndex(j, v98);
      if ((v102 & 0xFF00000000) != 0) {
        uint64_t v103 = qword_1810FE468[(int)v102];
      }
      else {
        uint64_t v103 = 5;
      }
      uint64_t v104 = *((void *)__p + (void)j);
      uint64_t v106 = (uint64_t *)*((void *)v3 + 21);
      unint64_t v105 = *((void *)v3 + 22);
      if ((unint64_t)v106 < v105)
      {
        uint64_t *v106 = v103 | (v104 << 32);
        uint64_t v101 = v106 + 1;
      }
      else
      {
        uint64_t v107 = *v145;
        uint64_t v108 = (char *)v106 - (char *)*v145;
        uint64_t v109 = v108 >> 3;
        unint64_t v110 = (v108 >> 3) + 1;
        if (v110 >> 61) {
          goto LABEL_190;
        }
        uint64_t v111 = v105 - (void)v107;
        if (v111 >> 2 > v110) {
          unint64_t v110 = v111 >> 2;
        }
        if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFF8) {
          unint64_t v112 = 0x1FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v112 = v110;
        }
        if (v112)
        {
          if (v112 >> 61) {
            goto LABEL_191;
          }
          uint64_t v113 = operator new(8 * v112);
        }
        else
        {
          uint64_t v113 = 0;
        }
        uint64_t v114 = (uint64_t *)&v113[8 * v109];
        *uint64_t v114 = v103 | (v104 << 32);
        uint64_t v101 = v114 + 1;
        if (v106 != v107)
        {
          unint64_t v115 = (char *)v106 - (char *)v107 - 8;
          if (v115 < 0x58) {
            goto LABEL_196;
          }
          if ((unint64_t)((char *)v106 - v113 - v108) < 0x20) {
            goto LABEL_196;
          }
          uint64_t v116 = (v115 >> 3) + 1;
          uint64_t v117 = 8 * (v116 & 0x3FFFFFFFFFFFFFFCLL);
          uint64_t v118 = &v106[v117 / 0xFFFFFFFFFFFFFFF8];
          uint64_t v114 = (uint64_t *)((char *)v114 - v117);
          uint64_t v119 = &v113[8 * v109 - 16];
          uint64_t v120 = v106 - 2;
          uint64_t v121 = v116 & 0x3FFFFFFFFFFFFFFCLL;
          do
          {
            long long v122 = *(_OWORD *)v120;
            *(v119 - 1) = *((_OWORD *)v120 - 1);
            *uint64_t v119 = v122;
            v119 -= 2;
            v120 -= 4;
            v121 -= 4;
          }
          while (v121);
          uint64_t v106 = v118;
          if (v116 != (v116 & 0x3FFFFFFFFFFFFFFCLL))
          {
LABEL_196:
            do
            {
              uint64_t v123 = *--v106;
              *--uint64_t v114 = v123;
            }
            while (v106 != v107);
          }
          uint64_t v106 = *v145;
        }
        *((void *)v3 + 20) = v114;
        *((void *)v3 + 21) = v101;
        *((void *)v3 + 22) = &v113[8 * v112];
        if (v106) {
          operator delete(v106);
        }
      }
      *((void *)v3 + 21) = v101;
    }
  }
  uint64_t OutputDimsAttr = mlir::anec::CropResize::getOutputDimsAttr((mlir::Operation **)v143);
  mlir::DenseElementsAttr::tryGetValues<llvm::APInt,void>((mlir::DenseElementsAttr *)&OutputDimsAttr, (uint64_t)&v160);
  long long v147 = v160;
  *(void *)&long long v148 = v161 + 1;
  *((void *)&v148 + 1) = *((void *)&v161 + 1);
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v160);
  int v124 = DWORD2(v160);
  if (DWORD2(v160) >= 0x41)
  {
    unsigned int v125 = v124 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v160);
    unsigned int v126 = (void *)v160;
    if (v125 <= 0x40)
    {
      uint64_t v127 = *(void *)v160;
      if (*(void *)v160 >= 0x7FFFFFFFuLL) {
        LODWORD(v127) = 0x7FFFFFFF;
      }
      *((_DWORD *)v3 + 46) = v127;
    }
    else
    {
      *((_DWORD *)v3 + 46) = 0x7FFFFFFF;
      if (!v126) {
        goto LABEL_144;
      }
    }
    operator delete[](v126);
    goto LABEL_144;
  }
  if ((unint64_t)v160 >> 31) {
    *((_DWORD *)v3 + 46) = 0x7FFFFFFF;
  }
  else {
    *((_DWORD *)v3 + 46) = v160;
  }
LABEL_144:
  uint64_t OutputDimsAttr = mlir::anec::CropResize::getOutputDimsAttr((mlir::Operation **)v143);
  mlir::DenseElementsAttr::tryGetValues<llvm::APInt,void>((mlir::DenseElementsAttr *)&OutputDimsAttr, (uint64_t)&v160);
  long long v147 = v160;
  long long v148 = v161;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v160);
  int v128 = DWORD2(v160);
  if (DWORD2(v160) >= 0x41)
  {
    unsigned int v129 = v128 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v160);
    uint64_t v130 = (void *)v160;
    if (v129 <= 0x40)
    {
      uint64_t v131 = *(void *)v160;
      if (*(void *)v160 >= 0x7FFFFFFFuLL) {
        LODWORD(v131) = 0x7FFFFFFF;
      }
      *((_DWORD *)v3 + 47) = v131;
    }
    else
    {
      *((_DWORD *)v3 + 47) = 0x7FFFFFFF;
      if (!v130) {
        goto LABEL_155;
      }
    }
    operator delete[](v130);
    goto LABEL_155;
  }
  if ((unint64_t)v160 >> 31) {
    *((_DWORD *)v3 + 47) = 0x7FFFFFFF;
  }
  else {
    *((_DWORD *)v3 + 47) = v160;
  }
LABEL_155:
  uint64_t OutputDimsAttr = mlir::anec::CropResize::getCropDimsAttr((mlir::Operation **)v143);
  mlir::DenseElementsAttr::tryGetValues<llvm::APInt,void>((mlir::DenseElementsAttr *)&OutputDimsAttr, (uint64_t)&v160);
  long long v147 = v160;
  *(void *)&long long v148 = v161 + 1;
  *((void *)&v148 + 1) = *((void *)&v161 + 1);
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v160);
  int v132 = DWORD2(v160);
  if (DWORD2(v160) >= 0x41)
  {
    unsigned int v133 = v132 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v160);
    uint64_t v134 = (void *)v160;
    if (v133 <= 0x40)
    {
      uint64_t v135 = *(void *)v160;
      if (*(void *)v160 >= 0x7FFFFFFFuLL) {
        LODWORD(v135) = 0x7FFFFFFF;
      }
      *((_DWORD *)v3 + 48) = v135;
    }
    else
    {
      *((_DWORD *)v3 + 48) = 0x7FFFFFFF;
      if (!v134) {
        goto LABEL_166;
      }
    }
    operator delete[](v134);
    goto LABEL_166;
  }
  if ((unint64_t)v160 >> 31) {
    *((_DWORD *)v3 + 48) = 0x7FFFFFFF;
  }
  else {
    *((_DWORD *)v3 + 48) = v160;
  }
LABEL_166:
  uint64_t OutputDimsAttr = mlir::anec::CropResize::getCropDimsAttr((mlir::Operation **)v143);
  mlir::DenseElementsAttr::tryGetValues<llvm::APInt,void>((mlir::DenseElementsAttr *)&OutputDimsAttr, (uint64_t)&v160);
  long long v147 = v160;
  long long v148 = v161;
  mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v147, (llvm::APInt *)&v160);
  int v136 = DWORD2(v160);
  if (DWORD2(v160) >= 0x41)
  {
    unsigned int v138 = v136 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&v160);
    uint64_t v139 = (void *)v160;
    if (v138 <= 0x40)
    {
      uint64_t v140 = *(void *)v160;
      if (*(void *)v160 >= 0x7FFFFFFFuLL) {
        LODWORD(v140) = 0x7FFFFFFF;
      }
      *((_DWORD *)v3 + 49) = v140;
      uint64_t v137 = a2;
    }
    else
    {
      *((_DWORD *)v3 + 49) = 0x7FFFFFFF;
      uint64_t v137 = a2;
      if (!v139) {
        goto LABEL_177;
      }
    }
    operator delete[](v139);
    goto LABEL_177;
  }
  uint64_t v137 = a2;
  if ((unint64_t)v160 >> 31) {
    *((_DWORD *)v3 + 49) = 0x7FFFFFFF;
  }
  else {
    *((_DWORD *)v3 + 49) = v160;
  }
LABEL_177:
  *uint64_t v137 = v3;
  if (__p != v151) {
    free(__p);
  }
  if (v152[0] != v153) {
    free(v152[0]);
  }
  if (v154[0] != v155) {
    free(v154[0]);
  }
  if (v156[0] != v157) {
    free(v156[0]);
  }
  if (v158[0] != v159) {
    free(v158[0]);
  }
}

llvm::detail::DoubleAPFloat *mlir::anec::CropResize::getBackgroundValue@<X0>(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t BackgroundValueAttr = mlir::anec::CropResize::getBackgroundValueAttr(this);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&BackgroundValueAttr, a2);
}

uint64_t mlir::anec::CropResize::getBoxCoordinateMode(mlir::Operation **this)
{
  Boxuint64_t CoordinateModeAttr = mlir::anec::CropResize::getBoxCoordinateModeAttr(this);
  return mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&BoxCoordinateModeAttr);
}

uint64_t mlir::anec::CropResize::addOpToNetwork(mlir::anec::CropResize *a1, uint64_t a2)
{
  mlir::anec::CropResize::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    unint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::CropResize::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  v100[63] = *MEMORY[0x1E4F143B8];
  ANECCropResizeLayerDescInitialize();
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  unint64_t v7 = v6;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(3, v6);
  if (!v9 || (unint64_t v10 = (mlir::anec::_anonymous_namespace_ *)IndexFromDim, v11 = mlir::anec::getIndexFromDim(4, v7), !v12)) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  uint64_t v96 = v98;
  v98[0] = v10;
  v98[1] = v11;
  uint64_t v97 = 0x200000002;
  unint64_t v92 = &ANECDimension;
  uint64_t v95 = 0;
  uint64_t ANECDimension = 0;
  uint64_t v93 = 0x200000002;
  v90[0] = v91;
  v90[1] = (void *)0x600000000;
  uint64_t SamplingModeAttr = mlir::anec::CropResize::getSamplingModeAttr(a1);
  mlir::getValues<unsigned long long>(SamplingModeAttr, (uint64_t)v90);
  v88[0] = v89;
  v88[1] = (void *)0x600000000;
  uint64_t SamplingMethodAttr = mlir::anec::CropResize::getSamplingMethodAttr(a1);
  mlir::getValues<unsigned long long>(SamplingMethodAttr, (uint64_t)v88);
  v86[0] = v87;
  v86[1] = (void *)0x600000000;
  uint64_t PaddingModesAttr = mlir::anec::CropResize::getPaddingModesAttr(a1);
  mlir::getValues<unsigned long long>(PaddingModesAttr, (uint64_t)v86);
  v84[0] = v85;
  v84[1] = (void *)0x600000000;
  uint64_t CoordinateModeAttr = mlir::anec::CropResize::getCoordinateModeAttr(a1);
  mlir::getValues<unsigned long long>(CoordinateModeAttr, (uint64_t)v84);
  v82[0] = v83;
  v82[1] = (void *)0x600000000;
  uint64_t NormalizedRangeAttr = mlir::anec::CropResize::getNormalizedRangeAttr(a1);
  mlir::getValues<unsigned long long>(NormalizedRangeAttr, (uint64_t)v82);
  *(void *)buffer = mlir::anec::CropResize::getBoxCoordinateModeAttr(a1);
  uint64_t v44 = (uint64_t)*(&off_1E4FBF020 + mlir::IntegerAttr::getInt((mlir::IntegerAttr *)buffer));
  uint64_t v45 = *(void *)v92;
  uint64_t v18 = 8 * *(void *)v96;
  uint64_t v46 = (uint64_t)*(&off_1E4FBF0A0 + *(void *)((char *)v90[0] + v18));
  uint64_t v49 = *(void *)v92;
  if (*(void *)((char *)v88[0] + v18)) {
    uint64_t v19 = @"NearestNeighbor";
  }
  else {
    uint64_t v19 = @"Linear";
  }
  uint64_t v50 = v19;
  uint64_t v53 = *(void *)v92;
  uint64_t v54 = (uint64_t)*(&off_1E4FBF0D0 + *(void *)((char *)v86[0] + v18));
  uint64_t v57 = *(void *)v92;
  uint64_t v59 = (uint64_t)*(&off_1E4FBF110 + *(void *)((char *)v84[0] + v18));
  if (*(void *)((char *)v82[0] + v18)) {
    uint64_t v20 = @"RangeMinusOneToOne";
  }
  else {
    uint64_t v20 = @"RangeZeroToOne";
  }
  unint64_t v58 = v20;
  uint64_t v47 = *((void *)v92 + 1);
  uint64_t v21 = 8 * *((void *)v96 + 1);
  uint64_t v48 = (uint64_t)*(&off_1E4FBF0A0 + *(void *)((char *)v90[0] + v21));
  uint64_t v51 = *((void *)v92 + 1);
  if (*(void *)((char *)v88[0] + v21)) {
    uint64_t v22 = @"NearestNeighbor";
  }
  else {
    uint64_t v22 = @"Linear";
  }
  uint64_t v52 = v22;
  uint64_t v55 = *((void *)v92 + 1);
  uint64_t v56 = (uint64_t)*(&off_1E4FBF0D0 + *(void *)((char *)v86[0] + v21));
  uint64_t v60 = *((void *)v92 + 1);
  uint64_t v62 = (uint64_t)*(&off_1E4FBF110 + *(void *)((char *)v84[0] + v21));
  if (*(void *)((char *)v82[0] + v21)) {
    uint64_t v23 = @"RangeMinusOneToOne";
  }
  else {
    uint64_t v23 = @"RangeZeroToOne";
  }
  uint64_t v61 = v23;
  v68[0] = (const void **)mlir::anec::CropResize::getBackgroundValueAttr(a1);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)v68, (uint64_t)buffer);
  float v63 = llvm::APFloat::convertToFloat((void **)buffer);
  unint64_t v24 = (void *)v100[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v25) == v24) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v100);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v100);
  }
  v80[0] = v81;
  v80[1] = (void *)0xC00000000;
  uint64_t OutputDimsAttr = mlir::anec::CropResize::getOutputDimsAttr(a1);
  mlir::getValues<unsigned int>(OutputDimsAttr, (uint64_t)v80);
  int v65 = *(_DWORD *)v80[0];
  int v64 = *((_DWORD *)v80[0] + 1);
  v78[0] = v79;
  v78[1] = (void *)0xC00000000;
  uint64_t CropDimsAttr = mlir::anec::CropResize::getCropDimsAttr(a1);
  mlir::getValues<unsigned int>(CropDimsAttr, (uint64_t)v78);
  int v67 = *(_DWORD *)v78[0];
  int v66 = *((_DWORD *)v78[0] + 1);
  v76[0] = v77;
  v76[1] = (void *)0x100000000;
  uint64_t v28 = 1;
  *(void *)buffer = 1;
  v68[0] = 0;
  ANECUnitValidatorCreate();
  uint64_t v42 = 0;
  uint64_t v43 = 0;
  if (ANECValidateCropResizeLayer())
  {
    unint64_t v38 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    unint64_t v39 = *a1;
    uint64_t v29 = MEMORY[0x1E4FBA488] + 104;
    v75[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v30 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v69 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v31 = MEMORY[0x1E4FBA408];
    BOOL v32 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v68[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v68 + (unint64_t)*(v68[0] - 3)) = v32;
    v68[1] = 0;
    int v33 = (std::ios_base *)((char *)v68 + (unint64_t)*(v68[0] - 3));
    std::ios_base::init(v33, &v70);
    v33[1].__vftable = 0;
    v33[1].__fmtflags_ = -1;
    uint64_t v34 = *(void *)(v31 + 40);
    uint64_t v69 = *(void *)(v31 + 32);
    *(uint64_t *)((char *)&v69 + *(void *)(v69 - 24)) = v34;
    v68[0] = *(const void ***)(v31 + 8);
    *(const void ***)((char *)v68 + (unint64_t)*(v68[0] - 3)) = *(const void ***)(v31 + 48);
    v75[0] = v29;
    v68[0] = v38;
    uint64_t v69 = v30;
    std::streambuf::basic_streambuf();
    uint64_t v35 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v70 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v73 = 0u;
    int v74 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v69, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v68[0] = *(const void ***)v31;
    uint64_t v36 = *(void *)(v31 + 72);
    *(const void ***)((char *)v68 + (unint64_t)*(v68[0] - 3)) = *(const void ***)(v31 + 64);
    uint64_t v69 = v36;
    uint64_t v70 = v35;
    if (SBYTE7(v73) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v75);
    __int16 v71 = 260;
    v68[0] = (const void **)&v40;
    uint64_t v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v100);
    if (v41 < 0) {
      operator delete(v40);
    }
  }
  ANECUnitValidatorDelete();
  if (v76[0] != v77) {
    free(v76[0]);
  }
  if (v78[0] != v79) {
    free(v78[0]);
  }
  if (v80[0] != v81) {
    free(v80[0]);
  }
  if (v82[0] != v83) {
    free(v82[0]);
  }
  if (v84[0] != v85) {
    free(v84[0]);
  }
  if (v86[0] != v87) {
    free(v86[0]);
  }
  if (v88[0] != v89) {
    free(v88[0]);
  }
  if (v90[0] != v91) {
    free(v90[0]);
  }
  if (v92 != &ANECDimension) {
    free(v92);
  }
  if (v96 != v98) {
    free(v96);
  }
  return v28;
}

void mlir::getValues<unsigned int>(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v14, a1, 0);
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v17);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v11, a1, NumElements);
  while (1)
  {
    BOOL v5 = v14 == v11 && v15 == v12;
    if (v5 && v16 == v13) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v14, (llvm::APInt *)&__p);
    if (v10 >= 0x41) {
      p_p = (int *)__p;
    }
    else {
      p_p = (int *)&__p;
    }
    int v7 = *p_p;
    uint64_t v8 = *(unsigned int *)(a2 + 8);
    if (v8 >= *(_DWORD *)(a2 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v8 + 1, 4);
      uint64_t v8 = *(unsigned int *)(a2 + 8);
    }
    *(_DWORD *)(*(void *)a2 + 4 * v8) = v7;
    ++*(_DWORD *)(a2 + 8);
    if (v10 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v16;
  }
}

uint64_t mlir::anec::GatherND::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v89[22] = *MEMORY[0x1E4F143B8];
  uint64_t v80 = a6;
  LOBYTE(v81) = 0;
  char v82 = 0;
  uint64_t v83 = a7;
  uint64_t v84 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v80);
    if (v82) {
      char v82 = 0;
    }
    mlir::OperationName::OperationName(&v81, "anec.gather_nd", 14, Context);
    char v82 = 1;
  }
  uint64_t v85 = a4;
  uint64_t v86 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (!mlir::anec::GatherNDAdaptor::verify(&v80, v18))
  {
    if (!a3) {
      return 0;
    }
    mlir::emitError((uint64_t)a2, (uint64_t)&v87);
    if (v87) {
      mlir::Diagnostic::operator<<((uint64_t)&v88, "Failed to verify adaptor");
    }
    uint64_t v53 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v87);
    if (v87) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v87);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v88);
    return v53;
  }
  uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
  uint64_t v20 = (uint64_t)v19;
  if (!v19) {
    goto LABEL_18;
  }
  uint64_t v21 = *v19;
  unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v23 = *(unsigned int *)(v21 + 16);
  if (!v23) {
    goto LABEL_18;
  }
  unint64_t v24 = *(void **)(v21 + 8);
  uint64_t v25 = &v24[2 * v23];
  do
  {
    unint64_t v26 = v23 >> 1;
    unint64_t v27 = &v24[2 * (v23 >> 1)];
    unint64_t v29 = *v27;
    uint64_t v28 = v27 + 2;
    v23 += ~(v23 >> 1);
    if (v29 < v22) {
      unint64_t v24 = v28;
    }
    else {
      unint64_t v23 = v26;
    }
  }
  while (v23);
  if (v24 != v25 && *v24 == v22) {
    uint64_t v30 = v24[1];
  }
  else {
LABEL_18:
  }
    uint64_t v30 = 0;
  v74[0] = v20;
  v74[1] = v30;
  uint64_t v31 = (void *)mlir::TypeRange::dereference_iterator(a9, 1);
  BOOL v32 = v31;
  if (!v31) {
    goto LABEL_28;
  }
  uint64_t v33 = *v31;
  unint64_t v34 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v35 = *(unsigned int *)(v33 + 16);
  if (!v35) {
    goto LABEL_28;
  }
  uint64_t v36 = *(void **)(v33 + 8);
  uint64_t v37 = &v36[2 * v35];
  do
  {
    unint64_t v38 = v35 >> 1;
    unint64_t v39 = &v36[2 * (v35 >> 1)];
    unint64_t v41 = *v39;
    unint64_t v40 = v39 + 2;
    v35 += ~(v35 >> 1);
    if (v41 < v34) {
      uint64_t v36 = v40;
    }
    else {
      unint64_t v35 = v38;
    }
  }
  while (v35);
  if (v36 != v37 && *v36 == v34) {
    uint64_t v42 = v36[1];
  }
  else {
LABEL_28:
  }
    uint64_t v42 = 0;
  v73[0] = v32;
  v73[1] = v42;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v74);
  int64_t v44 = v43;
  unint64_t IndexFromDim = mlir::anec::getIndexFromDim(1, v43);
  if (v46)
  {
    unint64_t v47 = IndexFromDim;
    uint64_t v87 = v89;
    uint64_t v88 = 0x500000000;
    uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v80);
    uint64_t v49 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v80);
    uint64_t v50 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v49, **(void **)(v81 + 96));
    if (v51) {
      uint64_t v52 = *((void *)v50 + 1);
    }
    else {
      uint64_t v52 = 0;
    }
    mlir::getValues<unsigned long long>(v52, (uint64_t)&v87);
    unint64_t v54 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73)
                    + 8 * v47);
    unint64_t v55 = v88;
    unint64_t v77 = v79;
    uint64_t v78 = 0x500000000;
    if (!v44) {
      goto LABEL_61;
    }
    if ((unint64_t)v44 < 6)
    {
      uint64_t v56 = 0;
      int64_t v57 = v44;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v77, v79, v44, 8);
      uint64_t v56 = v78;
      int64_t v57 = v44 - v78;
      if (v44 == v78)
      {
LABEL_45:
        LODWORD(v78) = v44;
        if (v44 >= 1)
        {
          uint64_t v58 = 0;
          unint64_t v59 = v54 / v55;
          do
          {
            uint64_t v65 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v74) + 8 * v58);
            uint64_t v64 = v59;
            if (v47 != v58) {
              uint64_t v64 = *(void *)(mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73) + 8 * v58);
            }
            if (v88)
            {
              uint64_t v66 = 8 * v88;
              uint64_t v60 = (char *)v87;
              while (*(void *)v60 != v58)
              {
                v60 += 8;
                v66 -= 8;
                if (!v66)
                {
                  uint64_t v60 = (char *)v87 + 8 * v88;
                  break;
                }
              }
            }
            else
            {
              uint64_t v60 = (char *)v87;
            }
            uint64_t v61 = v60 - (unsigned char *)v87;
            if (v65 <= v64) {
              uint64_t v62 = v64;
            }
            else {
              uint64_t v62 = v65;
            }
            float v63 = v77;
            if (v88 == v61 >> 3) {
              uint64_t v64 = v62;
            }
            *((void *)v77 + v58++) = v64;
          }
          while (v58 != v44);
          LODWORD(v44) = v78;
          goto LABEL_63;
        }
LABEL_61:
        float v63 = v77;
LABEL_63:
        *(void *)&long long v75 = v63;
        *((void *)&v75 + 1) = v44;
        char v76 = 1;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v74);
        uint64_t v68 = mlir::ShapedType::cloneWith(v74, &v75, OperandRange);
        uint64_t v69 = *(unsigned int *)(a11 + 8);
        if (v69 >= *(_DWORD *)(a11 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v69 + 1, 8);
          LODWORD(v69) = *(_DWORD *)(a11 + 8);
        }
        *(void *)(*(void *)a11 + 8 * v69) = v68;
        ++*(_DWORD *)(a11 + 8);
        if (v77 != v79) {
          free(v77);
        }
        if (v87 != v89) {
          free(v87);
        }
        return 1;
      }
    }
    bzero((char *)v77 + 8 * v56, 8 * v57);
    goto LABEL_45;
  }
  __int16 v71 = (uint64_t *)std::__throw_bad_optional_access[abi:nn180100]();
  return mlir::anec::GatherNDAdaptor::verify(v71, v72);
}

uint64_t mlir::anec::GatherNDAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v41[23] = *MEMORY[0x1E4F143B8];
  uint64_t v39 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v39); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v39))
    {
      BOOL v5 = "'anec.gather_nd' op requires attribute 'axes'";
      goto LABEL_33;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  unint64_t v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    unsigned int v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      uint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        unsigned int v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v37[0] = v6;
    v37[1] = v16;
    uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v37);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    unint64_t v22 = *(void **)(v19 + 8);
    unint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      uint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      unint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        unint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    unint64_t v40 = v18;
    v41[0] = v28;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v40);
    if (v29 == 1 && mlir::hasUniqueValues((uint64_t)v6))
    {
      uint64_t v36 = v6;
      if (mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v36))
      {
        uint64_t v33 = v6;
        v34[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v33);
        v34[1] = v30;
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v34);
        if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
          return 1;
        }
      }
    }
  }
  BOOL v5 = "'anec.gather_nd' op attribute 'axes' failed to satisfy constraint: ui64 unique not empty elements attribute of ranks 1";
LABEL_33:
  v37[0] = v5;
  __int16 v38 = 259;
  mlir::emitError(a2, (uint64_t)v37, (uint64_t)&v40);
  uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v40);
  if (v40) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v40);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v41);
  return v31;
}

void mlir::anec::GatherND::getZinIrUnitInfo(mlir::anec::GatherND *this@<X0>, void *a2@<X8>)
{
  void v34[6] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0xB8uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_OWORD *)v4 + 7) = 0u;
  *((_OWORD *)v4 + 8) = 0u;
  *(_OWORD *)(v4 + 138) = 0u;
  *(void *)uint64_t v4 = &unk_1EC995B00;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 20) = 0;
  uint64_t v31 = (void **)(v4 + 160);
  *((void *)v4 + 21) = 0;
  *((void *)v4 + 22) = 0;
  BOOL v32 = v34;
  uint64_t v33 = 0x600000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(MultipliersAttr, (uint64_t)&v32);
  unint64_t v6 = (mlir::anec **)v32;
  if (v33)
  {
    uint64_t v30 = a2;
    uint64_t v7 = (mlir::anec **)((char *)v32 + 8 * v33);
    do
    {
      int v9 = 5;
      uint64_t DimFromIndex = mlir::anec::getDimFromIndex(*v6, 5uLL);
      if ((DimFromIndex & 0xFF00000000) != 0) {
        int v9 = dword_1810FE490[(int)DimFromIndex];
      }
      unint64_t v12 = (int *)*((void *)v4 + 21);
      unint64_t v11 = *((void *)v4 + 22);
      if ((unint64_t)v12 < v11)
      {
        int *v12 = v9;
        unint64_t v8 = v12 + 1;
      }
      else
      {
        uint64_t v13 = (int *)*v31;
        uint64_t v14 = (char *)v12 - (unsigned char *)*v31;
        uint64_t v15 = v14 >> 2;
        unint64_t v16 = (v14 >> 2) + 1;
        if (v16 >> 62) {
          abort();
        }
        uint64_t v17 = v11 - (void)v13;
        if (v17 >> 1 > v16) {
          unint64_t v16 = v17 >> 1;
        }
        if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL) {
          unint64_t v18 = 0x3FFFFFFFFFFFFFFFLL;
        }
        else {
          unint64_t v18 = v16;
        }
        if (v18)
        {
          if (v18 >> 62) {
            std::__throw_bad_array_new_length[abi:nn180100]();
          }
          uint64_t v19 = operator new(4 * v18);
        }
        else
        {
          uint64_t v19 = 0;
        }
        unint64_t v20 = (int *)&v19[4 * v15];
        *unint64_t v20 = v9;
        unint64_t v8 = v20 + 1;
        if (v12 != v13)
        {
          unint64_t v21 = (char *)v12 - (char *)v13 - 4;
          if (v21 < 0x2C) {
            goto LABEL_35;
          }
          if ((unint64_t)((char *)v12 - v19 - v14) < 0x20) {
            goto LABEL_35;
          }
          uint64_t v22 = (v21 >> 2) + 1;
          uint64_t v23 = 4 * (v22 & 0x7FFFFFFFFFFFFFF8);
          unint64_t v24 = &v12[v23 / 0xFFFFFFFFFFFFFFFCLL];
          unint64_t v20 = (int *)((char *)v20 - v23);
          uint64_t v25 = &v19[4 * v15 - 16];
          unint64_t v26 = v12 - 4;
          uint64_t v27 = v22 & 0x7FFFFFFFFFFFFFF8;
          do
          {
            long long v28 = *(_OWORD *)v26;
            *(v25 - 1) = *((_OWORD *)v26 - 1);
            *uint64_t v25 = v28;
            v25 -= 2;
            v26 -= 8;
            v27 -= 8;
          }
          while (v27);
          unint64_t v12 = v24;
          if (v22 != (v22 & 0x7FFFFFFFFFFFFFF8))
          {
LABEL_35:
            do
            {
              int v29 = *--v12;
              *--unint64_t v20 = v29;
            }
            while (v12 != v13);
          }
        }
        *((void *)v4 + 20) = v20;
        *((void *)v4 + 21) = v8;
        *((void *)v4 + 22) = &v19[4 * v18];
        if (v13) {
          operator delete(v13);
        }
      }
      *((void *)v4 + 21) = v8;
      ++v6;
    }
    while (v6 != v7);
    unint64_t v6 = (mlir::anec **)v32;
    a2 = v30;
  }
  *a2 = v4;
  if (v6 != v34) {
    free(v6);
  }
}

uint64_t mlir::anec::GatherND::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  ANECGatherLayerDescInitialize();
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  v31[0] = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&MultipliersAttr);
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  unint64_t v7 = v6;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(buffer, MultipliersAttr, 0);
  uint64_t v8 = MultipliersAttr;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&MultipliersAttr);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v32, v8, NumElements);
  for (uint64_t i = 1; ; ++i)
  {
    BOOL v11 = *(void ***)buffer == v32 && v45[0] == v33;
    if (v11 && v46 == v34) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)buffer, (llvm::APInt *)&__p);
    int v12 = v42;
    if (v42 >= 0x41)
    {
      if (v12 - llvm::APInt::countLeadingZerosSlowCase((llvm::APInt *)&__p) <= 0x40) {
        uint64_t v13 = *(void *)__p;
      }
      else {
        uint64_t v13 = -1;
      }
    }
    else
    {
      uint64_t v13 = (uint64_t)__p;
    }
    if (v42 >= 0x41)
    {
      if (__p) {
        operator delete[](__p);
      }
    }
    ++v46;
  }
  uint64_t v14 = 1;
  *(void *)buffer = 1;
  BOOL v32 = 0;
  ANECUnitValidatorCreate();
  long long __p = v43;
  uint64_t v42 = 0x100000000;
  uint64_t v28 = 0;
  uint64_t v29 = 0;
  if (ANECValidateGatherLayer())
  {
    unint64_t v24 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v25 = *a1;
    uint64_t v15 = MEMORY[0x1E4FBA488] + 104;
    v40[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v16 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v34 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v17 = MEMORY[0x1E4FBA408];
    unint64_t v18 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    BOOL v32 = *(void ***)(MEMORY[0x1E4FBA408] + 16);
    *(void ***)((char *)&v32 + (void)*(v32 - 3)) = (void **)v18;
    uint64_t v33 = 0;
    uint64_t v19 = (std::ios_base *)((char *)&v32 + (void)*(v32 - 3));
    std::ios_base::init(v19, &v35);
    v19[1].__vftable = 0;
    v19[1].__fmtflags_ = -1;
    uint64_t v20 = *(void *)(v17 + 40);
    uint64_t v34 = *(void *)(v17 + 32);
    *(uint64_t *)((char *)&v34 + *(void *)(v34 - 24)) = v20;
    BOOL v32 = *(void ***)(v17 + 8);
    *(void ***)((char *)&v32 + (void)*(v32 - 3)) = *(void ***)(v17 + 48);
    v40[0] = v15;
    BOOL v32 = (void **)v24;
    uint64_t v34 = v16;
    std::streambuf::basic_streambuf();
    uint64_t v21 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v35 = MEMORY[0x1E4FBA470] + 16;
    long long v37 = 0u;
    long long v38 = 0u;
    int v39 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v34, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    BOOL v32 = *(void ***)v17;
    uint64_t v22 = *(void *)(v17 + 72);
    *(void ***)((char *)&v32 + (void)*(v32 - 3)) = *(void ***)(v17 + 64);
    uint64_t v34 = v22;
    uint64_t v35 = v21;
    if (SBYTE7(v38) < 0) {
      operator delete((void *)v37);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v40);
    __int16 v36 = 260;
    BOOL v32 = &v26;
    uint64_t v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v45);
    if (v27 < 0) {
      operator delete(v26);
    }
  }
  if (__p != v43) {
    free(__p);
  }
  ANECUnitValidatorDelete();
  return v14;
}

uint64_t mlir::anec::GatherND::addOpToNetwork(mlir::anec::GatherND *a1, uint64_t a2)
{
  mlir::anec::GatherND::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  unint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *unint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::ArgMinMax::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v73[22] = *MEMORY[0x1E4F143B8];
  uint64_t v64 = a6;
  LOBYTE(v65) = 0;
  char v66 = 0;
  uint64_t v67 = a7;
  uint64_t v68 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v64);
    if (v66) {
      char v66 = 0;
    }
    mlir::OperationName::OperationName(&v65, "anec.arg_min_max", 16, Context);
    char v66 = 1;
  }
  uint64_t v69 = a4;
  uint64_t v70 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (mlir::anec::ArgMinMaxAdaptor::verify(&v64, v18))
  {
    uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_18;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_18;
    }
    unint64_t v24 = *(void **)(v21 + 8);
    uint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      char v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      uint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        unint64_t v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_18:
    }
      uint64_t v30 = 0;
    v58[0] = v20;
    v58[1] = v30;
    __int16 v71 = v73;
    uint64_t v72 = 0x600000000;
    uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v64);
    uint64_t v32 = mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v64);
    uint64_t v33 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v32 - 64), **(void **)(v65 + 96));
    if (v34) {
      uint64_t v35 = *((void *)v33 + 1);
    }
    else {
      uint64_t v35 = 0;
    }
    mlir::getValues<long long>(v35, (uint64_t)&v71);
    if (v72)
    {
      long long v37 = (uint64_t *)v71;
      uint64_t v38 = 8 * v72;
      while (1)
      {
        uint64_t v39 = *v37;
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v58);
        if (v40 <= v39) {
          break;
        }
        ++v37;
        v38 -= 8;
        if (!v38) {
          goto LABEL_32;
        }
      }
      uint64_t v55 = v58[0];
      uint64_t v56 = *(unsigned int *)(a11 + 8);
      if (v56 >= *(_DWORD *)(a11 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v56 + 1, 8);
        LODWORD(v56) = *(_DWORD *)(a11 + 8);
      }
      *(void *)(*(void *)a11 + 8 * v56) = v55;
      ++*(_DWORD *)(a11 + 8);
      goto LABEL_47;
    }
LABEL_32:
    uint64_t ArgAttrsAttr = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v58);
    uint64_t v42 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v58);
    int64_t v44 = (unsigned char *)(v42 + 8 * (void)v43);
    uint64_t v61 = v63;
    uint64_t v62 = 0x600000000;
    uint64_t v45 = v44 - ArgAttrsAttr;
    if ((unint64_t)(v44 - ArgAttrsAttr) < 0x31)
    {
      int v46 = 0;
      uint64_t v47 = v63;
      if (v44 == ArgAttrsAttr)
      {
LABEL_37:
        uint64_t v48 = v46 + ((unint64_t)v45 >> 3);
        LODWORD(v62) = v48;
        if (v72)
        {
          uint64_t v49 = (uint64_t *)v71;
          uint64_t v50 = 8 * v72;
          do
          {
            uint64_t v51 = *v49++;
            *(void *)&v47[8 * v51] = 1;
            v50 -= 8;
          }
          while (v50);
        }
        uint64_t v52 = mlir::Float16Type::get(this, v43);
        *(void *)&long long v59 = v47;
        *((void *)&v59 + 1) = v48;
        char v60 = 1;
        uint64_t v53 = mlir::ShapedType::cloneWith(v58, &v59, v52);
        uint64_t v54 = *(unsigned int *)(a11 + 8);
        if (v54 >= *(_DWORD *)(a11 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v54 + 1, 8);
          LODWORD(v54) = *(_DWORD *)(a11 + 8);
        }
        *(void *)(*(void *)a11 + 8 * v54) = v53;
        ++*(_DWORD *)(a11 + 8);
        if (v61 != v63) {
          free(v61);
        }
LABEL_47:
        if (v71 != v73) {
          free(v71);
        }
        return 1;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v63, v45 >> 3, 8);
      int v46 = v62;
      uint64_t v47 = v61;
      if (v44 == ArgAttrsAttr) {
        goto LABEL_37;
      }
    }
    memcpy(&v47[8 * v46], ArgAttrsAttr, v44 - ArgAttrsAttr);
    int v46 = v62;
    uint64_t v47 = v61;
    goto LABEL_37;
  }
  if (!a3) {
    return 0;
  }
  mlir::emitError((uint64_t)a2, (uint64_t)&v71);
  if (v71) {
    mlir::Diagnostic::operator<<((uint64_t)&v72, "Failed to verify adaptor");
  }
  uint64_t v36 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v71);
  if (v71) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v71);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v72);
  return v36;
}

uint64_t mlir::anec::ArgMinMaxAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v54[23] = *MEMORY[0x1E4F143B8];
  uint64_t v51 = *a1;
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v51);
  uint64_t v50 = 0;
  while (1)
  {
    if (Value == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v51))
    {
      BOOL v5 = "'anec.arg_min_max' op requires attribute 'axes'";
LABEL_26:
      uint64_t v47 = (uint64_t *)v5;
      __int16 v49 = 259;
      mlir::emitError(a2, (uint64_t)&v47, (uint64_t)&v53);
      uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
      if (v53) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v54);
      return v9;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(Value)) {
      break;
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
  }
  uint64_t v50 = (uint64_t *)*((void *)Value + 1);
  while (1)
  {
    if (Value == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v51))
    {
      BOOL v5 = "'anec.arg_min_max' op requires attribute 'kernel_size'";
      goto LABEL_26;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(Value)) {
      break;
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
  }
  long long v6 = (uint64_t *)*((void *)Value + 1);
  int v46 = v6;
  while (1)
  {
    if (Value == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v51))
    {
      BOOL v5 = "'anec.arg_min_max' op requires attribute 'mode'";
      goto LABEL_26;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 16) == mlir::CallGraphNode::getCallableRegion(Value)) {
      break;
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
  }
  uint64_t v7 = *((void *)Value + 1);
  uint64_t v45 = v7;
  while (1)
  {
    if (Value == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v51))
    {
      BOOL v5 = "'anec.arg_min_max' op requires attribute 'pad_values'";
      goto LABEL_26;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 24) == mlir::CallGraphNode::getCallableRegion(Value)) {
      break;
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
  }
  uint64_t v8 = (uint64_t *)*((void *)Value + 1);
  int64_t v44 = v8;
  while (1)
  {
    if (Value == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v51))
    {
      BOOL v5 = "'anec.arg_min_max' op requires attribute 'stride_values'";
      goto LABEL_26;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 32) == mlir::CallGraphNode::getCallableRegion(Value)) {
      break;
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
  }
  uint64_t v11 = (uint64_t *)*((void *)Value + 1);
  unint64_t v43 = v11;
  if (!v50) {
    goto LABEL_38;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)v50)) {
    goto LABEL_55;
  }
  uint64_t v47 = mlir::Attribute::cast<mlir::ElementsAttr>(&v50);
  uint64_t v48 = v12;
  uint64_t Type = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v47);
  uint64_t v53 = mlir::Type::cast<mlir::ShapedType>(&Type);
  v54[0] = v13;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v53);
  if (v14)
  {
    v38[0] = mlir::Attribute::cast<mlir::ElementsAttr>(&v50);
    v38[1] = v15;
    uint64_t v39 = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v38);
    uint64_t v40 = mlir::Type::cast<mlir::ShapedType>(&v39);
    uint64_t v41 = v16;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v40);
    if (v17 != 1) {
      goto LABEL_55;
    }
  }
  if (mlir::hasUniqueValues((uint64_t)v50)
    && (long long v37 = v50, mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v37))
    && (uint64_t v35 = v50,
        v52[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v35),
        v52[1] = v18,
        uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v52),
        mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
  {
LABEL_38:
    if (v7 && (llvm::isa<mlir::anec::ArgMinMaxModeAttr,mlir::Attribute>(&v45) & 1) == 0)
    {
      char v34 = "'anec.arg_min_max' op attribute 'mode' failed to satisfy constraint: valid ArgMinMaxMode";
    }
    else
    {
      if (!v6) {
        goto LABEL_63;
      }
      if (!mlir::DenseIntElementsAttr::classof((uint64_t)v6)) {
        goto LABEL_56;
      }
      uint64_t v47 = mlir::Attribute::cast<mlir::ElementsAttr>(&v46);
      uint64_t v48 = v19;
      v38[0] = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v47);
      uint64_t v53 = mlir::Type::cast<mlir::ShapedType>(v38);
      v54[0] = v20;
      uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v53);
      v52[0] = 2;
      if (v22 != 1) {
        goto LABEL_56;
      }
      if (*ArgAttrsAttr == v52[0]
        && (uint64_t v39 = v46,
            uint64_t v40 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39),
            uint64_t v41 = v23,
            uint64_t Type = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v40),
            mlir::Type::isUnsignedInteger((mlir::Type *)&Type, 64)))
      {
LABEL_63:
        if (!v11) {
          goto LABEL_64;
        }
        if (!mlir::DenseIntElementsAttr::classof((uint64_t)v11)) {
          goto LABEL_58;
        }
        uint64_t v47 = mlir::Attribute::cast<mlir::ElementsAttr>(&v43);
        uint64_t v48 = v24;
        v38[0] = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v47);
        uint64_t v53 = mlir::Type::cast<mlir::ShapedType>(v38);
        v54[0] = v25;
        unint64_t v26 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v53);
        v52[0] = 2;
        if (v27 != 1) {
          goto LABEL_58;
        }
        if (*v26 == v52[0]
          && (uint64_t v39 = v43,
              uint64_t v40 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39),
              uint64_t v41 = v28,
              uint64_t Type = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v40),
              mlir::Type::isUnsignedInteger((mlir::Type *)&Type, 64)))
        {
LABEL_64:
          if (!v8) {
            return 1;
          }
          if (mlir::DenseIntElementsAttr::classof((uint64_t)v8))
          {
            uint64_t v47 = mlir::Attribute::cast<mlir::ElementsAttr>(&v44);
            uint64_t v48 = v29;
            v38[0] = (uint64_t *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v47);
            uint64_t v53 = mlir::Type::cast<mlir::ShapedType>(v38);
            v54[0] = v30;
            uint64_t v31 = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v53);
            v52[0] = 4;
            if (v32 == 1 && *v31 == v52[0])
            {
              uint64_t v39 = v44;
              uint64_t v40 = (uint64_t *)mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
              uint64_t v41 = v33;
              uint64_t Type = (uint64_t *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v40);
              if (mlir::Type::isUnsignedInteger((mlir::Type *)&Type, 64)) {
                return 1;
              }
            }
          }
          char v34 = "'anec.arg_min_max' op attribute 'pad_values' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        }
        else
        {
LABEL_58:
          char v34 = "'anec.arg_min_max' op attribute 'stride_values' failed to satisfy constraint: ui64 elements attribute of shape {2}";
        }
      }
      else
      {
LABEL_56:
        char v34 = "'anec.arg_min_max' op attribute 'kernel_size' failed to satisfy constraint: ui64 elements attribute of shape {2}";
      }
    }
  }
  else
  {
LABEL_55:
    char v34 = "'anec.arg_min_max' op attribute 'axes' failed to satisfy constraint: ui64 unique not empty elements attribute of ranks 0/1";
  }
  uint64_t v47 = (uint64_t *)v34;
  __int16 v49 = 259;
  mlir::emitError(a2, (uint64_t)&v47, (uint64_t)&v53);
  uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&v53);
  return v9;
}

void mlir::anec::ArgMinMax::getZinIrUnitInfo(mlir::anec::ArgMinMax *this@<X0>, void *a2@<X8>)
{
  v37[6] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0x80uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995C30;
  *((void *)v4 + 1) = 0;
  *(void *)&long long v5 = 0x100000001;
  *((void *)&v5 + 1) = 0x100000001;
  *((_OWORD *)v4 + 5) = v5;
  *((void *)v4 + 13) = 0;
  *((void *)v4 + 14) = 0;
  *((void *)v4 + 12) = 0;
  *((_DWORD *)v4 + 30) = 0;
  long long v6 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  unsigned int v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    uint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      unsigned int v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v29[0] = v6;
  v29[1] = v16;
  v36[0] = v37;
  v36[1] = (void *)0x600000000;
  uint64_t AxesAttr = mlir::anec::ArgMinMax::getAxesAttr((mlir::Operation **)this);
  mlir::getValues<long long>(AxesAttr, (uint64_t)v36);
  uint64_t v18 = *(mlir::anec **)v36[0];
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v29);
  uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v18, v19);
  if ((DimFromIndex & 0xFF00000000) == 0) {
    std::__throw_bad_optional_access[abi:nn180100]();
  }
  int v21 = DimFromIndex;
  v34[0] = (void *)mlir::anec::ArgMinMax::getModeAttr((mlir::Operation **)this);
  uint64_t Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)v34);
  if (Int) {
    int v23 = 4;
  }
  else {
    int v23 = 2;
  }
  if (Int) {
    int v24 = 3;
  }
  else {
    int v24 = 1;
  }
  if (v21 != 1) {
    int v23 = v24;
  }
  *((_DWORD *)v4 + 30) = v23;
  v34[0] = v35;
  v34[1] = (void *)0x600000000;
  Kerneluint64_t SizeAttr = mlir::anec::ArgMinMax::getKernelSizeAttr((mlir::Operation **)this);
  mlir::getValues<long long>(KernelSizeAttr, (uint64_t)v34);
  *((int32x2_t *)v4 + 10) = vmovn_s64(*(int64x2_t *)v34[0]);
  if (v21 == 3 || (*((_DWORD *)v4 + 20) = 1, v21 != 4)) {
    *((_DWORD *)v4 + 21) = 1;
  }
  v32[0] = v33;
  v32[1] = (void *)0x600000000;
  uint64_t StrideValuesAttr = mlir::anec::ArgMinMax::getStrideValuesAttr((mlir::Operation **)this);
  mlir::getValues<long long>(StrideValuesAttr, (uint64_t)v32);
  *((int32x2_t *)v4 + 11) = vmovn_s64(*(int64x2_t *)v32[0]);
  v30[0] = v31;
  v30[1] = (void *)0x600000000;
  uint64_t PadValuesAttr = mlir::anec::ArgMinMax::getPadValuesAttr((mlir::Operation **)this);
  mlir::getValues<long long>(PadValuesAttr, (uint64_t)v30);
  uint64_t v28 = v30[0];
  *((int32x4_t *)v4 + 6) = vuzp1q_s32(*((int32x4_t *)v30[0] + 1), *(int32x4_t *)v30[0]);
  *a2 = v4;
  if (v28 != v31) {
    free(v28);
  }
  if (v32[0] != v33) {
    free(v32[0]);
  }
  if (v34[0] != v35) {
    free(v34[0]);
  }
  if (v36[0] != v37) {
    free(v36[0]);
  }
}

uint64_t mlir::anec::ArgMinMax::getMode(mlir::Operation **this)
{
  uint64_t ModeAttr = mlir::anec::ArgMinMax::getModeAttr(this);
  return mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&ModeAttr);
}

uint64_t mlir::anec::ArgMinMax::verifyWithANEC(mlir::Operation **a1, mlir::MemoryMapperInterface *a2, unint64_t a3)
{
  v75[63] = *MEMORY[0x1E4F143B8];
  long long v37 = *(_OWORD *)a2;
  __int16 v71 = v73;
  uint64_t v72 = 0x600000000;
  uint64_t AxesAttr = mlir::anec::ArgMinMax::getAxesAttr(a1);
  mlir::getValues<long long>(AxesAttr, (uint64_t)&v71);
  if (v72 >= 3)
  {
    uint64_t v7 = *a1;
    uint64_t v50 = (const void **)"failed: a maximum of two axes can be handled by the operation, but found {0}";
    uint64_t v51 = 76;
    uint64_t v52 = v56;
    uint64_t v53 = 1;
    uint64_t v54 = &unk_1EC9A46D8;
    unint64_t v55 = v72;
    v56[0] = &v54;
    __int16 v64 = 263;
    v62[0] = &v50;
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
LABEL_30:
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v75);
    goto LABEL_31;
  }
  unint64_t v9 = *(mlir::anec **)v71;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
  uint64_t DimFromIndex = mlir::anec::getDimFromIndex(v9, v10);
  if ((DimFromIndex & 0xFF00000000) == 0)
  {
    uint64_t v27 = *a1;
    uint64_t v28 = v71;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v37);
    uint64_t v50 = (const void **)"failed: found axis ({0}) incompatible with rank of tensor input ({1}). ArgMin/Max is supported "
                         "only on Channel or Spatial dimensions.";
    uint64_t v51 = 133;
    uint64_t v52 = v57;
    uint64_t v53 = 2;
    uint64_t v54 = &unk_1EC9A4648;
    unint64_t v55 = (unint64_t)v28;
    v56[0] = &unk_1EC9A4708;
    v56[1] = v29;
    v57[0] = &v54;
    v57[1] = v56;
    __int16 v64 = 263;
    v62[0] = &v50;
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    goto LABEL_30;
  }
  int v12 = DimFromIndex;
  *(void *)buffer = mlir::anec::ArgMinMax::getModeAttr(a1);
  uint64_t Int = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)buffer);
  if (v12 == 1) {
    uint64_t v14 = @"ChannelArgMin";
  }
  else {
    uint64_t v14 = @"SpatialArgMin";
  }
  unint64_t v15 = @"SpatialArgMax";
  if (v12 == 1) {
    unint64_t v15 = @"ChannelArgMax";
  }
  if (Int == 1) {
    uint64_t v14 = v15;
  }
  uint64_t v38 = v14;
  v69[0] = v70;
  v69[1] = (void *)0x600000000;
  Kerneluint64_t SizeAttr = mlir::anec::ArgMinMax::getKernelSizeAttr(a1);
  mlir::getValues<unsigned long long>(KernelSizeAttr, (uint64_t)v69);
  uint64_t v8 = 1;
  uint64_t v40 = 1;
  int8x16_t v39 = vextq_s8(*(int8x16_t *)v69[0], *(int8x16_t *)v69[0], 8uLL);
  v67[0] = v68;
  v67[1] = (void *)0x600000000;
  uint64_t StrideValuesAttr = mlir::anec::ArgMinMax::getStrideValuesAttr(a1);
  mlir::getValues<unsigned long long>(StrideValuesAttr, (uint64_t)v67);
  int v43 = 1;
  int v42 = *(void *)v67[0];
  int v41 = *((void *)v67[0] + 1);
  v65[0] = v66;
  v65[1] = (void *)0xC00000000;
  uint64_t PadValuesAttr = mlir::anec::ArgMinMax::getPadValuesAttr(a1);
  mlir::getValues<int>(PadValuesAttr, (uint64_t)v65);
  int v48 = 0;
  int v49 = 0;
  int v46 = *(_DWORD *)v65[0];
  int v47 = *((_DWORD *)v65[0] + 1);
  int v44 = *((_DWORD *)v65[0] + 2);
  int v45 = *((_DWORD *)v65[0] + 3);
  *(void *)buffer = 1;
  uint64_t v50 = 0;
  ANECUnitValidatorCreate();
  v62[0] = v63;
  v62[1] = (void *)0x100000000;
  uint64_t v35 = 0;
  uint64_t v36 = 0;
  if (ANECValidateArgMinMaxLayer())
  {
    uint64_t v31 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v32 = *a1;
    uint64_t v19 = MEMORY[0x1E4FBA488] + 104;
    v61[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v20 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v52 = (void *)(MEMORY[0x1E4FBA488] + 64);
    uint64_t v21 = MEMORY[0x1E4FBA408];
    uint64_t v22 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    uint64_t v50 = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)&v50 + (void)*(v50 - 3)) = v22;
    uint64_t v51 = 0;
    int v23 = (std::ios_base *)((char *)&v50 + (void)*(v50 - 3));
    std::ios_base::init(v23, &v53);
    v23[1].__vftable = 0;
    v23[1].__fmtflags_ = -1;
    int v24 = *(void **)(v21 + 40);
    uint64_t v52 = *(void **)(v21 + 32);
    *(void **)((char *)&v52 + *(v52 - 3)) = v24;
    uint64_t v50 = *(const void ***)(v21 + 8);
    *(const void ***)((char *)&v50 + (void)*(v50 - 3)) = *(const void ***)(v21 + 48);
    v61[0] = v19;
    uint64_t v50 = v31;
    uint64_t v52 = (void *)v20;
    std::streambuf::basic_streambuf();
    uint64_t v25 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v53 = MEMORY[0x1E4FBA470] + 16;
    long long __p = 0u;
    long long v59 = 0u;
    int v60 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v52, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    uint64_t v50 = *(const void ***)v21;
    unint64_t v26 = *(void **)(v21 + 72);
    *(const void ***)((char *)&v50 + (void)*(v50 - 3)) = *(const void ***)(v21 + 64);
    uint64_t v52 = v26;
    uint64_t v53 = v25;
    if (SBYTE7(v59) < 0) {
      operator delete((void *)__p);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v61);
    LOWORD(v54) = 260;
    uint64_t v50 = (const void **)&v33;
    uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v75);
    if (v34 < 0) {
      operator delete(v33);
    }
  }
  if (v62[0] != v63) {
    free(v62[0]);
  }
  ANECUnitValidatorDelete();
  if (v65[0] != v66) {
    free(v65[0]);
  }
  if (v67[0] != v68) {
    free(v67[0]);
  }
  if (v69[0] != v70) {
    free(v69[0]);
  }
LABEL_31:
  if (v71 != v73) {
    free(v71);
  }
  return v8;
}

uint64_t mlir::anec::ArgMinMax::addOpToNetwork(mlir::anec::ArgMinMax *a1, uint64_t a2)
{
  mlir::anec::ArgMinMax::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::GlobalArgMinMax::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v62[22] = *MEMORY[0x1E4F143B8];
  uint64_t v53 = a6;
  v54[0] = 0;
  char v55 = 0;
  uint64_t v56 = a7;
  uint64_t v57 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v53);
    if (v55) {
      char v55 = 0;
    }
    mlir::OperationName::OperationName(v54, "anec.global_arg_min_max", 23, Context);
    char v55 = 1;
  }
  uint64_t v58 = a4;
  uint64_t v59 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (mlir::anec::GlobalArgMinMaxAdaptor::verify(&v53, v18))
  {
    uint64_t v19 = (uint64_t *)mlir::TypeRange::dereference_iterator(a9, 0);
    uint64_t v20 = (uint64_t)v19;
    if (!v19) {
      goto LABEL_18;
    }
    uint64_t v21 = *v19;
    unint64_t v22 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v23 = *(unsigned int *)(v21 + 16);
    if (!v23) {
      goto LABEL_18;
    }
    int v24 = *(void **)(v21 + 8);
    uint64_t v25 = &v24[2 * v23];
    do
    {
      unint64_t v26 = v23 >> 1;
      uint64_t v27 = &v24[2 * (v23 >> 1)];
      unint64_t v29 = *v27;
      uint64_t v28 = v27 + 2;
      v23 += ~(v23 >> 1);
      if (v29 < v22) {
        int v24 = v28;
      }
      else {
        unint64_t v23 = v26;
      }
    }
    while (v23);
    if (v24 != v25 && *v24 == v22) {
      uint64_t v30 = v24[1];
    }
    else {
LABEL_18:
    }
      uint64_t v30 = 0;
    v50[0] = v20;
    v50[1] = v30;
    unsigned int Axis = mlir::anec::detail::GlobalArgMinMaxGenericAdaptorBase::getAxis((mlir::anec::detail::GlobalArgMinMaxGenericAdaptorBase *)&v53);
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
    if (v32 <= Axis)
    {
      uint64_t v40 = v50[0];
      uint64_t v41 = *(unsigned int *)(a11 + 8);
      if (v41 >= *(_DWORD *)(a11 + 12))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v41 + 1, 8);
        LODWORD(v41) = *(_DWORD *)(a11 + 8);
      }
      *(void *)(*(void *)a11 + 8 * v41) = v40;
      ++*(_DWORD *)(a11 + 8);
      return 1;
    }
    uint64_t ArgAttrsAttr = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
    uint64_t v34 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v50);
    uint64_t v36 = (unsigned char *)(v34 + 8 * v35);
    int v60 = v62;
    uint64_t v61 = 0x600000000;
    uint64_t v37 = v36 - ArgAttrsAttr;
    if ((unint64_t)(v36 - ArgAttrsAttr) < 0x31)
    {
      unsigned int v38 = 0;
      if (v36 == ArgAttrsAttr)
      {
LABEL_34:
        LODWORD(v61) = v38 + ((unint64_t)v37 >> 3);
        unsigned int v42 = mlir::anec::detail::GlobalArgMinMaxGenericAdaptorBase::getAxis((mlir::anec::detail::GlobalArgMinMaxGenericAdaptorBase *)&v53);
        int v43 = v60;
        *((void *)v60 + v42) = 1;
        uint64_t v44 = v61;
        uint64_t v46 = mlir::Float16Type::get(this, v45);
        *(void *)&long long v51 = v43;
        *((void *)&v51 + 1) = v44;
        char v52 = 1;
        uint64_t v47 = mlir::ShapedType::cloneWith(v50, &v51, v46);
        uint64_t v48 = *(unsigned int *)(a11 + 8);
        if (v48 >= *(_DWORD *)(a11 + 12))
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v48 + 1, 8);
          LODWORD(v48) = *(_DWORD *)(a11 + 8);
        }
        *(void *)(*(void *)a11 + 8 * v48) = v47;
        ++*(_DWORD *)(a11 + 8);
        if (v60 != v62) {
          free(v60);
        }
        return 1;
      }
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v62, v37 >> 3, 8);
      unsigned int v38 = v61;
      if (v36 == ArgAttrsAttr) {
        goto LABEL_34;
      }
    }
    memcpy((char *)v60 + 8 * v38, ArgAttrsAttr, v36 - ArgAttrsAttr);
    unsigned int v38 = v61;
    goto LABEL_34;
  }
  if (!a3) {
    return 0;
  }
  mlir::emitError((uint64_t)a2, (uint64_t)&v60);
  if (v60) {
    mlir::Diagnostic::operator<<((uint64_t)&v61, "Failed to verify adaptor");
  }
  uint64_t v39 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v60);
  if (v60) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v60);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v61);
  return v39;
}

uint64_t mlir::anec::GlobalArgMinMaxAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v16[23] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = *a1;
  for (uint64_t i = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v12);
        ;
        uint64_t i = (mlir::CallGraphNode *)((char *)i + 16))
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v12))
    {
      long long v5 = "'anec.global_arg_min_max' op requires attribute 'axis'";
      goto LABEL_11;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
  }
  uint64_t v6 = *((void *)i + 1);
  while (1)
  {
    if (i == (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v12))
    {
      long long v5 = "'anec.global_arg_min_max' op requires attribute 'mode'";
      goto LABEL_11;
    }
    if (*(void *)(*(void *)(a1[1] + 96) + 8) == mlir::CallGraphNode::getCallableRegion(i)) {
      break;
    }
    uint64_t i = (mlir::CallGraphNode *)((char *)i + 16);
  }
  uint64_t v9 = *((void *)i + 1);
  if (!v6
    || *(_UNKNOWN **)(*(void *)v6 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
    && (v10[0] = v6,
        uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v10),
        mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 32)))
  {
    if (!v9) {
      return 1;
    }
    if (*(_UNKNOWN **)(*(void *)v9 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      v10[0] = v9;
      uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v10);
      if (mlir::Type::isSignlessInteger((mlir::Type *)&Value, 64))
      {
        uint64_t v14 = v9;
        if (!mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v14)) {
          return 1;
        }
        uint64_t v13 = v9;
        if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v13) == 1) {
          return 1;
        }
      }
    }
    long long v5 = "'anec.global_arg_min_max' op attribute 'mode' failed to satisfy constraint: valid ArgMinMaxMode";
  }
  else
  {
    long long v5 = "'anec.global_arg_min_max' op attribute 'axis' failed to satisfy constraint: 32-bit unsigned integer attribute";
  }
LABEL_11:
  v10[0] = v5;
  __int16 v11 = 259;
  mlir::emitError(a2, (uint64_t)v10, (uint64_t)&Value);
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v16);
  return v7;
}

void *mlir::anec::detail::GlobalArgMinMaxGenericAdaptorBase::getAxis(mlir::anec::detail::GlobalArgMinMaxGenericAdaptorBase *this)
{
  uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue(this);
  uint64_t v3 = mlir::DictionaryAttr::end(this);
  uint64_t v4 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v3 - 16), **(void **)(*((void *)this + 1) + 96));
  if (v5) {
    uint64_t v6 = *((void *)v4 + 1);
  }
  else {
    uint64_t v6 = 0;
  }
  uint64_t v11 = v6;
  mlir::IntegerAttr::getValue(&v11, (llvm::APInt *)&__p);
  if (v10 <= 0x40) {
    return __p;
  }
  uint64_t v7 = *(void *)__p;
  operator delete[](__p);
  return (void *)v7;
}

uint64_t mlir::anec::GlobalArgMinMax::getZinIrUnitInfo@<X0>(mlir::anec::GlobalArgMinMax *this@<X0>, void *a2@<X8>)
{
  uint64_t v4 = (char *)operator new(0x58uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC9960A8;
  *((void *)v4 + 1) = 0;
  *((void *)v4 + 10) = 0x400000006;
  char v5 = (uint64_t *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v5) {
    goto LABEL_10;
  }
  uint64_t v6 = *v5;
  unint64_t v7 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v8 = *(unsigned int *)(v6 + 16);
  if (!v8) {
    goto LABEL_10;
  }
  uint64_t v9 = *(void **)(v6 + 8);
  unsigned int v10 = &v9[2 * v8];
  do
  {
    unint64_t v11 = v8 >> 1;
    uint64_t v12 = &v9[2 * (v8 >> 1)];
    unint64_t v14 = *v12;
    uint64_t v13 = v12 + 2;
    v8 += ~(v8 >> 1);
    if (v14 < v7) {
      uint64_t v9 = v13;
    }
    else {
      unint64_t v8 = v11;
    }
  }
  while (v8);
  if (v9 != v10 && *v9 == v7) {
    uint64_t v15 = v9[1];
  }
  else {
LABEL_10:
  }
    uint64_t v15 = 0;
  v22[0] = v5;
  v22[1] = v15;
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMaxValueAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&MaxValueAttr, (llvm::APInt *)&__p);
  if (v24 > 0x40)
  {
    unint64_t v16 = *(unsigned int *)__p;
    operator delete[](__p);
  }
  else
  {
    unint64_t v16 = __p;
  }
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v22);
  uint64_t DimFromIndex = mlir::anec::getDimFromIndex((mlir::anec *)v16, v17);
  if ((DimFromIndex & 0xFF00000000) != 0) {
    int v19 = dword_1810FE490[(int)DimFromIndex];
  }
  else {
    int v19 = 5;
  }
  *((_DWORD *)v4 + 21) = v19;
  long long __p = (void *)mlir::anec::ClampedRelu::getMinValueAttr((mlir::Operation **)this);
  uint64_t result = mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&__p);
  if (result) {
    int v21 = 2;
  }
  else {
    int v21 = 1;
  }
  *((_DWORD *)v4 + 20) = v21;
  *a2 = v4;
  return result;
}

void *mlir::anec::GlobalArgMinMax::getAxis(mlir::Operation **this)
{
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMaxValueAttr(this);
  mlir::IntegerAttr::getValue(&MaxValueAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return __p;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return (void *)v1;
}

uint64_t mlir::anec::GlobalArgMinMax::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *this, unint64_t a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  mlir::CallableOpInterface::getArgAttrsAttr(this);
  unint64_t v7 = v6;
  v27[0] = (const void **)mlir::anec::ClampedRelu::getMaxValueAttr(a1);
  mlir::IntegerAttr::getValue(v27, (llvm::APInt *)&__p);
  if (v38[0] > 0x40)
  {
    unint64_t v8 = *(unsigned int *)__p;
    operator delete[](__p);
  }
  else
  {
    unint64_t v8 = __p;
  }
  long long __p = (void *)mlir::anec::ClampedRelu::getMinValueAttr(a1);
  mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&__p);
  uint64_t v25 = @"Min";
  uint64_t v9 = 1;
  long long __p = (void *)1;
  v27[0] = 0;
  ANECUnitValidatorCreate();
  v35[0] = v36;
  v35[1] = (void *)0x100000000;
  uint64_t v23 = 0;
  uint64_t v24 = 0;
  if (ANECValidateGlobalArgMinMaxLayer())
  {
    int v19 = (const void **)(MEMORY[0x1E4FBA488] + 24);
    uint64_t v20 = *a1;
    uint64_t v10 = MEMORY[0x1E4FBA488] + 104;
    v34[0] = MEMORY[0x1E4FBA488] + 104;
    uint64_t v11 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v28 = MEMORY[0x1E4FBA488] + 64;
    uint64_t v12 = MEMORY[0x1E4FBA408];
    uint64_t v13 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
    v27[0] = *(const void ***)(MEMORY[0x1E4FBA408] + 16);
    *(const void ***)((char *)v27 + (unint64_t)*(v27[0] - 3)) = v13;
    v27[1] = 0;
    unint64_t v14 = (std::ios_base *)((char *)v27 + (unint64_t)*(v27[0] - 3));
    std::ios_base::init(v14, &v29);
    v14[1].__vftable = 0;
    v14[1].__fmtflags_ = -1;
    uint64_t v15 = *(void *)(v12 + 40);
    uint64_t v28 = *(void *)(v12 + 32);
    *(uint64_t *)((char *)&v28 + *(void *)(v28 - 24)) = v15;
    v27[0] = *(const void ***)(v12 + 8);
    *(const void ***)((char *)v27 + (unint64_t)*(v27[0] - 3)) = *(const void ***)(v12 + 48);
    v34[0] = v10;
    v27[0] = v19;
    uint64_t v28 = v11;
    std::streambuf::basic_streambuf();
    uint64_t v16 = MEMORY[0x1E4FBA470] + 16;
    uint64_t v29 = MEMORY[0x1E4FBA470] + 16;
    long long v31 = 0u;
    long long v32 = 0u;
    int v33 = 24;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v28, (uint64_t)"Invalid configuration", 21);
    std::stringbuf::str();
    v27[0] = *(const void ***)v12;
    uint64_t v17 = *(void *)(v12 + 72);
    *(const void ***)((char *)v27 + (unint64_t)*(v27[0] - 3)) = *(const void ***)(v12 + 64);
    uint64_t v28 = v17;
    uint64_t v29 = v16;
    if (SBYTE7(v32) < 0) {
      operator delete((void *)v31);
    }
    std::streambuf::~streambuf();
    std::iostream::~basic_iostream();
    MEMORY[0x1852FDD70](v34);
    __int16 v30 = 260;
    v27[0] = (const void **)&v21;
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&__p);
    if (__p) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&__p);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v38);
    if (v22 < 0) {
      operator delete(v21);
    }
  }
  if (v35[0] != v36) {
    free(v35[0]);
  }
  ANECUnitValidatorDelete();
  return v9;
}

uint64_t mlir::anec::GlobalArgMinMax::addOpToNetwork(mlir::anec::GlobalArgMinMax *a1, uint64_t a2)
{
  mlir::anec::GlobalArgMinMax::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  unint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    unint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *unint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::Tile::inferPromotedReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v67[22] = *MEMORY[0x1E4F143B8];
  uint64_t v58 = a6;
  LOBYTE(v59) = 0;
  char v60 = 0;
  uint64_t v61 = a7;
  uint64_t v62 = a8;
  if (a6)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)&v58);
    if (v60) {
      char v60 = 0;
    }
    mlir::OperationName::OperationName(&v59, "anec.tile", 9, Context);
    char v60 = 1;
  }
  float v63 = a4;
  uint64_t v64 = a5;
  uint64_t v17 = mlir::UnknownLoc::get(this, a2);
  if (a3) {
    uint64_t v18 = (uint64_t)a2;
  }
  else {
    uint64_t v18 = v17;
  }
  if (mlir::anec::TileAdaptor::verify(&v58, v18))
  {
    uint64_t v65 = v63;
    uint64_t v66 = 0;
    int v19 = (uint64_t *)(*(void *)(mlir::ValueRange::dereference_iterator(&v65, 0) + 8) & 0xFFFFFFFFFFFFFFF8);
    if (!v19) {
      goto LABEL_18;
    }
    uint64_t v20 = *v19;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *(unsigned int *)(v20 + 16);
    if (!v22) {
      goto LABEL_18;
    }
    uint64_t v23 = *(void **)(v20 + 8);
    uint64_t v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      unint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      uint64_t v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        uint64_t v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_18:
    }
      uint64_t v29 = 0;
    v52[0] = (uint64_t)v19;
    v52[1] = v29;
    uint64_t v65 = v67;
    uint64_t v66 = 0x500000000;
    uint64_t Value = (mlir::CallGraphNode *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v58);
    long long v31 = (mlir::CallGraphNode *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v58);
    long long v32 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, v31, **(void **)(v59 + 96));
    if (v33) {
      uint64_t v34 = *((void *)v32 + 1);
    }
    else {
      uint64_t v34 = 0;
    }
    mlir::getValues<unsigned long long>(v34, (uint64_t)&v65);
    uint64_t ArgAttrsAttr = (unsigned char *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v52);
    uint64_t v37 = mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v52);
    uint64_t v39 = (unsigned char *)(v37 + 8 * v38);
    char v55 = v57;
    uint64_t v56 = 0x500000000;
    uint64_t v40 = v39 - ArgAttrsAttr;
    if ((unint64_t)(v39 - ArgAttrsAttr) < 0x29)
    {
      int v41 = 0;
      unsigned int v42 = v57;
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v57, v40 >> 3, 8);
      int v41 = v56;
      unsigned int v42 = v55;
    }
    if (v39 != ArgAttrsAttr)
    {
      memcpy(&v42[8 * v41], ArgAttrsAttr, v39 - ArgAttrsAttr);
      int v41 = v56;
      unsigned int v42 = v55;
    }
    uint64_t v43 = v41 + ((unint64_t)v40 >> 3);
    LODWORD(v56) = v43;
    uint64_t v44 = v66;
    if (v66 == v43 && v66)
    {
      int v45 = (uint64_t *)v65;
      uint64_t v46 = v42;
      do
      {
        uint64_t v47 = *v45++;
        *v46++ *= v47;
        --v44;
      }
      while (v44);
    }
    *(void *)&long long v53 = v42;
    *((void *)&v53 + 1) = v43;
    char v54 = 1;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v52);
    uint64_t v49 = mlir::ShapedType::cloneWith(v52, &v53, OperandRange);
    uint64_t v50 = *(unsigned int *)(a11 + 8);
    if (v50 >= *(_DWORD *)(a11 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v50 + 1, 8);
      LODWORD(v50) = *(_DWORD *)(a11 + 8);
    }
    *(void *)(*(void *)a11 + 8 * v50) = v49;
    ++*(_DWORD *)(a11 + 8);
    if (v55 != v57) {
      free(v55);
    }
    if (v65 != v67) {
      free(v65);
    }
    return 1;
  }
  else if (a3)
  {
    mlir::emitError((uint64_t)a2, (uint64_t)&v65);
    if (v65) {
      mlir::Diagnostic::operator<<((uint64_t)&v66, "Failed to verify adaptor");
    }
    uint64_t v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v65);
    if (v65) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v65);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)&v66);
  }
  else
  {
    return 0;
  }
  return v35;
}

uint64_t mlir::anec::TileAdaptor::verify(uint64_t *a1, uint64_t a2)
{
  v40[23] = *MEMORY[0x1E4F143B8];
  uint64_t v38 = *a1;
  for (uint64_t i = (uint64_t *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v38); ; i += 2)
  {
    if (i == (uint64_t *)mlir::DictionaryAttr::end((mlir::DictionaryAttr *)&v38))
    {
      char v5 = "'anec.tile' op requires attribute 'multipliers'";
      goto LABEL_31;
    }
    if (**(void **)(a1[1] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)i)) {
      break;
    }
  }
  long long v6 = (void *)i[1];
  if (!v6) {
    return 1;
  }
  if (mlir::DenseIntElementsAttr::classof(i[1]))
  {
    uint64_t v7 = *v6;
    unint64_t v8 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v9 = *(unsigned int *)(v7 + 16);
    if (!v9) {
      goto LABEL_16;
    }
    uint64_t v10 = *(void **)(v7 + 8);
    uint64_t v11 = &v10[2 * v9];
    do
    {
      unint64_t v12 = v9 >> 1;
      uint64_t v13 = &v10[2 * (v9 >> 1)];
      unint64_t v15 = *v13;
      unint64_t v14 = v13 + 2;
      v9 += ~(v9 >> 1);
      if (v15 < v8) {
        uint64_t v10 = v14;
      }
      else {
        unint64_t v9 = v12;
      }
    }
    while (v9);
    if (v10 != v11 && *v10 == v8) {
      uint64_t v16 = v10[1];
    }
    else {
LABEL_16:
    }
      uint64_t v16 = 0;
    v36[0] = v6;
    v36[1] = v16;
    uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v36);
    uint64_t v18 = Type;
    if (!Type) {
      goto LABEL_26;
    }
    uint64_t v19 = *Type;
    unint64_t v20 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v21 = *(unsigned int *)(v19 + 16);
    if (!v21) {
      goto LABEL_26;
    }
    unint64_t v22 = *(void **)(v19 + 8);
    uint64_t v23 = &v22[2 * v21];
    do
    {
      unint64_t v24 = v21 >> 1;
      unint64_t v25 = &v22[2 * (v21 >> 1)];
      unint64_t v27 = *v25;
      unint64_t v26 = v25 + 2;
      v21 += ~(v21 >> 1);
      if (v27 < v20) {
        unint64_t v22 = v26;
      }
      else {
        unint64_t v21 = v24;
      }
    }
    while (v21);
    if (v22 != v23 && *v22 == v20) {
      uint64_t v28 = v22[1];
    }
    else {
LABEL_26:
    }
      uint64_t v28 = 0;
    uint64_t v39 = v18;
    v40[0] = v28;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v39);
    if (v29 == 1)
    {
      char v33 = v6;
      v34[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v33);
      v34[1] = v30;
      uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v34);
      if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
        return 1;
      }
    }
  }
  char v5 = "'anec.tile' op attribute 'multipliers' failed to satisfy constraint: ui64 elements attribute of rank 1";
LABEL_31:
  v36[0] = v5;
  __int16 v37 = 259;
  mlir::emitError(a2, (uint64_t)v36, (uint64_t)&v39);
  uint64_t v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
  if (v39) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v40);
  return v31;
}

void mlir::anec::Tile::getZinIrUnitInfo(mlir::anec::Tile *this@<X0>, void *a2@<X8>)
{
  v26[6] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0x78uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC9958E8;
  *((void *)v4 + 1) = 0;
  *((_OWORD *)v4 + 5) = 0u;
  *((_OWORD *)v4 + 6) = 0u;
  *((_DWORD *)v4 + 28) = 1065353216;
  v25[0] = v26;
  v25[1] = (void *)0x600000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr((mlir::Operation **)this);
  mlir::getValues<unsigned long long>(MultipliersAttr, (uint64_t)v25);
  long long v6 = (_DWORD *)(*(void *)(*(void *)(*(void *)(*(void *)this + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = *(void *)v6;
  unint64_t v8 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v9 = *(unsigned int *)(v7 + 16);
  if (!v9) {
    goto LABEL_10;
  }
  uint64_t v10 = *(void **)(v7 + 8);
  uint64_t v11 = &v10[2 * v9];
  do
  {
    unint64_t v12 = v9 >> 1;
    uint64_t v13 = &v10[2 * (v9 >> 1)];
    unint64_t v15 = *v13;
    unint64_t v14 = v13 + 2;
    v9 += ~(v9 >> 1);
    if (v15 < v8) {
      uint64_t v10 = v14;
    }
    else {
      unint64_t v9 = v12;
    }
  }
  while (v9);
  if (v10 != v11 && *v10 == v8) {
    uint64_t v16 = (_DWORD *)v10[1];
  }
  else {
LABEL_10:
  }
    uint64_t v16 = 0;
  v24[0] = v6;
  v24[1] = v16;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v24);
  if (v17)
  {
    unint64_t v18 = v17;
    for (uint64_t i = 0; i != (mlir::anec *)v18; uint64_t i = (mlir::anec *)((char *)i + 1))
    {
      uint64_t v21 = *((void *)v25[0] + i);
      uint64_t DimFromIndex = mlir::anec::getDimFromIndex(i, v18);
      if ((DimFromIndex & 0xFF00000000) != 0) {
        int v20 = dword_1810FE490[(int)DimFromIndex];
      }
      else {
        int v20 = 5;
      }
      int v23 = v20;
      v24[0] = &v23;
      *((_DWORD *)std::__hash_table<std::__hash_value_type<ZinIrDimension,int>,std::__unordered_map_hasher<ZinIrDimension,std::__hash_value_type<ZinIrDimension,int>,std::hash<ZinIrDimension>,std::equal_to<ZinIrDimension>,true>,std::__unordered_map_equal<ZinIrDimension,std::__hash_value_type<ZinIrDimension,int>,std::equal_to<ZinIrDimension>,std::hash<ZinIrDimension>,true>,std::allocator<std::__hash_value_type<ZinIrDimension,int>>>::__emplace_unique_key_args<ZinIrDimension,std::piecewise_construct_t const&,std::tuple<ZinIrDimension&&>,std::tuple<>>((uint64_t)(v4 + 80), &v23, (uint64_t)&std::piecewise_construct, v24)+ 5) = v21;
    }
  }
  *a2 = v4;
  if (v25[0] != v26) {
    free(v25[0]);
  }
}

uint64_t mlir::anec::Tile::verifyWithANEC(mlir::Operation **a1, mlir::CallableOpInterface *a2, unint64_t a3)
{
  v50[63] = *MEMORY[0x1E4F143B8];
  ANECTileLayerDescInitialize();
  uint64_t v46 = v48;
  uint64_t v47 = 0x600000000;
  uint64_t MultipliersAttr = mlir::anec::Tile::getMultipliersAttr(a1);
  mlir::getValues<long long>(MultipliersAttr, (uint64_t)&v46);
  uint64_t v7 = v47;
  mlir::CallableOpInterface::getArgAttrsAttr(a2);
  if (v8 == v7)
  {
    if (v47 == 4)
    {
      *(void *)buffer = 1;
      llvm::SmallVectorImpl<long long>::insert_one_impl<long long>((uint64_t)&v46, (uint64_t)v46 + 16, (uint64_t *)buffer);
    }
    uint64_t v9 = *((void *)v46 + 1);
    uint64_t v29 = *(void *)v46;
    uint64_t v32 = v9;
    char v33 = 0;
    long long v30 = *((_OWORD *)v46 + 1);
    uint64_t v31 = *((void *)v46 + 4);
    uint64_t v10 = 1;
    *(void *)buffer = 1;
    ANECUnitValidatorCreate();
    v44[0] = v45;
    v44[1] = (void *)0x100000000;
    uint64_t v27 = 0;
    uint64_t v28 = 0;
    if (ANECValidateTileLayer())
    {
      int v23 = (const void **)(MEMORY[0x1E4FBA488] + 24);
      unint64_t v24 = *a1;
      uint64_t v11 = MEMORY[0x1E4FBA488] + 104;
      v43[0] = MEMORY[0x1E4FBA488] + 104;
      uint64_t v12 = MEMORY[0x1E4FBA488] + 64;
      uint64_t v35 = (void *)(MEMORY[0x1E4FBA488] + 64);
      uint64_t v13 = MEMORY[0x1E4FBA408];
      unint64_t v14 = *(const void ***)(MEMORY[0x1E4FBA408] + 24);
      char v33 = *(void ***)(MEMORY[0x1E4FBA408] + 16);
      *(void ***)((char *)&v33 + (void)*(v33 - 3)) = (void **)v14;
      uint64_t v34 = 0;
      unint64_t v15 = (std::ios_base *)((char *)&v33 + (void)*(v33 - 3));
      std::ios_base::init(v15, &v36);
      v15[1].__vftable = 0;
      v15[1].__fmtflags_ = -1;
      uint64_t v16 = *(void **)(v13 + 40);
      uint64_t v35 = *(void **)(v13 + 32);
      *(void **)((char *)&v35 + *(v35 - 3)) = v16;
      char v33 = *(void ***)(v13 + 8);
      *(void ***)((char *)&v33 + (void)*(v33 - 3)) = *(void ***)(v13 + 48);
      v43[0] = v11;
      char v33 = (void **)v23;
      uint64_t v35 = (void *)v12;
      std::streambuf::basic_streambuf();
      uint64_t v17 = MEMORY[0x1E4FBA470] + 16;
      uint64_t v36 = MEMORY[0x1E4FBA470] + 16;
      long long __p = 0u;
      long long v41 = 0u;
      int v42 = 24;
      std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(&v35, (uint64_t)"Invalid configuration", 21);
      std::stringbuf::str();
      char v33 = *(void ***)v13;
      unint64_t v18 = *(void **)(v13 + 72);
      *(void ***)((char *)&v33 + (void)*(v33 - 3)) = *(void ***)(v13 + 64);
      uint64_t v35 = v18;
      uint64_t v36 = v17;
      if (SBYTE7(v41) < 0) {
        operator delete((void *)__p);
      }
      std::streambuf::~streambuf();
      std::iostream::~basic_iostream();
      MEMORY[0x1852FDD70](v43);
      LOWORD(v37[0]) = 260;
      char v33 = &v25;
      uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
      if (*(void *)buffer) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v50);
      if (v26 < 0) {
        operator delete(v25);
      }
    }
    if (v44[0] != v45) {
      free(v44[0]);
    }
    ANECUnitValidatorDelete();
  }
  else
  {
    uint64_t v19 = *a1;
    uint64_t v20 = v47;
    mlir::CallableOpInterface::getArgAttrsAttr(a2);
    char v33 = (void **)"failed: the number of multipliers ({0}) must be equal to rank ({1})";
    uint64_t v34 = 67;
    uint64_t v35 = v39;
    uint64_t v36 = 2;
    v37[0] = &unk_1EC9A46D8;
    v37[1] = v20;
    v38[0] = &unk_1EC9A4708;
    v38[1] = v21;
    v39[0] = v37;
    v39[1] = v38;
    unsigned char v45[8] = 263;
    v44[0] = &v33;
    uint64_t v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)buffer);
    if (*(void *)buffer) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)buffer);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v50);
  }
  if (v46 != v48) {
    free(v46);
  }
  return v10;
}

uint64_t mlir::anec::Tile::getMultipliersAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  char v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    long long v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    long long v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8), **(void **)(*((void *)*this + 6) + 96));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::Tile::addOpToNetwork(mlir::anec::Tile *a1, uint64_t a2)
{
  mlir::anec::Tile::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

BOOL mlir::anec::DeQuant::getZinIrUnitInfo@<W0>(mlir::anec::DeQuant *this@<X0>, void *a2@<X8>)
{
  v12[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0x90uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC995B50;
  *((void *)v4 + 1) = 0;
  v4[80] = 0;
  *(void *)(v4 + 84) = -1;
  *((void *)v4 + 12) = -1;
  v4[104] = 0;
  *(void *)(v4 + 108) = -1;
  *((void *)v4 + 15) = -1;
  *((_DWORD *)v4 + 32) = 1065353216;
  *(void *)(v4 + 132) = 0x600000000;
  *((_DWORD *)v4 + 35) = 0;
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMaxValueAttr((mlir::Operation **)this);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&MaxValueAttr, (uint64_t)&__p);
  *((float *)v4 + 32) = llvm::APFloat::convertToFloat(&__p);
  char v5 = (void *)v12[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v6) == v5) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v12);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v12);
  }
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMinValueAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&MaxValueAttr, (llvm::APInt *)&__p);
  if (LODWORD(v12[0]) > 0x40)
  {
    uint64_t v7 = *(void *)__p;
    operator delete[](__p);
  }
  else
  {
    uint64_t v7 = (uint64_t)((void)__p << -(uint64_t)LODWORD(v12[0])) >> -(uint64_t)LODWORD(v12[0]);
  }
  *((_DWORD *)v4 + 33) = v7;
  long long __p = (void *)mlir::getElementTypeOrSelf(*(void *)(*(void *)(*(void *)this + 72) + 24));
  BOOL result = mlir::Type::isSignedInteger((mlir::Type *)&__p);
  if (result) {
    int v9 = 1;
  }
  else {
    int v9 = 2;
  }
  *((_DWORD *)v4 + 35) = v9;
  *a2 = v4;
  return result;
}

llvm::detail::DoubleAPFloat *mlir::anec::DeQuant::getScale@<X0>(mlir::Operation **this@<X0>, uint64_t a2@<X8>)
{
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMaxValueAttr(this);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&MaxValueAttr, a2);
}

uint64_t mlir::anec::DeQuant::getZeroPoint(mlir::Operation **this)
{
  uint64_t MinValueAttr = mlir::anec::ClampedRelu::getMinValueAttr(this);
  mlir::IntegerAttr::getValue(&MinValueAttr, (llvm::APInt *)&__p);
  if (v4 <= 0x40) {
    return (uint64_t)((void)__p << -(uint64_t)v4) >> -(uint64_t)v4;
  }
  uint64_t v1 = *(void *)__p;
  operator delete[](__p);
  return v1;
}

uint64_t mlir::anec::DeQuant::addOpToNetwork(mlir::anec::DeQuant *a1, uint64_t a2)
{
  mlir::anec::DeQuant::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

void mlir::anec::Quant::getZinIrUnitInfo(mlir::anec::Quant *this@<X0>, void *a2@<X8>)
{
  v10[3] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = (char *)operator new(0x90uLL);
  *((void *)v4 + 2) = 0;
  *((void *)v4 + 3) = 0;
  *((_DWORD *)v4 + 8) = 0;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_OWORD *)(v4 + 56) = 0u;
  *((void *)v4 + 9) = -1;
  *(void *)uint64_t v4 = &unk_1EC9959B8;
  *((void *)v4 + 1) = 0;
  v4[80] = 0;
  *(void *)(v4 + 84) = -1;
  *((void *)v4 + 12) = -1;
  v4[104] = 0;
  *(void *)(v4 + 108) = -1;
  *((void *)v4 + 15) = -1;
  *((_DWORD *)v4 + 32) = 1065353216;
  *(void *)(v4 + 132) = 0x600000000;
  *((_DWORD *)v4 + 35) = 0;
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMaxValueAttr((mlir::Operation **)this);
  mlir::FloatAttr::getValue((mlir::FloatAttr *)&MaxValueAttr, (uint64_t)&__p);
  *((float *)v4 + 32) = llvm::APFloat::convertToFloat(&__p);
  char v5 = (void *)v10[0];
  if (llvm::APFloatBase::PPCDoubleDouble(v6) == v5) {
    llvm::detail::DoubleAPFloat::~DoubleAPFloat((llvm::detail::DoubleAPFloat *)v10);
  }
  else {
    llvm::detail::IEEEFloat::~IEEEFloat((llvm::detail::IEEEFloat *)v10);
  }
  uint64_t MaxValueAttr = mlir::anec::ClampedRelu::getMinValueAttr((mlir::Operation **)this);
  mlir::IntegerAttr::getValue(&MaxValueAttr, (llvm::APInt *)&__p);
  if (LODWORD(v10[0]) > 0x40)
  {
    uint64_t v7 = *(void *)__p;
    operator delete[](__p);
  }
  else
  {
    uint64_t v7 = (uint64_t)((void)__p << -(uint64_t)LODWORD(v10[0])) >> -(uint64_t)LODWORD(v10[0]);
  }
  *((_DWORD *)v4 + 33) = v7;
  *a2 = v4;
}

uint64_t mlir::anec::Quant::addOpToNetwork(mlir::anec::Quant *a1, uint64_t a2)
{
  mlir::anec::Quant::getZinIrUnitInfo(a1, &v11);
  uint64_t v3 = (std::__shared_weak_count *)operator new(0xC8uLL);
  v3->__shared_owners_ = 0;
  v3->__shared_weak_owners_ = 0;
  v3->__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9D0088;
  uint64_t v4 = v11;
  uint64_t v11 = 0;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB3F8;
  p_shared_owners = (std::string *)&v3[1].__shared_owners_;
  if (*(char *)(v4 + 31) < 0)
  {
    std::string::__init_copy_ctor_external(p_shared_owners, *(const std::string::value_type **)(v4 + 8), *(void *)(v4 + 16));
  }
  else
  {
    long long v6 = *(_OWORD *)(v4 + 8);
    v3[2].__vftable = *(std::__shared_weak_count_vtbl **)(v4 + 24);
    *(_OWORD *)&p_shared_owners->__r_.__value_.__l.__data_ = v6;
  }
  LODWORD(v3[2].__shared_owners_) = 17;
  v3[1].__vftable = (std::__shared_weak_count_vtbl *)&unk_1EC9CB310;
  v3[2].__shared_weak_owners_ = v4;
  LOBYTE(v3[3].__vftable) = 0;
  v3[3].__shared_owners_ = 0;
  v3[3].__shared_weak_owners_ = (uint64_t)&v3[4].__shared_owners_;
  v3[4].__vftable = (std::__shared_weak_count_vtbl *)0x100000000;
  v3[5].__shared_weak_owners_ = (uint64_t)&v3[6].__shared_owners_;
  v3[6].__vftable = (std::__shared_weak_count_vtbl *)0x300000000;
  *(void *)&long long v12 = v3 + 1;
  *((void *)&v12 + 1) = v3;
  uint64_t v7 = *(void **)(a2 + 232);
  if ((unint64_t)v7 >= *(void *)(a2 + 240))
  {
    uint64_t v8 = std::vector<std::shared_ptr<mlir::anec::ANECIRUnit>>::__push_back_slow_path<std::shared_ptr<mlir::anec::ANECIRUnit> const&>(a2 + 224, &v12);
    uint64_t v3 = (std::__shared_weak_count *)*((void *)&v12 + 1);
    *(void *)(a2 + 232) = v8;
    if (!v3) {
      goto LABEL_8;
    }
  }
  else
  {
    *uint64_t v7 = v3 + 1;
    v7[1] = v3;
    atomic_fetch_add_explicit(&v3->__shared_owners_, 1uLL, memory_order_relaxed);
    *(void *)(a2 + 232) = v7 + 2;
  }
  if (!atomic_fetch_add(&v3->__shared_owners_, 0xFFFFFFFFFFFFFFFFLL))
  {
    ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
    std::__shared_weak_count::__release_weak(v3);
    uint64_t v9 = v11;
    if (!v11) {
      return 1;
    }
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v9 = v11;
  if (v11) {
LABEL_9:
  }
    (*(void (**)(uint64_t))(*(void *)v9 + 8))(v9);
  return 1;
}

uint64_t mlir::anec::T0::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::T0::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::anec::A11Legacy::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A11Legacy::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::anec::A17::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A17::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::anec::A16::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A16::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::anec::A12::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A12::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::anec::A13::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A13::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::anec::A14::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A14::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

uint64_t mlir::anec::A15::parse(mlir::AsmParser *a1, uint64_t a2)
{
  return mlir::function_interface_impl::parseFunctionOp(a1, a2, 0, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), (uint64_t (*)(uint64_t, mlir::DictionaryAttr **, void *, void, void *, void, void, void **))llvm::function_ref<mlir::Type ()(mlir::Builder &,llvm::ArrayRef<mlir::Type>,llvm::ArrayRef<mlir::Type>,mlir::function_interface_impl::VariadicFlag,std::string &)>::callback_fn<mlir::anec::A15::parse(mlir::OpAsmParser &,mlir::OperationState &)::$_0>, (uint64_t)&v3, **(void **)(*(void *)(a2 + 8) + 96), *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16));
}

unint64_t mlir::anec::A11Legacy::getBody(mlir::anec::A11Legacy *this)
{
  unint64_t v1 = *(unsigned int *)(*(void *)this + 44);
  if ((v1 & 0x7FFFFF) != 0) {
    return ((*(void *)this + 16 * ((v1 >> 23) & 1) + ((v1 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
  }
         + 32 * *(unsigned int *)(*(void *)this + 40);
  else {
    return 0;
  }
}

uint64_t mlir::anec::A11Legacy::getSymNameAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  char v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    long long v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    long long v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 24));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::A11Legacy::getSymName(mlir::Operation **this)
{
  uint64_t SymNameAttr = mlir::anec::A11Legacy::getSymNameAttr(this);
  return mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&SymNameAttr);
}

uint64_t mlir::anec::A11Legacy::getFunctionTypeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  char v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    long long v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    long long v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::A11Legacy::getFunctionType(mlir::Operation **this)
{
  uint64_t FunctionTypeAttr = mlir::anec::A11Legacy::getFunctionTypeAttr(this);
  return mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&FunctionTypeAttr);
}

uint64_t mlir::anec::A11Legacy::getArgAttrsAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  char v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    long long v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    long long v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 32), **(void **)(*((void *)*this + 6) + 96));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (*(_UNKNOWN **)(*(void *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id) {
    return *((void *)v9 + 1);
  }
  return 0;
}

uint64_t mlir::anec::A11Legacy::getResAttrsAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  char v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    long long v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    long long v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 16));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (*(_UNKNOWN **)(*(void *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id) {
    return *((void *)v9 + 1);
  }
  return 0;
}

uint64_t mlir::Operation::removeAttr(uint64_t a1, uint64_t a2)
{
  v12[9] = *MEMORY[0x1E4F143B8];
  uint64_t v10 = a2;
  if (*(unsigned char *)(a1 + 47)
    && (uint64_t AttrData = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10),
        uint64_t InherentAttr = mlir::Operation::getInherentAttr(a1, AttrData, v4),
        v6))
  {
    uint64_t v7 = InherentAttr;
    mlir::Operation::setInherentAttr(a1, v10, 0);
  }
  else
  {
    mlir::NamedAttrList::NamedAttrList(v11, *(void *)(a1 + 56));
    uint64_t v7 = mlir::NamedAttrList::erase((uint64_t)v11, v10);
    if (v7)
    {
      uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
      *(void *)(a1 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v11, Context);
    }
    if (v11[0] != v12) {
      free(v11[0]);
    }
  }
  return v7;
}

void mlir::anec::A11Legacy::build(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t *a5, void *a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, void *a11, unint64_t a12, uint64_t a13, uint64_t a14, mlir::Operation **a15, uint64_t a16, void *__src, uint64_t a18)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a2 + 112;
  *(void *)(a2 + 192) = 0;
  uint64_t v26 = *(unsigned int *)(a2 + 120);
  if (a18 + v26 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(v25, (void *)(a2 + 128), a18 + v26, 16);
    LODWORD(v26) = *(_DWORD *)(a2 + 120);
  }
  if (a18)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v26), __src, 16 * a18);
    LODWORD(v26) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v26 + a18;
  char v73[8] = 261;
  __int16 v71 = a3;
  uint64_t v72 = a4;
  uint64_t StringAttr = mlir::Builder::getStringAttr((mlir::StringAttr **)a1, (mlir::MLIRContext *)&v71);
  uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  __int16 v70 = 261;
  uint64_t v67 = "sym_name";
  uint64_t v68 = 8;
  uint64_t v29 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v67);
  mlir::NamedAttribute::NamedAttribute(&v74, v29, StringAttr);
  mlir::NamedAttrList::push_back(v25, (uint64_t)v74, v75);
  uint64_t v30 = mlir::FunctionType::get(*(mlir::MLIRContext **)a1, a9, a10, a13, a14);
  uint64_t v31 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8);
  uint64_t v32 = mlir::TypeAttr::get(v30);
  mlir::NamedAttribute::NamedAttribute(&v67, v31, v32);
  mlir::NamedAttrList::push_back(v25, (uint64_t)v67, v68);
  char v33 = (uint64_t *)mlir::OperationState::addRegion((mlir::OperationState *)a2);
  uint64_t v34 = operator new(0x48uLL);
  *uint64_t v34 = 0u;
  v34[1] = 0u;
  *((void *)v34 + 4) = v34 + 2;
  *((void *)v34 + 5) = v34 + 2;
  *((void *)v34 + 7) = 0;
  *((void *)v34 + 8) = 0;
  *((void *)v34 + 6) = 0;
  __int16 v71 = v73;
  uint64_t v72 = 0x400000000;
  uint64_t v67 = a6;
  uint64_t v68 = 0;
  if (a7)
  {
    uint64_t v35 = 0;
    do
    {
      int v74 = (void *)mlir::ValueRange::dereference_iterator(&v67, v35);
      uint64_t Loc = mlir::Value::getLoc((mlir::Value *)&v74);
      uint64_t v37 = v72;
      if (v72 >= (unint64_t)HIDWORD(v72))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, v72 + 1, 8);
        uint64_t v37 = v72;
      }
      *((void *)v71 + v37) = Loc;
      uint64_t v38 = (v72 + 1);
      LODWORD(v72) = v72 + 1;
      uint64_t v35 = ++v68;
    }
    while (v67 != a6 || v35 != a7);
    uint64_t v40 = v71;
  }
  else
  {
    uint64_t v38 = 0;
    uint64_t v40 = v73;
  }
  mlir::Block::addArguments(v34, a9, a10, (uint64_t)v40, v38);
  llvm::ilist_traits<mlir::Block>::addNodeToList((uint64_t)v33, (uint64_t)v34);
  uint64_t v41 = *v33;
  *((void *)v34 + 2) = v33;
  *((void *)v34 + 1) = v41;
  *(void *)(v41 + 8) = (char *)v34 + 8;
  uint64_t *v33 = (uint64_t)v34 + 8;
  int v42 = (_OWORD *)(a1 + 16);
  long long v64 = *(_OWORD *)(a1 + 16);
  uint64_t v44 = *((void *)v34 + 5);
  uint64_t v43 = *((void *)v34 + 6);
  *(void *)(a1 + 16) = v34;
  *(void *)(a1 + 24) = v44;
  uint64_t v45 = *((void *)v34 + 7);
  uint64_t v67 = a6;
  uint64_t v68 = 0;
  v69[0] = v43;
  if (a7 && v45 != v43)
  {
    uint64_t v46 = 0;
    do
    {
      uint64_t v50 = mlir::ValueRange::dereference_iterator(&v67, v46);
      uint64_t v51 = *(void *)v69[0];
      uint64_t v66 = v50;
      int v74 = 0;
      char v52 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(a5, (unint64_t *)&v66, &v74);
      long long v53 = v74;
      if ((v52 & 1) == 0)
      {
        long long v53 = llvm::DenseMapBase<llvm::DenseMap<mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>,mlir::Value,mlir::Value,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,mlir::Value>>::InsertIntoBucketImpl<mlir::Value>((uint64_t)a5, (uint64_t)&v66, (unint64_t *)&v66, v74);
        *long long v53 = v66;
        v53[1] = 0;
      }
      v53[1] = v51;
      uint64_t v46 = v68 + 1;
      uint64_t v47 = v69[0] + 8;
      uint64_t v68 = v46;
      v69[0] += 8;
    }
    while ((v46 != a7 || v67 != a6) && v47 != v45);
  }
  if (a16)
  {
    uint64_t v55 = 8 * a16;
    do
    {
      uint64_t v56 = *a15++;
      mlir::OpBuilder::clone((uint64_t **)a1, v56, (mlir::IRMapping *)a5);
      v55 -= 8;
    }
    while (v55);
  }
  uint64_t v67 = v69;
  uint64_t v68 = 0x600000000;
  if (a12 < 7)
  {
    unsigned int v57 = 0;
  }
  else
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v67, v69, a12, 8);
    unsigned int v57 = v68;
  }
  int v74 = a11;
  uint64_t v75 = 0;
  char v76 = a5;
  char v77 = 1;
  if (a12)
  {
    uint64_t v58 = 0;
    uint64_t v59 = (uint64_t *)((char *)v67 + 8 * v57);
    do
    {
      uint64_t v61 = mlir::ValueRange::dereference_iterator(&v74, v58);
      uint64_t v62 = v76;
      uint64_t v65 = v61;
      uint64_t v66 = 0;
      if (llvm::DenseMapBase<llvm::DenseMap<mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>,mlir::Value,unsigned int,llvm::DenseMapInfo<mlir::Value,void>,llvm::detail::DenseMapPair<mlir::Value,unsigned int>>::LookupBucketFor<mlir::Value>(v76, (unint64_t *)&v65, &v66))BOOL v63 = v66 == *v62 + 16 * *((unsigned int *)v62 + 4); {
      else
      }
        BOOL v63 = 1;
      if (!v63) {
        uint64_t v61 = *(void *)(v66 + 8);
      }
      *v59++ = v61;
      uint64_t v58 = ++v75;
    }
    while (v74 != a11 || v58 != a12);
    unsigned int v57 = v68;
  }
  LODWORD(v68) = v57 + a12;
  mlir::OpBuilder::create<mlir::anec::RegionReturn,llvm::SmallVector<mlir::Value,6u> &>((mlir::OpBuilder *)a1, *(void *)a2, (uint64_t)&v67);
  if (v67 != v69) {
    free(v67);
  }
  if ((void)v64)
  {
    *int v42 = v64;
  }
  else
  {
    *(void *)int v42 = 0;
    *(void *)(a1 + 24) = 0;
  }
  if (v71 != v73) {
    free(v71);
  }
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::anec::RegionReturn,llvm::SmallVector<mlir::Value,6u> &>(mlir::OpBuilder *a1, uint64_t a2, uint64_t a3)
{
  v18[38] = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a2;
  uint64_t Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  uint64_t v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"anec.region_return", (const unsigned __int8 *)0x12, Context);
  if (!v8)
  {
    __int16 v16 = 1283;
    _OWORD v15[2] = (uint64_t)"anec.region_return";
    v15[3] = 18;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    __int16 v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v18);
    llvm::report_fatal_error((llvm::Twine *)v18, 1);
  }
  mlir::OperationState::OperationState(v18, a2, v7);
  mlir::ValueRange::ValueRange(v17, *(void *)a3, *(unsigned int *)(a3 + 8));
  mlir::OperationState::addOperands((uint64_t)v18, v17[0], v17[1]);
  uint64_t v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v18);
  if (*(_UNKNOWN **)(*((void *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::anec::RegionReturn,void>::id) {
    uint64_t v10 = v9;
  }
  else {
    uint64_t v10 = 0;
  }
  mlir::OperationState::~OperationState((mlir::OperationState *)v18);
  return v10;
}

BOOL mlir::anec::A11Legacy::verifyInvariantsImpl(uint64_t **this)
{
  v16[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (uint64_t *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_10:
    char v8 = "requires attribute 'function_type'";
LABEL_18:
    uint64_t v13 = (const void **)v8;
    __int16 v14 = 259;
    mlir::OpState::emitOpError(this, &v13, (uint64_t)&AttrDictionary);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v16);
    return v11;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 16 * v4;
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (**(void **)((*this)[6] + 96) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      uint64_t v6 = Value[1];
    }
    Value += 2;
    v7 -= 16;
    if (!v7) {
      goto LABEL_10;
    }
  }
  if (!v7)
  {
LABEL_17:
    char v8 = "requires attribute 'sym_name'";
    goto LABEL_18;
  }
  uint64_t v9 = 0;
  uint64_t v10 = (const void **)Value[1];
  while (*(void *)(*(void *)((*this)[6] + 96) + 24) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    if (*(void *)(*(void *)((*this)[6] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value)) {
      uint64_t v9 = Value[1];
    }
    Value += 2;
    v7 -= 16;
    if (!v7) {
      goto LABEL_17;
    }
  }
  return mlir::anec::__mlir_ods_local_attr_constraint_ANECOps0(*this, Value[1], (const void **)"sym_name", (const void **)8)&& mlir::anec::__mlir_ods_local_attr_constraint_ANECOps1(*this, v10, (const void **)"function_type", (const void **)0xD)&& mlir::anec::__mlir_ods_local_attr_constraint_ANECOps2(*this, v6, (const void **)"arg_attrs", (const void **)9)&& mlir::anec::__mlir_ods_local_attr_constraint_ANECOps2(*this, v9, (const void **)"res_attrs", (const void **)9)
      && mlir::anec::__mlir_ods_local_region_constraint_ANECOps0(*this, (((unint64_t)&(*this)[2* (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1)+ 8]+ (((unint64_t)*((unsigned int *)*this + 11) >> 21) & 0x7F8)+ 7) & 0xFFFFFFFFFFFFFFF8)+ 32 * *((unsigned int *)*this + 10), (uint64_t)"body", 4, 0) != 0;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps0(uint64_t *a1, uint64_t a2, const void **a3, const void **a4)
{
  v11[23] = *MEMORY[0x1E4F143B8];
  if (!a2 || *(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id) {
    return 1;
  }
  __int16 v9 = 257;
  mlir::Operation::emitOpError(a1, v8, (uint64_t)&v10);
  if (v10)
  {
    mlir::Diagnostic::operator<<((uint64_t)v11, "attribute '");
    if (v10)
    {
      __int16 v9 = 261;
      v8[0] = a3;
      v8[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v11, v8);
      if (v10) {
        mlir::Diagnostic::operator<<((uint64_t)v11, "' failed to satisfy constraint: string attribute");
      }
    }
  }
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v10);
  if (v10) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v10);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v11);
  return v6;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps1(uint64_t *a1, const void **a2, const void **a3, const void **a4)
{
  v13[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    uint64_t v12 = a2;
    if (*(_UNKNOWN **)(*(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v12) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id)
    {
      v10[0] = a2;
      if (*(_UNKNOWN **)(*(void *)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v10) + 136) == &mlir::detail::TypeIDResolver<mlir::FunctionType,void>::id) {
        return 1;
      }
    }
  }
  __int16 v11 = 257;
  mlir::Operation::emitOpError(a1, v10, (uint64_t)&v12);
  if (v12)
  {
    mlir::Diagnostic::operator<<((uint64_t)v13, "attribute '");
    if (v12)
    {
      __int16 v11 = 261;
      v10[0] = a3;
      v10[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v13, v10);
      if (v12) {
        mlir::Diagnostic::operator<<((uint64_t)v13, "' failed to satisfy constraint: type attribute of function type");
      }
    }
  }
  uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v12);
  if (v12) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v12);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v13);
  return v8;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps2(uint64_t *a1, uint64_t a2, const void **a3, const void **a4)
{
  v16[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (*(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::ArrayAttr,void>::id)
  {
    uint64_t v15 = a2;
    uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v15);
    uint64_t v9 = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v15);
    uint64_t v11 = v9 + 8 * v10;
    if (v11 != Value)
    {
      while (*(void *)Value
           && *(_UNKNOWN **)(**(void **)Value + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
      {
        Value += 8;
        if (Value == v11) {
          return 1;
        }
      }
      goto LABEL_3;
    }
    return 1;
  }
LABEL_3:
  __int16 v14 = 257;
  mlir::Operation::emitOpError(a1, v13, (uint64_t)&v15);
  if (v15)
  {
    mlir::Diagnostic::operator<<((uint64_t)v16, "attribute '");
    if (v15)
    {
      __int16 v14 = 261;
      v13[0] = a3;
      v13[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v16, v13);
      if (v15) {
        mlir::Diagnostic::operator<<((uint64_t)v16, "' failed to satisfy constraint: Array of dictionary attributes");
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v15);
  if (v15) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v15);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v16);
  return v7;
}

uint64_t mlir::anec::__mlir_ods_local_region_constraint_ANECOps0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  v29[19] = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a2 + 8);
  if (v8 != a2 && *(void *)(v8 + 8) == a2) {
    return 1;
  }
  unint64_t v22 = (const void **)"region #";
  __int16 v23 = 259;
  mlir::Operation::emitOpError(a1, &v22, (uint64_t)&v24);
  if (v24)
  {
    LODWORD(v20[0]) = 5;
    v20[1] = (const void **)a5;
    uint64_t v9 = v20;
    unint64_t v10 = v26;
    if (v27 >= v28)
    {
      unint64_t v16 = v27 + 1;
      if (v26 <= (unint64_t)v20 && v26 + 24 * v27 > (unint64_t)v20)
      {
        uint64_t v17 = (char *)v20 - v26;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v29, v16, 24);
        unint64_t v10 = v26;
        uint64_t v9 = (const void ***)&v17[v26];
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v26, v29, v16, 24);
        uint64_t v9 = v20;
        unint64_t v10 = v26;
      }
    }
    unint64_t v11 = v10 + 24 * v27;
    long long v12 = *(_OWORD *)v9;
    *(void *)(v11 + 16) = v9[2];
    *(_OWORD *)unint64_t v11 = v12;
    ++v27;
  }
  if (a4)
  {
    __int16 v19 = 1283;
    v18[0] = " ('";
    v18[2] = a3;
    void v18[3] = a4;
    v20[0] = (const void **)v18;
    void v20[2] = (const void **)"') ";
    __int16 v13 = 770;
  }
  else
  {
    v20[0] = (const void **)" ";
    __int16 v13 = 259;
  }
  __int16 v21 = v13;
  if (v24)
  {
    mlir::Diagnostic::operator<<((uint64_t)v25, v20);
    if (v24) {
      mlir::Diagnostic::operator<<((uint64_t)v25, "failed to verify constraint: region with 1 blocks");
    }
  }
  uint64_t v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v24);
  if (v24) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v24);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v25);
  return v14;
}

uint64_t *mlir::Attribute::cast<mlir::ElementsAttr>(uint64_t **a1)
{
  unint64_t v1 = *a1;
  if (*a1)
  {
    uint64_t v2 = *v1;
    unint64_t v3 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v4 = *(unsigned int *)(v2 + 16);
    if (v4)
    {
      char v5 = *(void **)(v2 + 8);
      do
      {
        unint64_t v6 = v4 >> 1;
        uint64_t v7 = &v5[2 * (v4 >> 1)];
        unint64_t v9 = *v7;
        uint64_t v8 = v7 + 2;
        v4 += ~(v4 >> 1);
        if (v9 < v3) {
          char v5 = v8;
        }
        else {
          unint64_t v4 = v6;
        }
      }
      while (v4);
    }
  }
  return v1;
}

uint64_t llvm::isa<mlir::anec::ArgMinMaxModeAttr,mlir::Attribute>(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*(_UNKNOWN **)(*(void *)*a1 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
    return 0;
  }
  uint64_t v5 = *a1;
  uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v5);
  uint64_t result = mlir::Type::isSignlessInteger((mlir::Type *)&Value, 64);
  if (result)
  {
    uint64_t v4 = v1;
    if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v4))
    {
      uint64_t v3 = v1;
      return mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v3) == 1;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::anec::ArgMinMax::getAxesAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 64), **(void **)(*((void *)*this + 6) + 96));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ArgMinMax::getModeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 32);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 32), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 16));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ArgMinMax::getKernelSizeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 48), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ArgMinMax::getStrideValuesAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 64);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 32));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ArgMinMax::getPadValuesAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 48);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 24));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ArgMinMax>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      __int16 v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::ArgMinMax::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::ArgMinMax::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void v33[2] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a4);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v32);
  uint64_t v15 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16);
  uint64_t v16 = mlir::IntegerType::get(*a1, 0x40u, 0);
  uint64_t v17 = mlir::IntegerAttr::get(v16, a5);
  mlir::NamedAttribute::NamedAttribute(&__src, v15, v17);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v32);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), a6);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v32);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 32), a7);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v32);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 24), a8);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v32);
  __src = v33;
  uint64_t v32 = 0x200000000;
  uint64_t v18 = (mlir::UnknownLoc *)*a1;
  __int16 v19 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v30, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v22 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v29, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ArgMinMax>::inferReturnTypes(v18, v19, 1, v30[0], v30[1], Dictionary, v22, v23, v29[0], v29[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v24 = __src;
  }
  uint64_t v25 = v32;
  uint64_t v26 = *(unsigned int *)(a2 + 72);
  unint64_t v27 = v26 + v32;
  if (v27 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v27, 8);
    LODWORD(v26) = *(_DWORD *)(a2 + 72);
  }
  if (v25)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v26), v24, 8 * v25);
    LODWORD(v26) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v26 + v25;
  if (__src != v33) {
    free(__src);
  }
}

BOOL mlir::anec::ArgMinMax::verifyInvariantsImpl(uint64_t **this)
{
  v85[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&AttrDictionary);
    if (!v4)
    {
LABEL_8:
      uint64_t v7 = "requires attribute 'axes'";
LABEL_29:
      uint64_t v81 = (const void **)v7;
      __int16 v83 = 259;
      mlir::OpState::emitOpError(this, &v81, (uint64_t)&AttrDictionary);
      uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
      if (AttrDictionary) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v85);
      return v22;
    }
  }
  else
  {
    uint64_t Value = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)(v2 + 7));
    if (!v4) {
      goto LABEL_8;
    }
  }
  uint64_t v5 = 16 * v4;
  unint64_t v6 = (const void ***)(Value + 8);
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)(v6 - 1)))
  {
    v6 += 2;
    v5 -= 16;
    if (!v5) {
      goto LABEL_8;
    }
  }
  if (!v5)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'kernel_size'";
    goto LABEL_29;
  }
  unint64_t v8 = 0;
  unint64_t v9 = *v6;
  while (1)
  {
    char v10 = &v6[v8 / 8];
    if (*(void *)(*(void *)((*this)[6] + 96) + 8) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v6[v8 / 8 - 1])) {
      break;
    }
    v8 += 16;
    if (v5 == v8) {
      goto LABEL_13;
    }
  }
  unint64_t v11 = v5 - v8;
  if (v5 == v8)
  {
LABEL_18:
    uint64_t v7 = "requires attribute 'mode'";
    goto LABEL_29;
  }
  long long v12 = *v10;
  while (*(void *)(*(void *)((*this)[6] + 96) + 16) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)(v10 - 1)))
  {
    v10 += 2;
    v11 -= 16;
    if (!v11) {
      goto LABEL_18;
    }
  }
  if (!v11)
  {
LABEL_23:
    uint64_t v7 = "requires attribute 'pad_values'";
    goto LABEL_29;
  }
  unint64_t v13 = 0;
  uint64_t v14 = *v10;
  while (1)
  {
    uint64_t v15 = &v10[v13 / 8];
    if (*(void *)(*(void *)((*this)[6] + 96) + 24) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v10[v13 / 8 - 1])) {
      break;
    }
    v13 += 16;
    if (v11 == v13) {
      goto LABEL_23;
    }
  }
  unint64_t v16 = v11 - v13;
  if (!v16)
  {
LABEL_28:
    uint64_t v7 = "requires attribute 'stride_values'";
    goto LABEL_29;
  }
  __int16 v19 = *v15;
  uint64_t v18 = (mlir::CallGraphNode *)(v15 - 1);
  uint64_t v17 = v19;
  while (1)
  {
    uint64_t CallableRegion = mlir::CallGraphNode::getCallableRegion(v18);
    __int16 v21 = *this;
    if (*(void *)(*(void *)((*this)[6] + 96) + 32) == CallableRegion) {
      break;
    }
    uint64_t v18 = (mlir::CallGraphNode *)((char *)v18 + 16);
    v16 -= 16;
    if (!v16) {
      goto LABEL_28;
    }
  }
  uint64_t v24 = (const void **)*((void *)v18 + 1);
  if (v9)
  {
    if (!mlir::DenseIntElementsAttr::classof((uint64_t)v9)) {
      goto LABEL_78;
    }
    uint64_t v25 = *v9;
    unint64_t v26 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v27 = *((unsigned int *)v25 + 4);
    if (!v27) {
      goto LABEL_43;
    }
    uint64_t v28 = (void *)v25[1];
    uint64_t v29 = &v28[2 * v27];
    do
    {
      unint64_t v30 = v27 >> 1;
      uint64_t v31 = &v28[2 * (v27 >> 1)];
      unint64_t v33 = *v31;
      uint64_t v32 = v31 + 2;
      v27 += ~(v27 >> 1);
      if (v33 < v26) {
        uint64_t v28 = v32;
      }
      else {
        unint64_t v27 = v30;
      }
    }
    while (v27);
    if (v28 != v29 && *v28 == v26) {
      uint64_t v34 = v28[1];
    }
    else {
LABEL_43:
    }
      uint64_t v34 = 0;
    uint64_t v81 = v9;
    uint64_t v82 = v34;
    uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v81);
    uint64_t v36 = Type;
    if (!Type) {
      goto LABEL_53;
    }
    uint64_t v37 = *Type;
    unint64_t v38 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v39 = *(unsigned int *)(v37 + 16);
    if (!v39) {
      goto LABEL_53;
    }
    uint64_t v40 = *(void **)(v37 + 8);
    uint64_t v41 = &v40[2 * v39];
    do
    {
      unint64_t v42 = v39 >> 1;
      uint64_t v43 = &v40[2 * (v39 >> 1)];
      unint64_t v45 = *v43;
      uint64_t v44 = v43 + 2;
      v39 += ~(v39 >> 1);
      if (v45 < v38) {
        uint64_t v40 = v44;
      }
      else {
        unint64_t v39 = v42;
      }
    }
    while (v39);
    if (v40 != v41 && *v40 == v38) {
      uint64_t v46 = v40[1];
    }
    else {
LABEL_53:
    }
      uint64_t v46 = 0;
    unint64_t AttrDictionary = (unint64_t)v36;
    v85[0] = v46;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&AttrDictionary);
    if (v47)
    {
      uint64_t v48 = *v9;
      unint64_t v49 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v50 = *((unsigned int *)v48 + 4);
      if (!v50) {
        goto LABEL_63;
      }
      uint64_t v51 = (void *)v48[1];
      char v52 = &v51[2 * v50];
      do
      {
        unint64_t v53 = v50 >> 1;
        char v54 = &v51[2 * (v50 >> 1)];
        unint64_t v56 = *v54;
        uint64_t v55 = v54 + 2;
        v50 += ~(v50 >> 1);
        if (v56 < v49) {
          uint64_t v51 = v55;
        }
        else {
          unint64_t v50 = v53;
        }
      }
      while (v50);
      if (v51 != v52 && *v51 == v49) {
        uint64_t v57 = v51[1];
      }
      else {
LABEL_63:
      }
        uint64_t v57 = 0;
      v79[0] = v9;
      v79[1] = v57;
      uint64_t v58 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v79);
      uint64_t v59 = v58;
      if (!v58) {
        goto LABEL_73;
      }
      uint64_t v60 = *v58;
      unint64_t v61 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v62 = *(unsigned int *)(v60 + 16);
      if (!v62) {
        goto LABEL_73;
      }
      BOOL v63 = *(void **)(v60 + 8);
      long long v64 = &v63[2 * v62];
      do
      {
        unint64_t v65 = v62 >> 1;
        uint64_t v66 = &v63[2 * (v62 >> 1)];
        unint64_t v68 = *v66;
        uint64_t v67 = v66 + 2;
        v62 += ~(v62 >> 1);
        if (v68 < v61) {
          BOOL v63 = v67;
        }
        else {
          unint64_t v62 = v65;
        }
      }
      while (v62);
      if (v63 != v64 && *v63 == v61) {
        uint64_t v69 = v63[1];
      }
      else {
LABEL_73:
      }
        uint64_t v69 = 0;
      v80[0] = v59;
      v80[1] = v69;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v80);
      if (v70 != 1) {
        goto LABEL_78;
      }
    }
    if (!mlir::hasUniqueValues((uint64_t)v9)
      || (uint64_t v78 = v9, !mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v78))
      || (uint64_t v75 = v9,
          v76[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v75),
          v76[1] = v71,
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v76),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
LABEL_78:
      __int16 v83 = 257;
      mlir::Operation::emitOpError(v21, &v81, (uint64_t)&AttrDictionary);
      if (AttrDictionary)
      {
        mlir::Diagnostic::operator<<((uint64_t)v85, "attribute '");
        if (AttrDictionary)
        {
          __int16 v83 = 261;
          uint64_t v81 = (const void **)"axes";
          uint64_t v82 = 4;
          mlir::Diagnostic::operator<<((uint64_t)v85, &v81);
          if (AttrDictionary) {
            mlir::Diagnostic::operator<<((uint64_t)v85, "' failed to satisfy constraint: ui64 unique not empty elements attribute of ranks 0/1");
          }
        }
      }
      char v72 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
      if (AttrDictionary) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v85);
      if (!v72) {
        return 0;
      }
    }
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps4(*this, v14, (const void **)"mode", (const void **)4)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps5(*this, v12, (const void **)"kernel_size", 11)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps5(*this, v24, (const void **)"stride_values", 13)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps6(*this, v17, (const void **)"pad_values", 10)
    || !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v73 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v73 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v73, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps4(uint64_t *a1, const void **a2, const void **a3, const void **a4)
{
  v15[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v12[0] = a2;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v12);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&Value, 64))
    {
      unint64_t v11 = a2;
      if (!mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v11)) {
        return 1;
      }
      char v10 = a2;
      if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v10) == 1) {
        return 1;
      }
    }
  }
  __int16 v13 = 257;
  mlir::Operation::emitOpError(a1, v12, (uint64_t)&Value);
  if (Value)
  {
    mlir::Diagnostic::operator<<((uint64_t)v15, "attribute '");
    if (Value)
    {
      __int16 v13 = 261;
      v12[0] = a3;
      v12[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v15, v12);
      if (Value) {
        mlir::Diagnostic::operator<<((uint64_t)v15, "' failed to satisfy constraint: valid ArgMinMaxMode");
      }
    }
  }
  uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v15);
  return v8;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps5(uint64_t *a1, const void **a2, const void **a3, uint64_t a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a2)) {
    goto LABEL_26;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *((unsigned int *)v8 + 4);
  if (!v10) {
    goto LABEL_11;
  }
  unint64_t v11 = (void *)v8[1];
  long long v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      unint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_11:
  }
    uint64_t v17 = 0;
  unint64_t v38 = a2;
  uint64_t v39 = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v38);
  __int16 v19 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    unint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    unint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t v41 = v19;
  v42[0] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
  uint64_t v43 = 2;
  if (v31 == 1 && *ArgAttrsAttr == v43)
  {
    uint64_t v35 = a2;
    v36[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v35);
    v36[1] = v32;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v36);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_26:
  __int16 v40 = 257;
  mlir::Operation::emitOpError(a1, &v38, (uint64_t)&v41);
  if (v41)
  {
    mlir::Diagnostic::operator<<((uint64_t)v42, "attribute '");
    if (v41)
    {
      __int16 v40 = 261;
      unint64_t v38 = a3;
      uint64_t v39 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v42, &v38);
      if (v41) {
        mlir::Diagnostic::operator<<((uint64_t)v42, "' failed to satisfy constraint: ui64 elements attribute of shape {2}");
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v33;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps6(uint64_t *a1, const void **a2, const void **a3, uint64_t a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a2)) {
    goto LABEL_26;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *((unsigned int *)v8 + 4);
  if (!v10) {
    goto LABEL_11;
  }
  unint64_t v11 = (void *)v8[1];
  long long v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      unint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_11:
  }
    uint64_t v17 = 0;
  unint64_t v38 = a2;
  uint64_t v39 = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v38);
  __int16 v19 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  uint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    unint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    unint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      uint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t v41 = v19;
  v42[0] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
  uint64_t v43 = 4;
  if (v31 == 1 && *ArgAttrsAttr == v43)
  {
    uint64_t v35 = a2;
    v36[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v35);
    v36[1] = v32;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v36);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_26:
  __int16 v40 = 257;
  mlir::Operation::emitOpError(a1, &v38, (uint64_t)&v41);
  if (v41)
  {
    mlir::Diagnostic::operator<<((uint64_t)v42, "attribute '");
    if (v41)
    {
      __int16 v40 = 261;
      unint64_t v38 = a3;
      uint64_t v39 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v42, &v38);
      if (v41) {
        mlir::Diagnostic::operator<<((uint64_t)v42, "' failed to satisfy constraint: ui64 elements attribute of shape {4}");
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v33;
}

uint64_t mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  v74[19] = *MEMORY[0x1E4F143B8];
  unint64_t v65 = a2;
  unint64_t v9 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    goto LABEL_45;
  }
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *((unsigned int *)v9 + 4);
  if (!v12) {
    goto LABEL_10;
  }
  unint64_t v13 = (void *)v9[1];
  uint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    unint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      unint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  uint64_t v69 = a2;
  v70[0] = v19;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
  {
    uint64_t v20 = *a2;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *((unsigned int *)v20 + 4);
    if (!v22) {
      goto LABEL_22;
    }
    uint64_t v23 = (void *)v20[1];
    uint64_t v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      unint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      unint64_t v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        uint64_t v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_22:
    }
      uint64_t v29 = 0;
    unint64_t v61 = a2;
    uint64_t v62 = v29;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v61))
    {
      unint64_t v30 = *a2;
      unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v32 = *((unsigned int *)v30 + 4);
      if (!v32) {
        goto LABEL_32;
      }
      uint64_t v33 = (void *)v30[1];
      uint64_t v34 = &v33[2 * v32];
      do
      {
        unint64_t v35 = v32 >> 1;
        uint64_t v36 = &v33[2 * (v32 >> 1)];
        unint64_t v38 = *v36;
        uint64_t v37 = v36 + 2;
        v32 += ~(v32 >> 1);
        if (v38 < v31) {
          uint64_t v33 = v37;
        }
        else {
          unint64_t v32 = v35;
        }
      }
      while (v32);
      if (v33 != v34 && *v33 == v31) {
        uint64_t v39 = v33[1];
      }
      else {
LABEL_32:
      }
        uint64_t v39 = 0;
      uint64_t v67 = a2;
      uint64_t v68 = v39;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v67);
      if (v40 == 4) {
        return 1;
      }
      uint64_t v41 = *a2;
      unint64_t v42 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v43 = *((unsigned int *)v41 + 4);
      if (!v43) {
        goto LABEL_42;
      }
      uint64_t v44 = (void *)v41[1];
      unint64_t v45 = &v44[2 * v43];
      do
      {
        unint64_t v46 = v43 >> 1;
        uint64_t v47 = &v44[2 * (v43 >> 1)];
        unint64_t v49 = *v47;
        uint64_t v48 = v47 + 2;
        v43 += ~(v43 >> 1);
        if (v49 < v42) {
          uint64_t v44 = v48;
        }
        else {
          unint64_t v43 = v46;
        }
      }
      while (v43);
      if (v44 != v45 && *v44 == v42) {
        uint64_t v50 = v44[1];
      }
      else {
LABEL_42:
      }
        uint64_t v50 = 0;
      v64[0] = a2;
      v64[1] = v50;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v64);
      if (v51 == 5) {
        return 1;
      }
    }
  }
LABEL_45:
  __int16 v63 = 261;
  unint64_t v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)&v69);
  if (v69)
  {
    mlir::Diagnostic::operator<<((uint64_t)v70, " #");
    if (v69)
    {
      LODWORD(v67) = 5;
      uint64_t v68 = a5;
      unint64_t v53 = (char *)&v67;
      unint64_t v54 = v71;
      if (v72 >= v73)
      {
        unint64_t v59 = v72 + 1;
        if (v71 <= (unint64_t)&v67 && v71 + 24 * v72 > (unint64_t)&v67)
        {
          uint64_t v60 = (char *)&v67 - v71;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v59, 24);
          unint64_t v54 = v71;
          unint64_t v53 = &v60[v71];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v59, 24);
          unint64_t v53 = (char *)&v67;
          unint64_t v54 = v71;
        }
      }
      unint64_t v55 = v54 + 24 * v72;
      long long v56 = *(_OWORD *)v53;
      *(void *)(v55 + 16) = *((void *)v53 + 2);
      *(_OWORD *)unint64_t v55 = v56;
      ++v72;
      if (v69) {
        mlir::Diagnostic::operator<<((uint64_t)v70, " must be 4D/5D memref of 16-bit float or 8-bit signed integer or 8-bit unsigned integer values, but got ");
      }
    }
  }
  uint64_t v57 = mlir::InFlightDiagnostic::append<mlir::Type &>((uint64_t)&v69, (uint64_t *)&v65);
  uint64_t v52 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v57);
  if (v69) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v69);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v70);
  return v52;
}

uint64_t mlir::anec::AveragePool::getStrideAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 32);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 24));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::AveragePool::getPaddingAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 16));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::AveragePool::getKsizeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 32), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::AveragePool::getIncPadAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  uint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 48), **(void **)(*((void *)*this + 6) + 96));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (*(_UNKNOWN **)(*(void *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
    return *((void *)v9 + 1);
  }
  return 0;
}

BOOL mlir::anec::AveragePool::getIncPad(mlir::Operation **this)
{
  return mlir::anec::AveragePool::getIncPadAttr(this) != 0;
}

void mlir::anec::AveragePool::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v28[2] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 24), a4);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v27);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16), a5);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v27);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), a6);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v27);
  if (a7)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a7);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v27);
  }
  __src = v28;
  uint64_t v27 = 0x200000000;
  unint64_t v13 = *a1;
  uint64_t v14 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v25, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v17 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v24, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::AveragePool>::inferReturnTypes(v13, v14, 1, v25[0], v25[1], Dictionary, v17, v18, v24[0], v24[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v19 = __src;
  }
  uint64_t v20 = v27;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v27;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v28) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::AveragePool>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  unint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        unint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    unint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::AveragePool::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::AveragePool::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  void v26[2] = *MEMORY[0x1E4F143B8];
  mlir::OperationState::addOperands(a2, a3, a4);
  *(void *)(a2 + 192) = 0;
  uint64_t v12 = *(unsigned int *)(a2 + 120);
  if (a6 + v12 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a6 + v12, 16);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  if (a6)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v12), a5, 16 * a6);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v12 + a6;
  __src = v26;
  uint64_t v25 = 0x200000000;
  unint64_t v13 = *a1;
  uint64_t v14 = *(mlir::MLIRContext **)a2;
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v17 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::AveragePool>::inferReturnTypes(v13, v14, 1, a3, a4, Dictionary, v17, v18, v23[0], v23[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v19 = __src;
  }
  uint64_t v20 = v25;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v25;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v26) {
    free(__src);
  }
}

BOOL mlir::anec::AveragePool::verifyInvariantsImpl(uint64_t **this)
{
  v21[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_10:
    uint64_t v8 = "requires attribute 'ksize'";
LABEL_21:
    uint64_t v18 = (const void **)v8;
    __int16 v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)&AttrDictionary);
    uint64_t v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v21);
    return v14;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 16 * v4;
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    if (**(void **)((*this)[6] + 96) == mlir::CallGraphNode::getCallableRegion(Value)) {
      uint64_t v6 = *((void *)Value + 1);
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v7 -= 16;
    if (!v7) {
      goto LABEL_10;
    }
  }
  if (!v7)
  {
LABEL_15:
    uint64_t v8 = "requires attribute 'padding'";
    goto LABEL_21;
  }
  uint64_t v9 = 0;
  char v10 = (const void **)*((void *)Value + 1);
  while (1)
  {
    uint64_t v11 = (const void ***)((char *)Value + v9);
    if (*(void *)(*(void *)((*this)[6] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)((char *)Value + v9))) {
      break;
    }
    v9 += 16;
    if (v7 == v9) {
      goto LABEL_15;
    }
  }
  uint64_t v12 = v7 - v9;
  if (!v12)
  {
LABEL_20:
    uint64_t v8 = "requires attribute 'stride'";
    goto LABEL_21;
  }
  unint64_t v13 = v11[1];
  while (*(void *)(*(void *)((*this)[6] + 96) + 24) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)v11))
  {
    v11 += 2;
    v12 -= 16;
    if (!v12) {
      goto LABEL_20;
    }
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps7(*this, v11[1], (const void **)"stride", 6)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps8(*this, v13, (const void **)"padding", 7)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps7(*this, v10, (const void **)"ksize", 5)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps9(*this, v6, (const void **)"inc_pad", (const void **)7)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand",
                           7,
                           0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v16 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v16 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps7(uint64_t *a1, const void **a2, const void **a3, uint64_t a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a2)) {
    goto LABEL_26;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *((unsigned int *)v8 + 4);
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v11 = (void *)v8[1];
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_11:
  }
    uint64_t v17 = 0;
  unint64_t v38 = a2;
  uint64_t v39 = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v38);
  __int16 v19 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  unint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    unint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      unint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t v41 = v19;
  v42[0] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
  uint64_t v43 = 3;
  if (v31 == 1 && *ArgAttrsAttr == v43)
  {
    unint64_t v35 = a2;
    v36[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v35);
    v36[1] = v32;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v36);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_26:
  __int16 v40 = 257;
  mlir::Operation::emitOpError(a1, &v38, (uint64_t)&v41);
  if (v41)
  {
    mlir::Diagnostic::operator<<((uint64_t)v42, "attribute '");
    if (v41)
    {
      __int16 v40 = 261;
      unint64_t v38 = a3;
      uint64_t v39 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v42, &v38);
      if (v41) {
        mlir::Diagnostic::operator<<((uint64_t)v42, "' failed to satisfy constraint: ui64 elements attribute of shape {3}");
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v33;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps8(uint64_t *a1, const void **a2, const void **a3, uint64_t a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a2)) {
    goto LABEL_26;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *((unsigned int *)v8 + 4);
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v11 = (void *)v8[1];
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_11:
  }
    uint64_t v17 = 0;
  unint64_t v38 = a2;
  uint64_t v39 = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v38);
  __int16 v19 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  unint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    unint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      unint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t v41 = v19;
  v42[0] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v41);
  uint64_t v43 = 6;
  if (v31 == 1 && *ArgAttrsAttr == v43)
  {
    unint64_t v35 = a2;
    v36[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v35);
    v36[1] = v32;
    uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v36);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)) {
      return 1;
    }
  }
LABEL_26:
  __int16 v40 = 257;
  mlir::Operation::emitOpError(a1, &v38, (uint64_t)&v41);
  if (v41)
  {
    mlir::Diagnostic::operator<<((uint64_t)v42, "attribute '");
    if (v41)
    {
      __int16 v40 = 261;
      unint64_t v38 = a3;
      uint64_t v39 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v42, &v38);
      if (v41) {
        mlir::Diagnostic::operator<<((uint64_t)v42, "' failed to satisfy constraint: ui64 elements attribute of shape {6}");
      }
    }
  }
  uint64_t v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v41);
  if (v41) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v41);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v42);
  return v33;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps9(uint64_t *a1, uint64_t a2, const void **a3, const void **a4)
{
  v11[23] = *MEMORY[0x1E4F143B8];
  if (!a2 || *(_UNKNOWN **)(*(void *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
    return 1;
  }
  __int16 v9 = 257;
  mlir::Operation::emitOpError(a1, v8, (uint64_t)&v10);
  if (v10)
  {
    mlir::Diagnostic::operator<<((uint64_t)v11, "attribute '");
    if (v10)
    {
      __int16 v9 = 261;
      v8[0] = a3;
      v8[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v11, v8);
      if (v10) {
        mlir::Diagnostic::operator<<((uint64_t)v11, "' failed to satisfy constraint: unit attribute");
      }
    }
  }
  uint64_t v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v10);
  if (v10) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v10);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v11);
  return v6;
}

void mlir::anec::BatchToSpace::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v22[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a4);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v21);
  __src = v22;
  uint64_t v21 = 0x200000000;
  uint64_t v7 = *a1;
  uint64_t v8 = *(void *)a2;
  mlir::ValueRange::ValueRange(v19, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v11 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v18, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::BatchToSpace>::inferReturnTypes(v7, v8, 1, v19[0], v19[1], Dictionary, v11, v12, v18[0], v18[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v13 = __src;
  }
  uint64_t v14 = v21;
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  unint64_t v16 = v15 + v21;
  if (v16 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v16, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  if (v14)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v15), v13, 8 * v14);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v15 + v14;
  if (__src != v22) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::BatchToSpace>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  unint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      __int16 v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        unint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError(a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    unint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::BatchToSpace::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

BOOL mlir::anec::BatchToSpace::verifyInvariantsImpl(uint64_t **this)
{
  v14[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (const void ***)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (v4)
  {
    uint64_t v6 = 16 * v4;
    while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      Value += 2;
      v6 -= 16;
      if (!v6) {
        goto LABEL_8;
      }
    }
    if (mlir::anec::__mlir_ods_local_attr_constraint_ANECOps7(*this, Value[1], (const void **)"factors", 7)&& mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v8 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
      return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
LABEL_8:
    uint64_t v11 = (const void **)"requires attribute 'factors'";
    __int16 v12 = 259;
    mlir::OpState::emitOpError(this, &v11, (uint64_t)&AttrDictionary);
    uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v14);
  }
  return v7;
}

uint64_t mlir::anec::detail::BroadcastGenericAdaptorBase::BroadcastGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "anec.broadcast", 14, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::anec::Broadcast::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v7, 1);
  uint64_t v6 = *(unsigned int *)(a2 + 72);
  if (v6 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v6 + 1, 8);
    LODWORD(v6) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v6) = a3;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::anec::detail::CastGenericAdaptorBase::CastGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "anec.cast", 9, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::anec::Cast::verifyInvariantsImpl(uint64_t **this)
{
  v82[19] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  uint64_t v3 = (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  int v74 = v3;
  uint64_t v4 = *v3;
  if (*((_UNKNOWN **)*v3 + 17) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    goto LABEL_103;
  }
  unint64_t v5 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v6 = *((unsigned int *)v4 + 4);
  if (!v6) {
    goto LABEL_10;
  }
  uint64_t v7 = (void *)v4[1];
  uint64_t v8 = &v7[2 * v6];
  do
  {
    unint64_t v9 = v6 >> 1;
    uint64_t v10 = &v7[2 * (v6 >> 1)];
    unint64_t v12 = *v10;
    uint64_t v11 = v10 + 2;
    v6 += ~(v6 >> 1);
    if (v12 < v5) {
      uint64_t v7 = v11;
    }
    else {
      unint64_t v6 = v9;
    }
  }
  while (v6);
  if (v7 != v8 && *v7 == v5) {
    uint64_t v13 = v7[1];
  }
  else {
LABEL_10:
  }
    uint64_t v13 = 0;
  char v77 = v3;
  v78[0] = v13;
  uint64_t v14 = *(void **)(*(void *)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v77) + 136);
  BOOL v15 = v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2Type,void>::id
     || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNType,void>::id;
  BOOL v16 = v15 || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E5M2FNUZType,void>::id;
  BOOL v17 = v16 || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3FNUZType,void>::id;
  BOOL v18 = v17 || v14 == &mlir::detail::TypeIDResolver<mlir::Float8E4M3B11FNUZType,void>::id;
  BOOL v19 = v18 || v14 == &mlir::detail::TypeIDResolver<mlir::BFloat16Type,void>::id;
  BOOL v20 = v19 || v14 == &mlir::detail::TypeIDResolver<mlir::Float16Type,void>::id;
  BOOL v21 = v20 || v14 == &mlir::detail::TypeIDResolver<mlir::FloatTF32Type,void>::id;
  BOOL v22 = v21 || v14 == &mlir::detail::TypeIDResolver<mlir::Float32Type,void>::id;
  BOOL v23 = v22 || v14 == &mlir::detail::TypeIDResolver<mlir::Float64Type,void>::id;
  BOOL v24 = v23 || v14 == &mlir::detail::TypeIDResolver<mlir::IntegerType,void>::id;
  BOOL v25 = v24 || v14 == &mlir::detail::TypeIDResolver<mlir::Float80Type,void>::id;
  if (!v25 && v14 != &mlir::detail::TypeIDResolver<mlir::Float128Type,void>::id) {
    goto LABEL_103;
  }
  uint64_t v27 = *v3;
  unint64_t v28 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v29 = *((unsigned int *)v27 + 4);
  if (!v29) {
    goto LABEL_57;
  }
  unint64_t v30 = (void *)v27[1];
  uint64_t v31 = &v30[2 * v29];
  do
  {
    unint64_t v32 = v29 >> 1;
    uint64_t v33 = &v30[2 * (v29 >> 1)];
    unint64_t v35 = *v33;
    uint64_t v34 = v33 + 2;
    v29 += ~(v29 >> 1);
    if (v35 < v28) {
      unint64_t v30 = v34;
    }
    else {
      unint64_t v29 = v32;
    }
  }
  while (v29);
  if (v30 != v31 && *v30 == v28) {
    uint64_t v36 = v30[1];
  }
  else {
LABEL_57:
  }
    uint64_t v36 = 0;
  uint64_t v70 = v3;
  uint64_t v71 = v36;
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v70)) {
    goto LABEL_103;
  }
  uint64_t v37 = *v3;
  unint64_t v38 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v39 = *((unsigned int *)v37 + 4);
  if (!v39) {
    goto LABEL_67;
  }
  __int16 v40 = (void *)v37[1];
  uint64_t v41 = &v40[2 * v39];
  do
  {
    unint64_t v42 = v39 >> 1;
    uint64_t v43 = &v40[2 * (v39 >> 1)];
    unint64_t v45 = *v43;
    uint64_t v44 = v43 + 2;
    v39 += ~(v39 >> 1);
    if (v45 < v38) {
      __int16 v40 = v44;
    }
    else {
      unint64_t v39 = v42;
    }
  }
  while (v39);
  if (v40 != v41 && *v40 == v38) {
    uint64_t v46 = v40[1];
  }
  else {
LABEL_67:
  }
    uint64_t v46 = 0;
  uint64_t v75 = v3;
  uint64_t v76 = v46;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v75);
  if (v47 != 4)
  {
    uint64_t v48 = *v3;
    unint64_t v49 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v50 = *((unsigned int *)v48 + 4);
    if (!v50) {
      goto LABEL_77;
    }
    uint64_t v51 = (void *)v48[1];
    uint64_t v52 = &v51[2 * v50];
    do
    {
      unint64_t v53 = v50 >> 1;
      unint64_t v54 = &v51[2 * (v50 >> 1)];
      unint64_t v56 = *v54;
      unint64_t v55 = v54 + 2;
      v50 += ~(v50 >> 1);
      if (v56 < v49) {
        uint64_t v51 = v55;
      }
      else {
        unint64_t v50 = v53;
      }
    }
    while (v50);
    if (v51 != v52 && *v51 == v49) {
      uint64_t v57 = v51[1];
    }
    else {
LABEL_77:
    }
      uint64_t v57 = 0;
    v73[0] = v3;
    v73[1] = v57;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v73);
    if (v58 != 5)
    {
LABEL_103:
      __int16 v72 = 261;
      uint64_t v70 = (const void **)"operand";
      uint64_t v71 = 7;
      mlir::Operation::emitOpError(v2, &v70, (uint64_t)&v77);
      if (v77)
      {
        mlir::Diagnostic::operator<<((uint64_t)v78, " #");
        if (v77)
        {
          LODWORD(v75) = 5;
          uint64_t v76 = 0;
          unint64_t v59 = (char *)&v75;
          unint64_t v60 = v79;
          if (v80 >= v81)
          {
            unint64_t v68 = v80 + 1;
            if (v79 <= (unint64_t)&v75 && v79 + 24 * v80 > (unint64_t)&v75)
            {
              uint64_t v69 = (char *)&v75 - v79;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v82, v68, 24);
              unint64_t v60 = v79;
              unint64_t v59 = &v69[v79];
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v79, v82, v68, 24);
              unint64_t v59 = (char *)&v75;
              unint64_t v60 = v79;
            }
          }
          unint64_t v61 = v60 + 24 * v80;
          long long v62 = *(_OWORD *)v59;
          *(void *)(v61 + 16) = *((void *)v59 + 2);
          *(_OWORD *)unint64_t v61 = v62;
          ++v80;
          if (v77) {
            mlir::Diagnostic::operator<<((uint64_t)v78, " must be 4D/5D memref of floating-point or integer values, but got ");
          }
        }
      }
      uint64_t v63 = mlir::InFlightDiagnostic::append<mlir::Type &>((uint64_t)&v77, (uint64_t *)&v74);
      char v64 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v63);
      if (v77) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v77);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v78);
      if (!v64) {
        return 0;
      }
    }
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v65 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v65 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v65, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v38[23] = *MEMORY[0x1E4F143B8];
  uint64_t v33 = 0;
  uint64_t v34 = v36;
  uint64_t v35 = 0x600000000;
  uint64_t v32 = a4;
  if (a5)
  {
    uint64_t v15 = 0;
    while (1)
    {
      uint64_t v16 = mlir::ValueRange::dereference_iterator(&v32, v15);
      BOOL v17 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v17) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v17, v18);
      uint64_t v20 = v35;
      if (v35 >= (unint64_t)HIDWORD(v35))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v34, v36, v35 + 1, 8);
        uint64_t v20 = v35;
      }
      *((void *)v34 + v20) = RankPromotionTypeForANE;
      unint64_t v21 = (v35 + 1);
      LODWORD(v35) = v35 + 1;
      uint64_t v15 = ++v33;
      if (v32 == a4 && v15 == a5)
      {
        BOOL v23 = v34;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError(a2, (uint64_t)&v37);
      if (v37) {
        mlir::Diagnostic::operator<<((uint64_t)v38, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v37);
      if (v37) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v38);
    }
    else
    {
      uint64_t v22 = 0;
    }
  }
  else
  {
    unint64_t v21 = 0;
    BOOL v23 = v36;
LABEL_16:
    BOOL v24 = mlir::ValueRange::ValueRange(v31, (uint64_t)v23, v21);
    uint64_t v22 = mlir::anec::inferElementwiseReturnTypes((uint64_t)v24, v25, v26, a4, a5, v27, v28, v29, v31[0], v31[1], a11);
  }
  if (v34 != v36) {
    free(v34);
  }
  return v22;
}

void mlir::anec::Ceil::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  void v26[2] = *MEMORY[0x1E4F143B8];
  mlir::OperationState::addOperands(a2, a3, a4);
  *(void *)(a2 + 192) = 0;
  uint64_t v12 = *(unsigned int *)(a2 + 120);
  if (a6 + v12 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a6 + v12, 16);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  if (a6)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v12), a5, 16 * a6);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v12 + a6;
  __src = v26;
  uint64_t v25 = 0x200000000;
  uint64_t v13 = *a1;
  uint64_t v14 = *(void *)a2;
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v17 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(v13, v14, 1, a3, a4, Dictionary, v17, v18, v23[0], v23[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  BOOL v19 = __src;
  }
  uint64_t v20 = v25;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v25;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v26) {
    free(__src);
  }
}

void mlir::anec::ChannelToSpace::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v22[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a4);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v21);
  __src = v22;
  uint64_t v21 = 0x200000000;
  uint64_t v7 = *a1;
  uint64_t v8 = *(void *)a2;
  mlir::ValueRange::ValueRange(v19, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v11 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v18, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ChannelToSpace>::inferReturnTypes(v7, v8, 1, v19[0], v19[1], Dictionary, v11, v12, v18[0], v18[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v13 = __src;
  }
  uint64_t v14 = v21;
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  unint64_t v16 = v15 + v21;
  if (v16 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v16, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  if (v14)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v15), v13, 8 * v14);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v15 + v14;
  if (__src != v22) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ChannelToSpace>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  unint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      BOOL v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError(a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::ChannelToSpace::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

uint64_t mlir::anec::ClampedRelu::getMinValueAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::ClampedRelu::getMaxValueAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    unint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    unint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  unint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 16), **(void **)(*((void *)*this + 6) + 96));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

void mlir::anec::ClampedRelu::build(mlir::Float16Type **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  void v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v27 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8);
  uint64_t F16Type = mlir::Builder::getF16Type(a1, v10);
  uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)a1, F16Type, a4);
  mlir::NamedAttribute::NamedAttribute(&__src, v9, FloatAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v31);
  uint64_t v13 = **(void **)(*(void *)(a2 + 8) + 96);
  uint64_t v15 = mlir::Builder::getF16Type(a1, v14);
  uint64_t v16 = mlir::Builder::getFloatAttr((uint64_t)a1, v15, a5);
  mlir::NamedAttribute::NamedAttribute(&__src, v13, v16);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v31);
  __src = v32;
  uint64_t v31 = 0x200000000;
  uint64_t v17 = *a1;
  uint64_t v18 = *(void *)a2;
  mlir::ValueRange::ValueRange(v29, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v21 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v28, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes((uint64_t)v17, v18, 1, v29[0], v29[1], Dictionary, v21, v22, v28[0], v28[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v23 = __src;
  }
  uint64_t v24 = v31;
  uint64_t v25 = *(unsigned int *)(a2 + 72);
  unint64_t v26 = v25 + v31;
  if (v26 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v26, 8);
    LODWORD(v25) = *(_DWORD *)(a2 + 72);
  }
  if (v24)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v25), v23, 8 * v24);
    LODWORD(v25) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v25 + v24;
  if (__src != v32) {
    free(__src);
  }
}

BOOL mlir::anec::ClampedRelu::verifyInvariantsImpl(uint64_t **this)
{
  v16[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (const void ***)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = "requires attribute 'max_value'";
LABEL_14:
    uint64_t v13 = (const void **)v7;
    __int16 v14 = 259;
    mlir::OpState::emitOpError(this, &v13, (uint64_t)&AttrDictionary);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v16);
    return v9;
  }
  uint64_t v6 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    Value += 2;
    v6 -= 16;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (!v6)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'min_value'";
    goto LABEL_14;
  }
  uint64_t v8 = Value[1];
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
  {
    Value += 2;
    v6 -= 16;
    if (!v6) {
      goto LABEL_13;
    }
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, Value[1], (const void **)"min_value", (const void **)9)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, v8, (const void **)"max_value", (const void **)9)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v11 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v11 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(uint64_t *a1, const void **a2, const void **a3, const void **a4)
{
  v12[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v9[0] = a2;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v9);
    if (mlir::Type::isF16((mlir::Type *)&Value)) {
      return 1;
    }
  }
  __int16 v10 = 257;
  mlir::Operation::emitOpError(a1, v9, (uint64_t)&Value);
  if (Value)
  {
    mlir::Diagnostic::operator<<((uint64_t)v12, "attribute '");
    if (Value)
    {
      __int16 v10 = 261;
      v9[0] = a3;
      v9[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v12, v9);
      if (Value) {
        mlir::Diagnostic::operator<<((uint64_t)v12, "' failed to satisfy constraint: 16-bit float attribute");
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v12);
  return v7;
}

uint64_t mlir::anec::Concat::getInputs(mlir::anec::Concat *this)
{
  if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0) {
    return *(void *)(*(void *)this + 72);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::Concat::getInterleaveAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (*(_UNKNOWN **)(*(void *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id) {
    return *((void *)v9 + 1);
  }
  return 0;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Concat>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  unint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      BOOL v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::Concat::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::Concat::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  unint64_t v30[2] = *MEMORY[0x1E4F143B8];
  mlir::OperationState::addOperands(a2, a3, a4);
  uint64_t v10 = **(void **)(*(void *)(a2 + 8) + 96);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  mlir::NamedAttribute::NamedAttribute(&__src, v10, IntegerAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v29);
  if (a6)
  {
    uint64_t v14 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8);
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v13);
    mlir::NamedAttribute::NamedAttribute(&__src, v14, UnitAttr);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v29);
  }
  __src = v30;
  uint64_t v29 = 0x200000000;
  uint64_t v16 = *(mlir::UnknownLoc **)a1;
  uint64_t v17 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v27, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v20 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v26, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Concat>::inferReturnTypes(v16, v17, 1u, v27[0], v27[1], Dictionary, v20, v21, v26[0], v26[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v22 = __src;
  }
  uint64_t v23 = v29;
  uint64_t v24 = *(unsigned int *)(a2 + 72);
  unint64_t v25 = v24 + v29;
  if (v25 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v25, 8);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  if (v23)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v24), v22, 8 * v23);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v24 + v23;
  if (__src != v30) {
    free(__src);
  }
}

BOOL mlir::anec::Concat::verifyInvariantsImpl(uint64_t **this)
{
  v25[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (v4)
  {
    uint64_t v6 = 16 * v4;
    while (1)
    {
      uint64_t CallableRegion = mlir::CallGraphNode::getCallableRegion(Value);
      uint64_t v8 = *this;
      if (**(void **)((*this)[6] + 96) == CallableRegion) {
        break;
      }
      uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
      v6 -= 16;
      if (!v6) {
        goto LABEL_8;
      }
    }
    uint64_t v10 = (const void **)*((void *)Value + 1);
    for (uint64_t i = 0; v6; v6 -= 16)
    {
      uint64_t v20 = mlir::CallGraphNode::getCallableRegion(Value);
      uint64_t v8 = *this;
      if (*(void *)(*(void *)((*this)[6] + 96) + 8) == v20) {
        uint64_t i = *((void *)Value + 1);
      }
      uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    }
    if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps11(v8, v10, (const void **)"axis", (const void **)4)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps9(*this, i, (const void **)"interleave", (const void **)0xA))
    {
      return 0;
    }
    uint64_t v12 = *this;
    if ((*((unsigned char *)*this + 46) & 0x80) != 0)
    {
      uint64_t v13 = *((unsigned int *)v12 + 17);
      if (v13)
      {
        uint64_t v14 = 0;
        uint64_t v15 = v12[9] + 24;
        while (mlir::anec::__mlir_ods_local_type_constraint_ANECOps2(*this, (const void **)(*(void *)(*(void *)v15 + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v14))
        {
          ++v14;
          v15 += 32;
          if (v13 == v14)
          {
            uint64_t v12 = *this;
            goto LABEL_20;
          }
        }
        return 0;
      }
    }
LABEL_20:
    int v16 = *((_DWORD *)v12 + 9);
    uint64_t v17 = v12 - 2;
    if (v16) {
      uint64_t v18 = (uint64_t)v17;
    }
    else {
      uint64_t v18 = 0;
    }
    uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v18, 0);
    return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
  }
  else
  {
LABEL_8:
    uint64_t v22 = (const void **)"requires attribute 'axis'";
    __int16 v23 = 259;
    mlir::OpState::emitOpError(this, &v22, (uint64_t)&AttrDictionary);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v25);
  }
  return v9;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps11(uint64_t *a1, const void **a2, const void **a3, const void **a4)
{
  v12[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v9[0] = a2;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v9);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64)) {
      return 1;
    }
  }
  __int16 v10 = 257;
  mlir::Operation::emitOpError(a1, v9, (uint64_t)&Value);
  if (Value)
  {
    mlir::Diagnostic::operator<<((uint64_t)v12, "attribute '");
    if (Value)
    {
      __int16 v10 = 261;
      v9[0] = a3;
      v9[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v12, v9);
      if (Value) {
        mlir::Diagnostic::operator<<((uint64_t)v12, "' failed to satisfy constraint: 64-bit unsigned integer attribute");
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v12);
  return v7;
}

uint64_t mlir::anec::__mlir_ods_local_type_constraint_ANECOps2(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  v74[19] = *MEMORY[0x1E4F143B8];
  uint64_t v65 = a2;
  uint64_t v9 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    goto LABEL_45;
  }
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *((unsigned int *)v9 + 4);
  if (!v12) {
    goto LABEL_10;
  }
  uint64_t v13 = (void *)v9[1];
  uint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    int v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  uint64_t v69 = a2;
  v70[0] = v19;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
  {
    uint64_t v20 = *a2;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *((unsigned int *)v20 + 4);
    if (!v22) {
      goto LABEL_22;
    }
    __int16 v23 = (void *)v20[1];
    uint64_t v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      unint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      uint64_t v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        __int16 v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_22:
    }
      uint64_t v29 = 0;
    unint64_t v61 = a2;
    uint64_t v62 = v29;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v61))
    {
      unint64_t v30 = *a2;
      unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v32 = *((unsigned int *)v30 + 4);
      if (!v32) {
        goto LABEL_32;
      }
      uint64_t v33 = (void *)v30[1];
      uint64_t v34 = &v33[2 * v32];
      do
      {
        unint64_t v35 = v32 >> 1;
        uint64_t v36 = &v33[2 * (v32 >> 1)];
        unint64_t v38 = *v36;
        uint64_t v37 = v36 + 2;
        v32 += ~(v32 >> 1);
        if (v38 < v31) {
          uint64_t v33 = v37;
        }
        else {
          unint64_t v32 = v35;
        }
      }
      while (v32);
      if (v33 != v34 && *v33 == v31) {
        uint64_t v39 = v33[1];
      }
      else {
LABEL_32:
      }
        uint64_t v39 = 0;
      uint64_t v67 = a2;
      uint64_t v68 = v39;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v67);
      if (v40 == 4) {
        return 1;
      }
      uint64_t v41 = *a2;
      unint64_t v42 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v43 = *((unsigned int *)v41 + 4);
      if (!v43) {
        goto LABEL_42;
      }
      uint64_t v44 = (void *)v41[1];
      unint64_t v45 = &v44[2 * v43];
      do
      {
        unint64_t v46 = v43 >> 1;
        uint64_t v47 = &v44[2 * (v43 >> 1)];
        unint64_t v49 = *v47;
        uint64_t v48 = v47 + 2;
        v43 += ~(v43 >> 1);
        if (v49 < v42) {
          uint64_t v44 = v48;
        }
        else {
          unint64_t v43 = v46;
        }
      }
      while (v43);
      if (v44 != v45 && *v44 == v42) {
        uint64_t v50 = v44[1];
      }
      else {
LABEL_42:
      }
        uint64_t v50 = 0;
      v64[0] = a2;
      v64[1] = v50;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v64);
      if (v51 == 5) {
        return 1;
      }
    }
  }
LABEL_45:
  __int16 v63 = 261;
  unint64_t v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)&v69);
  if (v69)
  {
    mlir::Diagnostic::operator<<((uint64_t)v70, " #");
    if (v69)
    {
      LODWORD(v67) = 5;
      uint64_t v68 = a5;
      unint64_t v53 = (char *)&v67;
      unint64_t v54 = v71;
      if (v72 >= v73)
      {
        unint64_t v59 = v72 + 1;
        if (v71 <= (unint64_t)&v67 && v71 + 24 * v72 > (unint64_t)&v67)
        {
          unint64_t v60 = (char *)&v67 - v71;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v59, 24);
          unint64_t v54 = v71;
          unint64_t v53 = &v60[v71];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v59, 24);
          unint64_t v53 = (char *)&v67;
          unint64_t v54 = v71;
        }
      }
      unint64_t v55 = v54 + 24 * v72;
      long long v56 = *(_OWORD *)v53;
      *(void *)(v55 + 16) = *((void *)v53 + 2);
      *(_OWORD *)unint64_t v55 = v56;
      ++v72;
      if (v69) {
        mlir::Diagnostic::operator<<((uint64_t)v70, " must be variadic of 4D/5D memref of 16-bit float or 8-bit signed integer or 8-bit unsigned integer values, but got ");
      }
    }
  }
  uint64_t v57 = mlir::InFlightDiagnostic::append<mlir::Type &>((uint64_t)&v69, (uint64_t *)&v65);
  uint64_t v52 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v57);
  if (v69) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v69);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v70);
  return v52;
}

uint64_t mlir::anec::Convolution::getODSOperands(mlir::anec::Convolution *this, unsigned int a2)
{
  if ((*(unsigned char *)(*(void *)this + 46) & 0x80) != 0) {
    uint64_t v2 = *(void *)(*(void *)this + 72);
  }
  else {
    uint64_t v2 = 0;
  }
  return v2 + 32 * a2;
}

uint64_t mlir::anec::Convolution::getODSResults(mlir::anec::Convolution *this, unsigned int a2)
{
  if (*(_DWORD *)(*(void *)this + 36)) {
    uint64_t result = *(void *)this - 16;
  }
  else {
    uint64_t result = 0;
  }
  if (a2) {
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2);
  }
  return result;
}

uint64_t mlir::anec::Convolution::getStrideAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 32);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 56));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::Convolution::getPaddingAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 40));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::Convolution::getPaddingModeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 32);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 48));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (mlir::anec::PaddingModeAttr::classof(*((void *)v9 + 1))) {
    return v11;
  }
  return 0;
}

uint64_t mlir::anec::Convolution::getPaddingMode(mlir::Operation **this)
{
  Paddinguint64_t ModeAttr = mlir::anec::Convolution::getPaddingModeAttr(this);
  return mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&PaddingModeAttr);
}

uint64_t mlir::anec::Convolution::getGroupsAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 32), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 16));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (*(_UNKNOWN **)(*(void *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id) {
    return *((void *)v9 + 1);
  }
  return 0;
}

uint64_t mlir::anec::Convolution::getKernelScaleAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 32), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 24));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (mlir::DenseFPElementsAttr::classof(*((void *)v9 + 1))) {
    return v11;
  }
  return 0;
}

uint64_t mlir::anec::Convolution::getKernelScale(mlir::Operation **this)
{
  return mlir::anec::Convolution::getKernelScaleAttr(this);
}

uint64_t mlir::anec::Convolution::getKernelZeroPointAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 32), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 32));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (mlir::DenseIntElementsAttr::classof(*((void *)v9 + 1))) {
    return v11;
  }
  return 0;
}

uint64_t mlir::anec::Convolution::getKernelZeroPoint(mlir::Operation **this)
{
  return mlir::anec::Convolution::getKernelZeroPointAttr(this);
}

void mlir::anec::Convolution::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v63 = a5;
  uint64_t v64 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v64, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v63, 1);
  int v74 = &v76;
  uint64_t v77 = 1;
  long long v76 = xmmword_1810FE3A0;
  uint64_t v75 = 0x300000003;
  unint64_t v71 = v73;
  uint64_t v72 = 0x300000000;
  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v73, 6uLL, 8);
  int v8 = v72;
  uint64_t v9 = (char *)v71 + 8 * v72;
  *uint64_t v9 = 0u;
  v9[1] = 0u;
  v9[2] = 0u;
  LODWORD(v72) = v8 + 6;
  uint64_t v70 = 3;
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v11 = (void *)mlir::RankedTensorType::get((uint64_t)&v70, 1, IntegerType, 0);
  unint64_t v12 = v11;
  if (!v11) {
    goto LABEL_10;
  }
  uint64_t v13 = *v11;
  unint64_t v14 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v15 = *(unsigned int *)(v13 + 16);
  if (!v15) {
    goto LABEL_10;
  }
  int v16 = *(void **)(v13 + 8);
  uint64_t v17 = &v16[2 * v15];
  do
  {
    unint64_t v18 = v15 >> 1;
    uint64_t v19 = &v16[2 * (v15 >> 1)];
    unint64_t v21 = *v19;
    uint64_t v20 = v19 + 2;
    v15 += ~(v15 >> 1);
    if (v21 < v14) {
      int v16 = v20;
    }
    else {
      unint64_t v15 = v18;
    }
  }
  while (v15);
  if (v16 != v17 && *v16 == v14) {
    uint64_t v22 = v16[1];
  }
  else {
LABEL_10:
  }
    uint64_t v22 = 0;
  uint64_t v23 = mlir::DenseElementsAttr::getFromRawBuffer(v12, v22, v74, 8 * v75, 8, 1, 0);
  uint64_t Context = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  __int16 v67 = 261;
  uint64_t v65 = "stride";
  uint64_t v66 = 6;
  uint64_t v25 = mlir::StringAttr::get(Context, (mlir::MLIRContext *)&v65);
  mlir::NamedAttribute::NamedAttribute(&v68, v25, v23);
  mlir::NamedAttrList::push_back(a2 + 112, v68, v69);
  uint64_t v70 = 3;
  uint64_t v26 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v27 = (void *)mlir::RankedTensorType::get((uint64_t)&v70, 1, v26, 0);
  unint64_t v28 = v27;
  if (!v27) {
    goto LABEL_20;
  }
  uint64_t v29 = *v27;
  unint64_t v30 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v31 = *(unsigned int *)(v29 + 16);
  if (!v31) {
    goto LABEL_20;
  }
  unint64_t v32 = *(void **)(v29 + 8);
  uint64_t v33 = &v32[2 * v31];
  do
  {
    unint64_t v34 = v31 >> 1;
    unint64_t v35 = &v32[2 * (v31 >> 1)];
    unint64_t v37 = *v35;
    uint64_t v36 = v35 + 2;
    v31 += ~(v31 >> 1);
    if (v37 < v30) {
      unint64_t v32 = v36;
    }
    else {
      unint64_t v31 = v34;
    }
  }
  while (v31);
  if (v32 != v33 && *v32 == v30) {
    uint64_t v38 = v32[1];
  }
  else {
LABEL_20:
  }
    uint64_t v38 = 0;
  uint64_t v39 = mlir::DenseElementsAttr::getFromRawBuffer(v28, v38, v74, 8 * v75, 8, 1, 0);
  uint64_t v40 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  __int16 v67 = 261;
  uint64_t v65 = "dilation";
  uint64_t v66 = 8;
  uint64_t v41 = mlir::StringAttr::get(v40, (mlir::MLIRContext *)&v65);
  mlir::NamedAttribute::NamedAttribute(&v68, v41, v39);
  mlir::NamedAttrList::push_back(a2 + 112, v68, v69);
  uint64_t v70 = 6;
  uint64_t v42 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  unint64_t v43 = (void *)mlir::RankedTensorType::get((uint64_t)&v70, 1, v42, 0);
  uint64_t v44 = v43;
  if (!v43) {
    goto LABEL_30;
  }
  uint64_t v45 = *v43;
  unint64_t v46 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v47 = *(unsigned int *)(v45 + 16);
  if (!v47) {
    goto LABEL_30;
  }
  uint64_t v48 = *(void **)(v45 + 8);
  unint64_t v49 = &v48[2 * v47];
  do
  {
    unint64_t v50 = v47 >> 1;
    uint64_t v51 = &v48[2 * (v47 >> 1)];
    unint64_t v53 = *v51;
    uint64_t v52 = v51 + 2;
    v47 += ~(v47 >> 1);
    if (v53 < v46) {
      uint64_t v48 = v52;
    }
    else {
      unint64_t v47 = v50;
    }
  }
  while (v47);
  if (v48 != v49 && *v48 == v46) {
    uint64_t v54 = v48[1];
  }
  else {
LABEL_30:
  }
    uint64_t v54 = 0;
  uint64_t v55 = mlir::DenseElementsAttr::getFromRawBuffer(v44, v54, v71, 8 * v72, 8, 1, 0);
  long long v56 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  __int16 v67 = 261;
  uint64_t v65 = "padding";
  uint64_t v66 = 7;
  uint64_t v57 = mlir::StringAttr::get(v56, (mlir::MLIRContext *)&v65);
  mlir::NamedAttribute::NamedAttribute(&v68, v57, v55);
  mlir::NamedAttrList::push_back(a2 + 112, v68, v69);
  uint64_t v58 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, v58, 1);
  unint64_t v60 = (mlir::StringAttr *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  __int16 v67 = 261;
  uint64_t v65 = "groups";
  uint64_t v66 = 6;
  uint64_t v61 = mlir::StringAttr::get(v60, (mlir::MLIRContext *)&v65);
  mlir::NamedAttribute::NamedAttribute(&v68, v61, IntegerAttr);
  mlir::NamedAttrList::push_back(a2 + 112, v68, v69);
  uint64_t v62 = *(unsigned int *)(a2 + 72);
  if (v62 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v62 + 1, 8);
    LODWORD(v62) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v62) = a3;
  ++*(_DWORD *)(a2 + 72);
  if (v71 != v73) {
    free(v71);
  }
  if (v74 != &v76) {
    free(v74);
  }
}

void mlir::anec::Convolution::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  void v34[2] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a4;
  uint64_t v29 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 56), a5);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), a6);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 40), a7);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  if (a8)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 48), a8);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  if (a9)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16), a9);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  if (a10)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a10);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  if (a11)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 24), a11);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  if (a12)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 32), a12);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  __src = v34;
  uint64_t v33 = 0x200000000;
  unint64_t v18 = *a1;
  uint64_t v19 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v31, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v22 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v30, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Convolution>::inferReturnTypes(v18, v19, 1, v31[0], v31[1], Dictionary, v22, v23, v30[0], v30[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v24 = __src;
  }
  uint64_t v25 = v33;
  uint64_t v26 = *(unsigned int *)(a2 + 72);
  unint64_t v27 = v26 + v33;
  if (v27 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v27, 8);
    LODWORD(v26) = *(_DWORD *)(a2 + 72);
  }
  if (v25)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v26), v24, 8 * v25);
    LODWORD(v26) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v26 + v25;
  if (__src != v34) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Convolution>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  unint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::Convolution::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::Convolution::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  void v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a4;
  uint64_t v38 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v38, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v37, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 56), a5);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), a6);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 40), a7);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  uint64_t v18 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 48);
  uint64_t v19 = mlir::IntegerType::get(*a1, 0x40u, 0);
  uint64_t v20 = mlir::IntegerAttr::get(v19, a8);
  mlir::NamedAttribute::NamedAttribute(&__src, v18, v20);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  uint64_t v21 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a9);
  mlir::NamedAttribute::NamedAttribute(&__src, v21, IntegerAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  if (a10)
  {
    uint64_t v25 = **(void **)(*(void *)(a2 + 8) + 96);
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v24);
    mlir::NamedAttribute::NamedAttribute(&__src, v25, UnitAttr);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  }
  if (a11)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 24), a11);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  }
  if (a12)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 32), a12);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  }
  __src = v43;
  uint64_t v42 = 0x200000000;
  unint64_t v27 = (mlir::UnknownLoc *)*a1;
  uint64_t v28 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v40, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v31 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v39, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Convolution>::inferReturnTypes(v27, v28, 1, v40[0], v40[1], Dictionary, v31, v32, v39[0], v39[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v33 = __src;
  }
  uint64_t v34 = v42;
  uint64_t v35 = *(unsigned int *)(a2 + 72);
  unint64_t v36 = v35 + v42;
  if (v36 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v36, 8);
    LODWORD(v35) = *(_DWORD *)(a2 + 72);
  }
  if (v34)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v35), v33, 8 * v34);
    LODWORD(v35) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v35 + v34;
  if (__src != v43) {
    free(__src);
  }
}

void mlir::anec::Convolution::populateDefaultAttrs(mlir::anec::Convolution *this, const mlir::OperationName *a2, mlir::NamedAttrList *a3)
{
  uint64_t v4 = *(uint64_t **)(*(void *)this + 96);
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)v4);
  uint64_t v12 = Context;
  if (!mlir::NamedAttrList::get((uint64_t)a2, v4[6]))
  {
    uint64_t v6 = v4[6];
    uint64_t v7 = mlir::IntegerType::get(Context, 0x40u, 0);
    uint64_t v8 = mlir::IntegerAttr::get(v7, 0);
    mlir::NamedAttribute::NamedAttribute(&v13, v6, v8);
    mlir::NamedAttrList::push_back((uint64_t)a2, v13, v14);
  }
  if (!mlir::NamedAttrList::get((uint64_t)a2, v4[2]))
  {
    uint64_t v9 = v4[2];
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v12, 0x40u, 0);
    uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)&v12, IntegerType, 1);
    mlir::NamedAttribute::NamedAttribute(&v13, v9, IntegerAttr);
    mlir::NamedAttrList::push_back((uint64_t)a2, v13, v14);
  }
}

BOOL mlir::anec::Convolution::verifyInvariantsImpl(uint64_t **this)
{
  v25[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_10:
    uint64_t v8 = "requires attribute 'dilation'";
LABEL_29:
    uint64_t v22 = (const void **)v8;
    __int16 v23 = 259;
    mlir::OpState::emitOpError(this, &v22, (uint64_t)&AttrDictionary);
    uint64_t v18 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v25);
    return v18;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 16 * v4;
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    if (**(void **)((*this)[6] + 96) == mlir::CallGraphNode::getCallableRegion(Value)) {
      uint64_t v6 = *((void *)Value + 1);
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v7 -= 16;
    if (!v7) {
      goto LABEL_10;
    }
  }
  if (!v7)
  {
LABEL_21:
    uint64_t v8 = "requires attribute 'padding'";
    goto LABEL_29;
  }
  uint64_t v9 = 0;
  char v10 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = 0;
  uint64_t v13 = (const void **)*((void *)Value + 1);
  while (1)
  {
    uint64_t v14 = (const void ***)((char *)Value + v9);
    if (*(void *)(*(void *)((*this)[6] + 96) + 40) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)((char *)Value + v9))) {
      break;
    }
    if (*(void *)(*(void *)((*this)[6] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)((char *)Value + v9)))
    {
      char v10 = *(const void ***)((char *)Value + v9 + 8);
    }
    else if (*(void *)(*(void *)((*this)[6] + 96) + 24) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)((char *)Value + v9)))
    {
      uint64_t v11 = *(const void ***)((char *)Value + v9 + 8);
    }
    else if (*(void *)(*(void *)((*this)[6] + 96) + 32) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)((char *)Value + v9)))
    {
      uint64_t v12 = *(const void ***)((char *)Value + v9 + 8);
    }
    v9 += 16;
    if (v7 == v9) {
      goto LABEL_21;
    }
  }
  uint64_t v15 = v7 - v9;
  if (!v15)
  {
LABEL_28:
    uint64_t v8 = "requires attribute 'stride'";
    goto LABEL_29;
  }
  uint64_t v16 = 0;
  uint64_t v17 = v14[1];
  while (*(void *)(*(void *)((*this)[6] + 96) + 56) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)v14))
  {
    if (*(void *)(*(void *)((*this)[6] + 96) + 48) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)v14)) {
      uint64_t v16 = (uint64_t)v14[1];
    }
    v14 += 2;
    v15 -= 16;
    if (!v15) {
      goto LABEL_28;
    }
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps7(*this, v14[1], (const void **)"stride", 6)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps7(*this, v13, (const void **)"dilation", 8)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps8(*this, v17, (const void **)"padding", 7)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps12(*this, v16, (const void **)"padding_mode", (const void **)0xC)
    || !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps11(*this, v10, (const void **)"groups", (const void **)6)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps9(*this, v6, (const void **)"channel_wise", (const void **)0xC)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps13(*this, v11, (const void **)"kernel_scale", 12)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps14(*this, v12, (const void **)"kernel_zero_point", 17)
    || !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps3(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v20 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v20 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v20, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps12(uint64_t *a1, uint64_t a2, const void **a3, const void **a4)
{
  v12[23] = *MEMORY[0x1E4F143B8];
  if (!a2 || (mlir::anec::PaddingModeAttr::classof(a2) & 1) != 0) {
    return 1;
  }
  __int16 v10 = 257;
  mlir::Operation::emitOpError(a1, v9, (uint64_t)&v11);
  if (v11)
  {
    mlir::Diagnostic::operator<<((uint64_t)v12, "attribute '");
    if (v11)
    {
      __int16 v10 = 261;
      v9[0] = a3;
      v9[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v12, v9);
      if (v11) {
        mlir::Diagnostic::operator<<((uint64_t)v12, "' failed to satisfy constraint: valid PaddingMode");
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v11);
  if (v11) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v11);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v12);
  return v7;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps13(uint64_t *a1, const void **a2, const void **a3, uint64_t a4)
{
  v70[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (!mlir::DenseFPElementsAttr::classof((uint64_t)a2)) {
    goto LABEL_46;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *((unsigned int *)v8 + 4);
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v11 = (void *)v8[1];
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_11:
  }
    uint64_t v17 = 0;
  uint64_t v66 = a2;
  uint64_t v67 = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
  uint64_t v19 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  __int16 v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    unint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      __int16 v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t v69 = v19;
  v70[0] = v29;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v69);
  if (v30)
  {
    uint64_t v31 = *a2;
    unint64_t v32 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v33 = *((unsigned int *)v31 + 4);
    if (!v33) {
      goto LABEL_31;
    }
    uint64_t v34 = (void *)v31[1];
    uint64_t v35 = &v34[2 * v33];
    do
    {
      unint64_t v36 = v33 >> 1;
      uint64_t v37 = &v34[2 * (v33 >> 1)];
      unint64_t v39 = *v37;
      uint64_t v38 = v37 + 2;
      v33 += ~(v33 >> 1);
      if (v39 < v32) {
        uint64_t v34 = v38;
      }
      else {
        unint64_t v33 = v36;
      }
    }
    while (v33);
    if (v34 != v35 && *v34 == v32) {
      uint64_t v40 = v34[1];
    }
    else {
LABEL_31:
    }
      uint64_t v40 = 0;
    v64[0] = a2;
    v64[1] = v40;
    uint64_t v41 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v64);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_41;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_41;
    }
    unint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      unint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      unint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        unint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_41:
    }
      uint64_t v52 = 0;
    v65[0] = v42;
    v65[1] = v52;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v65);
    if (v53 != 1) {
      goto LABEL_46;
    }
  }
  uint64_t v61 = a2;
  v62[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v61);
  v62[1] = v54;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange)) {
    return 1;
  }
  uint64_t v58 = a2;
  v59[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58);
  v59[1] = v55;
  uint64_t v60 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v59);
  if (mlir::Type::isF32((mlir::Type *)&v60)) {
    return 1;
  }
LABEL_46:
  __int16 v68 = 257;
  mlir::Operation::emitOpError(a1, &v66, (uint64_t)&v69);
  if (v69)
  {
    mlir::Diagnostic::operator<<((uint64_t)v70, "attribute '");
    if (v69)
    {
      __int16 v68 = 261;
      uint64_t v66 = a3;
      uint64_t v67 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v70, &v66);
      if (v69) {
        mlir::Diagnostic::operator<<((uint64_t)v70, "' failed to satisfy constraint: f16 or f32 elements attribute of rank 0/1");
      }
    }
  }
  uint64_t v56 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v69);
  if (v69) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v69);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v70);
  return v56;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps14(uint64_t *a1, const void **a2, const void **a3, uint64_t a4)
{
  v70[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a2)) {
    goto LABEL_46;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *((unsigned int *)v8 + 4);
  if (!v10) {
    goto LABEL_11;
  }
  uint64_t v11 = (void *)v8[1];
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    uint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    uint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_11:
  }
    uint64_t v17 = 0;
  uint64_t v66 = a2;
  uint64_t v67 = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v66);
  uint64_t v19 = Type;
  if (!Type) {
    goto LABEL_21;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_21;
  }
  __int16 v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    unint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      __int16 v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_21:
  }
    uint64_t v29 = 0;
  uint64_t v69 = v19;
  v70[0] = v29;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v69);
  if (v30)
  {
    uint64_t v31 = *a2;
    unint64_t v32 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v33 = *((unsigned int *)v31 + 4);
    if (!v33) {
      goto LABEL_31;
    }
    uint64_t v34 = (void *)v31[1];
    uint64_t v35 = &v34[2 * v33];
    do
    {
      unint64_t v36 = v33 >> 1;
      uint64_t v37 = &v34[2 * (v33 >> 1)];
      unint64_t v39 = *v37;
      uint64_t v38 = v37 + 2;
      v33 += ~(v33 >> 1);
      if (v39 < v32) {
        uint64_t v34 = v38;
      }
      else {
        unint64_t v33 = v36;
      }
    }
    while (v33);
    if (v34 != v35 && *v34 == v32) {
      uint64_t v40 = v34[1];
    }
    else {
LABEL_31:
    }
      uint64_t v40 = 0;
    v64[0] = a2;
    v64[1] = v40;
    uint64_t v41 = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v64);
    uint64_t v42 = v41;
    if (!v41) {
      goto LABEL_41;
    }
    uint64_t v43 = *v41;
    unint64_t v44 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v45 = *(unsigned int *)(v43 + 16);
    if (!v45) {
      goto LABEL_41;
    }
    unint64_t v46 = *(void **)(v43 + 8);
    unint64_t v47 = &v46[2 * v45];
    do
    {
      unint64_t v48 = v45 >> 1;
      unint64_t v49 = &v46[2 * (v45 >> 1)];
      unint64_t v51 = *v49;
      unint64_t v50 = v49 + 2;
      v45 += ~(v45 >> 1);
      if (v51 < v44) {
        unint64_t v46 = v50;
      }
      else {
        unint64_t v45 = v48;
      }
    }
    while (v45);
    if (v46 != v47 && *v46 == v44) {
      uint64_t v52 = v46[1];
    }
    else {
LABEL_41:
    }
      uint64_t v52 = 0;
    v65[0] = v42;
    v65[1] = v52;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v65);
    if (v53 != 1) {
      goto LABEL_46;
    }
  }
  uint64_t v61 = a2;
  v62[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v61);
  v62[1] = v54;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)) {
    return 1;
  }
  uint64_t v58 = a2;
  v59[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v58);
  v59[1] = v55;
  uint64_t v60 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v59);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&v60, 8)) {
    return 1;
  }
LABEL_46:
  __int16 v68 = 257;
  mlir::Operation::emitOpError(a1, &v66, (uint64_t)&v69);
  if (v69)
  {
    mlir::Diagnostic::operator<<((uint64_t)v70, "attribute '");
    if (v69)
    {
      __int16 v68 = 261;
      uint64_t v66 = a3;
      uint64_t v67 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v70, &v66);
      if (v69) {
        mlir::Diagnostic::operator<<((uint64_t)v70, "' failed to satisfy constraint: si8 or ui8 elements attribute of rank 0/1");
      }
    }
  }
  uint64_t v56 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v69);
  if (v69) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v69);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v70);
  return v56;
}

uint64_t mlir::anec::__mlir_ods_local_type_constraint_ANECOps3(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  v74[19] = *MEMORY[0x1E4F143B8];
  uint64_t v65 = a2;
  unint64_t v9 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    goto LABEL_46;
  }
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *((unsigned int *)v9 + 4);
  if (!v12) {
    goto LABEL_10;
  }
  unint64_t v13 = (void *)v9[1];
  uint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    unint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      unint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  uint64_t v69 = a2;
  v70[0] = v19;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69);
  if (mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
  {
    uint64_t v20 = *a2;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *((unsigned int *)v20 + 4);
    if (!v22) {
      goto LABEL_23;
    }
    __int16 v23 = (void *)v20[1];
    uint64_t v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      uint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      unint64_t v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        __int16 v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_23:
    }
      uint64_t v29 = 0;
    uint64_t v61 = a2;
    uint64_t v62 = v29;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v61))
    {
      uint64_t v30 = *a2;
      unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v32 = *((unsigned int *)v30 + 4);
      if (!v32) {
        goto LABEL_33;
      }
      unint64_t v33 = (void *)v30[1];
      uint64_t v34 = &v33[2 * v32];
      do
      {
        unint64_t v35 = v32 >> 1;
        unint64_t v36 = &v33[2 * (v32 >> 1)];
        unint64_t v38 = *v36;
        uint64_t v37 = v36 + 2;
        v32 += ~(v32 >> 1);
        if (v38 < v31) {
          unint64_t v33 = v37;
        }
        else {
          unint64_t v32 = v35;
        }
      }
      while (v32);
      if (v33 != v34 && *v33 == v31) {
        uint64_t v39 = v33[1];
      }
      else {
LABEL_33:
      }
        uint64_t v39 = 0;
      uint64_t v67 = a2;
      uint64_t v68 = v39;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v67);
      if (v40 == 4) {
        return 1;
      }
      uint64_t v41 = *a2;
      unint64_t v42 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v43 = *((unsigned int *)v41 + 4);
      if (!v43) {
        goto LABEL_43;
      }
      unint64_t v44 = (void *)v41[1];
      unint64_t v45 = &v44[2 * v43];
      do
      {
        unint64_t v46 = v43 >> 1;
        unint64_t v47 = &v44[2 * (v43 >> 1)];
        unint64_t v49 = *v47;
        unint64_t v48 = v47 + 2;
        v43 += ~(v43 >> 1);
        if (v49 < v42) {
          unint64_t v44 = v48;
        }
        else {
          unint64_t v43 = v46;
        }
      }
      while (v43);
      if (v44 != v45 && *v44 == v42) {
        uint64_t v50 = v44[1];
      }
      else {
LABEL_43:
      }
        uint64_t v50 = 0;
      v64[0] = a2;
      v64[1] = v50;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v64);
      if (v51 == 5) {
        return 1;
      }
    }
  }
LABEL_46:
  __int16 v63 = 261;
  uint64_t v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)&v69);
  if (v69)
  {
    mlir::Diagnostic::operator<<((uint64_t)v70, " #");
    if (v69)
    {
      LODWORD(v67) = 5;
      uint64_t v68 = a5;
      uint64_t v53 = (char *)&v67;
      unint64_t v54 = v71;
      if (v72 >= v73)
      {
        unint64_t v59 = v72 + 1;
        if (v71 <= (unint64_t)&v67 && v71 + 24 * v72 > (unint64_t)&v67)
        {
          uint64_t v60 = (char *)&v67 - v71;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v59, 24);
          unint64_t v54 = v71;
          uint64_t v53 = &v60[v71];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v59, 24);
          uint64_t v53 = (char *)&v67;
          unint64_t v54 = v71;
        }
      }
      unint64_t v55 = v54 + 24 * v72;
      long long v56 = *(_OWORD *)v53;
      *(void *)(v55 + 16) = *((void *)v53 + 2);
      *(_OWORD *)unint64_t v55 = v56;
      ++v72;
      if (v69) {
        mlir::Diagnostic::operator<<((uint64_t)v70, " must be 4D/5D memref of 32-bit float or 16-bit float or 8-bit signed integer or 8-bit unsigned integer values, but got ");
      }
    }
  }
  uint64_t v57 = mlir::InFlightDiagnostic::append<mlir::Type &>((uint64_t)&v69, (uint64_t *)&v65);
  uint64_t v52 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v57);
  if (v69) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v69);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v70);
  return v52;
}

uint64_t llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_0>(uint64_t *a1)
{
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, *a1, 0);
  uint64_t v2 = *a1;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v7, v2, NumElements);
  while (1)
  {
    BOOL v4 = v10 == v7 && v11 == v8;
    if (v4 && v12 == v9) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v10, (llvm::APInt *)&v13);
    if (v14 <= 0x40)
    {
      if ((unint64_t)((uint64_t)((void)v13 << -(char)v14) >> -(char)v14) > 2) {
        return 0;
      }
    }
    else
    {
      unint64_t v5 = *(void *)v13;
      operator delete[](v13);
      if (v5 > 2) {
        return 0;
      }
    }
    ++v12;
  }
  return 1;
}

uint64_t llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_1>(uint64_t *a1)
{
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, *a1, 0);
  uint64_t v2 = *a1;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v7, v2, NumElements);
  while (1)
  {
    BOOL v4 = v10 == v7 && v11 == v8;
    if (v4 && v12 == v9) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v10, (llvm::APInt *)&v13);
    if (v14 <= 0x40)
    {
      if ((unint64_t)((uint64_t)((void)v13 << -(char)v14) >> -(char)v14) > 1) {
        return 0;
      }
    }
    else
    {
      unint64_t v5 = *(void *)v13;
      operator delete[](v13);
      if (v5 > 1) {
        return 0;
      }
    }
    ++v12;
  }
  return 1;
}

uint64_t llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_2>(uint64_t *a1)
{
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, *a1, 0);
  uint64_t v2 = *a1;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v7, v2, NumElements);
  while (1)
  {
    BOOL v4 = v10 == v7 && v11 == v8;
    if (v4 && v12 == v9) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v10, (llvm::APInt *)&v13);
    if (v14 <= 0x40)
    {
      if ((unint64_t)((uint64_t)((void)v13 << -(char)v14) >> -(char)v14) > 5) {
        return 0;
      }
    }
    else
    {
      unint64_t v5 = *(void *)v13;
      operator delete[](v13);
      if (v5 > 5) {
        return 0;
      }
    }
    ++v12;
  }
  return 1;
}

uint64_t llvm::all_of<mlir::DenseIntElementsAttr,mlir::anec::CropResizeAdaptor::verify(mlir::Location)::$_4>(uint64_t *a1)
{
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, *a1, 0);
  uint64_t v2 = *a1;
  uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v7, v2, NumElements);
  while (1)
  {
    BOOL v4 = v10 == v7 && v11 == v8;
    if (v4 && v12 == v9) {
      break;
    }
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v10, (llvm::APInt *)&v13);
    if (v14 <= 0x40)
    {
      if ((unint64_t)((uint64_t)((void)v13 << -(char)v14) >> -(char)v14) > 8) {
        return 0;
      }
    }
    else
    {
      unint64_t v5 = *(void *)v13;
      operator delete[](v13);
      if (v5 > 8) {
        return 0;
      }
    }
    ++v12;
  }
  return 1;
}

uint64_t mlir::anec::CropResize::getOutputDimsAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  BOOL v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 64);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 48), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 40));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::CropResize::getCropDimsAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  BOOL v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 48);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 80), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 24));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (mlir::DenseIntElementsAttr::classof(*((void *)v9 + 1))) {
    return v11;
  }
  return 0;
}

uint64_t mlir::anec::CropResize::getBoxCoordinateModeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  BOOL v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 96), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::CropResize::getCoordinateModeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  BOOL v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 32);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 80), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 16));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::CropResize::getNormalizedRangeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  BOOL v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 48);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 64), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 32));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::CropResize::getSamplingModeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  BOOL v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 112);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 64));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::CropResize::getSamplingMethodAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  BOOL v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 96);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 56));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::CropResize::getPaddingModesAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  BOOL v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 80);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 32), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 48));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::CropResize::getBackgroundValueAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 112), **(void **)(*((void *)*this + 6) + 96));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::CropResize>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        unint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    unint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::CropResize::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::CropResize::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  unint64_t v26[2] = *MEMORY[0x1E4F143B8];
  mlir::OperationState::addOperands(a2, a3, a4);
  *(void *)(a2 + 192) = 0;
  uint64_t v12 = *(unsigned int *)(a2 + 120);
  if (a6 + v12 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a6 + v12, 16);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  if (a6)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v12), a5, 16 * a6);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v12 + a6;
  __src = v26;
  uint64_t v25 = 0x200000000;
  unint64_t v13 = *a1;
  unsigned int v14 = *(mlir::MLIRContext **)a2;
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v17 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::CropResize>::inferReturnTypes(v13, v14, 1, a3, a4, Dictionary, v17, v18, v23[0], v23[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v19 = __src;
  }
  uint64_t v20 = v25;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v25;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v26) {
    free(__src);
  }
}

void mlir::anec::CropResize::populateDefaultAttrs(mlir::anec::CropResize *this, const mlir::OperationName *a2, mlir::NamedAttrList *a3)
{
  v23[1] = *MEMORY[0x1E4F143B8];
  BOOL v4 = *(uint64_t **)(*(void *)this + 96);
  uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)v4);
  if (!mlir::NamedAttrList::get((uint64_t)a2, v4[3]))
  {
    uint64_t v5 = v4[3];
    v23[0] = 2;
    uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&Context, 0x40u, 0);
    uint64_t v7 = (void *)mlir::RankedTensorType::get((uint64_t)v23, 1, IntegerType, 0);
    uint64_t v8 = v7;
    if (!v7) {
      goto LABEL_11;
    }
    uint64_t v9 = *v7;
    unint64_t v10 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v11 = *(unsigned int *)(v9 + 16);
    if (!v11) {
      goto LABEL_11;
    }
    uint64_t v12 = *(void **)(v9 + 8);
    unint64_t v13 = &v12[2 * v11];
    do
    {
      unint64_t v14 = v11 >> 1;
      unint64_t v15 = &v12[2 * (v11 >> 1)];
      unint64_t v17 = *v15;
      unint64_t v16 = v15 + 2;
      v11 += ~(v11 >> 1);
      if (v17 < v10) {
        uint64_t v12 = v16;
      }
      else {
        unint64_t v11 = v14;
      }
    }
    while (v11);
    if (v12 != v13 && *v12 == v10) {
      uint64_t v18 = v12[1];
    }
    else {
LABEL_11:
    }
      uint64_t v18 = 0;
    v22[0] = 0;
    v22[1] = 0;
    uint64_t v19 = mlir::DenseElementsAttr::getFromRawBuffer(v8, v18, v22, 16, 8, 1, 0);
    mlir::NamedAttribute::NamedAttribute(v21, v5, v19);
    mlir::NamedAttrList::push_back((uint64_t)a2, v21[0], v21[1]);
  }
}

BOOL mlir::anec::CropResize::verifyInvariantsImpl(uint64_t **this)
{
  v39[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v8 = "requires attribute 'background_value'";
LABEL_31:
    v36[0] = (const void **)v8;
    __int16 v37 = 259;
    mlir::OpState::emitOpError(this, v36, (uint64_t)&AttrDictionary);
    uint64_t v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v39);
    return v20;
  }
  uint64_t v6 = 0;
  uint64_t v7 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)(Value + v6)))
  {
    v6 += 16;
    if (v7 == v6) {
      goto LABEL_8;
    }
  }
  uint64_t v9 = v7 - v6;
  if (v7 == v6)
  {
LABEL_13:
    uint64_t v8 = "requires attribute 'box_coordinate_mode'";
    goto LABEL_31;
  }
  unint64_t v10 = *(const void ***)(Value + v6 + 8);
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)(Value + v6)))
  {
    v9 -= 16;
    v6 += 16;
    if (v7 == v6) {
      goto LABEL_13;
    }
  }
  if (v7 == v6)
  {
LABEL_18:
    uint64_t v8 = "requires attribute 'coordinate_mode'";
    goto LABEL_31;
  }
  uint64_t v11 = 0;
  uint64_t v12 = *(void *)(Value + v6 + 8);
  while (*(void *)(*(void *)((*this)[6] + 96) + 16) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)(Value + v6 + v11)))
  {
    v11 += 16;
    if (v9 == v11) {
      goto LABEL_18;
    }
  }
  uint64_t v13 = v9 - v11;
  if (v9 == v11)
  {
LABEL_25:
    uint64_t v8 = "requires attribute 'normalized_range'";
    goto LABEL_31;
  }
  unint64_t v14 = 0;
  unint64_t v15 = *(void **)(Value + v11 + v6 + 8);
  unint64_t v16 = (const void ***)(Value + v6 + v11 + 8);
  while (*(void *)(*(void *)((*this)[6] + 96) + 32) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)(v16 - 1)))
  {
    if (*(void *)(*(void *)((*this)[6] + 96) + 24) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)(v16 - 1))) {
      unint64_t v14 = *v16;
    }
    v16 += 2;
    v13 -= 16;
    if (!v13) {
      goto LABEL_25;
    }
  }
  if (!v13)
  {
LABEL_30:
    uint64_t v8 = "requires attribute 'output_dims'";
    goto LABEL_31;
  }
  unint64_t v17 = 0;
  uint64_t v18 = *v16;
  while (1)
  {
    uint64_t v19 = &v16[v17 / 8];
    if (*(void *)(*(void *)((*this)[6] + 96) + 40) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v16[v17 / 8 - 1])) {
      break;
    }
    v17 += 16;
    if (v13 == v17) {
      goto LABEL_30;
    }
  }
  uint64_t v22 = v13 - v17;
  if (v13 == v17)
  {
LABEL_39:
    uint64_t v24 = "requires attribute 'padding_modes'";
LABEL_50:
    v36[0] = (const void **)v24;
    __int16 v37 = 259;
    mlir::OpState::emitOpError(this, v36, (uint64_t)&AttrDictionary);
    uint64_t v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)&AttrDictionary);
    return v20;
  }
  unint64_t v23 = *v19;
  while (*(void *)(*(void *)((*this)[6] + 96) + 48) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)(v19 - 1)))
  {
    v19 += 2;
    v22 -= 16;
    if (!v22) {
      goto LABEL_39;
    }
  }
  unint64_t v35 = v23;
  if (!v22)
  {
LABEL_44:
    uint64_t v24 = "requires attribute 'sampling_method'";
    goto LABEL_50;
  }
  unint64_t v25 = 0;
  uint64_t v34 = *v19;
  while (1)
  {
    uint64_t v26 = &v19[v25 / 8];
    if (*(void *)(*(void *)((*this)[6] + 96) + 56) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)&v19[v25 / 8 - 1])) {
      break;
    }
    v25 += 16;
    if (v22 == v25) {
      goto LABEL_44;
    }
  }
  uint64_t v27 = v22 - v25;
  if (!v27)
  {
LABEL_49:
    uint64_t v24 = "requires attribute 'sampling_mode'";
    goto LABEL_50;
  }
  uint64_t v30 = *v26;
  uint64_t v29 = (mlir::CallGraphNode *)(v26 - 1);
  uint64_t v28 = v30;
  while (*(void *)(*(void *)((*this)[6] + 96) + 64) != mlir::CallGraphNode::getCallableRegion(v29))
  {
    uint64_t v29 = (mlir::CallGraphNode *)((char *)v29 + 16);
    v27 -= 16;
    if (!v27) {
      goto LABEL_49;
    }
  }
  uint64_t v31 = (void *)*((void *)v29 + 1);
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps5(*this, v35, (const void **)"output_dims", 11)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps5(*this, v14, (const void **)"crop_dims", 9)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps15(*this, v12, (const void **)"box_coordinate_mode", (const void **)0x13)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps16(*this, v15, (const void **)"coordinate_mode", 15)
    || !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps17(*this, v18, (const void **)"normalized_range", 16)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps18(*this, v31, (const void **)"sampling_mode", 13)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps19(*this, v28, (const void **)"sampling_method", 15)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps20(*this, v34, (const void **)"padding_modes", 13)
    || !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, v10, (const void **)"background_value", (const void **)0x10)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps4(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps5(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v32 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v32 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v32, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps15(uint64_t *a1, uint64_t a2, const void **a3, const void **a4)
{
  v12[23] = *MEMORY[0x1E4F143B8];
  if (!a2 || (mlir::anec::BoxCoordinateModeAttr::classof(a2) & 1) != 0) {
    return 1;
  }
  __int16 v10 = 257;
  mlir::Operation::emitOpError(a1, v9, (uint64_t)&v11);
  if (v11)
  {
    mlir::Diagnostic::operator<<((uint64_t)v12, "attribute '");
    if (v11)
    {
      __int16 v10 = 261;
      v9[0] = a3;
      v9[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v12, v9);
      if (v11) {
        mlir::Diagnostic::operator<<((uint64_t)v12, "' failed to satisfy constraint: valid BoxCoordinateMode");
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v11);
  if (v11) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v11);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v12);
  return v7;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps16(uint64_t *a1, void *a2, const void **a3, uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v38[0] = a2;
  v38[1] = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v38);
  uint64_t v19 = Type;
  if (!Type) {
    goto LABEL_20;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  unint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      unint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  v39[0] = v19;
  v39[1] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  uint64_t v49 = 5;
  if (v31 == 1 && *ArgAttrsAttr == v49)
  {
    __int16 v37 = a2;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v46, (uint64_t)a2, 0);
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v37);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v42, (uint64_t)a2, NumElements);
    while (1)
    {
      BOOL v35 = v46 == v42 && v47[0] == v43;
      if (v35 && v48 == v44) {
        return 1;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v46, (llvm::APInt *)&__p);
      if (v41 > 0x40)
      {
        unint64_t v34 = *(void *)__p;
        operator delete[](__p);
        if (v34 > 2) {
          break;
        }
      }
      else if ((unint64_t)((uint64_t)((void)__p << -(uint64_t)v41) >> -(uint64_t)v41) > 2)
      {
        break;
      }
      ++v48;
    }
  }
  __int16 v45 = 257;
  mlir::Operation::emitOpError(a1, &v42, (uint64_t)&v46);
  if (v46)
  {
    mlir::Diagnostic::operator<<((uint64_t)v47, "attribute '");
    if (v46)
    {
      __int16 v45 = 261;
      unint64_t v42 = a3;
      uint64_t v43 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v47, &v42);
      if (v46) {
        mlir::Diagnostic::operator<<((uint64_t)v47, "' failed to satisfy constraint: CoordinateMode elements attribute of shape {5}");
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v47);
  return v32;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps17(uint64_t *a1, void *a2, const void **a3, uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v38[0] = a2;
  v38[1] = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v38);
  uint64_t v19 = Type;
  if (!Type) {
    goto LABEL_20;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  unint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      unint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  v39[0] = v19;
  v39[1] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  uint64_t v49 = 5;
  if (v31 == 1 && *ArgAttrsAttr == v49)
  {
    __int16 v37 = a2;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v46, (uint64_t)a2, 0);
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v37);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v42, (uint64_t)a2, NumElements);
    while (1)
    {
      BOOL v35 = v46 == v42 && v47[0] == v43;
      if (v35 && v48 == v44) {
        return 1;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v46, (llvm::APInt *)&__p);
      if (v41 > 0x40)
      {
        unint64_t v34 = *(void *)__p;
        operator delete[](__p);
        if (v34 > 1) {
          break;
        }
      }
      else if ((unint64_t)((uint64_t)((void)__p << -(uint64_t)v41) >> -(uint64_t)v41) > 1)
      {
        break;
      }
      ++v48;
    }
  }
  __int16 v45 = 257;
  mlir::Operation::emitOpError(a1, &v42, (uint64_t)&v46);
  if (v46)
  {
    mlir::Diagnostic::operator<<((uint64_t)v47, "attribute '");
    if (v46)
    {
      __int16 v45 = 261;
      unint64_t v42 = a3;
      uint64_t v43 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v47, &v42);
      if (v46) {
        mlir::Diagnostic::operator<<((uint64_t)v47, "' failed to satisfy constraint: NormalizedCoordinateRange elements attribute of shape {5}");
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v47);
  return v32;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps18(uint64_t *a1, void *a2, const void **a3, uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v38[0] = a2;
  v38[1] = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v38);
  uint64_t v19 = Type;
  if (!Type) {
    goto LABEL_20;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  unint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      unint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  v39[0] = v19;
  v39[1] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  uint64_t v49 = 5;
  if (v31 == 1 && *ArgAttrsAttr == v49)
  {
    __int16 v37 = a2;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v46, (uint64_t)a2, 0);
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v37);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v42, (uint64_t)a2, NumElements);
    while (1)
    {
      BOOL v35 = v46 == v42 && v47[0] == v43;
      if (v35 && v48 == v44) {
        return 1;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v46, (llvm::APInt *)&__p);
      if (v41 > 0x40)
      {
        unint64_t v34 = *(void *)__p;
        operator delete[](__p);
        if (v34 > 5) {
          break;
        }
      }
      else if ((unint64_t)((uint64_t)((void)__p << -(uint64_t)v41) >> -(uint64_t)v41) > 5)
      {
        break;
      }
      ++v48;
    }
  }
  __int16 v45 = 257;
  mlir::Operation::emitOpError(a1, &v42, (uint64_t)&v46);
  if (v46)
  {
    mlir::Diagnostic::operator<<((uint64_t)v47, "attribute '");
    if (v46)
    {
      __int16 v45 = 261;
      unint64_t v42 = a3;
      uint64_t v43 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v47, &v42);
      if (v46) {
        mlir::Diagnostic::operator<<((uint64_t)v47, "' failed to satisfy constraint: SamplingGridMode elements attribute of shape {5}");
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v47);
  return v32;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps19(uint64_t *a1, void *a2, const void **a3, uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v38[0] = a2;
  v38[1] = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v38);
  uint64_t v19 = Type;
  if (!Type) {
    goto LABEL_20;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  unint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      unint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  v39[0] = v19;
  v39[1] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  uint64_t v49 = 5;
  if (v31 == 1 && *ArgAttrsAttr == v49)
  {
    __int16 v37 = a2;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v46, (uint64_t)a2, 0);
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v37);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v42, (uint64_t)a2, NumElements);
    while (1)
    {
      BOOL v35 = v46 == v42 && v47[0] == v43;
      if (v35 && v48 == v44) {
        return 1;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v46, (llvm::APInt *)&__p);
      if (v41 > 0x40)
      {
        unint64_t v34 = *(void *)__p;
        operator delete[](__p);
        if (v34 > 1) {
          break;
        }
      }
      else if ((unint64_t)((uint64_t)((void)__p << -(uint64_t)v41) >> -(uint64_t)v41) > 1)
      {
        break;
      }
      ++v48;
    }
  }
  __int16 v45 = 257;
  mlir::Operation::emitOpError(a1, &v42, (uint64_t)&v46);
  if (v46)
  {
    mlir::Diagnostic::operator<<((uint64_t)v47, "attribute '");
    if (v46)
    {
      __int16 v45 = 261;
      unint64_t v42 = a3;
      uint64_t v43 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v47, &v42);
      if (v46) {
        mlir::Diagnostic::operator<<((uint64_t)v47, "' failed to satisfy constraint: SamplingGridMethod elements attribute of shape {5}");
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v47);
  return v32;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps20(uint64_t *a1, void *a2, const void **a3, uint64_t a4)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  uint64_t v8 = *a2;
  unint64_t v9 = mlir::TypeID::get<mlir::ElementsAttr>();
  unint64_t v10 = *(unsigned int *)(v8 + 16);
  if (!v10) {
    goto LABEL_10;
  }
  uint64_t v11 = *(void **)(v8 + 8);
  uint64_t v12 = &v11[2 * v10];
  do
  {
    unint64_t v13 = v10 >> 1;
    unint64_t v14 = &v11[2 * (v10 >> 1)];
    unint64_t v16 = *v14;
    unint64_t v15 = v14 + 2;
    v10 += ~(v10 >> 1);
    if (v16 < v9) {
      uint64_t v11 = v15;
    }
    else {
      unint64_t v10 = v13;
    }
  }
  while (v10);
  if (v11 != v12 && *v11 == v9) {
    uint64_t v17 = v11[1];
  }
  else {
LABEL_10:
  }
    uint64_t v17 = 0;
  v38[0] = a2;
  v38[1] = v17;
  uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v38);
  uint64_t v19 = Type;
  if (!Type) {
    goto LABEL_20;
  }
  uint64_t v20 = *Type;
  unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v22 = *(unsigned int *)(v20 + 16);
  if (!v22) {
    goto LABEL_20;
  }
  unint64_t v23 = *(void **)(v20 + 8);
  uint64_t v24 = &v23[2 * v22];
  do
  {
    unint64_t v25 = v22 >> 1;
    uint64_t v26 = &v23[2 * (v22 >> 1)];
    unint64_t v28 = *v26;
    uint64_t v27 = v26 + 2;
    v22 += ~(v22 >> 1);
    if (v28 < v21) {
      unint64_t v23 = v27;
    }
    else {
      unint64_t v22 = v25;
    }
  }
  while (v22);
  if (v23 != v24 && *v23 == v21) {
    uint64_t v29 = v23[1];
  }
  else {
LABEL_20:
  }
    uint64_t v29 = 0;
  v39[0] = v19;
  v39[1] = v29;
  uint64_t ArgAttrsAttr = (void *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v39);
  uint64_t v49 = 5;
  if (v31 == 1 && *ArgAttrsAttr == v49)
  {
    __int16 v37 = a2;
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v46, (uint64_t)a2, 0);
    uint64_t NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v37);
    mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v42, (uint64_t)a2, NumElements);
    while (1)
    {
      BOOL v35 = v46 == v42 && v47[0] == v43;
      if (v35 && v48 == v44) {
        return 1;
      }
      mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v46, (llvm::APInt *)&__p);
      if (v41 > 0x40)
      {
        unint64_t v34 = *(void *)__p;
        operator delete[](__p);
        if (v34 > 8) {
          break;
        }
      }
      else if ((unint64_t)((uint64_t)((void)__p << -(uint64_t)v41) >> -(uint64_t)v41) > 8)
      {
        break;
      }
      ++v48;
    }
  }
  __int16 v45 = 257;
  mlir::Operation::emitOpError(a1, &v42, (uint64_t)&v46);
  if (v46)
  {
    mlir::Diagnostic::operator<<((uint64_t)v47, "attribute '");
    if (v46)
    {
      __int16 v45 = 261;
      unint64_t v42 = a3;
      uint64_t v43 = a4;
      mlir::Diagnostic::operator<<((uint64_t)v47, &v42);
      if (v46) {
        mlir::Diagnostic::operator<<((uint64_t)v47, "' failed to satisfy constraint: PaddingMode elements attribute of shape {5}");
      }
    }
  }
  uint64_t v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v47);
  return v32;
}

uint64_t mlir::anec::__mlir_ods_local_type_constraint_ANECOps4(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  v62[19] = *MEMORY[0x1E4F143B8];
  uint64_t v53 = a2;
  unint64_t v9 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    goto LABEL_35;
  }
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *((unsigned int *)v9 + 4);
  if (!v12) {
    goto LABEL_10;
  }
  unint64_t v13 = (void *)v9[1];
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    unint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      unint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  uint64_t v57 = a2;
  v58[0] = v19;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v57);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
  {
    uint64_t v20 = *a2;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *((unsigned int *)v20 + 4);
    if (!v22) {
      goto LABEL_22;
    }
    unint64_t v23 = (void *)v20[1];
    uint64_t v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      uint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      uint64_t v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        unint64_t v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_22:
    }
      uint64_t v29 = 0;
    uint64_t v50 = a2;
    uint64_t v51 = v29;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v50))
    {
      uint64_t v30 = *a2;
      unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v32 = *((unsigned int *)v30 + 4);
      if (!v32) {
        goto LABEL_32;
      }
      uint64_t v33 = (void *)v30[1];
      unint64_t v34 = &v33[2 * v32];
      do
      {
        unint64_t v35 = v32 >> 1;
        unint64_t v36 = &v33[2 * (v32 >> 1)];
        unint64_t v38 = *v36;
        __int16 v37 = v36 + 2;
        v32 += ~(v32 >> 1);
        if (v38 < v31) {
          uint64_t v33 = v37;
        }
        else {
          unint64_t v32 = v35;
        }
      }
      while (v32);
      if (v33 != v34 && *v33 == v31) {
        uint64_t v39 = v33[1];
      }
      else {
LABEL_32:
      }
        uint64_t v39 = 0;
      unint64_t v55 = a2;
      uint64_t v56 = v39;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v55);
      if (v40 == 5) {
        return 1;
      }
    }
  }
LABEL_35:
  __int16 v52 = 261;
  uint64_t v50 = a3;
  uint64_t v51 = a4;
  mlir::Operation::emitOpError(a1, &v50, (uint64_t)&v57);
  if (v57)
  {
    mlir::Diagnostic::operator<<((uint64_t)v58, " #");
    if (v57)
    {
      LODWORD(v55) = 5;
      uint64_t v56 = a5;
      unint64_t v42 = (char *)&v55;
      unint64_t v43 = v59;
      if (v60 >= v61)
      {
        unint64_t v48 = v60 + 1;
        if (v59 <= (unint64_t)&v55 && v59 + 24 * v60 > (unint64_t)&v55)
        {
          uint64_t v49 = (char *)&v55 - v59;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v48, 24);
          unint64_t v43 = v59;
          unint64_t v42 = &v49[v59];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v48, 24);
          unint64_t v42 = (char *)&v55;
          unint64_t v43 = v59;
        }
      }
      unint64_t v44 = v43 + 24 * v60;
      long long v45 = *(_OWORD *)v42;
      *(void *)(v44 + 16) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v60;
      if (v57) {
        mlir::Diagnostic::operator<<((uint64_t)v58, " must be 5D memref of 16-bit float or 8-bit signed integer or 8-bit unsigned integer values, but got ");
      }
    }
  }
  uint64_t v46 = mlir::InFlightDiagnostic::append<mlir::Type &>((uint64_t)&v57, (uint64_t *)&v53);
  uint64_t v41 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v46);
  if (v57) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v57);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v58);
  return v41;
}

uint64_t mlir::anec::__mlir_ods_local_type_constraint_ANECOps5(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  v62[19] = *MEMORY[0x1E4F143B8];
  uint64_t v53 = a2;
  unint64_t v9 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    goto LABEL_33;
  }
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *((unsigned int *)v9 + 4);
  if (!v12) {
    goto LABEL_10;
  }
  unint64_t v13 = (void *)v9[1];
  unint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    unint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      unint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  uint64_t v57 = a2;
  v58[0] = v19;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v57);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v20 = *a2;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *((unsigned int *)v20 + 4);
    if (!v22) {
      goto LABEL_20;
    }
    unint64_t v23 = (void *)v20[1];
    uint64_t v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      uint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      uint64_t v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        unint64_t v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_20:
    }
      uint64_t v29 = 0;
    uint64_t v50 = a2;
    uint64_t v51 = v29;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v50))
    {
      uint64_t v30 = *a2;
      unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v32 = *((unsigned int *)v30 + 4);
      if (!v32) {
        goto LABEL_30;
      }
      uint64_t v33 = (void *)v30[1];
      unint64_t v34 = &v33[2 * v32];
      do
      {
        unint64_t v35 = v32 >> 1;
        unint64_t v36 = &v33[2 * (v32 >> 1)];
        unint64_t v38 = *v36;
        __int16 v37 = v36 + 2;
        v32 += ~(v32 >> 1);
        if (v38 < v31) {
          uint64_t v33 = v37;
        }
        else {
          unint64_t v32 = v35;
        }
      }
      while (v32);
      if (v33 != v34 && *v33 == v31) {
        uint64_t v39 = v33[1];
      }
      else {
LABEL_30:
      }
        uint64_t v39 = 0;
      unint64_t v55 = a2;
      uint64_t v56 = v39;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v55);
      if (v40 == 5) {
        return 1;
      }
    }
  }
LABEL_33:
  __int16 v52 = 261;
  uint64_t v50 = a3;
  uint64_t v51 = a4;
  mlir::Operation::emitOpError(a1, &v50, (uint64_t)&v57);
  if (v57)
  {
    mlir::Diagnostic::operator<<((uint64_t)v58, " #");
    if (v57)
    {
      LODWORD(v55) = 5;
      uint64_t v56 = a5;
      unint64_t v42 = (char *)&v55;
      unint64_t v43 = v59;
      if (v60 >= v61)
      {
        unint64_t v48 = v60 + 1;
        if (v59 <= (unint64_t)&v55 && v59 + 24 * v60 > (unint64_t)&v55)
        {
          uint64_t v49 = (char *)&v55 - v59;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v48, 24);
          unint64_t v43 = v59;
          unint64_t v42 = &v49[v59];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v48, 24);
          unint64_t v42 = (char *)&v55;
          unint64_t v43 = v59;
        }
      }
      unint64_t v44 = v43 + 24 * v60;
      long long v45 = *(_OWORD *)v42;
      *(void *)(v44 + 16) = *((void *)v42 + 2);
      *(_OWORD *)unint64_t v44 = v45;
      ++v60;
      if (v57) {
        mlir::Diagnostic::operator<<((uint64_t)v58, " must be 5D memref of 16-bit float values, but got ");
      }
    }
  }
  uint64_t v46 = mlir::InFlightDiagnostic::append<mlir::Type &>((uint64_t)&v57, (uint64_t *)&v53);
  uint64_t v41 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v46);
  if (v57) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v57);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v58);
  return v41;
}

void mlir::anec::DeQuant::build(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v19 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  uint64_t v11 = **(void **)(*(void *)(a2 + 8) + 96);
  uint64_t F32Type = mlir::Builder::getF32Type(a1, v12);
  uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)a1, F32Type, a5);
  mlir::NamedAttribute::NamedAttribute(&v20, v11, FloatAttr);
  mlir::NamedAttrList::push_back(a2 + 112, v20, v21);
  uint64_t v15 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)a1, 0x20u, 1);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  mlir::NamedAttribute::NamedAttribute(&v20, v15, IntegerAttr);
  mlir::NamedAttrList::push_back(a2 + 112, v20, v21);
  uint64_t v18 = *(unsigned int *)(a2 + 72);
  if (v18 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18 + 1, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v18) = a3;
  ++*(_DWORD *)(a2 + 72);
}

BOOL mlir::anec::DeQuant::verifyInvariantsImpl(uint64_t **this)
{
  v17[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = "requires attribute 'scale'";
LABEL_14:
    unint64_t v14 = (const void **)v7;
    __int16 v15 = 259;
    mlir::OpState::emitOpError(this, &v14, (uint64_t)&AttrDictionary);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v17);
    return v9;
  }
  uint64_t v6 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (!v6)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'zero_point'";
    goto LABEL_14;
  }
  uint64_t v8 = (const void **)*((void *)Value + 1);
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_13;
    }
  }
  uint64_t v11 = (const void **)*((void *)Value + 1);
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps21(*this, v8, (const void **)"scale", (const void **)5)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps22(*this, v11, (const void **)"zero_point", (const void **)0xA)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v12 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps21(uint64_t *a1, const void **a2, const void **a3, const void **a4)
{
  v12[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v9[0] = a2;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v9);
    if (mlir::Type::isF32((mlir::Type *)&Value)) {
      return 1;
    }
  }
  __int16 v10 = 257;
  mlir::Operation::emitOpError(a1, v9, (uint64_t)&Value);
  if (Value)
  {
    mlir::Diagnostic::operator<<((uint64_t)v12, "attribute '");
    if (Value)
    {
      __int16 v10 = 261;
      v9[0] = a3;
      v9[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v12, v9);
      if (Value) {
        mlir::Diagnostic::operator<<((uint64_t)v12, "' failed to satisfy constraint: 32-bit float attribute");
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v12);
  return v7;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps22(uint64_t *a1, const void **a2, const void **a3, const void **a4)
{
  v12[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v9[0] = a2;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v9);
    if (mlir::Type::isSignedInteger((mlir::Type *)&Value, 32)) {
      return 1;
    }
  }
  __int16 v10 = 257;
  mlir::Operation::emitOpError(a1, v9, (uint64_t)&Value);
  if (Value)
  {
    mlir::Diagnostic::operator<<((uint64_t)v12, "attribute '");
    if (Value)
    {
      __int16 v10 = 261;
      v9[0] = a3;
      v9[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v12, v9);
      if (Value) {
        mlir::Diagnostic::operator<<((uint64_t)v12, "' failed to satisfy constraint: 32-bit signed integer attribute");
      }
    }
  }
  uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v12);
  return v7;
}

void mlir::anec::Deconvolution::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  void v34[2] = *MEMORY[0x1E4F143B8];
  uint64_t v28 = a4;
  uint64_t v29 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 56), a5);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), a6);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 40), a7);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  if (a8)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 48), a8);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  if (a9)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16), a9);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  if (a10)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a10);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  if (a11)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 24), a11);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  if (a12)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 32), a12);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v33);
  }
  __src = v34;
  uint64_t v33 = 0x200000000;
  uint64_t v18 = *a1;
  uint64_t v19 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v31, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v22 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v30, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Deconvolution>::inferReturnTypes(v18, v19, 1u, v31[0], v31[1], Dictionary, v22, v23, v30[0], v30[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v24 = __src;
  }
  uint64_t v25 = v33;
  uint64_t v26 = *(unsigned int *)(a2 + 72);
  unint64_t v27 = v26 + v33;
  if (v27 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v27, 8);
    LODWORD(v26) = *(_DWORD *)(a2 + 72);
  }
  if (v25)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v26), v24, 8 * v25);
    LODWORD(v26) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v26 + v25;
  if (__src != v34) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Deconvolution>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::Deconvolution::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::Deconvolution::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12)
{
  void v43[2] = *MEMORY[0x1E4F143B8];
  uint64_t v37 = a4;
  uint64_t v38 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v38, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v37, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 56), a5);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), a6);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 40), a7);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  uint64_t v18 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 48);
  uint64_t v19 = mlir::IntegerType::get(*a1, 0x40u, 0);
  uint64_t v20 = mlir::IntegerAttr::get(v19, a8);
  mlir::NamedAttribute::NamedAttribute(&__src, v18, v20);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  uint64_t v21 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16);
  uint64_t IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a9);
  mlir::NamedAttribute::NamedAttribute(&__src, v21, IntegerAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  if (a10)
  {
    uint64_t v25 = **(void **)(*(void *)(a2 + 8) + 96);
    uint64_t UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v24);
    mlir::NamedAttribute::NamedAttribute(&__src, v25, UnitAttr);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  }
  if (a11)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 24), a11);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  }
  if (a12)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 32), a12);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v42);
  }
  __src = v43;
  uint64_t v42 = 0x200000000;
  unint64_t v27 = (mlir::UnknownLoc *)*a1;
  uint64_t v28 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v40, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v31 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v39, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Deconvolution>::inferReturnTypes(v27, v28, 1u, v40[0], v40[1], Dictionary, v31, v32, v39[0], v39[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v33 = __src;
  }
  uint64_t v34 = v42;
  uint64_t v35 = *(unsigned int *)(a2 + 72);
  unint64_t v36 = v35 + v42;
  if (v36 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v36, 8);
    LODWORD(v35) = *(_DWORD *)(a2 + 72);
  }
  if (v34)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v35), v33, 8 * v34);
    LODWORD(v35) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v35 + v34;
  if (__src != v43) {
    free(__src);
  }
}

void mlir::anec::ElementwiseAdd::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8 = a5;
  uint64_t v9 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v9, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v8, 1);
  uint64_t v7 = *(unsigned int *)(a2 + 72);
  if (v7 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v7 + 1, 8);
    LODWORD(v7) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v7) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::anec::ElementwiseAdd::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v22[2] = *MEMORY[0x1E4F143B8];
  uint64_t v16 = a4;
  uint64_t v17 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  __src = v22;
  uint64_t v21 = 0x200000000;
  uint64_t v6 = *a1;
  uint64_t v7 = *(void *)a2;
  mlir::ValueRange::ValueRange(v19, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v10 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v18, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(v6, v7, 1, v19[0], v19[1], Dictionary, v10, v11, v18[0], v18[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v12 = __src;
  }
  uint64_t v13 = v21;
  uint64_t v14 = *(unsigned int *)(a2 + 72);
  unint64_t v15 = v14 + v21;
  if (v15 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  if (v13)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v14), v12, 8 * v13);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + v13;
  if (__src != v22) {
    free(__src);
  }
}

BOOL mlir::anec::ElementwiseAdd::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::ElementwiseAdd::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"anec.add", 8, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D0A20;
  v4[12] = mlir::anec::ElementwiseAdd::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v38[23] = *MEMORY[0x1E4F143B8];
  uint64_t v33 = 0;
  uint64_t v34 = v36;
  uint64_t v35 = 0x600000000;
  uint64_t v32 = a4;
  if (a5)
  {
    uint64_t v16 = 0;
    while (1)
    {
      uint64_t v17 = mlir::ValueRange::dereference_iterator(&v32, v16);
      uint64_t v18 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v18) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v18, v19);
      uint64_t v21 = v35;
      if (v35 >= (unint64_t)HIDWORD(v35))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v34, v36, v35 + 1, 8);
        uint64_t v21 = v35;
      }
      *((void *)v34 + v21) = RankPromotionTypeForANE;
      unint64_t v22 = (v35 + 1);
      LODWORD(v35) = v35 + 1;
      uint64_t v16 = ++v33;
      if (v32 == a4 && v16 == a5)
      {
        uint64_t v24 = v34;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError(a2, (uint64_t)&v37);
      if (v37) {
        mlir::Diagnostic::operator<<((uint64_t)v38, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v37);
      if (v37) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v37);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v38);
    }
    else
    {
      uint64_t v23 = 0;
    }
  }
  else
  {
    unint64_t v22 = 0;
    uint64_t v24 = v36;
LABEL_16:
    mlir::ValueRange::ValueRange(v31, (uint64_t)v24, v22);
    uint64_t v23 = mlir::anec::inferElementwiseCompareReturnTypes(a1, v25, v26, a4, a5, v27, v28, v29, v31[0], v31[1], a11);
  }
  if (v34 != v36) {
    free(v34);
  }
  return v23;
}

void mlir::anec::ElementwiseEqual::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  unint64_t v26[2] = *MEMORY[0x1E4F143B8];
  mlir::OperationState::addOperands(a2, a3, a4);
  *(void *)(a2 + 192) = 0;
  uint64_t v12 = *(unsigned int *)(a2 + 120);
  if (a6 + v12 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a6 + v12, 16);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  if (a6)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v12), a5, 16 * a6);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v12 + a6;
  __src = v26;
  uint64_t v25 = 0x200000000;
  uint64_t v13 = *a1;
  uint64_t v14 = *(void *)a2;
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v17 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(v13, v14, 1, a3, a4, Dictionary, v17, v18, v23[0], v23[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v19 = __src;
  }
  uint64_t v20 = v25;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v25;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v26) {
    free(__src);
  }
}

void mlir::anec::ElementwiseEqualZero::build(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  void v20[2] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  __src = v20;
  uint64_t v19 = 0x200000000;
  uint64_t v5 = *a1;
  uint64_t v6 = *(void *)a2;
  mlir::ValueRange::ValueRange(v17, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v9 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v16, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(v5, v6, 1, v17[0], v17[1], Dictionary, v9, v10, v16[0], v16[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v11 = __src;
  }
  uint64_t v12 = v19;
  uint64_t v13 = *(unsigned int *)(a2 + 72);
  unint64_t v14 = v13 + v19;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (v12)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v20) {
    free(__src);
  }
}

void mlir::anec::ElementwiseGreaterThanEqualZero::build(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  void v20[2] = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  __src = v20;
  uint64_t v19 = 0x200000000;
  uint64_t v5 = *a1;
  uint64_t v6 = *(void *)a2;
  mlir::ValueRange::ValueRange(v17, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v9 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v16, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::ElementwiseEqual>::inferReturnTypes(v5, v6, 1, v17[0], v17[1], Dictionary, v9, v10, v16[0], v16[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v11 = __src;
  }
  uint64_t v12 = v19;
  uint64_t v13 = *(unsigned int *)(a2 + 72);
  unint64_t v14 = v13 + v19;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if (v12)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v20) {
    free(__src);
  }
}

uint64_t mlir::anec::ElementwiseMax::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"anec.max", 8, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D0A78;
  v4[12] = mlir::anec::ElementwiseMax::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::anec::ElementwiseMin::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"anec.min", 8, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D0AD0;
  v4[12] = mlir::anec::ElementwiseMin::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::anec::ElementwiseMult::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"anec.mult", 9, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D0B80;
  v4[12] = mlir::anec::ElementwiseMult::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

uint64_t mlir::anec::ElementwiseSub::getCanonicalizationPatterns(uint64_t *a1)
{
  mlir::PatternBenefit::PatternBenefit(&v8, 1);
  __int16 v2 = v8;
  uint64_t v3 = *a1;
  uint64_t v4 = operator new(0x68uLL);
  uint64_t result = mlir::Pattern::Pattern((uint64_t)(v4 + 1), (uint64_t)"anec.sub", 8, v2, v3, 0, 0);
  void *v4 = &unk_1EC9D0B28;
  v4[12] = mlir::anec::ElementwiseSub::canonicalize;
  uint64_t v9 = v4;
  uint64_t v6 = (void *)a1[2];
  if ((unint64_t)v6 >= a1[3])
  {
    uint64_t v7 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a1 + 1, (uint64_t *)&v9);
    uint64_t result = (uint64_t)v9;
    a1[2] = (uint64_t)v7;
    uint64_t v9 = 0;
    if (result) {
      return (*(uint64_t (**)(uint64_t))(*(void *)result + 8))(result);
    }
  }
  else
  {
    void *v6 = v4;
    a1[2] = (uint64_t)(v6 + 1);
  }
  return result;
}

BOOL mlir::anec::Elu::verifyInvariantsImpl(uint64_t **this)
{
  v14[23] = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (const void ***)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (v4)
  {
    uint64_t v6 = 16 * v4;
    while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      Value += 2;
      v6 -= 16;
      if (!v6) {
        goto LABEL_8;
      }
    }
    if (mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, Value[1], (const void **)"alpha", (const void **)5)&& mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v8 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
      return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
LABEL_8:
    uint64_t v11 = (const void **)"requires attribute 'alpha'";
    __int16 v12 = 259;
    mlir::OpState::emitOpError(this, &v11, (uint64_t)&AttrDictionary);
    uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v14);
  }
  return v7;
}

void mlir::anec::Flatten::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v22[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a4);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v21);
  __src = v22;
  uint64_t v21 = 0x200000000;
  uint64_t v7 = *a1;
  uint64_t v8 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v19, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v11 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v18, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Flatten>::inferReturnTypes(v7, v8, 1, v19[0], v19[1], Dictionary, v11, v12, v18[0], v18[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v13 = __src;
  }
  uint64_t v14 = v21;
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  unint64_t v16 = v15 + v21;
  if (v16 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v16, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  if (v14)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v15), v13, 8 * v14);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v15 + v14;
  if (__src != v22) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Flatten>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::Flatten::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

BOOL mlir::anec::Flatten::verifyInvariantsImpl(uint64_t **this)
{
  v14[23] = *MEMORY[0x1E4F143B8];
  __int16 v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (const void ***)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (v4)
  {
    uint64_t v6 = 16 * v4;
    while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      Value += 2;
      v6 -= 16;
      if (!v6) {
        goto LABEL_8;
      }
    }
    if (mlir::anec::__mlir_ods_local_attr_constraint_ANECOps23(*this, Value[1], (const void **)"flatten_mode", (const void **)0xC)&& mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v8 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
      return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
LABEL_8:
    uint64_t v11 = (const void **)"requires attribute 'flatten_mode'";
    __int16 v12 = 259;
    mlir::OpState::emitOpError(this, &v11, (uint64_t)&AttrDictionary);
    uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v14);
  }
  return v7;
}

uint64_t mlir::anec::__mlir_ods_local_attr_constraint_ANECOps23(uint64_t *a1, const void **a2, const void **a3, const void **a4)
{
  v15[23] = *MEMORY[0x1E4F143B8];
  if (!a2) {
    return 1;
  }
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v12[0] = a2;
    uint64_t Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v12);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&Value, 64))
    {
      uint64_t v11 = a2;
      if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v11) == 1) {
        return 1;
      }
      uint64_t v10 = a2;
      if (mlir::IntegerAttr::getInt((mlir::IntegerAttr *)&v10) == 2) {
        return 1;
      }
    }
  }
  __int16 v13 = 257;
  mlir::Operation::emitOpError(a1, v12, (uint64_t)&Value);
  if (Value)
  {
    mlir::Diagnostic::operator<<((uint64_t)v15, "attribute '");
    if (Value)
    {
      __int16 v13 = 261;
      v12[0] = a3;
      v12[1] = a4;
      mlir::Diagnostic::operator<<((uint64_t)v15, v12);
      if (Value) {
        mlir::Diagnostic::operator<<((uint64_t)v15, "' failed to satisfy constraint: valid FlattenMode");
      }
    }
  }
  uint64_t v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v15);
  return v8;
}

uint64_t mlir::anec::detail::GOCGenericAdaptorBase::GOCGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  unint64_t v5 = a2[11];
  unint64_t v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    uint64_t v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    uint64_t v7 = 0;
    unint64_t v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(void *)a1 = AttrDictionary;
  *(unsigned char *)(a1 + 8) = 0;
  *(unsigned char *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    uint64_t Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(unsigned char *)(a1 + 16)) {
      *(unsigned char *)(a1 + 16) = 0;
    }
    mlir::OperationName::OperationName(a1 + 8, "anec.gain_offset_control", 24, Context);
    *(unsigned char *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::anec::GOC::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = a5;
  uint64_t v11 = a4;
  uint64_t v9 = a6;
  mlir::OperationState::addOperands(a2, (uint64_t)&v11, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v10, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v9, 1);
  uint64_t v8 = *(unsigned int *)(a2 + 72);
  if (v8 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v8 + 1, 8);
    LODWORD(v8) = *(_DWORD *)(a2 + 72);
  }
  *(void *)(*(void *)(a2 + 64) + 8 * v8) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::anec::GOC::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v24[2] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a4;
  uint64_t v19 = a3;
  uint64_t v17 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v24;
  uint64_t v23 = 0x200000000;
  uint64_t v7 = *a1;
  uint64_t v8 = *(void *)a2;
  mlir::ValueRange::ValueRange(v21, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v11 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(v7, v8, 1, v21[0], v21[1], Dictionary, v11, v12, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  __int16 v13 = __src;
  }
  uint64_t v14 = v23;
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  unint64_t v16 = v15 + v23;
  if (v16 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v16, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  if (v14)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v15), v13, 8 * v14);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v15 + v14;
  if (__src != v24) {
    free(__src);
  }
}

void mlir::anec::GOC::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const void *a7, uint64_t a8)
{
  mlir::OperationState::addOperands(a2, a5, a6);
  *(void *)(a2 + 192) = 0;
  uint64_t v13 = *(unsigned int *)(a2 + 120);
  if (a8 + v13 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a8 + v13, 16);
    LODWORD(v13) = *(_DWORD *)(a2 + 120);
  }
  if (a8)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v13), a7, 16 * a8);
    LODWORD(v13) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v13 + a8;
  uint64_t v14 = *(unsigned int *)(a2 + 72);
  if (a4 + v14 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a4 + v14, 8);
    uint64_t v14 = *(unsigned int *)(a2 + 72);
  }
  if (a4)
  {
    uint64_t v15 = 0;
    uint64_t v16 = *(void *)(a2 + 64) + 8 * v14;
    do
    {
      *(void *)(v16 + 8 * v15) = mlir::TypeRange::dereference_iterator(a3, v15);
      ++v15;
    }
    while (a4 != v15);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + a4;
}

BOOL mlir::anec::GOC::verifyInvariantsImpl(uint64_t **this)
{
  if (!mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps6(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps6(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v2 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v2 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::__mlir_ods_local_type_constraint_ANECOps6(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  v74[19] = *MEMORY[0x1E4F143B8];
  uint64_t v65 = a2;
  uint64_t v9 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id) {
    goto LABEL_43;
  }
  unint64_t v11 = mlir::TypeID::get<mlir::ShapedType>();
  unint64_t v12 = *((unsigned int *)v9 + 4);
  if (!v12) {
    goto LABEL_10;
  }
  uint64_t v13 = (void *)v9[1];
  uint64_t v14 = &v13[2 * v12];
  do
  {
    unint64_t v15 = v12 >> 1;
    uint64_t v16 = &v13[2 * (v12 >> 1)];
    unint64_t v18 = *v16;
    uint64_t v17 = v16 + 2;
    v12 += ~(v12 >> 1);
    if (v18 < v11) {
      uint64_t v13 = v17;
    }
    else {
      unint64_t v12 = v15;
    }
  }
  while (v12);
  if (v13 != v14 && *v13 == v11) {
    uint64_t v19 = v13[1];
  }
  else {
LABEL_10:
  }
    uint64_t v19 = 0;
  uint64_t v69 = a2;
  v70[0] = v19;
  uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v69);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange))
  {
    uint64_t v20 = *a2;
    unint64_t v21 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v22 = *((unsigned int *)v20 + 4);
    if (!v22) {
      goto LABEL_20;
    }
    uint64_t v23 = (void *)v20[1];
    uint64_t v24 = &v23[2 * v22];
    do
    {
      unint64_t v25 = v22 >> 1;
      uint64_t v26 = &v23[2 * (v22 >> 1)];
      unint64_t v28 = *v26;
      uint64_t v27 = v26 + 2;
      v22 += ~(v22 >> 1);
      if (v28 < v21) {
        uint64_t v23 = v27;
      }
      else {
        unint64_t v22 = v25;
      }
    }
    while (v22);
    if (v23 != v24 && *v23 == v21) {
      uint64_t v29 = v23[1];
    }
    else {
LABEL_20:
    }
      uint64_t v29 = 0;
    unsigned int v61 = a2;
    uint64_t v62 = v29;
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v61))
    {
      uint64_t v30 = *a2;
      unint64_t v31 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v32 = *((unsigned int *)v30 + 4);
      if (!v32) {
        goto LABEL_30;
      }
      uint64_t v33 = (void *)v30[1];
      uint64_t v34 = &v33[2 * v32];
      do
      {
        unint64_t v35 = v32 >> 1;
        unint64_t v36 = &v33[2 * (v32 >> 1)];
        unint64_t v38 = *v36;
        uint64_t v37 = v36 + 2;
        v32 += ~(v32 >> 1);
        if (v38 < v31) {
          uint64_t v33 = v37;
        }
        else {
          unint64_t v32 = v35;
        }
      }
      while (v32);
      if (v33 != v34 && *v33 == v31) {
        uint64_t v39 = v33[1];
      }
      else {
LABEL_30:
      }
        uint64_t v39 = 0;
      uint64_t v67 = a2;
      uint64_t v68 = v39;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v67);
      if (v40 == 4) {
        return 1;
      }
      uint64_t v41 = *a2;
      unint64_t v42 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v43 = *((unsigned int *)v41 + 4);
      if (!v43) {
        goto LABEL_40;
      }
      unint64_t v44 = (void *)v41[1];
      long long v45 = &v44[2 * v43];
      do
      {
        unint64_t v46 = v43 >> 1;
        unint64_t v47 = &v44[2 * (v43 >> 1)];
        unint64_t v49 = *v47;
        unint64_t v48 = v47 + 2;
        v43 += ~(v43 >> 1);
        if (v49 < v42) {
          unint64_t v44 = v48;
        }
        else {
          unint64_t v43 = v46;
        }
      }
      while (v43);
      if (v44 != v45 && *v44 == v42) {
        uint64_t v50 = v44[1];
      }
      else {
LABEL_40:
      }
        uint64_t v50 = 0;
      v64[0] = a2;
      v64[1] = v50;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v64);
      if (v51 == 5) {
        return 1;
      }
    }
  }
LABEL_43:
  __int16 v63 = 261;
  unsigned int v61 = a3;
  uint64_t v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)&v69);
  if (v69)
  {
    mlir::Diagnostic::operator<<((uint64_t)v70, " #");
    if (v69)
    {
      LODWORD(v67) = 5;
      uint64_t v68 = a5;
      uint64_t v53 = (char *)&v67;
      unint64_t v54 = v71;
      if (v72 >= v73)
      {
        unint64_t v59 = v72 + 1;
        if (v71 <= (unint64_t)&v67 && v71 + 24 * v72 > (unint64_t)&v67)
        {
          unsigned int v60 = (char *)&v67 - v71;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v59, 24);
          unint64_t v54 = v71;
          uint64_t v53 = &v60[v71];
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v59, 24);
          uint64_t v53 = (char *)&v67;
          unint64_t v54 = v71;
        }
      }
      unint64_t v55 = v54 + 24 * v72;
      long long v56 = *(_OWORD *)v53;
      *(void *)(v55 + 16) = *((void *)v53 + 2);
      *(_OWORD *)unint64_t v55 = v56;
      ++v72;
      if (v69) {
        mlir::Diagnostic::operator<<((uint64_t)v70, " must be 4D/5D memref of 16-bit float values, but got ");
      }
    }
  }
  uint64_t v57 = mlir::InFlightDiagnostic::append<mlir::Type &>((uint64_t)&v69, (uint64_t *)&v65);
  uint64_t v52 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v57);
  if (v69) {
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v69);
  }
  std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v70);
  return v52;
}

void mlir::anec::GatherND::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v24[2] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a4;
  uint64_t v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a5);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v23);
  __src = v24;
  uint64_t v23 = 0x200000000;
  uint64_t v8 = *a1;
  uint64_t v9 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v21, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v12 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GatherND>::inferReturnTypes(v8, v9, 1, v21[0], v21[1], Dictionary, v12, v13, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v14 = __src;
  }
  uint64_t v15 = v23;
  uint64_t v16 = *(unsigned int *)(a2 + 72);
  unint64_t v17 = v16 + v23;
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if (v15)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v16), v14, 8 * v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + v15;
  if (__src != v24) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GatherND>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        unint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    unint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::GatherND::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

BOOL mlir::anec::GatherND::verifyInvariantsImpl(uint64_t **this)
{
  v47[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (v4)
  {
    uint64_t v6 = 16 * v4;
    while (1)
    {
      uint64_t CallableRegion = mlir::CallGraphNode::getCallableRegion(Value);
      uint64_t v8 = *this;
      if (**(void **)((*this)[6] + 96) == CallableRegion) {
        break;
      }
      uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
      v6 -= 16;
      if (!v6) {
        goto LABEL_8;
      }
    }
    uint64_t v10 = (const void **)*((void *)Value + 1);
    if (v10)
    {
      if (!mlir::DenseIntElementsAttr::classof((uint64_t)v10)) {
        goto LABEL_36;
      }
      unint64_t v11 = *v10;
      unint64_t v12 = mlir::TypeID::get<mlir::ElementsAttr>();
      unint64_t v13 = *((unsigned int *)v11 + 4);
      if (!v13) {
        goto LABEL_21;
      }
      uint64_t v14 = (void *)v11[1];
      uint64_t v15 = &v14[2 * v13];
      do
      {
        unint64_t v16 = v13 >> 1;
        uint64_t v17 = &v14[2 * (v13 >> 1)];
        unint64_t v19 = *v17;
        uint64_t v18 = v17 + 2;
        v13 += ~(v13 >> 1);
        if (v19 < v12) {
          uint64_t v14 = v18;
        }
        else {
          unint64_t v13 = v16;
        }
      }
      while (v13);
      if (v14 != v15 && *v14 == v12) {
        uint64_t v20 = v14[1];
      }
      else {
LABEL_21:
      }
        uint64_t v20 = 0;
      unint64_t v43 = v10;
      uint64_t v44 = v20;
      uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v43);
      uint64_t v22 = Type;
      if (!Type) {
        goto LABEL_31;
      }
      uint64_t v23 = *Type;
      unint64_t v24 = mlir::TypeID::get<mlir::ShapedType>();
      unint64_t v25 = *(unsigned int *)(v23 + 16);
      if (!v25) {
        goto LABEL_31;
      }
      uint64_t v26 = *(void **)(v23 + 8);
      uint64_t v27 = &v26[2 * v25];
      do
      {
        unint64_t v28 = v25 >> 1;
        uint64_t v29 = &v26[2 * (v25 >> 1)];
        unint64_t v31 = *v29;
        uint64_t v30 = v29 + 2;
        v25 += ~(v25 >> 1);
        if (v31 < v24) {
          uint64_t v26 = v30;
        }
        else {
          unint64_t v25 = v28;
        }
      }
      while (v25);
      if (v26 != v27 && *v26 == v24) {
        uint64_t v32 = v26[1];
      }
      else {
LABEL_31:
      }
        uint64_t v32 = 0;
      unint64_t AttrDictionary = (unint64_t)v22;
      v47[0] = v32;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&AttrDictionary);
      if (v33 != 1
        || !mlir::hasUniqueValues((uint64_t)v10)
        || (unint64_t v42 = v10, !mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v42))
        || (uint64_t v39 = v10,
            v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39),
            v40[1] = v34,
            uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40),
            !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
      {
LABEL_36:
        __int16 v45 = 257;
        mlir::Operation::emitOpError(v8, &v43, (uint64_t)&AttrDictionary);
        if (AttrDictionary)
        {
          mlir::Diagnostic::operator<<((uint64_t)v47, "attribute '");
          if (AttrDictionary)
          {
            __int16 v45 = 261;
            unint64_t v43 = (const void **)"axes";
            uint64_t v44 = 4;
            mlir::Diagnostic::operator<<((uint64_t)v47, &v43);
            if (AttrDictionary) {
              mlir::Diagnostic::operator<<((uint64_t)v47, "' failed to satisfy constraint: ui64 unique not empty elements attribute of ranks 1");
            }
          }
        }
        char v35 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
        if (AttrDictionary) {
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
        }
        std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v47);
        if (!v35) {
          return 0;
        }
      }
    }
    if (mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v36 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v36 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v36, 0);
      return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
LABEL_8:
    unint64_t v43 = (const void **)"requires attribute 'axes'";
    __int16 v45 = 259;
    mlir::OpState::emitOpError(this, &v43, (uint64_t)&AttrDictionary);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v47);
  }
  return v9;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GlobalArgMinMax>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      unint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        unint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    unint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::GlobalArgMinMax::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::GlobalArgMinMax::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5)
{
  unint64_t v30[2] = *MEMORY[0x1E4F143B8];
  uint64_t v25 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  uint64_t v9 = **(void **)(*(void *)(a2 + 8) + 96);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a4);
  mlir::NamedAttribute::NamedAttribute(&__src, v9, IntegerAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v29);
  uint64_t v12 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8);
  uint64_t v13 = mlir::IntegerType::get(*(void *)a1, 0x40u, 0);
  uint64_t v14 = mlir::IntegerAttr::get(v13, a5);
  mlir::NamedAttribute::NamedAttribute(&__src, v12, v14);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v29);
  __src = v30;
  uint64_t v29 = 0x200000000;
  uint64_t v15 = *(mlir::UnknownLoc **)a1;
  unint64_t v16 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v27, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v19 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v26, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::GlobalArgMinMax>::inferReturnTypes(v15, v16, 1, v27[0], v27[1], Dictionary, v19, v20, v26[0], v26[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v21 = __src;
  }
  uint64_t v22 = v29;
  uint64_t v23 = *(unsigned int *)(a2 + 72);
  unint64_t v24 = v23 + v29;
  if (v24 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v24, 8);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  if (v22)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v23), v21, 8 * v22);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v23 + v22;
  if (__src != v30) {
    free(__src);
  }
}

BOOL mlir::anec::GlobalArgMinMax::verifyInvariantsImpl(uint64_t **this)
{
  v20[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = "requires attribute 'axis'";
LABEL_14:
    v17[0] = (const void **)v7;
    __int16 v18 = 259;
    mlir::OpState::emitOpError(this, v17, (uint64_t)&AttrDictionary);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v20);
    return v11;
  }
  uint64_t v6 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (!v6)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'mode'";
    goto LABEL_14;
  }
  uint64_t v8 = (const void **)*((void *)Value + 1);
  while (1)
  {
    uint64_t CallableRegion = mlir::CallGraphNode::getCallableRegion(Value);
    uint64_t v10 = *this;
    if (*(void *)(*(void *)((*this)[6] + 96) + 8) == CallableRegion) {
      break;
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_13;
    }
  }
  uint64_t v13 = (const void **)*((void *)Value + 1);
  if (v8)
  {
    if (*((_UNKNOWN **)*v8 + 17) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id
      || (v17[0] = v8,
          unint64_t AttrDictionary = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)v17),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&AttrDictionary, 32)))
    {
      __int16 v18 = 257;
      mlir::Operation::emitOpError(v10, v17, (uint64_t)&AttrDictionary);
      if (AttrDictionary)
      {
        mlir::Diagnostic::operator<<((uint64_t)v20, "attribute '");
        if (AttrDictionary)
        {
          __int16 v18 = 261;
          v17[0] = (const void **)"axis";
          v17[1] = (const void **)4;
          mlir::Diagnostic::operator<<((uint64_t)v20, v17);
          if (AttrDictionary) {
            mlir::Diagnostic::operator<<((uint64_t)v20, "' failed to satisfy constraint: 32-bit unsigned integer attribute");
          }
        }
      }
      char v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
      if (AttrDictionary) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v20);
      if (!v14) {
        return 0;
      }
    }
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps4(*this, v13, (const void **)"mode", (const void **)4)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v15 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::InputView::getDimensionAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 48), **(void **)(*((void *)*this + 6) + 96));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::InputView::getOffsetAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 32), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::InputView::getSizeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 32);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 16));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::InputView::getStepAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 48);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 24));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

void mlir::anec::InputView::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
}

void mlir::anec::InputView::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  void v40[2] = *MEMORY[0x1E4F143B8];
  uint64_t v35 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v35, 1);
  uint64_t v13 = **(void **)(*(void *)(a2 + 8) + 96);
  uint64_t IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a4);
  mlir::NamedAttribute::NamedAttribute(&__src, v13, IntegerAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v39);
  uint64_t v16 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8);
  uint64_t v17 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v18 = mlir::Builder::getIntegerAttr((uint64_t)a1, v17, a5);
  mlir::NamedAttribute::NamedAttribute(&__src, v16, v18);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v39);
  uint64_t v19 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16);
  uint64_t v20 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v21 = mlir::Builder::getIntegerAttr((uint64_t)a1, v20, a6);
  mlir::NamedAttribute::NamedAttribute(&__src, v19, v21);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v39);
  uint64_t v22 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 24);
  uint64_t v23 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  uint64_t v24 = mlir::Builder::getIntegerAttr((uint64_t)a1, v23, a7);
  mlir::NamedAttribute::NamedAttribute(&__src, v22, v24);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v39);
  __src = v40;
  uint64_t v39 = 0x200000000;
  uint64_t v25 = *(mlir::UnknownLoc **)a1;
  uint64_t v26 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v37, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v29 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v36, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InputView>::inferReturnTypes(v25, v26, 1u, v37[0], v37[1], Dictionary, v29, v30, v36[0], v36[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v31 = __src;
  }
  uint64_t v32 = v39;
  uint64_t v33 = *(unsigned int *)(a2 + 72);
  unint64_t v34 = v33 + v39;
  if (v34 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v34, 8);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  if (v32)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v33), v31, 8 * v32);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v33 + v32;
  if (__src != v40) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InputView>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, unsigned __int8 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::InputView::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

BOOL mlir::anec::InputView::verifyInvariantsImpl(uint64_t **this)
{
  v22[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = "requires attribute 'dimension'";
LABEL_23:
    uint64_t v19 = (const void **)v7;
    __int16 v20 = 259;
    mlir::OpState::emitOpError(this, &v19, (uint64_t)&AttrDictionary);
    uint64_t v14 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v22);
    return v14;
  }
  uint64_t v6 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (!v6)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'offset'";
    goto LABEL_23;
  }
  uint64_t v8 = (const void **)*((void *)Value + 1);
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_13;
    }
  }
  uint64_t v9 = 0;
  char v10 = (const void **)*((void *)Value + 1);
  while (1)
  {
    uint64_t v11 = (mlir::CallGraphNode *)((char *)Value + v9);
    if (*(void *)(*(void *)((*this)[6] + 96) + 16) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)((char *)Value + v9))) {
      break;
    }
    v9 += 16;
    if (v6 == v9)
    {
      uint64_t v7 = "requires attribute 'size'";
      goto LABEL_23;
    }
  }
  uint64_t v12 = v6 - v9;
  if (!v12)
  {
LABEL_22:
    uint64_t v7 = "requires attribute 'step'";
    goto LABEL_23;
  }
  uint64_t v13 = (const void **)*((void *)v11 + 1);
  while (*(void *)(*(void *)((*this)[6] + 96) + 24) != mlir::CallGraphNode::getCallableRegion(v11))
  {
    uint64_t v11 = (mlir::CallGraphNode *)((char *)v11 + 16);
    v12 -= 16;
    if (!v12) {
      goto LABEL_22;
    }
  }
  uint64_t v16 = (const void **)*((void *)v11 + 1);
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps11(*this, v8, (const void **)"dimension", (const void **)9)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps11(*this, v10, (const void **)"offset", (const void **)6)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps11(*this, v13, (const void **)"size", (const void **)4)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps11(*this, v16, (const void **)"step", (const void **)4)
    || !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v17 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v17 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v17, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InstanceNorm>::inferReturnTypes(mlir::Float16Type *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v40[23] = *MEMORY[0x1E4F143B8];
  uint64_t v35 = 0;
  uint64_t v36 = v38;
  uint64_t v37 = 0x600000000;
  uint64_t v34 = a4;
  if (a5)
  {
    uint64_t v16 = 0;
    while (1)
    {
      uint64_t v17 = mlir::ValueRange::dereference_iterator(&v34, v16);
      uint64_t v18 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v17 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v18) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v18, v19);
      uint64_t v21 = v37;
      if (v37 >= (unint64_t)HIDWORD(v37))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v36, v38, v37 + 1, 8);
        uint64_t v21 = v37;
      }
      *((void *)v36 + v21) = RankPromotionTypeForANE;
      unint64_t v22 = (v37 + 1);
      LODWORD(v37) = v37 + 1;
      uint64_t v16 = ++v35;
      if (v34 == a4 && v16 == a5)
      {
        uint64_t v24 = v36;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError(a2, (uint64_t)&v39);
      if (v39) {
        mlir::Diagnostic::operator<<((uint64_t)v40, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v39);
      if (v39) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v39);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v40);
    }
    else
    {
      uint64_t v23 = 0;
    }
  }
  else
  {
    unint64_t v22 = 0;
    uint64_t v24 = v38;
LABEL_16:
    mlir::ValueRange::ValueRange(&v33, (uint64_t)v24, v22);
    uint64_t v23 = mlir::anec::InstanceNorm::inferPromotedReturnTypes(a1, v25, v26, a4, a5, v27, v28, v29, v31, v32, a11);
  }
  if (v36 != v38) {
    free(v36);
  }
  return v23;
}

void mlir::anec::InstanceNorm::build(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v28[2] = *MEMORY[0x1E4F143B8];
  uint64_t v23 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a4);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v27);
  uint64_t v9 = *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8);
  uint64_t F32Type = mlir::Builder::getF32Type(a1, v10);
  uint64_t FloatAttr = mlir::Builder::getFloatAttr((uint64_t)a1, F32Type, a5);
  mlir::NamedAttribute::NamedAttribute(&__src, v9, FloatAttr);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v27);
  __src = v28;
  uint64_t v27 = 0x200000000;
  uint64_t v13 = *a1;
  uint64_t v14 = *(void *)a2;
  mlir::ValueRange::ValueRange(v25, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v17 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v24, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::InstanceNorm>::inferReturnTypes(v13, v14, 1, v25[0], v25[1], Dictionary, v17, v18, v24[0], v24[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v19 = __src;
  }
  uint64_t v20 = v27;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v27;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v28) {
    free(__src);
  }
}

BOOL mlir::anec::InstanceNorm::verifyInvariantsImpl(uint64_t **this)
{
  v48[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = "requires attribute 'axes'";
LABEL_14:
    uint64_t v44 = (const void **)v7;
    __int16 v46 = 259;
    mlir::OpState::emitOpError(this, &v44, (uint64_t)&AttrDictionary);
    uint64_t v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v48);
    return v11;
  }
  uint64_t v6 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (!v6)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'epsilon'";
    goto LABEL_14;
  }
  uint64_t v8 = (const void **)*((void *)Value + 1);
  while (1)
  {
    uint64_t CallableRegion = mlir::CallGraphNode::getCallableRegion(Value);
    char v10 = *this;
    if (*(void *)(*(void *)((*this)[6] + 96) + 8) == CallableRegion) {
      break;
    }
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_13;
    }
  }
  uint64_t v13 = (const void **)*((void *)Value + 1);
  if (v8)
  {
    if (!mlir::DenseIntElementsAttr::classof((uint64_t)v8)) {
      goto LABEL_42;
    }
    uint64_t v14 = *v8;
    unint64_t v15 = mlir::TypeID::get<mlir::ElementsAttr>();
    unint64_t v16 = *((unsigned int *)v14 + 4);
    if (!v16) {
      goto LABEL_28;
    }
    uint64_t v17 = (void *)v14[1];
    uint64_t v18 = &v17[2 * v16];
    do
    {
      unint64_t v19 = v16 >> 1;
      uint64_t v20 = &v17[2 * (v16 >> 1)];
      unint64_t v22 = *v20;
      uint64_t v21 = v20 + 2;
      v16 += ~(v16 >> 1);
      if (v22 < v15) {
        uint64_t v17 = v21;
      }
      else {
        unint64_t v16 = v19;
      }
    }
    while (v16);
    if (v17 != v18 && *v17 == v15) {
      uint64_t v23 = v17[1];
    }
    else {
LABEL_28:
    }
      uint64_t v23 = 0;
    uint64_t v44 = v8;
    uint64_t v45 = v23;
    uint64_t Type = (void *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v44);
    uint64_t v25 = Type;
    if (!Type) {
      goto LABEL_38;
    }
    uint64_t v26 = *Type;
    unint64_t v27 = mlir::TypeID::get<mlir::ShapedType>();
    unint64_t v28 = *(unsigned int *)(v26 + 16);
    if (!v28) {
      goto LABEL_38;
    }
    uint64_t v29 = *(void **)(v26 + 8);
    uint64_t v30 = &v29[2 * v28];
    do
    {
      unint64_t v31 = v28 >> 1;
      uint64_t v32 = &v29[2 * (v28 >> 1)];
      unint64_t v34 = *v32;
      unint64_t v33 = v32 + 2;
      v28 += ~(v28 >> 1);
      if (v34 < v27) {
        uint64_t v29 = v33;
      }
      else {
        unint64_t v28 = v31;
      }
    }
    while (v28);
    if (v29 != v30 && *v29 == v27) {
      uint64_t v35 = v29[1];
    }
    else {
LABEL_38:
    }
      uint64_t v35 = 0;
    unint64_t AttrDictionary = (unint64_t)v25;
    v48[0] = v35;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&AttrDictionary);
    if (v36 != 1
      || !mlir::hasUniqueValues((uint64_t)v8)
      || (uint64_t v41 = v8,
          v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41),
          v42[1] = v37,
          uint64_t OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42),
          !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)))
    {
LABEL_42:
      __int16 v46 = 257;
      mlir::Operation::emitOpError(v10, &v44, (uint64_t)&AttrDictionary);
      if (AttrDictionary)
      {
        mlir::Diagnostic::operator<<((uint64_t)v48, "attribute '");
        if (AttrDictionary)
        {
          __int16 v46 = 261;
          uint64_t v44 = (const void **)"axes";
          uint64_t v45 = 4;
          mlir::Diagnostic::operator<<((uint64_t)v48, &v44);
          if (AttrDictionary) {
            mlir::Diagnostic::operator<<((uint64_t)v48, "' failed to satisfy constraint: ui64 unique elements attribute of ranks 1");
          }
        }
      }
      char v38 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
      if (AttrDictionary) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v48);
      if (!v38) {
        return 0;
      }
    }
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps21(*this, v13, (const void **)"epsilon", (const void **)7)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v39 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v39 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v39, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps6(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

void mlir::anec::Invert::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void v22[2] = *MEMORY[0x1E4F143B8];
  uint64_t v17 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a4);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v21);
  __src = v22;
  uint64_t v21 = 0x200000000;
  uint64_t v7 = *a1;
  uint64_t v8 = *(void *)a2;
  mlir::ValueRange::ValueRange(v19, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v11 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v18, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Ceil>::inferReturnTypes(v7, v8, 1, v19[0], v19[1], Dictionary, v11, v12, v18[0], v18[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v13 = __src;
  }
  uint64_t v14 = v21;
  uint64_t v15 = *(unsigned int *)(a2 + 72);
  unint64_t v16 = v15 + v21;
  if (v16 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v16, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  if (v14)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v15), v13, 8 * v14);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v15 + v14;
  if (__src != v22) {
    free(__src);
  }
}

BOOL mlir::anec::Invert::verifyInvariantsImpl(uint64_t **this)
{
  v14[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (const void ***)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (v4)
  {
    uint64_t v6 = 16 * v4;
    while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)Value))
    {
      Value += 2;
      v6 -= 16;
      if (!v6) {
        goto LABEL_8;
      }
    }
    if (mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, Value[1], (const void **)"epsilon", (const void **)7)&& mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
    {
      if (*((_DWORD *)*this + 9)) {
        uint64_t v8 = (uint64_t)(*this - 2);
      }
      else {
        uint64_t v8 = 0;
      }
      uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
      return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
LABEL_8:
    uint64_t v11 = (const void **)"requires attribute 'epsilon'";
    __int16 v12 = 259;
    mlir::OpState::emitOpError(this, &v11, (uint64_t)&AttrDictionary);
    uint64_t v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v14);
  }
  return v7;
}

uint64_t mlir::anec::L2NormPool::getStrideAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 32);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 16));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::L2NormPool::getPaddingAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t v4 = (mlir::CallGraphNode *)(mlir::ArrayAttr::getValue(p_AttrDictionary) + 16);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t Value = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(v4, (mlir::CallGraphNode *)(Value + 16 * v8 - 16), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::L2NormPool::getKsizeAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8 - 32), **(void **)(*((void *)*this + 6) + 96));
  if (v10) {
    return *((void *)v9 + 1);
  }
  else {
    return 0;
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::L2NormPool>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      unint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::L2NormPool::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::L2NormPool::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  unint64_t v26[2] = *MEMORY[0x1E4F143B8];
  mlir::OperationState::addOperands(a2, a3, a4);
  *(void *)(a2 + 192) = 0;
  uint64_t v12 = *(unsigned int *)(a2 + 120);
  if (a6 + v12 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a6 + v12, 16);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  if (a6)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v12), a5, 16 * a6);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v12 + a6;
  __src = v26;
  uint64_t v25 = 0x200000000;
  uint64_t v13 = *a1;
  uint64_t v14 = *(mlir::MLIRContext **)a2;
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v17 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::L2NormPool>::inferReturnTypes(v13, v14, 1, a3, a4, Dictionary, v17, v18, v23[0], v23[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v19 = __src;
  }
  uint64_t v20 = v25;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v25;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v26) {
    free(__src);
  }
}

BOOL mlir::anec::L2NormPool::verifyInvariantsImpl(uint64_t **this)
{
  v20[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = "requires attribute 'ksize'";
LABEL_19:
    uint64_t v17 = (const void **)v7;
    __int16 v18 = 259;
    mlir::OpState::emitOpError(this, &v17, (uint64_t)&AttrDictionary);
    uint64_t v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v20);
    return v13;
  }
  uint64_t v6 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (!v6)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'padding'";
    goto LABEL_19;
  }
  uint64_t v8 = 0;
  uint64_t v9 = (const void **)*((void *)Value + 1);
  while (1)
  {
    char v10 = (const void ***)((char *)Value + v8);
    if (*(void *)(*(void *)((*this)[6] + 96) + 8) == mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)((char *)Value + v8))) {
      break;
    }
    v8 += 16;
    if (v6 == v8) {
      goto LABEL_13;
    }
  }
  uint64_t v11 = v6 - v8;
  if (!v11)
  {
LABEL_18:
    uint64_t v7 = "requires attribute 'stride'";
    goto LABEL_19;
  }
  uint64_t v12 = v10[1];
  while (*(void *)(*(void *)((*this)[6] + 96) + 16) != mlir::CallGraphNode::getCallableRegion((mlir::CallGraphNode *)v10))
  {
    v10 += 2;
    v11 -= 16;
    if (!v11) {
      goto LABEL_18;
    }
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps7(*this, v10[1], (const void **)"stride", 6)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps8(*this, v12, (const void **)"padding", 7)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps7(*this, v9, (const void **)"ksize", 5)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v15 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v15 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v15, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

BOOL mlir::anec::LeakyRelu::verifyInvariantsImpl(uint64_t **this)
{
  v17[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = "requires attribute 'offset'";
LABEL_14:
    uint64_t v14 = (const void **)v7;
    __int16 v15 = 259;
    mlir::OpState::emitOpError(this, &v14, (uint64_t)&AttrDictionary);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v17);
    return v9;
  }
  uint64_t v6 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (!v6)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'slope'";
    goto LABEL_14;
  }
  uint64_t v8 = (const void **)*((void *)Value + 1);
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_13;
    }
  }
  uint64_t v11 = (const void **)*((void *)Value + 1);
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, v8, (const void **)"offset", (const void **)6)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, v11, (const void **)"slope", (const void **)5)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v12 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::Linear::getKernelScaleAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8), **(void **)(*((void *)*this + 6) + 96));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (mlir::DenseFPElementsAttr::classof(*((void *)v9 + 1))) {
    return v11;
  }
  return 0;
}

uint64_t mlir::anec::Linear::getKernelScale(mlir::Operation **this)
{
  return mlir::anec::Linear::getKernelScaleAttr(this);
}

uint64_t mlir::anec::Linear::getKernelZeroPointAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8), *(void *)(*(void *)(*((void *)*this + 6) + 96) + 8));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (mlir::DenseIntElementsAttr::classof(*((void *)v9 + 1))) {
    return v11;
  }
  return 0;
}

uint64_t mlir::anec::Linear::getKernelZeroPoint(mlir::Operation **this)
{
  return mlir::anec::Linear::getKernelZeroPointAttr(this);
}

void mlir::anec::Linear::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v26[2] = *MEMORY[0x1E4F143B8];
  uint64_t v20 = a4;
  uint64_t v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  if (a5)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a5);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v25);
  }
  if (a6)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), a6);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v25);
  }
  __src = v26;
  uint64_t v25 = 0x200000000;
  char v10 = *a1;
  uint64_t v11 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v14 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Linear>::inferReturnTypes(v10, v11, 1, v23[0], v23[1], Dictionary, v14, v15, v22[0], v22[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  unint64_t v16 = __src;
  }
  uint64_t v17 = v25;
  uint64_t v18 = *(unsigned int *)(a2 + 72);
  unint64_t v19 = v18 + v25;
  if (v19 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  if (v17)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v18), v16, 8 * v17);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v18 + v17;
  if (__src != v26) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Linear>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      unint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::Linear::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

BOOL mlir::anec::Linear::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (v4)
  {
    uint64_t v6 = 0;
    uint64_t v7 = 0;
    uint64_t v8 = 16 * v4;
    do
    {
      uint64_t CallableRegion = mlir::CallGraphNode::getCallableRegion(Value);
      char v10 = *this;
      if (**(void **)((*this)[6] + 96) == CallableRegion)
      {
        uint64_t v6 = (const void **)*((void *)Value + 1);
      }
      else
      {
        uint64_t v11 = mlir::CallGraphNode::getCallableRegion(Value);
        char v10 = *this;
        if (*(void *)(*(void *)((*this)[6] + 96) + 8) == v11) {
          uint64_t v7 = (const void **)*((void *)Value + 1);
        }
      }
      uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
      v8 -= 16;
    }
    while (v8);
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v6 = 0;
    char v10 = *this;
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps13(v10, v6, (const void **)"kernel_scale", 12)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps14(*this, v7, (const void **)"kernel_zero_point", 17)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand",
                           7,
                           1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v12 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::MatMul::getBiasAttr(mlir::Operation **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::Operation *)((char *)v2 + 56);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  unint64_t v5 = *this;
  if (*((unsigned char *)*this + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary(v5);
    uint64_t v6 = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    uint64_t v6 = (mlir::Operation *)((char *)v5 + 56);
  }
  uint64_t v7 = mlir::ArrayAttr::getValue(v6);
  uint64_t v9 = mlir::impl::findAttrSorted<mlir::NamedAttribute const*>(Value, (mlir::CallGraphNode *)(v7 + 16 * v8), **(void **)(*((void *)*this + 6) + 96));
  if ((v10 & 1) == 0) {
    return 0;
  }
  uint64_t v11 = *((void *)v9 + 1);
  if (!v11) {
    return 0;
  }
  if (*(_UNKNOWN **)(*(void *)v11 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id) {
    return *((void *)v9 + 1);
  }
  return 0;
}

void mlir::anec::MatMul::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v24[2] = *MEMORY[0x1E4F143B8];
  uint64_t v18 = a4;
  uint64_t v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  if (a5)
  {
    mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a5);
    mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v23);
  }
  __src = v24;
  uint64_t v23 = 0x200000000;
  uint64_t v8 = *a1;
  uint64_t v9 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v21, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v12 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MatMul>::inferReturnTypes(v8, v9, 1, v21[0], v21[1], Dictionary, v12, v13, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v14 = __src;
  }
  uint64_t v15 = v23;
  uint64_t v16 = *(unsigned int *)(a2 + 72);
  unint64_t v17 = v16 + v23;
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if (v15)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v16), v14, 8 * v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + v15;
  if (__src != v24) {
    free(__src);
  }
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MatMul>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::MatMul::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

BOOL mlir::anec::MatMul::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  uint64_t v6 = 0;
  if (v4)
  {
    uint64_t v7 = 16 * v4;
    do
    {
      uint64_t CallableRegion = mlir::CallGraphNode::getCallableRegion(Value);
      uint64_t v9 = *this;
      if (**(void **)((*this)[6] + 96) == CallableRegion) {
        uint64_t v6 = (const void **)*((void *)Value + 1);
      }
      uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
      v7 -= 16;
    }
    while (v7);
  }
  else
  {
    uint64_t v9 = *this;
  }
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(v9, v6, (const void **)"bias", (const void **)4)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v10 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v10 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MaxPool>::inferReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  v34[23] = *MEMORY[0x1E4F143B8];
  uint64_t v29 = 0;
  uint64_t v30 = v32;
  uint64_t v31 = 0x600000000;
  uint64_t v28 = a4;
  if (a5)
  {
    uint64_t v17 = 0;
    while (1)
    {
      uint64_t v18 = mlir::ValueRange::dereference_iterator(&v28, v17);
      uint64_t v19 = llvm::DefaultDoCastIfPossible<mlir::ShapedType,mlir::Type const,llvm::CastInfo<mlir::ShapedType,mlir::Type const,void>>::doCastIfPossible((uint64_t *)(*(void *)(v18 + 8) & 0xFFFFFFFFFFFFFFF8));
      if (!v19) {
        break;
      }
      uint64_t RankPromotionTypeForANE = mlir::getRankPromotionTypeForANE((uint64_t)v19, v20);
      uint64_t v22 = v31;
      if (v31 >= (unint64_t)HIDWORD(v31))
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v30, v32, v31 + 1, 8);
        uint64_t v22 = v31;
      }
      *((void *)v30 + v22) = RankPromotionTypeForANE;
      unint64_t v23 = (v31 + 1);
      LODWORD(v31) = v31 + 1;
      uint64_t v17 = ++v29;
      if (v28 == a4 && v17 == a5)
      {
        uint64_t v25 = v30;
        goto LABEL_16;
      }
    }
    if (a3)
    {
      mlir::emitError((uint64_t)a2, (uint64_t)&v33);
      if (v33) {
        mlir::Diagnostic::operator<<((uint64_t)v34, "expected a ShapedType for inferReturnTypes");
      }
      uint64_t v24 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
      if (v33) {
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
      }
      std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v34);
    }
    else
    {
      uint64_t v24 = 0;
    }
  }
  else
  {
    unint64_t v23 = 0;
    uint64_t v25 = v32;
LABEL_16:
    mlir::ValueRange::ValueRange(v27, (uint64_t)v25, v23);
    uint64_t v24 = mlir::anec::MaxPool::inferPromotedReturnTypes(a1, a2, a3, a4, a5, a6, a9, a10, v27[0], v27[1], a11);
  }
  if (v30 != v32) {
    free(v30);
  }
  return v24;
}

void mlir::anec::MaxPool::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6)
{
  unint64_t v26[2] = *MEMORY[0x1E4F143B8];
  mlir::OperationState::addOperands(a2, a3, a4);
  *(void *)(a2 + 192) = 0;
  uint64_t v12 = *(unsigned int *)(a2 + 120);
  if (a6 + v12 > (unint64_t)*(unsigned int *)(a2 + 124))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 112, (void *)(a2 + 128), a6 + v12, 16);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  if (a6)
  {
    memcpy((void *)(*(void *)(a2 + 112) + 16 * v12), a5, 16 * a6);
    LODWORD(v12) = *(_DWORD *)(a2 + 120);
  }
  *(_DWORD *)(a2 + 120) = v12 + a6;
  __src = v26;
  uint64_t v25 = 0x200000000;
  uint64_t v13 = *a1;
  uint64_t v14 = *(mlir::MLIRContext **)a2;
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v17 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::MaxPool>::inferReturnTypes(v13, v14, 1, a3, a4, Dictionary, v17, v18, v23[0], v23[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v19 = __src;
  }
  uint64_t v20 = v25;
  uint64_t v21 = *(unsigned int *)(a2 + 72);
  unint64_t v22 = v21 + v25;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if (v20)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v26) {
    free(__src);
  }
}

BOOL mlir::anec::NRelu::verifyInvariantsImpl(uint64_t **this)
{
  v17[23] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *this;
  if (*((unsigned char *)v2 + 47))
  {
    unint64_t AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)v2);
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)&AttrDictionary;
  }
  else
  {
    p_unint64_t AttrDictionary = (mlir::ArrayAttr *)(v2 + 7);
  }
  uint64_t Value = (mlir::CallGraphNode *)mlir::ArrayAttr::getValue(p_AttrDictionary);
  if (!v4)
  {
LABEL_8:
    uint64_t v7 = "requires attribute 'max_value'";
LABEL_14:
    uint64_t v14 = (const void **)v7;
    __int16 v15 = 259;
    mlir::OpState::emitOpError(this, &v14, (uint64_t)&AttrDictionary);
    uint64_t v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&AttrDictionary);
    if (AttrDictionary) {
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&AttrDictionary);
    }
    std::__optional_destruct_base<mlir::Diagnostic,false>::~__optional_destruct_base[abi:nn180100]((uint64_t)v17);
    return v9;
  }
  uint64_t v6 = 16 * v4;
  while (**(void **)((*this)[6] + 96) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_8;
    }
  }
  if (!v6)
  {
LABEL_13:
    uint64_t v7 = "requires attribute 'slope'";
    goto LABEL_14;
  }
  uint64_t v8 = (const void **)*((void *)Value + 1);
  while (*(void *)(*(void *)((*this)[6] + 96) + 8) != mlir::CallGraphNode::getCallableRegion(Value))
  {
    uint64_t Value = (mlir::CallGraphNode *)((char *)Value + 16);
    v6 -= 16;
    if (!v6) {
      goto LABEL_13;
    }
  }
  uint64_t v11 = (const void **)*((void *)Value + 1);
  if (!mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, v8, (const void **)"max_value", (const void **)9)|| !mlir::anec::__mlir_ods_local_attr_constraint_ANECOps10(*this, v11, (const void **)"slope", (const void **)5)|| !mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(*(void *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9)) {
    uint64_t v12 = (uint64_t)(*this - 2);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, 0);
  return mlir::anec::__mlir_ods_local_type_constraint_ANECOps0(*this, (const void **)(*(void *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

void mlir::anec::Padding::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unint64_t v26[2] = *MEMORY[0x1E4F143B8];
  uint64_t v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 8), a4);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v25);
  mlir::NamedAttribute::NamedAttribute(&__src, *(void *)(*(void *)(*(void *)(a2 + 8) + 96) + 16), a5);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v25);
  mlir::NamedAttribute::NamedAttribute(&__src, **(void **)(*(void *)(a2 + 8) + 96), a6);
  mlir::NamedAttrList::push_back(a2 + 112, (uint64_t)__src, v25);
  __src = v26;
  uint64_t v25 = 0x200000000;
  uint64_t v11 = *a1;
  uint64_t v12 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v23, *(void *)(a2 + 16), *(unsigned int *)(a2 + 24));
  uint64_t Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  unint64_t Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  uint64_t v15 = *(void *)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(void *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::anec::detail::InferReturnTypesInterfaceTrait<mlir::anec::Padding>::inferReturnTypes(v11, v12, 1u, v23[0], v23[1], Dictionary, v15, v16, v22[0], v22[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1); {
  uint64_t v17 = __src;
  }
  uint64_t v18 = v25;
  uint64_t v19 = *(unsigned int *)(a2 + 72);
  unint64_t v20 = v19 + v25;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if (v18)
  {
    memcpy((void *)(*(void *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v26) {
    free(__src);
  }
}